name: HumanEval_49_modp
language: rust
results:
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let (p, n) = (p as i64, n as i64);\n    let mut m = 1;\n    let mut x\
    \ = n % p;\n    while n > 0 {\n        if n % 2 == 1 {\n            m = (m * x)\
    \ % p;\n        }\n        x = (x * x) % p;\n        n /= 2;\n    }\n    m as\
    \ isize\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign twice to immutable variable `n`\n  --> /tmp/tmp1czi24y8.rs:21:9\n\
    \   |\n13 |     let (p, n) = (p as i64, n as i64);\n   |             -\n   | \
    \            |\n   |             first assignment to `n`\n   |             help:\
    \ consider making this binding mutable: `mut n`\n...\n21 |         n /= 2;\n \
    \  |         ^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut m = 1;\n    let mut i = 0;\n    while i < n {\n        m = (m\
    \ * 2) % p;\n        i += 1;\n    }\n    m\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut ret = 1;\n    for _ in 0..n {\n        ret = (ret * 2) % p;\n\
    \    }\n    ret\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n % p == 0 {\n        1\n    } else {\n        (2 * modp(n / 2, p))\
    \ % p\n    }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpymj2u7ts.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut result = 1;\n    for _ in 0..n {\n        result = (result *\
    \ 2) % p;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n  \
    \  assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut res = 1;\n    let mut pwr = n;\n    while pwr > 0 {\n       \
    \ if pwr % 2 == 1 {\n            res = (res * n) % p;\n        }\n        n =\
    \ (n * n) % p;\n        pwr /= 2;\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpokhy0fb0.rs:19:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n19 |         n = (n * n) % p;\n \
    \  |         ^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut n = n;\n    let mut res = 1;\n    while n > 0 {\n        if n\
    \ % 2 == 1 {\n            res = (res * n) % p;\n        }\n        n = n / 2;\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `64`,\n right: `2`', /tmp/tmpwk1kd6ff.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    let mut r = modp(n >> 1, p);\n\
    \    r = (r * r) % p;\n    if n & 1 == 1 {\n        r = (r * 2) % p;\n    }\n\
    \    r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut n = n;\n    let mut res = 1;\n    while n > 0 {\n        if n\
    \ % 2 == 1 {\n            res = (res * n) % p;\n        }\n        n = n / 2;\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `64`,\n right: `2`', /tmp/tmpe47ceqbg.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    let mut d = modp(n / 2, p);\n\
    \    d = (d * d) % p;\n    if n % 2 == 1 {\n        d = (d * 2) % p;\n    }\n\
    \    d\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut ret = 1;\n    let mut base = n;\n    let mut exp = p - 2;\n \
    \   while exp > 0 {\n        if exp % 2 == 1 {\n            ret = (ret * base)\
    \ % p;\n        }\n        base = (base * base) % p;\n        exp /= 2;\n    }\n\
    \    ret\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpm9wn0_he.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n / 2, p) * modp(n / 2, p) % p;\n    }\n    return modp(n - 1, p) * modp(n,\
    \ p) % p;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut a = 1;\n    let mut exp = n;\n    let mut two = 2;\n    while\
    \ exp > 0 {\n        if exp % 2 == 1 {\n            a = (a * two) % p;\n     \
    \   }\n        two = (two * two) % p;\n        exp /= 2;\n    }\n    a\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut res = 1;\n    let mut x = n;\n    let mut p = p;\n    while x\
    \ > 0 {\n        if x % 2 == 1 {\n            res = (res * n) % p;\n        }\n\
    \        x = x / 2;\n        n = (n * n) % p;\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpyi6bpd10.rs:15:9\n\
    \   |\n15 |     let mut p = p;\n   |         ----^\n   |         |\n   |     \
    \    help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\
    \nerror[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpyi6bpd10.rs:21:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n21 |         n = (n * n) % p;\n \
    \  |         ^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut res = 1;\n    let mut n = n;\n    while n > 0 {\n        if n\
    \ % 2 == 1 {\n            res = (res * n) % p;\n        }\n        n = n / 2;\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `64`,\n right: `2`', /tmp/tmp8u3et3qv.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut m = n;\n    let mut result = 1;\n    while m > 0 {\n        if\
    \ m % 2 == 1 {\n            result = (result * n) % p;\n        }\n        n =\
    \ (n * n) % p;\n        m = m / 2;\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp3ff3h4cb.rs:19:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n19 |         n = (n * n) % p;\n \
    \  |         ^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut n = n;\n    let mut res = 1;\n    while n > 0 {\n        if n\
    \ % 2 == 1 {\n            res = (res * n) % p;\n        }\n        n = n / 2;\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `64`,\n right: `2`', /tmp/tmp53xk1pqr.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n\n    let mut k = n;\n    let\
    \ mut a = 1;\n    let mut b = 0;\n    let mut x = 1;\n    let mut y = 0;\n\n \
    \   while k > 0 {\n        let q = k / 2;\n        let r = k % 2;\n        let\
    \ temp = a;\n        a = (a * x + b * y) % p;\n        b = (temp * y + b * x)\
    \ % p;\n        k = q;\n        x = x * x % p;\n        y = y * y % p;\n     \
    \   if r == 1 {\n            temp = a;\n            a = (a + b) % p;\n       \
    \     b = (temp + b) % p;\n            x = (x + y) % p;\n        }\n    }\n\n\
    \    a\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign twice to immutable variable `temp`\n  --> /tmp/tmp9dfs2s5n.rs:33:13\n\
    \   |\n26 |         let temp = a;\n   |             ----\n   |             |\n\
    \   |             first assignment to `temp`\n   |             help: consider\
    \ making this binding mutable: `mut temp`\n...\n33 |             temp = a;\n \
    \  |             ^^^^^^^^ cannot assign twice to immutable variable\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut tmp: isize = n;\n    let mut res: isize = 1;\n    while tmp >\
    \ 0 {\n        if tmp % 2 == 1 {\n            res = (res * n) % p;\n        }\n\
    \        n = (n * n) % p;\n        tmp /= 2;\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpv0tb9amv.rs:19:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n19 |         n = (n * n) % p;\n \
    \  |         ^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n\n    let x = modp(n / 2, p);\n\
    \    let y = x * x % p;\n    if n % 2 == 0 {\n        y\n    } else {\n      \
    \  y * 2 % p\n    }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n\n    if n % 2 == 0 {\n      \
    \  let a = modp(n / 2, p);\n        a * a % p\n    } else {\n        let a = modp(n\
    \ - 1, p);\n        a * n % p\n    }\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `94`,\n right: `2`', /tmp/tmpomarma7q.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    if n % 2 == 0 {\n        let\
    \ temp = modp(n / 2, p);\n        return (temp * temp) % p;\n    }\n    let temp\
    \ = modp(n - 1, p);\n    return (temp * (n % p)) % p;\n}\n\nfn main() {\n    let\
    \ candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `94`,\n right: `2`', /tmp/tmpc7dfsu2g.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    if n == 1 {\n        return\
    \ n;\n    }\n    let mut r = 1;\n    for _ in 0..n {\n        r = (r * 2) % p;\n\
    \    }\n    r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut y = 1;\n    let mut b = n;\n    let mut x = p;\n    while b >\
    \ 0 {\n        if b % 2 == 1 {\n            y = (y * b) % x;\n        }\n    \
    \    b = b / 2;\n        x = (x * x) % p;\n    }\n    y\n}\n\nfn main() {\n  \
    \  let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to calculate the remainder with a divisor\
    \ of zero', /tmp/tmpen1eaxrn.rs:18:17\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut res = 1;\n    let mut n = n;\n    while n > 0 {\n        if n\
    \ % 2 == 1 {\n            res = (res * n) % p;\n        }\n        n = n / 2;\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `64`,\n right: `2`', /tmp/tmp14wgf7uq.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    assert!(p > 0);\n    let mut res = 1;\n    let mut i = n;\n    let mut\
    \ x = 2;\n    while i > 0 {\n        if i % 2 == 1 {\n            res = (res *\
    \ x) % p;\n        }\n        x = (x * x) % p;\n        i = i / 2;\n    }\n  \
    \  res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut result = 1;\n    let mut i = 0;\n    let mut two_i = 1;\n   \
    \ while i < n {\n        result = result * 2;\n        while result >= p {\n \
    \           result = result - p;\n        }\n        i = i + 1;\n        two_i\
    \ = two_i * 2;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpuprwtv4i.rs:22:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let res = if n == 0 {\n        1\n    } else if n % 2 == 0 {\n      \
    \  let tmp = modp(n / 2, p);\n        (tmp * tmp) % p\n    } else {\n        (2\
    \ * modp(n - 1, p)) % p\n    };\n    if res < 0 {\n        res + p\n    } else\
    \ {\n        res\n    }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut t = 1;\n    let mut s = n;\n    while s > 0 {\n        if s %\
    \ 2 == 1 {\n            t = (t * n) % p;\n        }\n        n = (n * n) % p;\n\
    \        s /= 2;\n    }\n    t\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpxjhdb3xe.rs:19:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n19 |         n = (n * n) % p;\n \
    \  |         ^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n\n    let mut n = n;\n    let\
    \ mut ret = 1;\n    while n > 0 {\n        if n % 2 == 1 {\n            ret =\
    \ (ret * 2) % p;\n        }\n        n /= 2;\n    }\n    ret\n}\n\nfn main() {\n\
    \    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmp8ycgnziy.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut r = 1;\n    let mut x = n;\n    let mut i = p - 2;\n    while\
    \ i > 0 {\n        while i % 2 == 0 {\n            x = (x * x) % p;\n        \
    \    i = i / 2;\n        }\n        r = (r * x) % p;\n        i = i - 1;\n   \
    \ }\n    r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmp76v02pxm.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    // ????\n    if n == 0 {\n        return 1;\n    }\n    let mut y = 1;\n\
    \    let mut x = n;\n    while x > 1 {\n        if x % 2 == 0 {\n            x\
    \ = x / 2;\n            y = (y * y) % p;\n        } else {\n            x = x\
    \ - 1;\n            y = (y * y * n) % p;\n        }\n    }\n    y\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmp33_nfzn7.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    (n % p + p) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpkaf4weew.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    let mut i = n;\n    let mut\
    \ result = 2;\n    while i > 1 {\n        result = (result * 2) % p;\n       \
    \ i -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n  \
    \  assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    // check if n is a power of 2:\n    if n == 1 || (n & (n - 1)) == 0 {\n\
    \        return n % p;\n    }\n    let mut res = 1;\n    let mut curr = 2;\n \
    \   let mut nn = n;\n    while nn > 0 {\n        if nn & 1 == 1 {\n          \
    \  res = (res * curr) % p;\n        }\n        curr = (curr * curr) % p;\n   \
    \     nn >>= 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmpfjed6_yz.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    var a = 1;\n    var b = n;\n    while b > 0 {\n        if b & 1 == 1\
    \ {\n            a = (a * n) % p;\n        }\n        b >>= 1;\n        n = (n\
    \ * n) % p;\n    }\n    a\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "error: invalid variable declaration\n  --> /tmp/tmpcemp48wi.rs:13:5\n \
    \  |\n13 |     var a = 1;\n   |     ^^^\n   |\nhelp: write `let` instead of `var`\
    \ to introduce a new variable\n   |\n13 |     let a = 1;\n   |     ~~~\n\nerror:\
    \ invalid variable declaration\n  --> /tmp/tmpcemp48wi.rs:14:5\n   |\n14 |   \
    \  var b = n;\n   |     ^^^\n   |\nhelp: write `let` instead of `var` to introduce\
    \ a new variable\n   |\n14 |     let b = n;\n   |     ~~~\n\nerror: aborting due\
    \ to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        p + modp(n, p)\n    } else if n == 0 {\n        1\n\
    \    } else if n % 2 == 0 {\n        modp(n / 2, p) * modp(n / 2, p) % p\n   \
    \ } else {\n        p * modp(n - 1, p) % p\n    }\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp1e8lb2lw.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut res = 1;\n    for _ in 0..n {\n        res = res * 2 % p;\n \
    \   }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let n = n % p;\n    if n < 0 {\n        n + p\n    } else {\n       \
    \ n\n    }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpsotp7x3z.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut r = 1;\n    let mut b = n;\n    while b > 0 {\n        if b %\
    \ 2 == 1 {\n            r = (r * n) % p;\n        }\n        b = b / 2;\n    \
    \    n = (n * n) % p;\n    }\n    r\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp6aowu1x2.rs:20:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n20 |         n = (n * n) % p;\n \
    \  |         ^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut res = 1;\n    let mut n = n;\n    let mut i = p - 2;\n    while\
    \ i > 0 {\n        if i % 2 == 1 {\n            res = (res * n) % p;\n       \
    \ }\n        n = (n * n) % p;\n        i /= 2;\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpux54ci9g.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut r = 1;\n    let mut x = n;\n    let mut y = p;\n    while y >\
    \ 0 {\n        if y % 2 == 1 {\n            r = (r * x) % p;\n        }\n    \
    \    y = y / 2;\n        x = (x * x) % p;\n    }\n    r\n}\n\nfn main() {\n  \
    \  let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpt9hl7wlc.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    let mut result = 1;\n    let\
    \ mut t = 2;\n    let mut k = n % (p - 1);\n    while k > 0 {\n        if k %\
    \ 2 == 1 {\n            result = (result * t) % p;\n        }\n        t = (t\
    \ * t) % p;\n        k /= 2;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut n = n % p;\n    let mut res = 1;\n    for _ in 0..n {\n     \
    \   res = (res * 2) % p;\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `29`,\n right: `2`', /tmp/tmpm8bqqnxt.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let r = pow(2, n) % p;\n    assert!(r >= 0, \"Not a positive number!\"\
    );\n    r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `pow` in this scope\n  --> /tmp/tmpu7_rgp50.rs:13:13\n\
    \   |\n13 |     let r = pow(2, n) % p;\n   |             ^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    assert!(n > 0);\n    assert!(p > 1);\n    let mut r = 1;\n    let mut\
    \ n = n;\n    while n > 0 {\n        if n % 2 == 1 {\n            r = (r * n)\
    \ % p;\n        }\n        n = n / 2;\n    }\n    r\n}\n\nfn main() {\n    let\
    \ candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `64`,\n right: `2`', /tmp/tmpx5_u9w_m.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut res = 1;\n    let mut base = n;\n    while base > 0 {\n     \
    \   if base & 1 == 1 {\n            res = (res * n) % p;\n        }\n        base\
    \ >>= 1;\n        n = (n * n) % p;\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp6wwt1g2p.rs:20:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n20 |         n = (n * n) % p;\n \
    \  |         ^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut i = 1;\n    let mut j = n;\n    while j >= p {\n        j = n\
    \ % p;\n        n = n / p;\n    }\n    i * j\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpkptcazyv.rs:13:9\n\
    \   |\n13 |     let mut i = 1;\n   |         ----^\n   |         |\n   |     \
    \    help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\
    \nerror[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpkptcazyv.rs:17:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n17 |         n = n / p;\n   |   \
    \      ^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due to\
    \ previous error; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut x = 1;\n    let mut p = p as usize;\n    let mut n = n as usize;\n\
    \    while n > 0 {\n        if n % 2 == 1 {\n            x = (x * p) % MODP;\n\
    \        }\n        p = (p * p) % MODP;\n        n = n / 2;\n    }\n    x as isize\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `MODP` in this scope\n  --> /tmp/tmptem27cv4.rs:18:27\n\
    \   |\n18 |             x = (x * p) % MODP;\n   |                           ^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MODP` in this scope\n\
    \  --> /tmp/tmptem27cv4.rs:20:23\n   |\n20 |         p = (p * p) % MODP;\n   |\
    \                       ^^^^ not found in this scope\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut r = 1;\n    let mut b = n;\n    while b > 0 {\n        if b %\
    \ 2 == 1 {\n            r = (r * n) % p;\n        }\n        b /= 2;\n       \
    \ n = (n * n) % p;\n    }\n    r\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpqin1rnkf.rs:20:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n20 |         n = (n * n) % p;\n \
    \  |         ^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut n = n;\n    let mut m = 1;\n    while n > 0 {\n        if n %\
    \ 2 == 1 {\n            m = (m * n) % p;\n        }\n        n = n / 2;\n    }\n\
    \    m\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `64`,\n right: `2`', /tmp/tmp54szzbfe.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut m = n;\n    let mut r = 1;\n    while m > 0 {\n        if m %\
    \ 2 == 1 {\n            r = (r * n) % p;\n        }\n        n = (n * n) % p;\n\
    \        m /= 2;\n    }\n    r\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpp6exe7c3.rs:19:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n19 |         n = (n * n) % p;\n \
    \  |         ^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut ans = 1;\n    let mut k = n;\n    let mut x = 2;\n    while k\
    \ > 0 {\n        if k % 2 == 1 {\n            ans = (ans * x) % p;\n        }\n\
    \        k = k / 2;\n        x = (x * x) % p;\n    }\n    ans\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        modp(n % p + p, p)\n    } else if n == 0 {\n    \
    \    1\n    } else if n == 1 {\n        n\n    } else if n % 2 == 0 {\n      \
    \  modp(n * n, p) % p\n    } else {\n        n * modp(n - 1, p) % p\n    }\n}\n\
    \nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpr6zwnbbf.rs:20:14\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut ret = 1;\n    let mut b = n;\n    while b > 0 {\n        if b\
    \ % 2 == 1 {\n            ret = (ret * n) % p;\n        }\n        b /= 2;\n \
    \       n = (n * n) % p;\n    }\n    ret\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmppr3uiapr.rs:20:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n20 |         n = (n * n) % p;\n \
    \  |         ^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    let r = modp(n / 2, p);\n\
    \    let mut rr = (r * r) % p;\n    if n % 2 == 1 {\n        rr = (rr * 2) % p;\n\
    \    }\n    return rr;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let n = n as f64;\n    let p = p as f64;\n    let (p1, p2) = (p.ceil()\
    \ / 2.0, p.floor() / 2.0);\n    let result = (2_f64.powf(n) - 1_f64).rem_euclid(p);\n\
    \    if result < p2 {\n        result\n    } else {\n        result - p\n    }\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7vjnu6jh.rs:18:9\n   |\n\
    12 | fn modp(n: isize, p: isize) -> isize {\n   |                            \
    \    ----- expected `isize` because of return type\n...\n18 |         result\n\
    \   |         ^^^^^^ expected `isize`, found `f64`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7vjnu6jh.rs:20:9\n   |\n12 | fn modp(n: isize, p: isize)\
    \ -> isize {\n   |                                ----- expected `isize` because\
    \ of return type\n...\n20 |         result - p\n   |         ^^^^^^^^^^ expected\
    \ `isize`, found `f64`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    if n % 2 == 0 {\n        let\
    \ tmp = modp(n / 2, p);\n        return tmp * tmp % p;\n    }\n    modp(n - 1,\
    \ p) * n % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `94`,\n right: `2`', /tmp/tmphu38_v27.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut res = 1;\n    let mut pow = n;\n    let mut b = 2;\n    while\
    \ pow > 0 {\n        if pow % 2 == 1 {\n            res = (res * b) % p;\n   \
    \     }\n        pow = pow / 2;\n        b = (b * b) % p;\n    }\n    res\n}\n\
    \nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut res = 1;\n    let mut x = n;\n    let mut y = p;\n    while x\
    \ > 0 {\n        if x % 2 == 1 {\n            res = (res * y) % p;\n        }\n\
    \        x /= 2;\n        y = (y * y) % p;\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpqwjmr2gb.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n\n    let mut res = 1;\n    let\
    \ mut d = 2;\n    while d <= n {\n        res = (res * d) % p;\n        d *= 2;\n\
    \    }\n\n    res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpn0_cr317.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n\n    let mut f = modp(n / 2,\
    \ p);\n    f = f * f % p;\n    if n % 2 == 1 {\n        f = f * 2 % p;\n    }\n\
    \    f\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut d: isize = 1;\n    let mut k: isize = 0;\n    while (1 << k)\
    \ <= n {\n        k += 1;\n    }\n    for i in 0..k {\n        d = (d * d) % p;\n\
    \        if ((n >> i) & 1) == 1 {\n            d = (d * 2) % p;\n        }\n \
    \   }\n    d\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `10`,\n right: `2`', /tmp/tmp2cti6t8r.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut n = n;\n    let mut res = 1;\n    let mut base = 2;\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            res = (res * base) % p;\n    \
    \    }\n        base = (base * base) % p;\n        n /= 2;\n    }\n    res\n}\n\
    \nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    if n % 2 == 0 {\n        let\
    \ a = modp(n / 2, p);\n        return a * a % p;\n    }\n    let a = modp(n -\
    \ 1, p);\n    return a * n % p;\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `94`,\n right: `2`', /tmp/tmpk4boxtzp.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let n: isize = if n < 0 { n + p } else { n };\n    if n == 0 {\n    \
    \    return 1;\n    } else if n == 1 {\n        return n;\n    }\n    let m =\
    \ if n % 2 == 0 { modp(n / 2, p) } else { modp(n - 1, p) };\n    let m = m * m\
    \ % p;\n    if n % 2 == 0 {\n        m\n    } else {\n        m * n % p\n    }\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `8`,\n right: `2`', /tmp/tmp3zjzypnr.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    let mut _n = n;\n    let mut\
    \ _p = p;\n    let mut res = 1;\n    while _n > 0 {\n        if _n % 2 == 1 {\n\
    \            res = (res * _p) % INT_OVERFLOW;\n        }\n        _p = (_p * _p)\
    \ % INT_OVERFLOW;\n        _n = _n / 2;\n    }\n    res\n}\n\nfn main() {\n  \
    \  let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `INT_OVERFLOW` in this scope\n  --> /tmp/tmp9y54izte.rs:21:32\n\
    \   |\n21 |             res = (res * _p) % INT_OVERFLOW;\n   |               \
    \                 ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `INT_OVERFLOW` in this scope\n  --> /tmp/tmp9y54izte.rs:23:26\n \
    \  |\n23 |         _p = (_p * _p) % INT_OVERFLOW;\n   |                      \
    \    ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    // TODO\n    0\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp737k607w.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    if n == 1 {\n        return\
    \ n;\n    }\n    modp(n / 2, p) * modp(n - n / 2, p) % p\n}\n\nfn main() {\n \
    \   let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `3`', /tmp/tmpw8of2q97.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    let mut s = modp(n / 2, p);\n\
    \    s = (s * s) % p;\n    if n % 2 == 1 {\n        s = (s * 2) % p;\n    }\n\
    \    return s;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut b = 1;\n    let mut x = n;\n    while x > 0 {\n        if x %\
    \ 2 == 1 {\n            b = (b * n) % p;\n        }\n        x /= 2;\n       \
    \ n = (n * n) % p;\n    }\n    b\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpkid2kgc4.rs:20:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n20 |         n = (n * n) % p;\n \
    \  |         ^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let two = BigUint::from(2u8);\n    let n = BigUint::from(n);\n    let\
    \ p = BigUint::from(p);\n    let pow = n.modpow(&two, &p);\n    match pow.to_str_radix(10)\
    \ {\n        Ok(s) => s.parse::<isize>().unwrap(),\n        Err(_) => panic!(\"\
    No parse\"),\n    }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `BigUint`\n  -->\
    \ /tmp/tmp98e9ynrw.rs:13:15\n   |\n13 |     let two = BigUint::from(2u8);\n  \
    \ |               ^^^^^^^ use of undeclared type `BigUint`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `BigUint`\n  --> /tmp/tmp98e9ynrw.rs:14:13\n\
    \   |\n14 |     let n = BigUint::from(n);\n   |             ^^^^^^^ use of undeclared\
    \ type `BigUint`\n\nerror[E0433]: failed to resolve: use of undeclared type `BigUint`\n\
    \  --> /tmp/tmp98e9ynrw.rs:15:13\n   |\n15 |     let p = BigUint::from(p);\n \
    \  |             ^^^^^^^ use of undeclared type `BigUint`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n\n    if n % 2 == 0 {\n      \
    \  modp(n / 2, p) * modp(n / 2, p) % p\n    } else {\n        n * modp(n - 1,\
    \ p) % p\n    }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `94`,\n right: `2`', /tmp/tmphdxha1g0.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let (mut n, mut p) = (n, p);\n    let mut res = 1;\n    while n > 0 {\n\
    \        if n % 2 == 1 {\n            res = (res * p) % MODULO;\n        }\n \
    \       n = n / 2;\n        p = (p * p) % MODULO;\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `MODULO` in this scope\n  --> /tmp/tmpkhoehqsh.rs:17:31\n\
    \   |\n17 |             res = (res * p) % MODULO;\n   |                      \
    \         ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `MODULO`\
    \ in this scope\n  --> /tmp/tmpkhoehqsh.rs:20:23\n   |\n20 |         p = (p *\
    \ p) % MODULO;\n   |                       ^^^^^^ not found in this scope\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut n = n;\n    let mut res = 1;\n    let mut s = p - 2;\n    let\
    \ mut t = n;\n    while s > 0 {\n        if s % 2 == 1 {\n            res = (res\
    \ * t) % p;\n        }\n        t = (t * t) % p;\n        s /= 2;\n    }\n   \
    \ res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpgpwjdgyy.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    // let m = n % p;\n    // if m < 0 {\n    //     m + p\n    // } else\
    \ {\n    //     m\n    // }\n    n % p\n}\n\nfn main() {\n    let candidate =\
    \ modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101),\
    \ 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11),\
    \ 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5),\
    \ 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpck4v1010.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut d = n;\n    let mut r = 1;\n    while d > 0 {\n        if d %\
    \ 2 == 1 {\n            r = (r * n) % p;\n        }\n        d = d / 2;\n    \
    \    n = (n * n) % p;\n    }\n    r\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp3rc_7n7w.rs:20:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n20 |         n = (n * n) % p;\n \
    \  |         ^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut result = 1;\n    let mut base = n;\n    let mut exponent = p;\n\
    \    while exponent > 0 {\n        if exponent % 2 == 1 {\n            result\
    \ = (result * base) % p;\n        }\n        exponent >>= 1;\n        base = (base\
    \ * base) % p;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpl7giyplr.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    // O(log n)\n    let mut r = 1;\n    let mut b = n;\n    let mut p =\
    \ p;\n    while b > 0 {\n        if b % 2 == 1 {\n            r = (r * n) % p;\n\
    \        }\n        b = b / 2;\n        n = (n * n) % p;\n    }\n    r\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpgpqqlgya.rs:16:9\n\
    \   |\n16 |     let mut p = p;\n   |         ----^\n   |         |\n   |     \
    \    help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\
    \nerror[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpgpqqlgya.rs:22:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n22 |         n = (n * n) % p;\n \
    \  |         ^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut result = 1;\n    let mut base = n;\n    let mut exp = p;\n  \
    \  while exp > 0 {\n        if exp % 2 == 1 {\n            result = (result *\
    \ base) % p;\n        }\n        exp = exp >> 1;\n        base = (base * base)\
    \ % p;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpy_w8qvjd.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut res = 1;\n    let mut n = n;\n    while n > 0 {\n        if n\
    \ % 2 == 1 {\n            res = (res * n) % p;\n        }\n        n = n / 2;\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `64`,\n right: `2`', /tmp/tmpvas9f0gb.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut s = 1;\n    let mut m = n;\n    while m > 0 {\n        if m %\
    \ 2 == 1 {\n            s = (s * n) % p;\n        }\n        n = (n * n) % p;\n\
    \        m = m / 2;\n    }\n    s\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp1smufbja.rs:19:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n19 |         n = (n * n) % p;\n \
    \  |         ^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n\n    if n % 2 == 0 {\n      \
    \  let half_result = modp(n / 2, p);\n        return (half_result * half_result)\
    \ % p;\n    } else {\n        return (modp(n - 1, p) * n) % p;\n    }\n}\n\nfn\
    \ main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n \
    \   assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `94`,\n right: `2`', /tmp/tmp0jv40kkz.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    if n % 2 == 0 {\n        let\
    \ t = modp(n / 2, p);\n        return t * t % p;\n    }\n    return n * modp(n\
    \ - 1, p) % p;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `94`,\n right: `2`', /tmp/tmpaslpp9c3.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut ret = 1;\n    for _ in 0..n {\n        ret = (ret * 2) % p;\n\
    \    }\n    ret\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut r = 1;\n    let mut k = n;\n    let mut a = 2;\n    while k >\
    \ 0 {\n        if k % 2 == 1 {\n            r = (r * a) % p;\n        }\n    \
    \    k = k / 2;\n        a = (a * a) % p;\n    }\n    r\n}\n\nfn main() {\n  \
    \  let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut n = n % p;\n    let mut nn = n;\n    let mut out = 1;\n    while\
    \ nn > 0 {\n        if nn % 2 == 1 {\n            out = (out * n) % p;\n     \
    \   }\n        n = (n * n) % p;\n        nn /= 2;\n    }\n    out\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmp84h7zd6c.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut res = 1;\n    let mut num = n;\n    let mut p = p;\n    while\
    \ num > 0 {\n        if num % 2 == 1 {\n            res = (res * p) % 101;\n \
    \       }\n        p = (p * p) % 101;\n        num /= 2;\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `3`', /tmp/tmpmeegj16e.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n\n    if n % 2 == 0 {\n      \
    \  modp(n / 2, p) * modp(n / 2, p) % p\n    } else {\n        n * modp(n - 1,\
    \ p) % p\n    }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `94`,\n right: `2`', /tmp/tmp7z1djaz_.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    match n {\n     \
    \   0 => 1,\n        n => {\n            let (result, _) = powmod(2, n, p);\n\
    \            result\n        }\n    }\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `powmod` in this scope\n  --> /tmp/tmpyzapaj3i.rs:17:31\n\
    \   |\n17 |             let (result, _) = powmod(2, n, p);\n   |             \
    \                  ^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    if n == 1 {\n        return\
    \ n;\n    }\n    if n % 2 == 0 {\n        let nh = modp(n / 2, p);\n        nh\
    \ * nh % p\n    } else {\n        n * modp(n - 1, p) % p\n    }\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `94`,\n right: `2`', /tmp/tmp_4snabic.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut res = 1;\n    let mut base = n;\n    let mut pot = p - 2;\n \
    \   while pot > 0 {\n        if pot % 2 == 1 {\n            res = (res * base)\
    \ % p;\n        }\n        base = (base * base) % p;\n        pot /= 2;\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmp_ilk_3zk.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut n = n;\n    let mut ret = 1;\n    while n > 0 {\n        if n\
    \ % 2 == 1 {\n            ret = (ret * p) % MOD;\n        }\n        n /= 2;\n\
    \        p = (p * p) % MOD;\n    }\n    ret\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `MOD` in this scope\n  --> /tmp/tmpatj83lfm.rs:17:31\n\
    \   |\n17 |             ret = (ret * p) % MOD;\n   |                         \
    \      ^^^ not found in this scope\n\nerror[E0425]: cannot find value `MOD` in\
    \ this scope\n  --> /tmp/tmpatj83lfm.rs:20:23\n   |\n20 |         p = (p * p)\
    \ % MOD;\n   |                       ^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    if n == 1 {\n        return\
    \ n;\n    }\n    let mut answer = 1;\n    let mut base = n;\n    let mut exponent\
    \ = p - 2;\n    while exponent > 0 {\n        if exponent % 2 == 1 {\n       \
    \     answer = (answer * base) % p;\n        }\n        base = (base * base) %\
    \ p;\n        exponent /= 2;\n    }\n    answer\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpi8no_45_.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut ret = 1;\n    let mut n = n;\n    while n > 0 {\n        if n\
    \ % 2 == 1 {\n            ret = (ret * n) % p;\n        }\n        n = n / 2;\n\
    \    }\n    ret\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `64`,\n right: `2`', /tmp/tmpflp5w4hc.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    assert!(n >= 0);\n    assert!(p > 0);\n    let mut res = 1;\n    let\
    \ mut base = n;\n    while base > 0 {\n        if base & 1 == 1 {\n          \
    \  res = res * n % p;\n        }\n        base >>= 1;\n        n = n * n % p;\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpo4ktfhrh.rs:22:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n22 |         n = n * n % p;\n   |\
    \         ^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut n = n;\n    let mut result = 1;\n    while n > 0 {\n        if\
    \ n % 2 == 1 {\n            result = (result * n) % p;\n        }\n        n =\
    \ n / 2;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n   \
    \ assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `64`,\n right: `2`', /tmp/tmpkwdwbek5.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut r = 1;\n    let mut x = n;\n    let mut y = p;\n    while y >\
    \ 0 {\n        if y % 2 == 1 {\n            r = (r * x) % p;\n        }\n    \
    \    y /= 2;\n        x = (x * x) % p;\n    }\n    r\n}\n\nfn main() {\n    let\
    \ candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmp54_knset.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    // 2^(2^x) mod p\n    let twos: Vec<isize> = (0..p)\n        .map(|x|\
    \ modpow(2, x, p))\n        .collect();\n    // 2^(2^(2^x)) mod p\n    let twos_twos:\
    \ Vec<isize> = twos\n        .iter()\n        .map(|x| twos[(*x - 1) as usize])\n\
    \        .collect();\n    // 2^(2^(2^(2^x))) mod p\n    let twos_twos_twos: Vec<isize>\
    \ = twos_twos\n        .iter()\n        .map(|x| twos_twos[(*x - 1) as usize])\n\
    \        .collect();\n    // 2^(2^(2^(2^(2^x)))) mod p\n    let twos_twos_twos_twos:\
    \ Vec<isize> = twos_twos_twos\n        .iter()\n        .map(|x| twos_twos_twos[(*x\
    \ - 1) as usize])\n        .collect();\n    // 2^(2^(2^(2^(2^(2^x))))) mod p\n\
    \    let twos_twos_twos_twos_twos: Vec<isize> = twos_twos_twos_twos\n        .iter()\n\
    \        .map(|x| twos_twos_twos_twos[(*x - 1) as usize])\n        .collect();\n\
    \    // 2^(2^(2^(2^(2^(2^(2^x)))))) mod p\n    let twos_twos_twos_twos_twos_twos:\
    \ Vec<isize> = twos_twos_twos_twos_twos\n        .iter()\n        .map(|x| twos_twos_twos_twos_twos[(*x\
    \ - 1) as usize])\n        .collect();\n    // 2^(2^(2^(2^(2^(2^(2^(2^x))))\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `modpow` in this scope\n  --> /tmp/tmp2yhhdkb0.rs:15:18\n\
    \   |\n15 |         .map(|x| modpow(2, x, p))\n   |                  ^^^^^^ not\
    \ found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2yhhdkb0.rs:12:32\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----             \
    \           ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut r = 1;\n    let mut x = n;\n    while x > 0 {\n        if x %\
    \ 2 == 1 {\n            r = (r * n) % p;\n        }\n        x /= 2;\n       \
    \ n = (n * n) % p;\n    }\n    r\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp7s7mjstg.rs:20:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n20 |         n = (n * n) % p;\n \
    \  |         ^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut res = 1;\n    let mut modp = n % p;\n    let mut mult = modp;\n\
    \    for _ in 1..32 {\n        if (res & 1) == 1 {\n            res = (res * mult)\
    \ % p;\n        }\n        mult = (mult * mult) % p;\n        res = res >> 1;\n\
    \    }\n    return res;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpf2qwt1zl.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        modp(p as isize - (-n % p), p)\n    } else {\n  \
    \      let mut res = 1;\n        let mut k = n;\n        let mut y = 2;\n    \
    \    while k > 0 {\n            if k % 2 == 1 {\n                res = (res *\
    \ y) % p;\n            }\n            y = (y * y) % p;\n            k /= 2;\n\
    \        }\n        res\n    }\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let two = 2;\n    // modulo p of 2^n\n    fn modp_rec(n: isize, m: isize,\
    \ p: isize) -> isize {\n        if n == 0 {\n            return m;\n        }\
    \ else {\n            let m2 = m * m;\n            let m2 = m2 % p;\n        \
    \    return modp_rec(n - 1, m2, p);\n        }\n    }\n    return modp_rec(n,\
    \ two, p);\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `3`', /tmp/tmpkrg0orfc.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut r = 1;\n    let mut x = n;\n    while x > 0 {\n        if x %\
    \ 2 == 1 {\n            r = (r * n) % p;\n        }\n        x /= 2;\n       \
    \ n = (n * n) % p;\n    }\n    r\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp6qcyvrbv.rs:20:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n20 |         n = (n * n) % p;\n \
    \  |         ^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n\n    let mut res = modp(n / 2,\
    \ p);\n    res = (res * res) % p;\n\n    if n % 2 == 1 {\n        res = (res *\
    \ n) % p;\n    }\n\n    res\n}\n\nfn main() {\n    let candidate = modp;\n   \
    \ assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `94`,\n right: `2`', /tmp/tmprz92m1mr.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    let mut res = modp(n / 2,\
    \ p);\n    res = (res * res) % p;\n    if n % 2 == 1 {\n        res = (res * 2)\
    \ % p;\n    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n\n    let mut a = 1;\n    let\
    \ mut b = n;\n    while b != 0 {\n        if b % 2 == 1 {\n            a = (a\
    \ * n) % p;\n        }\n        b /= 2;\n        n = (n * n) % p;\n    }\n   \
    \ a\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpm4w5bxhd.rs:24:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n24 |         n = (n * n) % p;\n \
    \  |         ^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut n = n;\n    let mut result = 1;\n    let mut m = n % p;\n   \
    \ n = n / p;\n    while n > 0 {\n        result = (result * m) % p;\n        m\
    \ = (m * m) % p;\n        n = n / 2;\n    }\n    result\n}\n\nfn main() {\n  \
    \  let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `3`', /tmp/tmpcv_mx20q.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n % p == 0 {\n        return 1;\n    }\n    let mut i = 0;\n    let\
    \ mut res = 1;\n    while i < n {\n        res = (res * 2) % p;\n        i +=\
    \ 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp70eqhmbu.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    if n % 2 == 0 {\n        let\
    \ t = modp(n / 2, p);\n        return t * t % p;\n    }\n    modp(n - 1, p) *\
    \ n % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `94`,\n right: `2`', /tmp/tmptwrko_o2.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    // (n mod p)\n    let mut n = n % p;\n    // fast exponentiation\n  \
    \  let mut result = 1;\n    while n > 0 {\n        // (n & 1) == (n % 2)\n   \
    \     if n & 1 == 1 {\n            result = (result * result) % p;\n        }\n\
    \        n >>= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `3`', /tmp/tmpzmt2rb8e.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut result = 1;\n    for _ in 0..n {\n        result = (result *\
    \ 2) % p;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n  \
    \  assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    if n % 2 == 0 {\n        let\
    \ result = modp(n / 2, p);\n        return (result * result) % p;\n    }\n   \
    \ return (n * modp(n - 1, p)) % p;\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `94`,\n right: `2`', /tmp/tmpybz9miem.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut n = n;\n    let mut r = 1;\n    let mut s = 0;\n    loop {\n\
    \        let q = n / p;\n        r = (r * (n - p * q)) % p;\n        if r == 0\
    \ {\n            return 0;\n        }\n        s += 1;\n        if q == 0 {\n\
    \            return r;\n        }\n        n = q;\n    }\n}\n\nfn main() {\n \
    \   let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `2`', /tmp/tmpq9bywhfz.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut m = n;\n    let mut b = 1;\n    let mut e = p - 2;\n    while\
    \ e > 0 {\n        if e % 2 == 1 {\n            b = (b * m) % p;\n        }\n\
    \        m = (m * m) % p;\n        e = e / 2;\n    }\n    b\n}\n\nfn main() {\n\
    \    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmp1ciod7yc.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut n = n;\n    let mut res = 1;\n    let mut base = 2;\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            res = res * base % p;\n      \
    \  }\n        base = base * base % p;\n        n = n / 2;\n    }\n    res\n}\n\
    \nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut n = n % p;\n    if n < 0 {\n        n += p;\n    }\n    if n\
    \ < 0 {\n        panic!(\"Numerics for modp were not good enough.\")\n    }\n\
    \    n\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpqplo3ga6.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    // Maximum number of steps\
    \ is n.\n    let steps = std::cmp::min(n, p - 2);\n    let mut res = 2;\n    for\
    \ _ in 0..steps {\n        res = res * 2 % p;\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `3`', /tmp/tmpunoyub91.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    assert!(p > 0);\n    let mut n = n;\n    let mut res = 1;\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            res = (res * n) % p;\n       \
    \ }\n        n = n / 2;\n        n = (n * n) % p;\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut res = 1;\n    let mut n = n;\n    let mut p = p;\n    while n\
    \ > 0 {\n        if n % 2 == 1 {\n            res = (res * n) % p;\n        }\n\
    \        n = n / 2;\n        p = (p * p) % 101;\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to calculate the remainder with a divisor\
    \ of zero', /tmp/tmpya7hb7gi.rs:18:19\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut result = 1;\n    let mut current = n;\n    while current > 0\
    \ {\n        if current % 2 == 1 {\n            result = (result * n) % p;\n \
    \       }\n        current = current / 2;\n        n = (n * n) % p;\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpk9tln_yl.rs:20:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n20 |         n = (n * n) % p;\n \
    \  |         ^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    if n == 1 {\n        return\
    \ n;\n    }\n    let mut res = modp(n / 2, p);\n    res = (res * res) % p;\n \
    \   if n % 2 == 1 {\n        res = (res * n) % p;\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `94`,\n right: `2`', /tmp/tmp6fv3u21c.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    var a = 1;\n    for _ in 0..n {\n        a = (a * 2) % p;\n    }\n  \
    \  a\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "error: invalid variable declaration\n  --> /tmp/tmpvttzbflm.rs:13:5\n \
    \  |\n13 |     var a = 1;\n   |     ^^^\n   |\nhelp: write `let` instead of `var`\
    \ to introduce a new variable\n   |\n13 |     let a = 1;\n   |     ~~~\n\nerror:\
    \ aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    assert!(p > 0);\n    if n == 0 {\n        return 1;\n    }\n    let mut\
    \ m = modp(n / 2, p);\n    m = (m * m) % p;\n    if n % 2 == 1 {\n        m =\
    \ (m * 2) % p;\n    }\n    return m;\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    if n % 2 == 0 {\n        let\
    \ n2 = modp(n / 2, p);\n        return (n2 * n2) % p;\n    }\n    let n1 = modp(n\
    \ - 1, p);\n    return (n1 * n) % p;\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `94`,\n right: `2`', /tmp/tmp40xvehov.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    let mut res = 1;\n    let\
    \ mut k = 1;\n    while k <= n {\n        res = res * 2 % p;\n        k = k +\
    \ 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        return modp(-n, p);\n    }\n    let mut r = 1;\n\
    \    let mut n = n;\n    while n > 0 {\n        if n % 2 == 1 {\n            r\
    \ = (r * 2) % p;\n        }\n        n /= 2;\n    }\n    r\n}\n\nfn main() {\n\
    \    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmp2dq9ai7c.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut res = 1;\n    let mut mult = n;\n    while mult > 0 {\n     \
    \   if mult % 2 == 1 {\n            res = (res * n) % p;\n        }\n        mult\
    \ = mult / 2;\n        n = (n * n) % p;\n    }\n    res\n}\n\nfn main() {\n  \
    \  let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpu0llm4zg.rs:20:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n20 |         n = (n * n) % p;\n \
    \  |         ^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    // ToDo: because of the numerics, the current implementation is not correct\n\
    \    // for large numbers.\n\n    // Special case: modulo 1 is always 0.\n   \
    \ if p == 1 {\n        return 0;\n    }\n\n    // n: number to exponentiate\n\
    \    // p: modulo\n    // x: current power of n\n    // m: current number (x *\
    \ n)\n    let mut n = n;\n    let mut p = p;\n    let mut x = 1;\n    let mut\
    \ m = n;\n\n    // Because we are calculating modulo p,\n    // we only need to\
    \ calculate modulo p - 1.\n    // We stop as soon as we get a multiple of p -\
    \ 1.\n    // Because (p - 1) * (p - 1) = p\xB2 - 2p + 1 = 1 mod p,\n    // we\
    \ can use p\xB2 - 2p + 1 as stop criterion.\n    while m != p - 1 {\n        m\
    \ = (m * n) % p;\n        x = x + 1;\n    }\n\n    x\n}\n\nfn main() {\n    let\
    \ candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmp08514y1z.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    assert!(p > 1);\n    let mut result = 1;\n    for _ in 0..n {\n     \
    \   result = (result * 2) % p;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n\n    let mut result = 1;\n  \
    \  let mut factor = n;\n    let mut pow = p - 2;\n\n    while pow > 0 {\n    \
    \    if pow % 2 == 1 {\n            result = (result * factor) % p;\n        }\n\
    \        factor = (factor * factor) % p;\n        pow = pow / 2;\n    }\n\n  \
    \  result\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpfk2nh4go.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n / 2, p) * modp(n / 2, p) % p;\n    }\n    return modp(n - 1, p) * modp(n\
    \ / 2, p) % p;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `3`', /tmp/tmpf70pohi6.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    if n % 2 == 0 {\n        modp(n\
    \ / 2, p) * modp(n / 2, p) % p\n    } else {\n        n * modp(n - 1, p) % p\n\
    \    }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `94`,\n right: `2`', /tmp/tmpl08qhl40.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut ln: isize = n;\n    let mut lp: isize = p;\n    let mut pow:\
    \ isize = 1;\n    let mut rem: isize = 1;\n    while ln > 0 {\n        if ln %\
    \ 2 == 1 {\n            rem = (rem * pow) % lp;\n        }\n        pow = (pow\
    \ * pow) % lp;\n        ln = ln / 2;\n    }\n    rem\n}\n\nfn main() {\n    let\
    \ candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `3`', /tmp/tmpjqj78pd9.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut base = 1;\n    let mut tmp = n;\n    while tmp > 0 {\n      \
    \  if tmp % 2 == 1 {\n            base = (base * n) % p;\n        }\n        n\
    \ = (n * n) % p;\n        tmp /= 2;\n    }\n    base\n}\n\nfn main() {\n    let\
    \ candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpzu80go6s.rs:19:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n19 |         n = (n * n) % p;\n \
    \  |         ^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    let mut res = modp(n / 2,\
    \ p);\n    res = (res * res) % p;\n    if n % 2 == 1 {\n        res = (res * 2)\
    \ % p;\n    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut n = n;\n    let mut r = 1;\n    while n > 0 {\n        if n %\
    \ 2 == 1 {\n            r = (r * n) % p;\n        }\n        n = n / 2;\n    }\n\
    \    r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `64`,\n right: `2`', /tmp/tmpr1001805.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut n = n;\n    let mut ret = 1;\n    while n > 0 {\n        if n\
    \ % 2 == 1 {\n            ret = (ret * 2) % p;\n        }\n        n /= 2;\n \
    \   }\n    ret\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpyop8yjii.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    if n == 1 {\n        return\
    \ n;\n    }\n    let mut n = n;\n    let mut res = 1;\n    while n > 0 {\n   \
    \     if n % 2 == 1 {\n            res = (res * n) % p;\n        }\n        n\
    \ = n / 2;\n        n = (n * n) % p;\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut acc = 1;\n    let mut base = n;\n    let mut exp = p - 2;\n \
    \   while exp > 0 {\n        if exp % 2 == 1 {\n            acc = (acc * base)\
    \ % p;\n        }\n        base = (base * base) % p;\n        exp = exp / 2;\n\
    \    }\n    acc\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmp54ps87yp.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    let mut r: isize = 1;\n  \
    \  let mut nn = n;\n    while nn > 0 {\n        if nn % 2 == 1 {\n           \
    \ r = (r * n) % p;\n        }\n        nn /= 2;\n        n = (n * n) % p;\n  \
    \  }\n    r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpuz7_qtqf.rs:23:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n23 |         n = (n * n) % p;\n \
    \  |         ^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut n = n % p;\n    if n < 0 {\n        n += p;\n    }\n    n\n}\n\
    \nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpekt4mzty.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    let mut k = modp(n / 2, p);\n\
    \    k = (k * k) % p;\n    if n % 2 == 1 {\n        k = (k * (n % p)) % p;\n \
    \   }\n    k\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `94`,\n right: `2`', /tmp/tmpwiiblo3q.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut pow = 1;\n    let mut i = 0;\n    while i < n {\n        pow\
    \ = (pow * 2) % p;\n        i += 1;\n    }\n    pow\n}\n\nfn main() {\n    let\
    \ candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    if n % 2 == 0 {\n        let\
    \ temp = modp(n / 2, p);\n        return (temp * temp) % p;\n    }\n    return\
    \ (modp(n - 1, p) * (n % p)) % p;\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `94`,\n right: `2`', /tmp/tmpeti6xcfp.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut r = 1;\n    let mut t = 2;\n    let mut i = n;\n    while i >\
    \ 0 {\n        if i % 2 == 1 {\n            r = (r * t) % p;\n        }\n    \
    \    t = (t * t) % p;\n        i = i / 2;\n    }\n    r\n}\n\nfn main() {\n  \
    \  let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    let mut i = 0;\n    let mut\
    \ res = 1;\n    while i < n.abs() {\n        res = (res * 2) % p;\n        i +=\
    \ 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut res = 1;\n    let mut tmp = n;\n    while tmp > 0 {\n       \
    \ if tmp % 2 == 1 {\n            res = (res * n) % p;\n        }\n        n =\
    \ (n * n) % p;\n        tmp /= 2;\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp0syfs6t7.rs:19:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n19 |         n = (n * n) % p;\n \
    \  |         ^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut n = n;\n    let mut r = 1;\n    while n > 0 {\n        if n %\
    \ 2 == 1 {\n            r = (r * 2) % p;\n        }\n        n /= 2;\n    }\n\
    \    r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpivatrfiv.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    let mut result = modp(n /\
    \ 2, p);\n    result = result * result % p;\n    if n % 2 == 1 {\n        result\
    \ = result * 2 % p;\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101),\
    \ 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11),\
    \ 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5),\
    \ 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let one = match n % p {\n        0 => 1,\n        r => r,\n    };\n \
    \   let mut result = one;\n    for _ in 0..n {\n        result = (result * 2)\
    \ % p;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmp5l2q5koq.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut r = 1;\n    let mut x = n;\n    while x > 0 {\n        if x %\
    \ 2 == 1 {\n            r = (r * n) % p;\n        }\n        x = x / 2;\n    \
    \    n = (n * n) % p;\n    }\n    r\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpx4komd6q.rs:20:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n20 |         n = (n * n) % p;\n \
    \  |         ^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    // TODO: implement modp\n    0\n}\n\nfn main() {\n    let candidate =\
    \ modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101),\
    \ 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11),\
    \ 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5),\
    \ 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmps9pqqduw.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    if n == 1 {\n        return\
    \ n;\n    }\n    if n % 2 == 0 {\n        let val = modp(n / 2, p);\n        return\
    \ (val * val) % p;\n    }\n    if n % 2 == 1 {\n        let val = modp(n - 1,\
    \ p);\n        return (val * n) % p;\n    }\n    1\n}\n\nfn main() {\n    let\
    \ candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `94`,\n right: `2`', /tmp/tmpp6l727i3.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let e = modulo(n, p - 1);\n    modulo(2, e)\n}\n\nfn main() {\n    let\
    \ candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `modulo` in this scope\n  --> /tmp/tmp7p1wxzq5.rs:13:13\n\
    \   |\n13 |     let e = modulo(n, p - 1);\n   |             ^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find function `modulo` in this scope\n  -->\
    \ /tmp/tmp7p1wxzq5.rs:14:5\n   |\n14 |     modulo(2, e)\n   |     ^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    let mut tmp = modp(n / 2,\
    \ p);\n    tmp = (tmp * tmp) % p;\n    if n % 2 == 1 {\n        tmp = (tmp * 2)\
    \ % p;\n    }\n    return tmp;\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    match n {\n        0 => 1,\n        _ => {\n            let b = modp(n\
    \ / 2, p);\n            let c = (b * b) % p;\n            if n % 2 == 0 {\n  \
    \              c\n            } else {\n                (c * n) % p\n        \
    \    }\n        }\n    }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `94`,\n right: `2`', /tmp/tmpow3u_lu9.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n\n    if n == 1 {\n        return\
    \ n;\n    }\n\n    let x = n % 2;\n    let y = n - x;\n    let z = modp(y / 2,\
    \ p);\n\n    if x == 0 {\n        return z * z % p;\n    } else {\n        return\
    \ z * z * n % p;\n    }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `94`,\n right: `2`', /tmp/tmpi891l8wd.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    let mut result = 1;\n    let\
    \ mut a = 2;\n    let mut b = n;\n    while b > 0 {\n        if b % 2 == 1 {\n\
    \            result = (result * a) % p;\n        }\n        a = (a * a) % p;\n\
    \        b = b / 2;\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101),\
    \ 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11),\
    \ 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5),\
    \ 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut n = n % p;\n    if n < 0 {\n        n += p;\n    }\n    n\n}\n\
    \nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpowrl7q88.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut n = n;\n    if n < 0 {\n        n = (n % p) + p;\n    }\n   \
    \ n % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpe_fo5tky.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    match n {\n        0 => 1,\n        1 => n,\n        _ => {\n       \
    \     let mut r = modp(n / 2, p);\n            r = (r * r) % p;\n            if\
    \ n % 2 == 1 {\n                r = (r * n) % p;\n            }\n            r\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `94`,\n right: `2`', /tmp/tmp2wi1guri.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut num: isize = n;\n    let mut result: isize = 1;\n    while num\
    \ > 0 {\n        result = (result * num) % p;\n        num = num - 1;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `3`', /tmp/tmpa68iz7yz.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    match n {\n        0 => 1,\n        _ => {\n            let res = modp(n\
    \ / 2, p);\n            let res = res * res % p;\n            if n % 2 == 0 {\n\
    \                res\n            } else {\n                res * 2 % p\n    \
    \        }\n        }\n    }\n}\n\nfn main() {\n    let candidate = modp;\n  \
    \  assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n >= p {\n        return modp(n % p, p);\n    }\n    let mut n = n;\n\
    \    let mut n_pow_1 = 1;\n    let mut n_pow_2 = n;\n    while n_pow_2 > 1 {\n\
    \        n_pow_2 = modp(n_pow_2 * n_pow_2, p);\n        if n % 2 == 1 {\n    \
    \        n_pow_1 = modp(n_pow_1 * n_pow_2, p);\n        }\n        n /= 2;\n \
    \   }\n    n_pow_1\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `3`', /tmp/tmpxo4kg8mv.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut r = 1;\n    let mut n = n;\n    while n > 0 {\n        if n %\
    \ 2 == 1 {\n            r = (r * n) % p;\n        }\n        n = n / 2;\n    }\n\
    \    r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `64`,\n right: `2`', /tmp/tmp39bpwqst.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut n = n;\n    let mut k = 1;\n    let mut x = n % p;\n    n = n\
    \ / p;\n    while n > 0 {\n        if n % 2 == 1 {\n            k = (k * x) %\
    \ p;\n        }\n        x = (x * x) % p;\n        n = n / 2;\n    }\n    k\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `3`', /tmp/tmpxp33gmuq.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut i = 1;\n    let mut c = 1;\n    while i <= n {\n        c = (c\
    \ * 2) % p;\n        i += 1;\n    }\n    c\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut res = 1;\n    let mut cur = n;\n    let mut p = p;\n    while\
    \ p > 0 {\n        if p % 2 == 1 {\n            res = (res * cur) % p;\n     \
    \   }\n        cur = (cur * cur) % p;\n        p = p / 2;\n    }\n    res\n}\n\
    \nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmphw9qh06x.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    match n {\n        0 => 1,\n        n => ((modp(n / 2, p) * modp(n /\
    \ 2, p)) % p * modp(n % 2, p)) % p,\n    }\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    let mut x = modp(n / 2, p);\n\
    \    x = x * x % p;\n    if n % 2 == 1 {\n        x = x * 2 % p;\n    }\n    x\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut res = 1;\n    let mut n = n;\n    let mut x = 2;\n    while n\
    \ > 0 {\n        if n % 2 == 1 {\n            res = (res * x) % p;\n        }\n\
    \        n = n / 2;\n        x = (x * x) % p;\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    if n % 2 == 0 {\n        let\
    \ z = modp(n / 2, p);\n        return (z * z) % p;\n    }\n    return (modp(n\
    \ - 1, p) * n) % p;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `94`,\n right: `2`', /tmp/tmpjo0pdtu4.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n >= p {\n        return modp(n - p, p);\n    }\n    if n == 0 {\n\
    \        return 1;\n    }\n    if n == 1 {\n        return n;\n    }\n    let\
    \ k = modp(n / 2, p);\n    if n % 2 == 0 {\n        return k * k % p;\n    }\n\
    \    return k * k * n % p;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `46`,\n right: `2`', /tmp/tmpd50pgbpt.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    assert!(n >= 0 && p > 0);\n    let mut result = 1;\n    for _ in 0..n\
    \ {\n        result = (result * 2) % p;\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    assert!(n >= 0);\n    assert!(p > 0);\n    if n == 0 {\n        return\
    \ 1;\n    }\n    if n == 1 {\n        return n;\n    }\n    let mut x = modp(n\
    \ / 2, p);\n    x = (x * x) % p;\n    if n % 2 == 1 {\n        x = (x * n) % p;\n\
    \    }\n    x\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `94`,\n right: `2`', /tmp/tmp42a9frrw.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut m = n;\n    let mut r = 1;\n    while m > 0 {\n        if m %\
    \ 2 == 1 {\n            r = (r * n) % p;\n        }\n        n = (n * n) % p;\n\
    \        m = m / 2;\n    }\n    r\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpac9xlvqa.rs:19:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n19 |         n = (n * n) % p;\n \
    \  |         ^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    let mut y = modp(n / 2, p);\n\
    \    y = (y * y) % p;\n    if n % 2 == 0 {\n        return y;\n    }\n    return\
    \ (y * n) % p;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `94`,\n right: `2`', /tmp/tmp7mr99k3z.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut result = 1;\n    let mut i = 0;\n    while i < n {\n        result\
    \ = (result * 2) % p;\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    return (1..n + 1).fold(1, |product, _| (product * 2) % p);\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    let mut result = 1;\n    let\
    \ mut n = n;\n    let mut n_pow_p = n % p;\n    loop {\n        if n % 2 == 1\
    \ {\n            result = (result * n_pow_p) % p;\n        }\n        n = n /\
    \ 2;\n        if n == 0 {\n            break;\n        }\n        n_pow_p = (n_pow_p\
    \ * n_pow_p) % p;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmps_po_14x.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut q = n;\n    let mut result = 1;\n    loop {\n        if q & 1\
    \ == 1 {\n            result = (result * n) % p;\n        }\n        q = q >>\
    \ 1;\n        if q == 0 {\n            break;\n        }\n        n = (n * n)\
    \ % p;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpq18nfiec.rs:23:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n23 |         n = (n * n) % p;\n \
    \  |         ^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut y = 1;\n    let mut x = n;\n    while x > 1 {\n        if x %\
    \ 2 == 0 {\n            x = x / 2;\n            y = y * 2;\n        } else {\n\
    \            x = (x + p) / 2;\n            y = (y + n) / 2;\n        }\n    }\n\
    \    y\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `8`,\n right: `3`', /tmp/tmpkznac7wp.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut res = 1;\n    let mut b = n;\n    let mut e = p;\n    while e\
    \ > 0 {\n        if e % 2 == 1 {\n            res = (res * b) % p;\n        }\n\
    \        e = e >> 1;\n        b = (b * b) % p;\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpkc1o0o25.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    let mut res = modp(n / 2,\
    \ p);\n    res = (res * res) % p;\n    if n % 2 == 1 {\n        res = (res * 2)\
    \ % p;\n    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    let mut result = modp(n /\
    \ 2, p);\n    result = (result * result) % p;\n    if n % 2 == 1 {\n        result\
    \ = (result * 2) % p;\n    }\n    return result;\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    let mut r = 1;\n    let mut\
    \ x = n;\n    loop {\n        if x & 1 == 1 {\n            r = (r * n) % p;\n\
    \        }\n        x = x >> 1;\n        if x == 0 {\n            break;\n   \
    \     }\n        n = (n * n) % p;\n    }\n    r\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpcbnv008c.rs:26:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n26 |         n = (n * n) % p;\n \
    \  |         ^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        let mut x = 1;\n        let mut i = -n;\n       \
    \ while i > 0 {\n            x = (x * n) % p;\n            i -= 1;\n        }\n\
    \        return inv(x, p);\n    } else {\n        let mut x = 1;\n        let\
    \ mut i = n;\n        while i > 0 {\n            x = (x * n) % p;\n          \
    \  i -= 1;\n        }\n        return x;\n    }\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `inv` in this scope\n  --> /tmp/tmpgmugn0pl.rs:20:16\n\
    \   |\n20 |         return inv(x, p);\n   |                ^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut a = 1;\n    let mut b = n;\n    while b > 0 {\n        if b %\
    \ 2 == 1 {\n            a = (a * n) % p;\n        }\n        b = b / 2;\n    \
    \    n = (n * n) % p;\n    }\n    a\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpd3kmf9ez.rs:20:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n20 |         n = (n * n) % p;\n \
    \  |         ^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n\n    if n % 2 == 0 {\n      \
    \  let a = modp(n / 2, p);\n        return a * a % p;\n    }\n\n    modp(n - 1,\
    \ p) * n % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `94`,\n right: `2`', /tmp/tmpdcczy5gm.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut result = 1;\n    let mut b = n;\n    let mut x = p;\n    while\
    \ b > 0 {\n        if b % 2 == 1 {\n            result = (result * x) % p;\n \
    \       }\n        b = b / 2;\n        x = (x * x) % p;\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp28j83cf5.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n % p == 0 {\n        return 1;\n    }\n    let mut k = 1;\n    let\
    \ mut power = 2;\n    while power <= n {\n        power *= 2;\n        k += 1;\n\
    \    }\n    let mut result = 1;\n    let mut power = 1;\n    for _ in 0..k {\n\
    \        power = modmul(power, power, p);\n        if (n & (1 << (k - 1))) !=\
    \ 0 {\n            result = modmul(result, power, p);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `modmul` in this scope\n  --> /tmp/tmp5v75qbdy.rs:25:17\n\
    \   |\n25 |         power = modmul(power, power, p);\n   |                 ^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `modmul` in this\
    \ scope\n  --> /tmp/tmp5v75qbdy.rs:27:22\n   |\n27 |             result = modmul(result,\
    \ power, p);\n   |                      ^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    if n % 2 == 0 {\n        let\
    \ m = modp(n / 2, p);\n        return m * m % p;\n    }\n    let m = modp(n -\
    \ 1, p);\n    return n * m % p;\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `94`,\n right: `2`', /tmp/tmp2ungogv4.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut r = 1;\n    let mut x = n;\n    let mut m = p;\n    while m >\
    \ 0 {\n        if m % 2 == 1 {\n            r = (r * x) % p;\n        }\n    \
    \    x = (x * x) % p;\n        m = m / 2;\n    }\n    r\n}\n\nfn main() {\n  \
    \  let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmp_hot8po4.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < p {\n        n\n    } else {\n        let d: isize = n / p;\n\
    \        let r: isize = n - p * d;\n        modp(r, p)\n    }\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpy9gqfn0w.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut res = 1;\n    let mut a = n;\n    let mut b = p;\n    let mut\
    \ b0 = b;\n    let mut hi = 1;\n    let mut lo = 0;\n    let mut t;\n    while\
    \ a > 0 {\n        if a & 1 == 1 {\n            t = hi;\n            hi = (res\
    \ * t) % b;\n            lo = (lo * t + res * hi) % b;\n            res = (lo\
    \ & ((1 << 31) - 1)) + (lo >> 31) + (hi << 31 >> 31) + (hi >> 1);\n          \
    \  res = res % b;\n        }\n        t = a;\n        a = t >> 1;\n        t =\
    \ hi;\n        hi = (t * t) % b;\n        lo = (lo * t + t * hi) % b;\n      \
    \  hi = (lo & ((1 << 31) - 1)) + (lo >> 31) + (hi << 31 >> 31) + (hi >> 1);\n\
    \        hi = hi % b;\n    }\n    if res < 0 {\n        res = res + b0;\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpgznepl39.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    if n % 2 == 0 {\n        let\
    \ t = modp(n / 2, p);\n        return (t * t) % p;\n    }\n    return (modp(n\
    \ - 1, p) * n) % p;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `94`,\n right: `2`', /tmp/tmp5b9tntsv.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    let mut res = 1;\n    for\
    \ _ in 0..n {\n        res = (res * 2) % p;\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n\n    if n % 2 == 0 {\n      \
    \  let m = modp(n / 2, p);\n        return (m * m) % p;\n    }\n\n    (modp(n\
    \ - 1, p) * n) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `94`,\n right: `2`', /tmp/tmp62et8gl2.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    if n % 2 == 0 {\n        let\
    \ half = modp(n / 2, p);\n        return (half * half) % p;\n    }\n    return\
    \ (modp(n - 1, p) * n) % p;\n}\n\nfn main() {\n    let candidate = modp;\n   \
    \ assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `94`,\n right: `2`', /tmp/tmpgyaibsrc.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
