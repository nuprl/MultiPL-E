name: HumanEval_95_check_dict_case
language: rust
results:
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut up =\
    \ true;\n    let mut low = true;\n    for key in dict.keys() {\n        for c\
    \ in key.chars() {\n            if c.is_uppercase() {\n                low = false;\n\
    \            } else if c.is_lowercase() {\n                up = false;\n     \
    \       } else {\n                return false;\n            }\n        }\n  \
    \  }\n    up || low\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjkccioqt.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.len()\
    \ == 0 {\n        return false;\n    }\n    let mut is_all_lower_key = true;\n\
    \    let mut is_all_upper_key = true;\n    for key in dict.keys() {\n        if\
    \ key.chars().any(|c| c.is_lowercase()) {\n            is_all_upper_key = false;\n\
    \        }\n        if key.chars().any(|c| c.is_uppercase()) {\n            is_all_lower_key\
    \ = false;\n        }\n    }\n    is_all_lower_key || is_all_upper_key\n}\n\n\
    fn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjb77o1dq.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut is_lower = true;\n    let mut is_upper\
    \ = true;\n    for key in dict.keys() {\n        if !key.is_empty() {\n      \
    \      is_lower = is_lower && key.chars().all(|c| c.is_lowercase());\n       \
    \     is_upper = is_upper && key.chars().all(|c| c.is_uppercase());\n        }\n\
    \    }\n    is_lower || is_upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut upper\
    \ = true;\n    let mut lower = true;\n    for key in dict.keys() {\n        let\
    \ string = key.as_str();\n        if string.is_ascii_uppercase() {\n         \
    \   lower = false;\n        } else if string.is_ascii_lowercase() {\n        \
    \    upper = false;\n        } else {\n            return false;\n        }\n\
    \    }\n    upper | lower\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_uppercase` found for reference\
    \ `&str` in the current scope\n  --> /tmp/tmpih_5j4sq.rs:17:19\n   |\n17 |   \
    \      if string.is_ascii_uppercase() {\n   |                   ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_uppercase`\n\
    \nerror[E0599]: no method named `is_ascii_lowercase` found for reference `&str`\
    \ in the current scope\n  --> /tmp/tmpih_5j4sq.rs:19:26\n   |\n19 |         }\
    \ else if string.is_ascii_lowercase() {\n   |                          ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.keys().all(|s|\
    \ s.eq_ignore_ascii_case(s))\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpv0g_ddj7.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut uppers:\
    \ i32 = 0;\n    let mut lowers: i32 = 0;\n    for (key, _) in dict {\n       \
    \ if key.chars().all(|c| c.is_uppercase()) {\n            uppers += 1;\n     \
    \   } else if key.chars().all(|c| c.is_lowercase()) {\n            lowers += 1;\n\
    \        } else {\n            return false;\n        }\n    }\n    if dict.len()\
    \ > 0 {\n        return uppers == dict.len() as i32 || lowers == dict.len() as\
    \ i32;\n    } else {\n        return false;\n    }\n}\n\nfn main() {\n    let\
    \ candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `dict`\n   --> /tmp/tmp5nhq2eaf.rs:24:8\n\
    \    |\n12  | fn check_dict_case(dict: HashMap<String, String>) -> bool {\n  \
    \  |                    ---- move occurs because `dict` has type `HashMap<String,\
    \ String>`, which does not implement the `Copy` trait\n...\n15  |     for (key,\
    \ _) in dict {\n    |                     ---- `dict` moved due to this implicit\
    \ call to `.into_iter()`\n...\n24  |     if dict.len() > 0 {\n    |        ^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `dict`\nhelp: consider iterating over a slice\
    \ of the `HashMap<String, String>`'s content to avoid moving into the `for` loop\n\
    \    |\n15  |     for (key, _) in &dict {\n    |                     +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    // unimplemented!()\n\
    \    let mut count_upper: u8 = 0;\n    let mut count_lower: u8 = 0;\n    let mut\
    \ result: bool = false;\n    if dict.len() > 0 {\n        for (key, _) in dict\
    \ {\n            if key.len() > 0 {\n                if key.chars().nth(0).unwrap().is_uppercase()\
    \ {\n                    count_upper += 1;\n                } else {\n       \
    \             count_lower += 1;\n                }\n            }\n        }\n\
    \        if count_upper == 0 || count_lower == 0 {\n            result = true;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvgar0z3g.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpjgn9qz8b.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.len()\
    \ == 0 {\n        return false;\n    }\n    let mut lower = true;\n    let mut\
    \ upper = true;\n    for key in dict.keys() {\n        let key_str = key.to_string();\n\
    \        if key_str.to_lowercase() != key_str {\n            lower = false;\n\
    \        }\n        if key_str.to_uppercase() != key_str {\n            upper\
    \ = false;\n        }\n    }\n    if lower || upper {\n        return true;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = check_dict_case;\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\"\
    )), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpiofr2khq.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    // In this case\
    \ it is sufficient to take a look at the first element.\n    // We don't check\
    \ for is_empty() because of the example.\n    let mut case = dict.keys().nth(0).unwrap().is_lowercase();\n\
    \    for key in dict.keys() {\n        if key.is_lowercase() != case {\n     \
    \       return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmp_r2s4naz.rs:15:48\n   |\n15 |     let mut\
    \ case = dict.keys().nth(0).unwrap().is_lowercase();\n   |                   \
    \                             ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `is_lowercase`\
    \ found for reference `&String` in the current scope\n  --> /tmp/tmp_r2s4naz.rs:17:16\n\
    \   |\n17 |         if key.is_lowercase() != case {\n   |                ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_lowercase`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_all_lower\
    \ = false;\n    let mut is_all_upper = false;\n    for key in dict.keys() {\n\
    \        if key.is_empty() {\n            return false;\n        }\n        if\
    \ key.chars().all(|c| c.is_lowercase()) {\n            is_all_lower = true;\n\
    \        } else if key.chars().all(|c| c.is_uppercase()) {\n            is_all_upper\
    \ = true;\n        } else {\n            return false;\n        }\n    }\n   \
    \ is_all_lower ^ is_all_upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_lower\
    \ = None;\n    for (key, _) in dict {\n        let is_lower_key = key.to_lowercase()\
    \ == key;\n        if is_lower.is_none() {\n            is_lower = Some(is_lower_key);\n\
    \        } else if is_lower.unwrap() != is_lower_key {\n            return false;\n\
    \        }\n    }\n    is_lower.unwrap_or(false)\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp3xcgf2q1.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    // If the dictionary\
    \ is empty, return false\n    if dict.is_empty() {\n        return false;\n  \
    \  }\n\n    // Assume the first key is all lowercase\n    let mut all_lower =\
    \ true;\n\n    // Make an iterator over the dictionary\n    let mut iter = dict.iter();\n\
    \n    // Grab the first key\n    let first_key = iter.next().unwrap().0;\n\n \
    \   // Check if all characters in the first key are uppercase\n    if first_key.chars().all(|ch|\
    \ ch.is_uppercase()) {\n        all_lower = false;\n    }\n\n    // Check the\
    \ rest of the characters\n    for (key, _) in iter {\n        if all_lower &&\
    \ key.chars().any(|ch| ch.is_uppercase()) {\n            return false;\n     \
    \   } else if !all_lower && key.chars().any(|ch| ch.is_lowercase()) {\n      \
    \      return false;\n        }\n    }\n\n    // True if all characters were uppercase\
    \ or lowercase\n    true\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvgy10rkw.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_all_lower\
    \ = true;\n    let mut is_all_upper = true;\n    for k in dict.keys() {\n    \
    \    if k.chars().all(|c| c.is_uppercase()) {\n            is_all_lower = false;\n\
    \        } else if k.chars().all(|c| c.is_lowercase()) {\n            is_all_upper\
    \ = false;\n        } else {\n            return false;\n        }\n    }\n  \
    \  is_all_lower ^ is_all_upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut all_lower\
    \ = true;\n    let mut all_upper = true;\n    for key in dict.keys() {\n     \
    \   if key.is_ascii_lowercase() {\n            all_upper = false;\n        } else\
    \ if key.is_ascii_uppercase() {\n            all_lower = false;\n        } else\
    \ {\n            return false;\n        }\n    }\n    return all_lower || all_upper;\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmp12tefl_f.rs:16:16\n   |\n16 |\
    \         if key.is_ascii_lowercase() {\n   |                ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmp12tefl_f.rs:18:23\n   |\n18 |         }\
    \ else if key.is_ascii_uppercase() {\n   |                       ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_uppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n\tlet mut count_upper\
    \ = 0;\n\tlet mut count_lower = 0;\n\tfor key in dict.keys() {\n\t\tif key.chars().all(|x|\
    \ x.is_lowercase()) {\n\t\t\tcount_lower += 1;\n\t\t} else if key.chars().all(|x|\
    \ x.is_uppercase()) {\n\t\t\tcount_upper += 1;\n\t\t}\n\t}\n\tif count_lower >\
    \ 0 && count_upper > 0 {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp05pif0ms.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    // your code\
    \ here\n\n    false\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpa2be7u0c.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut all_lower_keys\
    \ = true;\n    let mut all_upper_keys = true;\n    for key in dict.keys() {\n\
    \        if key.is_empty() {\n            return false;\n        }\n        if\
    \ key.chars().any(|c| c.is_uppercase()) {\n            all_lower_keys = false;\n\
    \        }\n        if key.chars().any(|c| c.is_lowercase()) {\n            all_upper_keys\
    \ = false;\n        }\n    }\n    return all_lower_keys || all_upper_keys;\n}\n\
    \nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo_0egg0f.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut keys_up\
    \ = true;\n    let mut keys_low = true;\n    for key in dict.keys() {\n      \
    \  if let Some(c) = key.chars().next() {\n            if c.is_uppercase() {\n\
    \                keys_low = false;\n            } else if c.is_lowercase() {\n\
    \                keys_up = false;\n            } else {\n                return\
    \ false;\n            }\n        }\n    }\n    keys_up || keys_low\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjhtaly2q.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ { return false; }\n    //check lower case\n    for (key, _) in dict.iter() {\n\
    \        if !key.is_ascii_lowercase() { return false; }\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpy1kfh5k8.rs:16:17\n   |\n16 |\
    \         if !key.is_ascii_lowercase() { return false; }\n   |               \
    \  ^^^^^^^^^^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `to_ascii_lowercase`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.len()\
    \ == 0 {\n        return false;\n    }\n    let mut flag = false;\n    for pair\
    \ in dict.iter() {\n        if !(pair.0.is_ascii_lowercase() || pair.0.is_ascii_uppercase())\
    \ {\n            return false;\n        }\n        if !flag {\n            flag\
    \ = pair.0.is_ascii_lowercase();\n        }\n    }\n    flag\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmph6599npd.rs:18:21\n   |\n18 |\
    \         if !(pair.0.is_ascii_lowercase() || pair.0.is_ascii_uppercase()) {\n\
    \   |                     ^^^^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_ascii_lowercase`\n\nerror[E0599]: no method named `is_ascii_uppercase`\
    \ found for reference `&String` in the current scope\n  --> /tmp/tmph6599npd.rs:18:52\n\
    \   |\n18 |         if !(pair.0.is_ascii_lowercase() || pair.0.is_ascii_uppercase())\
    \ {\n   |                                                    ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_uppercase`\n\
    \nerror[E0599]: no method named `is_ascii_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmph6599npd.rs:22:27\n   |\n22 |          \
    \   flag = pair.0.is_ascii_lowercase();\n   |                           ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut keys\
    \ = dict.keys();\n    if let Some(ref first_key) = keys.next() {\n        if keys.all(|key|\
    \ {\n            key.eq_ignore_ascii_case(first_key)\n        }) {\n         \
    \   return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmps9qx5km3.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lcase\
    \ = true;\n    let mut ucase = true;\n    for item in dict.keys() {\n        let\
    \ c = item.chars().next().unwrap();\n        let ascii = c as u8;\n        if\
    \ ascii >= 65 && ascii <= 90 {\n            lcase = false;\n        } else if\
    \ ascii >= 97 && ascii <= 122 {\n            ucase = false;\n        } else {\n\
    \            return false;\n        }\n    }\n    return lcase || ucase;\n}\n\n\
    fn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpbh8a0rtg.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_lower:\
    \ bool = false;\n    let mut is_upper: bool = false;\n    for (key, _) in dict\
    \ {\n        is_lower = is_lower || key.chars().all(|c| c.is_lowercase());\n \
    \       is_upper = is_upper || key.chars().all(|c| c.is_uppercase());\n    }\n\
    \    is_lower ^ is_upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp61hdqkho.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmps9w51zuz.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpw_za07dh.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut all_uppercase:\
    \ bool = true;\n    let mut all_lowercase: bool = true;\n    for k in dict.keys()\
    \ {\n        if k.to_lowercase() != k.to_uppercase() {\n            return false;\n\
    \        }\n        if !k.is_ascii_uppercase() {\n            all_uppercase =\
    \ false;\n        }\n        if !k.is_ascii_lowercase() {\n            all_lowercase\
    \ = false;\n        }\n    }\n    if all_uppercase || all_lowercase {\n      \
    \  return true;\n    }\n    return false;\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_uppercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpdtvg43dh.rs:19:15\n   |\n19 |\
    \         if !k.is_ascii_uppercase() {\n   |               ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_uppercase`\n\
    \nerror[E0599]: no method named `is_ascii_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpdtvg43dh.rs:22:15\n   |\n22 |         if\
    \ !k.is_ascii_lowercase() {\n   |               ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_lowercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut upper\
    \ = true;\n    let mut lower = true;\n    for key in dict.keys() {\n        if\
    \ key.is_uppercase() {\n            lower = false;\n        } else if key.is_lowercase()\
    \ {\n            upper = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    return upper || lower;\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmptbt29f0o.rs:16:16\n   |\n16 |         if\
    \ key.is_uppercase() {\n   |                ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named\
    \ `is_lowercase` found for reference `&String` in the current scope\n  --> /tmp/tmptbt29f0o.rs:18:23\n\
    \   |\n18 |         } else if key.is_lowercase() {\n   |                     \
    \  ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = false;\n    let mut upper = false;\n    for (key, _) in dict {\n        if\
    \ key.chars().all(|c| c.is_uppercase()) {\n            upper = true;\n       \
    \ } else if key.chars().all(|c| c.is_lowercase()) {\n            lower = true;\n\
    \        } else {\n            return false;\n        }\n    }\n    if lower &&\
    \ upper {\n        return false;\n    }\n    return true;\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp2zgli1e5.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut upper_count\
    \ = 0;\n    let mut lower_count = 0;\n    for key in dict.keys() {\n        let\
    \ mut split_key: Vec<&str> = key.split(\"\").collect();\n        split_key.retain(|s|\
    \ *s != \"\");\n        split_key[0].to_uppercase() == split_key[0] ? upper_count\
    \ += 1 : lower_count += 1;\n    }\n    if upper_count == 0 && lower_count == 0\
    \ {\n        return false;\n    }\n    upper_count == 0 || lower_count == 0\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `upper_count`\n\
    \  --> /tmp/tmpfrjw338b.rs:18:55\n   |\n18 |         split_key[0].to_uppercase()\
    \ == split_key[0] ? upper_count += 1 : lower_count += 1;\n   |               \
    \                                        ^^^^^^^^^^^ expected one of `.`, `;`,\
    \ `?`, `}`, or an operator\n\nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let is_lower_case\
    \ = dict.keys().all(|s| s.chars().all(|c| c.is_lowercase()));\n    let is_upper_case\
    \ = dict.keys().all(|s| s.chars().all(|c| c.is_uppercase()));\n    return is_lower_case\
    \ || is_upper_case;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphflk_9lh.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case_flag\
    \ = false;\n    let mut upper_case_flag = false;\n    for key in dict.keys() {\n\
    \        if key.chars().all(|character| character.is_lowercase()) {\n        \
    \    lower_case_flag = true;\n        } else if key.chars().all(|character| character.is_uppercase())\
    \ {\n            upper_case_flag = true;\n        } else {\n            return\
    \ false;\n        }\n    }\n    lower_case_flag || upper_case_flag\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwqi83j8i.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    // YOUR CODE\
    \ HERE\n    return false;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpg47t6s_j.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    // your code\
    \ here!\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpkfbraqxj.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.is_empty()\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpx7f4g318.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let all_lower\
    \ = dict.keys().all(|s| s.chars().all(|c| c.is_lowercase()));\n    let all_upper\
    \ = dict.keys().all(|s| s.chars().all(|c| c.is_uppercase()));\n    all_lower ||\
    \ all_upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpg8ntntfa.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for key in dict.keys() {\n        if\
    \ key.chars().next().unwrap().is_uppercase() {\n            lower = false;\n \
    \       } else {\n            upper = false;\n        }\n    }\n    lower || upper\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpql18ghkd.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    true\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplabl5ehg.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let key_vec:\
    \ Vec<String> = dict.keys().map(|x| x.to_string()).collect();\n    let mut lower_count\
    \ = 0;\n    let mut upper_count = 0;\n    for key in key_vec {\n        if key.chars().all(|x|\
    \ x.is_uppercase()) {\n            upper_count += 1;\n        } else if key.chars().all(|x|\
    \ x.is_lowercase()) {\n            lower_count += 1;\n        } else {\n     \
    \       return false;\n        }\n    }\n    if upper_count > 0 && lower_count\
    \ > 0 {\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpgxxe3d1_.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut prev\
    \ = 0;\n    for i in dict.keys() {\n        let mut all_lower = true;\n      \
    \  let mut all_upper = true;\n        for c in i.chars() {\n            if c.is_lowercase()\
    \ {\n                all_upper = false;\n            } else if c.is_uppercase()\
    \ {\n                all_lower = false;\n            } else {\n              \
    \  return false;\n            }\n        }\n        if prev == 0 {\n         \
    \   prev = if all_lower { 1 } else if all_upper { 2 } else { return false };\n\
    \        } else if prev == 1 && !all_lower {\n            return false;\n    \
    \    } else if prev == 2 && !all_upper {\n            return false;\n        }\n\
    \    }\n    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpmhx17f_h.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    match dict.keys().next()\
    \ {\n        Some(str) => str.chars().next().map_or(false, |x| str.chars().all(|y|\
    \ x == y)),\n        None => false\n    }\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpyi9cvmxm.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut is_lower = true;\n    let mut is_upper\
    \ = true;\n    for (key, _) in dict {\n        let lower = key.to_lowercase();\n\
    \        let upper = key.to_uppercase();\n        if key != lower {\n        \
    \    is_lower = false;\n        }\n        if key != upper {\n            is_upper\
    \ = false;\n        }\n    }\n    return is_lower || is_upper;\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_3nkf0w3.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut upper\
    \ = false;\n    let mut lower = false;\n    for (key, _value) in dict {\n    \
    \    if key.chars().all(|c| c.is_uppercase()) {\n            upper = true;\n \
    \       } else if key.chars().all(|c| c.is_lowercase()) {\n            lower =\
    \ true;\n        } else {\n            return false;\n        }\n    }\n    if\
    \ dict.len() == 0 {\n        return false;\n    }\n    return lower || upper;\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `dict`\n   --> /tmp/tmpl62qbee4.rs:24:8\n\
    \    |\n12  | fn check_dict_case(dict: HashMap<String, String>) -> bool {\n  \
    \  |                    ---- move occurs because `dict` has type `HashMap<String,\
    \ String>`, which does not implement the `Copy` trait\n...\n15  |     for (key,\
    \ _value) in dict {\n    |                          ---- `dict` moved due to this\
    \ implicit call to `.into_iter()`\n...\n24  |     if dict.len() == 0 {\n    |\
    \        ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `dict`\nhelp: consider iterating\
    \ over a slice of the `HashMap<String, String>`'s content to avoid moving into\
    \ the `for` loop\n    |\n15  |     for (key, _value) in &dict {\n    |       \
    \                   +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    // initialize\
    \ an empty list to hold the keys\n    let mut values = vec![];\n    // iterate\
    \ over the keys and push into the list\n    for key in dict.keys() {\n       \
    \ values.push(key.to_string());\n    }\n    // first, check if the length of the\
    \ list is zero\n    if values.len() == 0 {\n        return false;\n    }\n   \
    \ // next, check if all characters are upper case\n    if values.iter().all(|x|\
    \ x.to_uppercase() == x.to_string()) {\n        return true;\n    }\n    // next,\
    \ check if all characters are lower case\n    if values.iter().all(|x| x.to_lowercase()\
    \ == x.to_string()) {\n        return true;\n    }\n    // if neither of the above,\
    \ return false\n    false\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp2abx33xh.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut upper\
    \ = true;\n    let mut lower = true;\n    for key in dict.keys() {\n        if\
    \ !key.is_ascii_uppercase() {\n            upper = false;\n        }\n       \
    \ if !key.is_ascii_lowercase() {\n            lower = false;\n        }\n    }\n\
    \    lower || upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_uppercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpieqj4m1t.rs:16:17\n   |\n16 |\
    \         if !key.is_ascii_uppercase() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_uppercase`\n\
    \nerror[E0599]: no method named `is_ascii_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpieqj4m1t.rs:19:17\n   |\n19 |         if\
    \ !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_lowercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.len()\
    \ == 0 {\n        return false;\n    }\n    let mut upper = true;\n    let mut\
    \ lower = true;\n    for key in dict.keys() {\n        if key.contains(char::is_uppercase)\
    \ {\n            lower = false;\n        }\n        if key.contains(char::is_lowercase)\
    \ {\n            upper = false;\n        }\n    }\n    return upper || lower;\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5z2ui4ov.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_lower\
    \ = true;\n    let mut is_upper = true;\n    let mut dict_keys = dict.keys();\n\
    \    while let Some(key) = dict_keys.next() {\n        if key.is_ascii_lowercase()\
    \ {\n            is_upper = false;\n        } else if key.is_ascii_uppercase()\
    \ {\n            is_lower = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpiov2dwn2.rs:17:16\n   |\n17 |\
    \         if key.is_ascii_lowercase() {\n   |                ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpiov2dwn2.rs:19:23\n   |\n19 |         }\
    \ else if key.is_ascii_uppercase() {\n   |                       ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_uppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let check_dict\
    \ = |ch: char| {\n        if ch.is_ascii_uppercase() {\n            0\n      \
    \  } else if ch.is_ascii_lowercase() {\n            1\n        } else {\n    \
    \        2\n        }\n    };\n\n    let mut is_upper = true;\n    for (key, _)\
    \ in dict {\n        let mut all_chars_are_lower_or_upper = true;\n        for\
    \ ch in key.chars() {\n            if check_dict(ch) == 2 {\n                all_chars_are_lower_or_upper\
    \ = false;\n                break;\n            }\n        }\n        if all_chars_are_lower_or_upper\
    \ {\n            let is_upper_now = check_dict(key.chars().next().unwrap()) ==\
    \ 0;\n            if is_upper != is_upper_now {\n                return false;\n\
    \            }\n            is_upper = is_upper_now;\n        } else {\n     \
    \       return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpx37lsdux.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let (mut lower_count,\
    \ mut upper_count) = (0, 0);\n    for (_, v) in dict {\n        if v.chars().all(|c|\
    \ c.is_lowercase()) {\n            lower_count += 1;\n        } else if v.chars().all(|c|\
    \ c.is_uppercase()) {\n            upper_count += 1;\n        }\n    }\n    lower_count\
    \ == dict.len() || upper_count == dict.len()\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `dict`\n   --> /tmp/tmpdo5oli54.rs:21:20\n\
    \    |\n12  | fn check_dict_case(dict: HashMap<String, String>) -> bool {\n  \
    \  |                    ---- move occurs because `dict` has type `HashMap<String,\
    \ String>`, which does not implement the `Copy` trait\n13  |     let (mut lower_count,\
    \ mut upper_count) = (0, 0);\n14  |     for (_, v) in dict {\n    |          \
    \         ---- `dict` moved due to this implicit call to `.into_iter()`\n...\n\
    21  |     lower_count == dict.len() || upper_count == dict.len()\n    |      \
    \              ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `dict`\nhelp: consider iterating\
    \ over a slice of the `HashMap<String, String>`'s content to avoid moving into\
    \ the `for` loop\n    |\n14  |     for (_, v) in &dict {\n    |              \
    \     +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut has_upper = false;\n    let mut\
    \ has_lower = false;\n    for (key, _value) in dict {\n        for c in key.chars()\
    \ {\n            if c.is_lowercase() {\n                has_lower = true;\n  \
    \          } else if c.is_uppercase() {\n                has_upper = true;\n \
    \           } else {\n                return false;\n            }\n        }\n\
    \    }\n    has_lower && !has_upper || !has_lower && has_upper\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    // check if the\
    \ dictionary is empty\n    if dict.is_empty() {\n        return false;\n    }\n\
    \n    // get the keys of the dictionary\n    let keys = dict.keys();\n\n    //\
    \ check if all keys are in lower case\n    let all_lower = keys.all(|k| k.is_lowercase());\n\
    \n    // check if all keys are in upper case\n    let all_upper = keys.all(|k|\
    \ k.is_uppercase());\n\n    all_lower || all_upper\n}\n\nfn main() {\n    let\
    \ candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmp8j3psdm4.rs:22:36\n   |\n22 |     let all_lower\
    \ = keys.all(|k| k.is_lowercase());\n   |                                    ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_lowercase`\n\n\
    error[E0599]: no method named `is_uppercase` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmp8j3psdm4.rs:25:36\n   |\n25 |     let all_upper\
    \ = keys.all(|k| k.is_uppercase());\n   |                                    ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_uppercase`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut upper_case = true;\n    let mut\
    \ lower_case = true;\n    for key in dict.keys() {\n        if key.chars().all(|c|\
    \ c.is_uppercase()) {\n            lower_case = false;\n        } else if key.chars().all(|c|\
    \ c.is_lowercase()) {\n            upper_case = false;\n        } else {\n   \
    \         return false;\n        }\n    }\n    upper_case || lower_case\n}\n\n\
    fn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n\tlet mut has_lowercase\
    \ = false;\n\tlet mut has_uppercase = false;\n\t\n\tfor (key, _) in dict {\n\t\
    \tif key.chars().all(|c| c.is_uppercase()) {\n\t\t\thas_uppercase = true;\n\t\t\
    } else if key.chars().all(|c| c.is_lowercase()) {\n\t\t\thas_lowercase = true;\n\
    \t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\treturn has_lowercase != has_uppercase;\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n\tlet mut lower_count\
    \ = 0;\n\tlet mut upper_count = 0;\n\tfor key in dict.keys() {\n\t\tif key.chars().all(|c|\
    \ c.is_ascii_lowercase()) {\n\t\t\tlower_count += 1;\n\t\t} else if key.chars().all(|c|\
    \ c.is_ascii_uppercase()) {\n\t\t\tupper_count += 1;\n\t\t} else {\n\t\t\treturn\
    \ false;\n\t\t}\n\t}\n\treturn lower_count == dict.len() || upper_count == dict.len();\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpi09icxoc.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let (mut upper,\
    \ mut lower) = (0, 0);\n    for (key, _) in dict {\n        if key.is_lowercase()\
    \ {\n            lower += 1;\n        } else if key.is_uppercase() {\n       \
    \     upper += 1;\n        } else {\n            return false;\n        }\n  \
    \  }\n    if lower == 0 || upper == 0 {\n        return true;\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpyuttm3ux.rs:15:16\n   |\n15 |         if\
    \ key.is_lowercase() {\n   |                ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpyuttm3ux.rs:17:23\n\
    \   |\n17 |         } else if key.is_uppercase() {\n   |                     \
    \  ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_keys\
    \ = 0;\n    let mut upper_keys = 0;\n    for (key, _) in dict {\n        if key.is_ascii_lowercase()\
    \ {\n            lower_keys += 1;\n        } else if key.is_ascii_uppercase()\
    \ {\n            upper_keys += 1;\n        } else {\n            return false;\n\
    \        }\n    }\n    if lower_keys == 0 || upper_keys == 0 {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmphvzxnj1w.rs:16:16\n   |\n16 |         if\
    \ key.is_ascii_lowercase() {\n   |                ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_lowercase`\n\nerror[E0599]:\
    \ no method named `is_ascii_uppercase` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmphvzxnj1w.rs:18:23\n   |\n18 |         } else if key.is_ascii_uppercase()\
    \ {\n   |                       ^^^^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_ascii_uppercase`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = 0;\n    let mut upper = 0;\n    for item in dict.keys() {\n        if item.to_lowercase()\
    \ == *item {\n            lower += 1;\n        } else if item.to_uppercase() ==\
    \ *item {\n            upper += 1;\n        }\n    }\n    if lower > 0 && upper\
    \ > 0 {\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp1sku1f3q.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut lowercase = false;\n    let mut\
    \ uppercase = false;\n    for key in dict.keys() {\n        if key.is_lowercase()\
    \ {\n            lowercase = true;\n        } else if key.is_uppercase() {\n \
    \           uppercase = true;\n        } else {\n            return false;\n \
    \       }\n    }\n    lowercase ^ uppercase\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpa99w6568.rs:19:16\n   |\n19 |         if\
    \ key.is_lowercase() {\n   |                ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpa99w6568.rs:21:23\n\
    \   |\n21 |         } else if key.is_uppercase() {\n   |                     \
    \  ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut count_lower = 0;\n    let mut count_upper\
    \ = 0;\n    for (key, _) in dict {\n        if key.chars().all(|c| c.is_lowercase())\
    \ {\n            count_lower += 1;\n        } else if key.chars().all(|c| c.is_uppercase())\
    \ {\n            count_upper += 1;\n        } else {\n            return false;\n\
    \        }\n    }\n    (count_lower > 0 && count_upper == 0) || (count_lower ==\
    \ 0 && count_upper > 0)\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.len()\
    \ > 0 {\n        let mut is_lower = dict.keys().next().unwrap().chars().next().unwrap().is_lowercase();\n\
    \        for k in dict.keys() {\n            if k.chars().next().unwrap().is_lowercase()\
    \ != is_lower {\n                return false;\n            }\n        }\n   \
    \     return true;\n    } else {\n        return false;\n    }\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0ri12jxg.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lw: i32\
    \ = 0;\n    let mut up: i32 = 0;\n    for x in dict.keys() {\n        if x.is_uppercase()\
    \ {\n            up += 1;\n        } else if x.is_lowercase() {\n            lw\
    \ += 1;\n        }\n    }\n    if lw == dict.len() as i32 || up == dict.len()\
    \ as i32 {\n        return true;\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmp2zycy5f_.rs:16:14\n   |\n16 |         if\
    \ x.is_uppercase() {\n   |              ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named\
    \ `is_lowercase` found for reference `&String` in the current scope\n  --> /tmp/tmp2zycy5f_.rs:18:21\n\
    \   |\n18 |         } else if x.is_lowercase() {\n   |                     ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_lowercase`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for (key, _) in dict {\n        if !key.is_ascii_lowercase()\
    \ {\n            lower = false;\n        }\n        if !key.is_ascii_uppercase()\
    \ {\n            upper = false;\n        }\n    }\n    return lower || upper;\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpcrwz8qlk.rs:16:17\n   |\n16 |         if\
    \ !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_lowercase`\n\nerror[E0599]:\
    \ no method named `is_ascii_uppercase` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpcrwz8qlk.rs:19:17\n   |\n19 |         if !key.is_ascii_uppercase()\
    \ {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_ascii_uppercase`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.len()\
    \ == 0 {\n        return false;\n    }\n    let mut dict_keys = dict.keys().map(|s|s.to_uppercase()).collect::<Vec<String>>();\n\
    \    dict_keys.sort();\n    let mut dict_keys_sorted = dict.keys().map(|s|s.to_uppercase()).collect::<Vec<String>>();\n\
    \    dict_keys_sorted.sort();\n    dict_keys_sorted == dict_keys\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmponwx5n6n.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    //#1 Check if\
    \ keys are of the same case\n    let keys: Vec<String> = dict.keys().map(|x| x.to_lowercase()).collect();\n\
    \    let count: i32 = dict.keys().map(|x| x.chars().count()).sum();\n    if count\
    \ != keys.len() as i32 {\n        return false;\n    }\n    return true;\n}\n\n\
    fn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `i32: Sum<usize>` is not satisfied\n    -->\
    \ /tmp/tmpjuz6orrk.rs:15:61\n     |\n15   |     let count: i32 = dict.keys().map(|x|\
    \ x.chars().count()).sum();\n     |                                          \
    \                   ^^^ the trait `Sum<usize>` is not implemented for `i32`\n\
    \     |\n     = help: the following other types implement trait `Sum<A>`:\n  \
    \             <f32 as Sum<&'a f32>>\n               <f32 as Sum>\n           \
    \    <f64 as Sum<&'a f64>>\n               <f64 as Sum>\n               <i128\
    \ as Sum<&'a i128>>\n               <i128 as Sum>\n               <i16 as Sum<&'a\
    \ i16>>\n               <i16 as Sum>\n             and 20 others\nnote: required\
    \ by a bound in `std::iter::Iterator::sum`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    // for loop\n\
    \    for (_key, _value) in dict.iter() {\n        // print!(\"{:?}\", _key);\n\
    \        // if _key.is_uppercase() {\n        //     return false;\n        //\
    \ }\n        // if _key.is_lowercase() {\n        //     return false;\n     \
    \   // }\n        return false;\n    }\n    return true;\n}\n\nfn main() {\n \
    \   let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpo90l661r.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut all_lower_case\
    \ = true;\n    let mut all_upper_case = true;\n    for key in dict.keys() {\n\
    \        let key_str = key.to_uppercase();\n        if key != &key_str {\n   \
    \         all_upper_case = false;\n        }\n        let key_str = key.to_lowercase();\n\
    \        if key != &key_str {\n            all_lower_case = false;\n        }\n\
    \    }\n    all_lower_case || all_upper_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpkhm4pbq_.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    match dict.keys().next()\
    \ {\n        Some(k) => dict.keys().all(|l| l.eq_ignore_ascii_case(k)),\n    \
    \    None => false,\n    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpy5z5twah.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.len()\
    \ == 0 {\n        return false;\n    }\n    let mut have_lowercase = true;\n \
    \   let mut have_uppercase = true;\n    for key in dict.keys() {\n        if key.is_lowercase()\
    \ {\n            have_uppercase = false;\n        } else if key.is_uppercase()\
    \ {\n            have_lowercase = false;\n        } else {\n            return\
    \ false;\n        }\n    }\n    return have_lowercase || have_uppercase;\n}\n\n\
    fn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmp4vctqmas.rs:19:16\n   |\n19 |         if\
    \ key.is_lowercase() {\n   |                ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmp4vctqmas.rs:21:23\n\
    \   |\n21 |         } else if key.is_uppercase() {\n   |                     \
    \  ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut is_upper_key: bool = dict.keys().nth(0).unwrap().is_uppercase();\n\
    \    for key in dict.keys() {\n        if key.is_uppercase() != is_upper_key {\n\
    \            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n   \
    \ let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmp370b3a59.rs:16:62\n   |\n16 |     let mut\
    \ is_upper_key: bool = dict.keys().nth(0).unwrap().is_uppercase();\n   |     \
    \                                                         ^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]:\
    \ no method named `is_uppercase` found for reference `&String` in the current\
    \ scope\n  --> /tmp/tmp370b3a59.rs:18:16\n   |\n18 |         if key.is_uppercase()\
    \ != is_upper_key {\n   |                ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.len()\
    \ == 0 {\n        return false;\n    }\n    let mut is_upper = dict.keys().nth(0).unwrap().is_uppercase();\n\
    \    for key in dict.keys() {\n        if is_upper != key.is_uppercase() {\n \
    \           return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpo1v64n1p.rs:16:52\n   |\n16 |     let mut\
    \ is_upper = dict.keys().nth(0).unwrap().is_uppercase();\n   |               \
    \                                     ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpo1v64n1p.rs:18:28\n\
    \   |\n18 |         if is_upper != key.is_uppercase() {\n   |                \
    \            ^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut upper_case\
    \ = true;\n    let mut lower_case = true;\n    for key in dict.keys() {\n    \
    \    if !key.is_ascii_uppercase() {\n            upper_case = false;\n       \
    \ }\n        if !key.is_ascii_lowercase() {\n            lower_case = false;\n\
    \        }\n    }\n    upper_case || lower_case\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_uppercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpj5ng5oq3.rs:16:17\n   |\n16 |\
    \         if !key.is_ascii_uppercase() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_uppercase`\n\
    \nerror[E0599]: no method named `is_ascii_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpj5ng5oq3.rs:19:17\n   |\n19 |         if\
    \ !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_lowercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let (first_key, first_value) = dict.iter().next().unwrap();\n\
    \    let mut all_upper = first_key.to_uppercase() == *first_key;\n    let mut\
    \ all_lower = first_key.to_lowercase() == *first_key;\n    for (key, value) in\
    \ dict.iter() {\n        all_upper = all_upper && key.to_uppercase() == *key;\n\
    \        all_lower = all_lower && key.to_lowercase() == *key;\n    }\n    all_upper\
    \ || all_lower\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpxinlcw_s.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.len()\
    \ == 0 {\n        return false;\n    }\n    if dict.keys().any(|x| x.chars().any(|x|\
    \ x.is_uppercase())) && dict.keys().any(|x| x.chars().any(|x| x.is_lowercase()))\
    \ {\n        return false;\n    }\n    return true;\n}\n\nfn main() {\n    let\
    \ candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpd5j60xo9.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut case = None;\n    for key in dict.keys()\
    \ {\n        match case {\n            None => case = Some(key.is_uppercase()),\n\
    \            Some(v) => {\n                if v != key.is_uppercase() {\n    \
    \                return false;\n                }\n            }\n        }\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = check_dict_case;\n   \
    \ assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\"\
    )), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpim92o8yb.rs:19:37\n   |\n19 |          \
    \   None => case = Some(key.is_uppercase()),\n   |                           \
    \          ^^^^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `to_uppercase`\n\nerror[E0599]: no method named `is_uppercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpim92o8yb.rs:21:29\n   |\n21 |\
    \                 if v != key.is_uppercase() {\n   |                         \
    \    ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut check_lower\
    \ = true;\n    let mut check_upper = true;\n    if dict.is_empty() {\n       \
    \ return false;\n    }\n    for key in dict.keys() {\n        if key.to_lowercase()\
    \ != key {\n            check_lower = false;\n        }\n        if key.to_uppercase()\
    \ != key {\n            check_upper = false;\n        }\n    }\n    check_lower\
    \ || check_upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n   \
    \ assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\"\
    )), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmp5jtriwa2.rs:19:31\n\
    \   |\n19 |         if key.to_lowercase() != key {\n   |                     \
    \          ^^ no implementation for `String == &String`\n   |\n   = help: the\
    \ trait `PartialEq<&String>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: can't compare `String` with `&String`\n\
    \  --> /tmp/tmp5jtriwa2.rs:22:31\n   |\n22 |         if key.to_uppercase() !=\
    \ key {\n   |                               ^^ no implementation for `String ==\
    \ &String`\n   |\n   = help: the trait `PartialEq<&String>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut has_lower\
    \ = false;\n    let mut has_upper = false;\n    for key in dict.keys() {\n   \
    \     if key.is_lowercase() {\n            has_lower = true;\n        } else if\
    \ key.is_uppercase() {\n            has_upper = true;\n        } else {\n    \
    \        return false;\n        }\n    }\n    if has_lower == has_upper {\n  \
    \      false\n    } else {\n        true\n    }\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpdad6cuxe.rs:16:16\n   |\n16 |         if\
    \ key.is_lowercase() {\n   |                ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for reference `&String` in the current scope\n  --> /tmp/tmpdad6cuxe.rs:18:23\n\
    \   |\n18 |         } else if key.is_uppercase() {\n   |                     \
    \  ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpeudp6uaj.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.keys().all(|s|\
    \ {\n        s.chars().all(|c| c.is_uppercase()) || s.chars().all(|c| c.is_lowercase())\n\
    \    })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_pkbvtr0.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut all_lower_case:\
    \ bool = true;\n    let mut all_upper_case: bool = true;\n    for (key, _) in\
    \ dict {\n        if !key.is_lowercase() {\n            all_lower_case = false;\n\
    \        }\n        if !key.is_uppercase() {\n            all_upper_case = false;\n\
    \        }\n    }\n    all_lower_case || all_upper_case\n}\n\nfn main() {\n  \
    \  let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpklas9if6.rs:16:17\n   |\n16 |         if\
    \ !key.is_lowercase() {\n   |                 ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named\
    \ `is_uppercase` found for struct `String` in the current scope\n  --> /tmp/tmpklas9if6.rs:19:17\n\
    \   |\n19 |         if !key.is_uppercase() {\n   |                 ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_uppercase`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n\t\n\t// Criamos\
    \ dois boolens para verificar se s\xE3o todos maiusculos ou minusculos\n\tlet\
    \ mut is_upper = true;\n\tlet mut is_lower = true;\n\t\n\t// Fazemos um loop que\
    \ pega todas as keys do hash e verifica se \xE9 maiusculo ou minusculo\n\tfor\
    \ key in dict.keys() {\n\t\t// Verifica se a key \xE9 maiuscula, se ela n\xE3\
    o for ent\xE3o temos um key maiuscula.\n\t\tif !key.to_uppercase().eq(key) {\n\
    \t\t\tis_upper = false;\n\t\t}\n\t\t// Verifica se a key \xE9 minuscula, se ela\
    \ n\xE3o for ent\xE3o temos um key minuscula.\n\t\tif !key.to_lowercase().eq(key)\
    \ {\n\t\t\tis_lower = false;\n\t\t}\n\t}\n\t\n\t// Se for todas maiusculas ou\
    \ todas minusculas retorna true, sen\xE3o false.\n\tis_upper || is_lower\n}\n\n\
    fn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9cqexgp6.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    false\n}\n\n\
    fn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp260q_cva.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut all_upper\
    \ = true;\n    let mut all_lower = true;\n    for (key, _) in dict {\n       \
    \ let lower_key = key.to_lowercase();\n        if lower_key != key {\n       \
    \     all_lower = false;\n        }\n        let upper_key = key.to_uppercase();\n\
    \        if upper_key != key {\n            all_upper = false;\n        }\n  \
    \  }\n    all_upper || all_lower\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpic0g_yxy.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    return dict.keys().all(|k|\
    \ k.to_uppercase() == k) || dict.keys().all(|k| k.to_lowercase() == k);\n}\n\n\
    fn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpvvkd9hxp.rs:13:49\n\
    \   |\n13 |     return dict.keys().all(|k| k.to_uppercase() == k) || dict.keys().all(|k|\
    \ k.to_lowercase() == k);\n   |                                              \
    \   ^^ no implementation for `String == &String`\n   |\n   = help: the trait `PartialEq<&String>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: can't compare `String` with `&String`\n\
    \  --> /tmp/tmpvvkd9hxp.rs:13:95\n   |\n13 |     return dict.keys().all(|k| k.to_uppercase()\
    \ == k) || dict.keys().all(|k| k.to_lowercase() == k);\n   |                 \
    \                                                                            \
    \  ^^ no implementation for `String == &String`\n   |\n   = help: the trait `PartialEq<&String>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut first_iter\
    \ = true;\n    let mut is_upper = false;\n    for (key, _) in dict {\n       \
    \ if first_iter {\n            is_upper = key.is_uppercase();\n            first_iter\
    \ = false;\n        } else {\n            if key.is_uppercase() != is_upper {\n\
    \                return false;\n            }\n        }\n    }\n    return true;\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_uppercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmplpnpmo7a.rs:17:28\n   |\n17 |          \
    \   is_upper = key.is_uppercase();\n   |                            ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_uppercase`\n\n\
    error[E0599]: no method named `is_uppercase` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmplpnpmo7a.rs:20:20\n   |\n20 |             if key.is_uppercase()\
    \ != is_upper {\n   |                    ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpq41bi8g1.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.keys().all(|k|\
    \ k.is_lowercase()) || dict.keys().all(|k| k.is_uppercase())\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmp87tnbud6.rs:13:27\n   |\n13 |     dict.keys().all(|k|\
    \ k.is_lowercase()) || dict.keys().all(|k| k.is_uppercase())\n   |           \
    \                ^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `to_lowercase`\n\nerror[E0599]: no method named `is_uppercase` found for\
    \ reference `&String` in the current scope\n  --> /tmp/tmp87tnbud6.rs:13:68\n\
    \   |\n13 |     dict.keys().all(|k| k.is_lowercase()) || dict.keys().all(|k| k.is_uppercase())\n\
    \   |                                                                    ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_uppercase`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for key in dict.keys() {\n        if\
    \ let Some(c) = key.chars().next() {\n            if c.is_ascii_lowercase() {\n\
    \                upper = false;\n            } else if c.is_ascii_uppercase()\
    \ {\n                lower = false;\n            } else {\n                return\
    \ false;\n            }\n        }\n    }\n    lower || upper\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmppmjmhw0w.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut first_key\
    \ = true;\n    let mut is_upper = false;\n    for key in dict.keys() {\n     \
    \   if first_key {\n            is_upper = key.chars().next().unwrap().is_uppercase();\n\
    \            first_key = false;\n        } else {\n            if is_upper !=\
    \ key.chars().next().unwrap().is_uppercase() {\n                return false;\n\
    \            }\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmptc97b8m3.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.len()\
    \ == 0 {\n        return false;\n    }\n    let mut v: Vec<bool> = vec![];\n \
    \   for key in dict.keys() {\n        v.push(key.chars().all(|c| c.is_lowercase()));\n\
    \    }\n    v.iter().all(|&x| x) || v.iter().all(|&x| !x)\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphmsf7t5a.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpxxgmaeye.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for (key, _) in dict {\n        lower\
    \ = lower && key.is_lowercase();\n        upper = upper && key.is_uppercase();\n\
    \    }\n    dict.len() > 0 && (lower || upper)\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp1y0b4o9i.rs:16:30\n   |\n16 |         lower\
    \ = lower && key.is_lowercase();\n   |                              ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_lowercase`\n\n\
    error[E0599]: no method named `is_uppercase` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp1y0b4o9i.rs:17:30\n   |\n17 |         upper = upper\
    \ && key.is_uppercase();\n   |                              ^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `to_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut is_upper = None;\n    for (key,\
    \ _value) in dict {\n        if key.chars().all(|c| c.is_uppercase()) {\n    \
    \        if is_upper == Some(false) {\n                return false;\n       \
    \     }\n            is_upper = Some(true);\n        } else if key.chars().all(|c|\
    \ c.is_lowercase()) {\n            if is_upper == Some(true) {\n             \
    \   return false;\n            }\n            is_upper = Some(false);\n      \
    \  } else {\n            return false;\n        }\n    }\n    return true;\n}\n\
    \nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut upper\
    \ = true;\n    let mut lower = true;\n    for key in dict.keys() {\n        if\
    \ key.is_uppercase() {\n            lower = false;\n        } else if key.is_lowercase()\
    \ {\n            upper = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    return upper || lower;\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmp929z1cbh.rs:16:16\n   |\n16 |         if\
    \ key.is_uppercase() {\n   |                ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named\
    \ `is_lowercase` found for reference `&String` in the current scope\n  --> /tmp/tmp929z1cbh.rs:18:23\n\
    \   |\n18 |         } else if key.is_lowercase() {\n   |                     \
    \  ^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut lower = true;\n    let mut upper\
    \ = true;\n    for (key, _) in dict {\n        if !key.is_empty() {\n        \
    \    if !key.chars().all(|ch| ch.is_uppercase()) {\n                upper = false;\n\
    \            }\n            if !key.chars().all(|ch| ch.is_lowercase()) {\n  \
    \              lower = false;\n            }\n        }\n    }\n    lower || upper\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let (is_all_lower,\
    \ is_all_upper) = dict.keys().fold((true, true), |(lower, upper), key| {\n   \
    \     (lower && key.is_lowercase(), upper && key.is_uppercase())\n    });\n  \
    \  is_all_lower || is_all_upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpa6zedmju.rs:14:23\n   |\n14 |         (lower\
    \ && key.is_lowercase(), upper && key.is_uppercase())\n   |                  \
    \     ^^^^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `to_lowercase`\n\nerror[E0599]: no method named `is_uppercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpa6zedmju.rs:14:52\n   |\n14 |\
    \         (lower && key.is_lowercase(), upper && key.is_uppercase())\n   |   \
    \                                                 ^^^^^^^^^^^^ help: there is\
    \ an associated function with a similar name: `to_uppercase`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    false\n}\n\n\
    fn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfyirn80x.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    // if the first key is lowercase, set lower_case\
    \ to true\n    // and check the rest of the keys to see if they are also lowercase\n\
    \    let mut lower_case = false;\n    let mut upper_case = false;\n    for key\
    \ in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase() {\n\
    \            lower_case = true;\n        } else {\n            upper_case = true;\n\
    \        }\n    }\n    // if the first key is not lowercase, set lower_case to\
    \ false\n    // and check the rest of the keys to see if they are all uppercase\n\
    \    if lower_case && upper_case {\n        return false;\n    } else {\n    \
    \    return true;\n    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp61tiqp_g.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut s_lower\
    \ = true;\n    let mut s_upper = true;\n    for key in dict.keys() {\n       \
    \ s_lower = s_lower && key.is_lowercase();\n        s_upper = s_upper && key.is_uppercase();\n\
    \    }\n    return s_lower || s_upper;\n}\n\nfn main() {\n    let candidate =\
    \ check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"\
    ), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmporkm2mal.rs:16:34\n   |\n16 |         s_lower\
    \ = s_lower && key.is_lowercase();\n   |                                  ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_lowercase`\n\n\
    error[E0599]: no method named `is_uppercase` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmporkm2mal.rs:17:34\n   |\n17 |         s_upper\
    \ = s_upper && key.is_uppercase();\n   |                                  ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_uppercase`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let all_lower\
    \ = |k: &String| k.chars().all(|c| c.is_lowercase());\n    let all_upper = |k:\
    \ &String| k.chars().all(|c| c.is_uppercase());\n    match dict.keys().collect::<Vec<_>>().first()\
    \ {\n        Some(k) => dict.keys().all(|k| all_lower(k) || all_upper(k)),\n \
    \       None => false,\n    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp2dfqlr8x.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut first_key_char\
    \ = ' ';\n    let mut first_key_char_is_upper = false;\n    for key in dict.keys()\
    \ {\n        if first_key_char == ' ' {\n            first_key_char = key.chars().next().unwrap();\n\
    \            first_key_char_is_upper = first_key_char.is_uppercase();\n      \
    \  } else {\n            let curr_char = key.chars().next().unwrap();\n      \
    \      if curr_char.is_uppercase() != first_key_char_is_upper {\n            \
    \    return false;\n            }\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7g4pok8q.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_lower\
    \ = false;\n    let mut is_upper = false;\n    let mut is_number = false;\n  \
    \  if dict.is_empty() {\n        return false;\n    }\n    for (key, value) in\
    \ dict {\n        let chars: Vec<char> = key.chars().collect();\n        for c\
    \ in chars {\n            if c.is_alphabetic() {\n                if c.is_uppercase()\
    \ {\n                    is_upper = true;\n                } else {\n        \
    \            is_lower = true;\n                }\n            } else {\n     \
    \           is_number = true;\n            }\n        }\n    }\n    is_upper !=\
    \ is_lower && !is_number\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut all_lower:\
    \ bool = true;\n    let mut all_upper: bool = true;\n    for key in dict.keys()\
    \ {\n        if key.to_uppercase() != key {\n            all_upper = false;\n\
    \        }\n        if key.to_lowercase() != key {\n            all_lower = false;\n\
    \        }\n    }\n    return all_lower || all_upper;\n}\n\nfn main() {\n    let\
    \ candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpkk8u5wru.rs:16:31\n\
    \   |\n16 |         if key.to_uppercase() != key {\n   |                     \
    \          ^^ no implementation for `String == &String`\n   |\n   = help: the\
    \ trait `PartialEq<&String>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: can't compare `String` with `&String`\n\
    \  --> /tmp/tmpkk8u5wru.rs:19:31\n   |\n19 |         if key.to_lowercase() !=\
    \ key {\n   |                               ^^ no implementation for `String ==\
    \ &String`\n   |\n   = help: the trait `PartialEq<&String>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut upper_strs\
    \ = 0;\n    let mut lower_strs = 0;\n    for k in dict.keys() {\n        match\
    \ k.chars().next() {\n            Some(c) => {\n                if c.is_lowercase()\
    \ {\n                    lower_strs += 1;\n                } else if c.is_uppercase()\
    \ {\n                    upper_strs += 1;\n                }\n            },\n\
    \            None => return false,\n        }\n    }\n    dict.len() == lower_strs\
    \ || dict.len() == upper_strs\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpy_7fkcb7.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.keys().all(|key|\
    \ key.to_lowercase() == key) ||\n    dict.keys().all(|key| key.to_uppercase()\
    \ == key)\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmptdkjq4m3.rs:13:46\n\
    \   |\n13 |     dict.keys().all(|key| key.to_lowercase() == key) ||\n   |    \
    \                                          ^^ no implementation for `String ==\
    \ &String`\n   |\n   = help: the trait `PartialEq<&String>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `String` with `&String`\n  --> /tmp/tmptdkjq4m3.rs:14:46\n   |\n14 |     dict.keys().all(|key|\
    \ key.to_uppercase() == key)\n   |                                           \
    \   ^^ no implementation for `String == &String`\n   |\n   = help: the trait `PartialEq<&String>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut upper_case_keys\
    \ = true;\n    let mut lower_case_keys = true;\n    for key in dict.keys() {\n\
    \        if key.chars().next().unwrap().is_ascii_uppercase() {\n            lower_case_keys\
    \ = false;\n        } else {\n            upper_case_keys = false;\n        }\n\
    \    }\n    return upper_case_keys || lower_case_keys;\n}\n\nfn main() {\n   \
    \ let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpo1i07_7j.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ { return false; }\n    let mut is_upper = false;\n    for (key, _) in dict.iter()\
    \ {\n        if key.to_uppercase() == *key {\n            is_upper = true;\n \
    \       } else if key.to_lowercase() == *key {\n            is_upper = false;\n\
    \        } else {\n            return false;\n        }\n    }\n    return true;\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpzu_3eb6m.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut low =\
    \ true;\n    let mut up = true;\n    for (key, _) in dict {\n        if key.chars().next().unwrap().is_uppercase()\
    \ {\n            low = false;\n        } else {\n            up = false;\n   \
    \     }\n    }\n    low || up\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpkj99g_rw.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().fold((true,\
    \ true), |(is_lower, is_upper), (k, v)| {\n        match k.chars().next() {\n\
    \            Some(c) => (is_lower && c.is_lowercase(), is_upper && c.is_uppercase()),\n\
    \            None => (is_lower, is_upper),\n        }\n    }) == (true, true)\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpuroauxwv.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for item in dict.keys() {\n        let\
    \ s = item.to_string();\n        for c in s.chars() {\n            if lower {\n\
    \                if c.is_uppercase() {\n                    lower = false;\n \
    \               }\n            }\n            if upper {\n                if c.is_lowercase()\
    \ {\n                    upper = false;\n                }\n            }\n  \
    \      }\n    }\n    lower || upper\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpq38px_mg.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.len()\
    \ == 0 {\n        return false;\n    }\n    let mut lowercase = true;\n    let\
    \ mut uppercase = true;\n    for key in dict.keys() {\n        let contains_lowercase\
    \ = key.chars().any(|c| c.is_lowercase());\n        let contains_uppercase = key.chars().any(|c|\
    \ c.is_uppercase());\n        lowercase = lowercase && contains_lowercase;\n \
    \       uppercase = uppercase && contains_uppercase;\n    }\n    return lowercase\
    \ || uppercase;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmperu5id30.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    match dict.keys().nth(0)\
    \ {\n        Some(s) => {\n            if s.chars().all(|c| c.is_uppercase())\
    \ {\n                return dict.keys().all(|s| s.chars().all(|c| c.is_uppercase()));\n\
    \            } else if s.chars().all(|c| c.is_lowercase()) {\n               \
    \ return dict.keys().all(|s| s.chars().all(|c| c.is_lowercase()));\n         \
    \   } else {\n                return false;\n            }\n        },\n     \
    \   None => return false\n    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpa4gkrwcd.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.len()\
    \ == 0 {\n        return false;\n    }\n    let mut all_lower = true;\n    let\
    \ mut all_upper = true;\n    for key in dict.keys() {\n        if !key.is_ascii_lowercase()\
    \ {\n            all_lower = false;\n        }\n        if !key.is_ascii_uppercase()\
    \ {\n            all_upper = false;\n        }\n    }\n    all_lower || all_upper\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpdegy1tu5.rs:19:17\n   |\n19 |\
    \         if !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpdegy1tu5.rs:22:17\n   |\n22 |         if\
    \ !key.is_ascii_uppercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_uppercase`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_count\
    \ = 0;\n    let mut upper_count = 0;\n    for (key, _value) in dict {\n      \
    \  match key.to_lowercase().as_str() {\n            key => {\n               \
    \ if key == key.to_uppercase().as_str() {\n                    upper_count +=\
    \ 1;\n                } else {\n                    lower_count += 1;\n      \
    \          }\n            }\n        }\n    }\n    lower_count == dict.len() ||\
    \ upper_count == dict.len()\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `dict`\n   --> /tmp/tmp63kjsh6a.rs:26:20\n\
    \    |\n12  | fn check_dict_case(dict: HashMap<String, String>) -> bool {\n  \
    \  |                    ---- move occurs because `dict` has type `HashMap<String,\
    \ String>`, which does not implement the `Copy` trait\n...\n15  |     for (key,\
    \ _value) in dict {\n    |                          ---- `dict` moved due to this\
    \ implicit call to `.into_iter()`\n...\n26  |     lower_count == dict.len() ||\
    \ upper_count == dict.len()\n    |                    ^^^^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `dict`\nhelp: consider iterating over a slice of the `HashMap<String,\
    \ String>`'s content to avoid moving into the `for` loop\n    |\n15  |     for\
    \ (key, _value) in &dict {\n    |                          +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    true\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqhrih6w3.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut check_upper:\
    \ bool = false;\n    let mut check_lower: bool = false;\n    for (key, _value)\
    \ in dict {\n        if !key.chars().all(|x| x.is_uppercase()) {\n           \
    \ check_upper = true;\n        }\n        if !key.chars().all(|x| x.is_lowercase())\
    \ {\n            check_lower = true;\n        }\n    }\n    return !(check_upper\
    \ && check_lower);\n}\n\nfn main() {\n    let candidate = check_dict_case;\n \
    \   assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp3s80erbd.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut keys_lowercase\
    \ = true;\n    let mut keys_uppercase = true;\n    for key in dict.keys() {\n\
    \        if key.is_ascii_lowercase() {\n            keys_uppercase = false;\n\
    \        } else if key.is_ascii_uppercase() {\n            keys_lowercase = false;\n\
    \        } else {\n            return false;\n        }\n    }\n    keys_lowercase\
    \ || keys_uppercase\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpa56325e_.rs:16:16\n   |\n16 |\
    \         if key.is_ascii_lowercase() {\n   |                ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpa56325e_.rs:18:23\n   |\n18 |         }\
    \ else if key.is_ascii_uppercase() {\n   |                       ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_uppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.keys().all(|key|\
    \ key.to_lowercase() == key) ||\n    dict.keys().all(|key| key.to_uppercase()\
    \ == key)\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmp9t_cbrea.rs:13:46\n\
    \   |\n13 |     dict.keys().all(|key| key.to_lowercase() == key) ||\n   |    \
    \                                          ^^ no implementation for `String ==\
    \ &String`\n   |\n   = help: the trait `PartialEq<&String>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `String` with `&String`\n  --> /tmp/tmp9t_cbrea.rs:14:46\n   |\n14 |     dict.keys().all(|key|\
    \ key.to_uppercase() == key)\n   |                                           \
    \   ^^ no implementation for `String == &String`\n   |\n   = help: the trait `PartialEq<&String>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut keys_check:\
    \ bool = true;\n    let mut values_check: bool = true;\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    for (key, value) in dict.iter() {\n   \
    \     if key.chars().any(|c| c.is_uppercase()) {\n            keys_check = false;\n\
    \        }\n        if value.chars().any(|c| c.is_uppercase()) {\n           \
    \ values_check = false;\n        }\n    }\n    return keys_check || values_check;\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpc1np4_2k.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut upper\
    \ = 0;\n    let mut lower = 0;\n    for key in dict.keys() {\n        if key.is_ascii_uppercase()\
    \ {\n            upper += 1;\n        } else if key.is_ascii_lowercase() {\n \
    \           lower += 1;\n        }\n    }\n    if upper > 0 && lower > 0 {\n \
    \       return false;\n    } else {\n        return true;\n    }\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_uppercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmp746xy8sf.rs:16:16\n   |\n16 |\
    \         if key.is_ascii_uppercase() {\n   |                ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_uppercase`\n\
    \nerror[E0599]: no method named `is_ascii_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmp746xy8sf.rs:18:23\n   |\n18 |         }\
    \ else if key.is_ascii_lowercase() {\n   |                       ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut is_lower = true;\n    let mut is_upper\
    \ = true;\n    for key in dict.keys() {\n        let mut chars = key.chars();\n\
    \        if let Some(c) = chars.next() {\n            if c.is_lowercase() {\n\
    \                is_upper = false;\n            } else if c.is_uppercase() {\n\
    \                is_lower = false;\n            } else {\n                return\
    \ false;\n            }\n        }\n    }\n    is_lower || is_upper\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5kc2hrth.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.len()\
    \ == 0 {\n        return false;\n    }\n    let first_key: &String = dict.keys().next().unwrap();\n\
    \    let case = first_key.is_lowercase();\n    dict.keys().all(|s| s.is_lowercase()\
    \ == case)\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpp52qbbea.rs:17:26\n   |\n17 |     let case\
    \ = first_key.is_lowercase();\n   |                          ^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]:\
    \ no method named `is_lowercase` found for reference `&String` in the current\
    \ scope\n  --> /tmp/tmpp52qbbea.rs:18:27\n   |\n18 |     dict.keys().all(|s| s.is_lowercase()\
    \ == case)\n   |                           ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut bool_value\
    \ = true;\n    for (key, _value) in dict {\n        let string_key = key.as_str();\n\
    \        if !string_key.is_empty() {\n            if string_key.starts_with(\"\
    a\") {\n                let string_key = key.to_uppercase();\n               \
    \ bool_value = string_key.chars().next().unwrap().is_uppercase();\n          \
    \  } else {\n                let string_key = key.to_lowercase();\n          \
    \      bool_value = string_key.chars().next().unwrap().is_lowercase();\n     \
    \       }\n        }\n    }\n    bool_value\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpd5n_6wrq.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for (key, _) in dict {\n        if key.chars().all(|x|\
    \ x.is_lowercase()) {\n            upper = false;\n        } else if key.chars().all(|x|\
    \ x.is_uppercase()) {\n            lower = false;\n        } else {\n        \
    \    return false;\n        }\n    }\n    lower || upper\n}\n\nfn main() {\n \
    \   let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp6tf2t4_c.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for (key, _) in dict {\n        if lower\
    \ && key.chars().any(|c| c.is_uppercase()) {\n            lower = false;\n   \
    \     }\n        if upper && key.chars().any(|c| c.is_lowercase()) {\n       \
    \     upper = false;\n        }\n    }\n    lower || upper\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpoq0qezk2.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut uppercase_flag = false;\n    let\
    \ mut lowercase_flag = false;\n    for (key, _) in dict {\n        if key.chars().all(|c|\
    \ c.is_uppercase()) {\n            uppercase_flag = true;\n        } else if key.chars().all(|c|\
    \ c.is_lowercase()) {\n            lowercase_flag = true;\n        } else {\n\
    \            return false;\n        }\n    }\n    return uppercase_flag != lowercase_flag;\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut case\
    \ = \"lower\";\n    let mut result = true;\n    for k in dict.keys() {\n     \
    \   if case == \"lower\" {\n            if k.chars().any(|c| c.is_uppercase())\
    \ {\n                case = \"upper\";\n            }\n        }\n        if case\
    \ == \"upper\" {\n            if k.chars().any(|c| c.is_lowercase()) {\n     \
    \           result = false;\n                break;\n            }\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = check_dict_case;\n \
    \   assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmppwz27xhf.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut is_all_lower_case = true;\n   \
    \ let mut is_all_upper_case = true;\n    for (key, _) in dict {\n        if !key.is_ascii_lowercase()\
    \ {\n            is_all_lower_case = false;\n        }\n        if !key.is_ascii_uppercase()\
    \ {\n            is_all_upper_case = false;\n        }\n    }\n    return is_all_lower_case\
    \ || is_all_upper_case;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpjjgn5d6m.rs:19:17\n   |\n19 |         if\
    \ !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_lowercase`\n\nerror[E0599]:\
    \ no method named `is_ascii_uppercase` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpjjgn5d6m.rs:22:17\n   |\n22 |         if !key.is_ascii_uppercase()\
    \ {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_ascii_uppercase`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.len()\
    \ == 0 {\n        return false;\n    }\n    let mut lower = true;\n    let mut\
    \ upper = true;\n    for key in dict.keys() {\n        lower = lower && is_lower(key);\n\
    \        upper = upper && is_upper(key);\n    }\n    return lower || upper;\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_lower` in this scope\n  --> /tmp/tmpw72u2_7p.rs:19:26\n\
    \   |\n19 |         lower = lower && is_lower(key);\n   |                    \
    \      ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `is_upper` in this scope\n  --> /tmp/tmpw72u2_7p.rs:20:26\n   |\n20 |      \
    \   upper = upper && is_upper(key);\n   |                          ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.len()\
    \ == 0 {\n        return false;\n    }\n    let mut is_lower_case: bool = dict.keys().next().unwrap().chars().next().unwrap().is_lowercase();\n\
    \    for key in dict.keys() {\n        if key.chars().next().unwrap().is_lowercase()\
    \ != is_lower_case {\n            return false;\n        }\n    }\n    return\
    \ true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpsmm5bqrb.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n\
    \    match keys.next() {\n        Some(k) => {\n            let mut i = k.chars();\n\
    \            let first_letter = i.next().unwrap();\n            let mut is_upper\
    \ = first_letter.is_uppercase();\n            if !is_upper {\n               \
    \ is_upper = !first_letter.is_lowercase();\n            }\n            for key\
    \ in keys {\n                for c in key.chars() {\n                    if c.is_uppercase()\
    \ != is_upper {\n                        return false;\n                    }\n\
    \                }\n            }\n            true\n        },\n        None\
    \ => false\n    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\"\
    )), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `keys` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp2uk2tkcy.rs:14:11\n   |\n13 |     let keys = dict.keys();\n\
    \   |         ---- help: consider changing this to be mutable: `mut keys`\n14\
    \ |     match keys.next() {\n   |           ^^^^^^^^^^^ cannot borrow as mutable\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_count\
    \ = 0;\n    let mut upper_count = 0;\n    for key in dict.keys() {\n        if\
    \ key.chars().next().unwrap().is_uppercase() {\n            upper_count += 1;\n\
    \        } else {\n            lower_count += 1;\n        }\n    }\n    // println!(\"\
    {}, {}\", lower_count, upper_count);\n    if dict.is_empty() {\n        return\
    \ false;\n    } else if lower_count == 0 || upper_count == 0 {\n        return\
    \ true;\n    } else {\n        return false;\n    }\n}\n\nfn main() {\n    let\
    \ candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpw667nv_y.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut upper_keys\
    \ = 0;\n    let mut lower_keys = 0;\n    for key in dict.keys() {\n        if\
    \ key.to_uppercase() == key {\n            upper_keys += 1;\n        } else if\
    \ key.to_lowercase() == key {\n            lower_keys += 1;\n        }\n    }\n\
    \    upper_keys == dict.len() || lower_keys == dict.len()\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpf4hjgr9j.rs:16:31\n\
    \   |\n16 |         if key.to_uppercase() == key {\n   |                     \
    \          ^^ no implementation for `String == &String`\n   |\n   = help: the\
    \ trait `PartialEq<&String>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: can't compare `String` with `&String`\n\
    \  --> /tmp/tmpf4hjgr9j.rs:18:38\n   |\n18 |         } else if key.to_lowercase()\
    \ == key {\n   |                                      ^^ no implementation for\
    \ `String == &String`\n   |\n   = help: the trait `PartialEq<&String>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n         \
    \    <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n\
    \    let mut is_case_equal = true;\n    let mut is_lower = false;\n    let mut\
    \ is_upper = false;\n    for key in keys {\n        if key.len() > 0 {\n     \
    \       if key.chars().nth(0).unwrap().is_lowercase() {\n                is_lower\
    \ = true;\n            } else if key.chars().nth(0).unwrap().is_uppercase() {\n\
    \                is_upper = true;\n            }\n        }\n        if is_lower\
    \ && is_upper {\n            is_case_equal = false;\n            break;\n    \
    \    }\n    }\n    return is_case_equal;\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpdwlwci1i.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut has_uppercase\
    \ = false;\n    let mut has_lowercase = false;\n    for key in dict.keys() {\n\
    \        if key.to_lowercase() == key {\n            has_lowercase = true;\n \
    \       } else if key.to_uppercase() == key {\n            has_uppercase = true;\n\
    \        } else {\n            return false;\n        }\n    }\n    has_uppercase\
    \ && has_lowercase\n}\n\nfn main() {\n    let candidate = check_dict_case;\n \
    \   assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmpjkt8fn2g.rs:16:31\n\
    \   |\n16 |         if key.to_lowercase() == key {\n   |                     \
    \          ^^ no implementation for `String == &String`\n   |\n   = help: the\
    \ trait `PartialEq<&String>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: can't compare `String` with `&String`\n\
    \  --> /tmp/tmpjkt8fn2g.rs:18:38\n   |\n18 |         } else if key.to_uppercase()\
    \ == key {\n   |                                      ^^ no implementation for\
    \ `String == &String`\n   |\n   = help: the trait `PartialEq<&String>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n         \
    \    <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut all_lower\
    \ = true;\n    let mut all_upper = true;\n    for key in dict.keys() {\n     \
    \   if key.chars().any(|x| x.is_lowercase()) {\n            all_upper = false;\n\
    \        }\n        if key.chars().any(|x| x.is_uppercase()) {\n            all_lower\
    \ = false;\n        }\n    }\n    all_lower || all_upper\n}\n\nfn main() {\n \
    \   let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmppntz8yjl.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut lower = true;\n    let mut upper\
    \ = true;\n    for key in dict.keys() {\n        if !key.to_string().is_ascii_lowercase()\
    \ {\n            lower = false;\n        }\n        if !key.to_string().is_ascii_uppercase()\
    \ {\n            upper = false;\n        }\n    }\n    lower || upper\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpojc_rdf4.rs:19:29\n   |\n19 |         if\
    \ !key.to_string().is_ascii_lowercase() {\n   |                             ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_uppercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpojc_rdf4.rs:22:29\n   |\n22 |         if\
    \ !key.to_string().is_ascii_uppercase() {\n   |                             ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_uppercase`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    // Solution 1:\n\
    \    let mut lower_counter = 0;\n    let mut upper_counter = 0;\n    for key in\
    \ dict.keys() {\n        let lower = key.to_lowercase();\n        let upper =\
    \ key.to_uppercase();\n        if key == &lower {\n            lower_counter +=\
    \ 1;\n        } else if key == &upper {\n            upper_counter += 1;\n   \
    \     } else {\n            return false;\n        }\n    }\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    lower_counter == dict.len() || upper_counter\
    \ == dict.len()\n    // Solution 2:\n    // let mut l_case = true;\n    // let\
    \ mut u_case = true;\n    // for key in dict.keys() {\n    //     if key.to_lowercase()\
    \ != key {\n    //         l_case = false;\n    //     }\n    //     if key.to_uppercase()\
    \ != key {\n    //         u_case = false;\n    //     }\n    // }\n    // if\
    \ dict.is_empty() {\n    //     return false;\n    // }\n    // l_case || u_case\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpigfl3okb.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if let Some(ch) = key.chars().next() {\n            if !ch.is_lowercase()\
    \ {\n                lower_case = false;\n            }\n            if !ch.is_uppercase()\
    \ {\n                upper_case = false;\n            }\n        }\n    }\n  \
    \  lower_case || upper_case\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5523cnds.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut count_lower\
    \ = 0;\n    let mut count_upper = 0;\n    for value in dict.keys() {\n       \
    \ if value.chars().nth(0).unwrap().is_uppercase() {\n            count_upper +=\
    \ 1;\n        } else {\n            count_lower += 1;\n        }\n    }\n    if\
    \ count_lower == 0 || count_upper == 0 {\n        return true;\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpk5mqzjd7.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut upper_case\
    \ = true;\n    let mut lower_case = true;\n    let mut result = false;\n    for\
    \ key in dict.keys() {\n        if key.chars().all(|x| x.is_uppercase()) {\n \
    \           lower_case = false;\n        } else if key.chars().all(|x| x.is_lowercase())\
    \ {\n            upper_case = false;\n        } else {\n            return false;\n\
    \        }\n    }\n    if upper_case {\n        result = true;\n    } else if\
    \ lower_case {\n        result = true;\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5gr2ypk3.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut upper_count\
    \ = 0;\n    let mut lower_count = 0;\n    let mut number_count = 0;\n    for key\
    \ in dict.keys() {\n        let (upper, lower, number) = count_chars(&key);\n\
    \        upper_count += upper;\n        lower_count += lower;\n        number_count\
    \ += number;\n    }\n    println!(\"upper: {}, lower: {}, number: {}\", upper_count,\
    \ lower_count, number_count);\n    upper_count == 0 || lower_count == 0\n}\n\n\
    fn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `count_chars` in this scope\n  --> /tmp/tmpv11wu4jw.rs:17:38\n\
    \   |\n17 |         let (upper, lower, number) = count_chars(&key);\n   |    \
    \                                  ^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut all_keys_are_lower\
    \ = true;\n    let mut all_keys_are_upper = true;\n    for (key, _) in dict {\n\
    \        if !key.is_ascii_lowercase() {\n            all_keys_are_lower = false;\n\
    \        }\n        if !key.is_ascii_uppercase() {\n            all_keys_are_upper\
    \ = false;\n        }\n    }\n    all_keys_are_lower || all_keys_are_upper\n}\n\
    \nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpi1lvfhej.rs:16:17\n   |\n16 |         if\
    \ !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_lowercase`\n\nerror[E0599]:\
    \ no method named `is_ascii_uppercase` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpi1lvfhej.rs:19:17\n   |\n19 |         if !key.is_ascii_uppercase()\
    \ {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_ascii_uppercase`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut out =\
    \ true;\n    for (key, _value) in dict {\n        out = out && key.is_lowercase();\n\
    \    }\n    for (key, _value) in dict {\n        out = out && key.is_uppercase();\n\
    \    }\n    out\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpx1v3iaex.rs:15:26\n   |\n15 |         out\
    \ = out && key.is_lowercase();\n   |                          ^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]:\
    \ no method named `is_uppercase` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpx1v3iaex.rs:18:26\n   |\n18 |         out = out && key.is_uppercase();\n\
    \   |                          ^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut flag = true;\n    let mut upper\
    \ = true;\n    let mut lower = true;\n    for (key, _) in dict {\n        if flag\
    \ {\n            if key.chars().next().unwrap().is_uppercase() {\n           \
    \     upper = true;\n                lower = false;\n                flag = false;\n\
    \            } else {\n                upper = false;\n                lower =\
    \ true;\n                flag = false;\n            }\n        } else {\n    \
    \        if upper {\n                if key.chars().next().unwrap().is_lowercase()\
    \ {\n                    return false;\n                }\n            } else\
    \ {\n                if key.chars().next().unwrap().is_uppercase() {\n       \
    \             return false;\n                }\n            }\n        }\n   \
    \ }\n    true\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpj4izueb2.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut count\
    \ = 0;\n    for key in dict.keys() {\n        if key.to_lowercase() == key {\n\
    \            count += 1;\n        }\n    }\n    dict.len() == count || dict.len()\
    \ == dict.len() - count\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmp_dyeuz69.rs:15:31\n\
    \   |\n15 |         if key.to_lowercase() == key {\n   |                     \
    \          ^^ no implementation for `String == &String`\n   |\n   = help: the\
    \ trait `PartialEq<&String>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut upper\
    \ = true;\n    let mut lower = true;\n    for (key, _) in dict {\n        if !key.chars().all(|char|\
    \ char.is_uppercase()) {\n            upper = false;\n        }\n        if !key.chars().all(|char|\
    \ char.is_lowercase()) {\n            lower = false;\n        }\n    }\n    upper\
    \ || lower\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpdvg_8on9.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut lowercase = true;\n    let mut\
    \ uppercase = true;\n    for (key, _) in dict {\n        if let Some(first_char)\
    \ = key.chars().next() {\n            lowercase = lowercase && first_char.is_lowercase();\n\
    \            uppercase = uppercase && first_char.is_uppercase();\n        }\n\
    \    }\n    lowercase || uppercase\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphqs79xnm.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut all_lower\
    \ = true;\n    let mut all_upper = true;\n    for (key, _) in dict {\n       \
    \ if key.contains(char::is_uppercase) {\n            all_lower = false;\n    \
    \    }\n        if key.contains(char::is_lowercase) {\n            all_upper =\
    \ false;\n        }\n    }\n    return all_lower || all_upper;\n}\n\nfn main()\
    \ {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpv6ons2dy.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmptoog1l0g.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_all_lower\
    \ = true;\n    let mut is_all_upper = true;\n    for (_, word) in dict {\n   \
    \     is_all_lower = is_all_lower && word.is_lowercase();\n        is_all_upper\
    \ = is_all_upper && word.is_uppercase();\n    }\n    is_all_lower || is_all_upper\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpgjh98y7u.rs:16:45\n   |\n16 |         is_all_lower\
    \ = is_all_lower && word.is_lowercase();\n   |                               \
    \              ^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `to_lowercase`\n\nerror[E0599]: no method named `is_uppercase` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpgjh98y7u.rs:17:45\n   |\n\
    17 |         is_all_upper = is_all_upper && word.is_uppercase();\n   |       \
    \                                      ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut case\
    \ = 0;\n    for key in dict.keys() {\n        if key.chars().all(|x| x.is_uppercase())\
    \ {\n            if case == 0 {\n                case = 1;\n            } else\
    \ if case == 2 {\n                return false;\n            }\n        } else\
    \ if key.chars().all(|x| x.is_lowercase()) {\n            if case == 0 {\n   \
    \             case = 2;\n            } else if case == 1 {\n                return\
    \ false;\n            }\n        } else {\n            return false;\n       \
    \ }\n    }\n    true\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpjha09ede.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.len()\
    \ == 0 {\n        return false;\n    }\n    let mut upper_only = true;\n    let\
    \ mut lower_only = true;\n    for (key, _) in dict {\n        if key != key.to_lowercase()\
    \ {\n            lower_only = false;\n        }\n        if key != key.to_uppercase()\
    \ {\n            upper_only = false;\n        }\n    }\n    upper_only || lower_only\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0qpv6z72.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys: Vec<String>\
    \ = dict.keys().map(|x| x.to_string()).collect();\n    let mut all_lower = true;\n\
    \    let mut all_upper = true;\n    for key in keys {\n        if key.to_uppercase()\
    \ != key {\n            all_upper = false;\n        }\n        if key.to_lowercase()\
    \ != key {\n            all_lower = false;\n        }\n    }\n    if all_lower\
    \ || all_upper {\n        return true;\n    }\n    false\n}\n\nfn main() {\n \
    \   let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpisnbh1mo.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let (size, mut\
    \ upper, mut lower): (usize, usize, usize) = (dict.len(), 0, 0);\n    if size\
    \ == 0 {\n        return false;\n    }\n    for s in dict.keys() {\n        match\
    \ s.chars().next() {\n            Some(c) => {\n                if c.is_uppercase()\
    \ {\n                    upper += 1;\n                } else if c.is_lowercase()\
    \ {\n                    lower += 1;\n                }\n            },\n    \
    \        None => {},\n        }\n    }\n    if size == upper || size == lower\
    \ {\n        return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpcov_hm4x.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut flag\
    \ = 0;\n    for (key, _) in dict {\n        if key.contains(char::is_uppercase)\
    \ {\n            flag += 1;\n        }\n    }\n    if dict.len() == 0 {\n    \
    \    return false;\n    } else if flag == 0 || flag == dict.len() {\n        return\
    \ true;\n    } else {\n        return false;\n    }\n}\n\nfn main() {\n    let\
    \ candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `dict`\n   --> /tmp/tmpmzujosle.rs:19:8\n\
    \    |\n12  | fn check_dict_case(dict: HashMap<String, String>) -> bool {\n  \
    \  |                    ---- move occurs because `dict` has type `HashMap<String,\
    \ String>`, which does not implement the `Copy` trait\n13  |     let mut flag\
    \ = 0;\n14  |     for (key, _) in dict {\n    |                     ---- `dict`\
    \ moved due to this implicit call to `.into_iter()`\n...\n19  |     if dict.len()\
    \ == 0 {\n    |        ^^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `dict`\nhelp:\
    \ consider iterating over a slice of the `HashMap<String, String>`'s content to\
    \ avoid moving into the `for` loop\n    |\n14  |     for (key, _) in &dict {\n\
    \    |                     +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.keys().all(|k|\
    \ k.to_lowercase() == k) || dict.keys().all(|k| k.to_uppercase() == k)\n}\n\n\
    fn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmp47q6jh__.rs:13:42\n\
    \   |\n13 |     dict.keys().all(|k| k.to_lowercase() == k) || dict.keys().all(|k|\
    \ k.to_uppercase() == k)\n   |                                          ^^ no\
    \ implementation for `String == &String`\n   |\n   = help: the trait `PartialEq<&String>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: can't compare `String` with `&String`\n\
    \  --> /tmp/tmp47q6jh__.rs:13:88\n   |\n13 |     dict.keys().all(|k| k.to_lowercase()\
    \ == k) || dict.keys().all(|k| k.to_uppercase() == k)\n   |                  \
    \                                                                      ^^ no implementation\
    \ for `String == &String`\n   |\n   = help: the trait `PartialEq<&String>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut lowercase = true;\n    let mut\
    \ uppercase = true;\n    for key in dict.keys() {\n        let first_char = key.chars().next().unwrap();\n\
    \        if first_char.is_uppercase() {\n            lowercase = false;\n    \
    \    } else if first_char.is_lowercase() {\n            uppercase = false;\n \
    \       } else {\n            lowercase = false;\n            uppercase = false;\n\
    \        }\n    }\n    lowercase || uppercase\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5xxrspa1.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.keys().fold(true,\
    \ |mut acc, key| {\n        for c in key.chars() {\n            if acc && c.is_uppercase()\
    \ {\n                acc = false;\n            }\n        }\n        acc\n   \
    \ })\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpih8wopyt.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys: Vec<String>\
    \ = dict.keys().map(|k| k.to_lowercase()).collect();\n    keys == keys.iter().map(|k|\
    \ k.to_uppercase()).collect()\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0283]: type annotations needed\n  --> /tmp/tmpb5vjpvtj.rs:14:10\n\
    \   |\n14 |     keys == keys.iter().map(|k| k.to_uppercase()).collect()\n   |\
    \          ^^ cannot infer type\n   |\n   = note: multiple `impl`s satisfying\
    \ `Vec<String>: PartialEq<_>` found in the `alloc` crate:\n           - impl<T,\
    \ U, A, N> PartialEq<&[U; N]> for Vec<T, A>\n             where A: Allocator,\
    \ T: PartialEq<U>;\n           - impl<T, U, A, N> PartialEq<[U; N]> for Vec<T,\
    \ A>\n             where A: Allocator, T: PartialEq<U>;\n           - impl<T,\
    \ U, A1, A2> PartialEq<Vec<U, A2>> for Vec<T, A1>\n             where A1: Allocator,\
    \ A2: Allocator, T: PartialEq<U>;\n           - impl<T, U, A> PartialEq<&[U]>\
    \ for Vec<T, A>\n             where A: Allocator, T: PartialEq<U>;\n         \
    \  and 2 more\nhelp: consider specifying the type argument in the method call\n\
    \   |\n14 |     keys == keys.iter().map(|k| k.to_uppercase()).collect::<B>()\n\
    \   |                                                          +++++\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0283`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut dict_keys = dict.keys().into_iter();\n\
    \    let is_lower = dict_keys.next().unwrap().is_lowercase();\n    dict_keys.all(|key|\
    \ key.is_lowercase() == is_lower)\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmp5_7v9jyt.rs:17:46\n   |\n17 |     let is_lower\
    \ = dict_keys.next().unwrap().is_lowercase();\n   |                          \
    \                    ^^^^^^^^^^^^ help: there is an associated function with a\
    \ similar name: `to_lowercase`\n\nerror[E0599]: no method named `is_lowercase`\
    \ found for reference `&String` in the current scope\n  --> /tmp/tmp5_7v9jyt.rs:18:29\n\
    \   |\n18 |     dict_keys.all(|key| key.is_lowercase() == is_lower)\n   |    \
    \                         ^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_lowercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut is_lower = dict.keys().next().unwrap().chars().next().unwrap().is_lowercase();\n\
    \    dict.keys().all(|key| key.chars().next().unwrap().is_lowercase() == is_lower)\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp2_xr504d.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut lowercase = true;\n    let mut\
    \ uppercase = true;\n    for (key, _) in dict {\n        if !key.is_ascii_lowercase()\
    \ {\n            lowercase = false;\n        }\n        if !key.is_ascii_uppercase()\
    \ {\n            uppercase = false;\n        }\n    }\n    lowercase || uppercase\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpdd4ogkqd.rs:19:17\n   |\n19 |         if\
    \ !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_lowercase`\n\nerror[E0599]:\
    \ no method named `is_ascii_uppercase` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpdd4ogkqd.rs:22:17\n   |\n22 |         if !key.is_ascii_uppercase()\
    \ {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_ascii_uppercase`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.keys().all(|s|\
    \ s.is_ascii_lowercase()) ||\n    dict.keys().all(|s| s.is_ascii_uppercase())\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpz9fw0otf.rs:13:27\n   |\n13 |\
    \     dict.keys().all(|s| s.is_ascii_lowercase()) ||\n   |                   \
    \        ^^^^^^^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `to_ascii_lowercase`\n\nerror[E0599]: no method named `is_ascii_uppercase`\
    \ found for reference `&String` in the current scope\n  --> /tmp/tmpz9fw0otf.rs:14:27\n\
    \   |\n14 |     dict.keys().all(|s| s.is_ascii_uppercase())\n   |            \
    \               ^^^^^^^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_ascii_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut all_lower\
    \ = true;\n    let mut all_upper = true;\n    for key in dict.keys() {\n     \
    \   for letter in key.chars() {\n            if letter.is_ascii_lowercase() {\n\
    \                all_upper = false;\n            } else if letter.is_ascii_uppercase()\
    \ {\n                all_lower = false;\n            } else {\n              \
    \  return false;\n            }\n        }\n    }\n    all_lower || all_upper\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpkme568hm.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let (keys, _)\
    \ = dict.into_iter().unzip();\n    let upper = keys.iter().all(|s| s.to_uppercase()\
    \ == *s);\n    let lower = keys.iter().all(|s| s.to_lowercase() == *s);\n    !dict.is_empty()\
    \ && (upper || lower)\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `(FromA, FromB)`\n  --> /tmp/tmpf5g3kyyf.rs:14:17\n\
    \   |\n13 |     let (keys, _) = dict.into_iter().unzip();\n   |         ---------\
    \ consider giving this pattern the explicit type `(FromA, FromB)`, with the type\
    \ parameters specified\n14 |     let upper = keys.iter().all(|s| s.to_uppercase()\
    \ == *s);\n   |                 ^^^^ cannot infer type\n   |\n   = note: type\
    \ must be known at this point\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_lower_case:\
    \ bool = true;\n    let mut is_upper_case: bool = true;\n    let mut is_all_string:\
    \ bool = true;\n    for (key, value) in dict {\n        if key.chars().next().unwrap().is_ascii_uppercase()\
    \ {\n            is_lower_case = false;\n        } else if key.chars().next().unwrap().is_ascii_lowercase()\
    \ {\n            is_upper_case = false;\n        } else {\n            is_all_string\
    \ = false;\n        }\n    }\n    return is_lower_case || is_upper_case && is_all_string;\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpb_w69uip.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut first_char:\
    \ char = dict.keys().next().unwrap().chars().next().unwrap();\n    let mut bool_check:\
    \ bool = first_char.is_lowercase();\n    let check = dict.keys().all(|key| {\n\
    \        let char_iter = key.chars();\n        bool_check == char_iter.all(|x|\
    \ x.is_lowercase())\n    });\n    check\n}\n\nfn main() {\n    let candidate =\
    \ check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"\
    ), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `char_iter` as mutable, as it is not declared\
    \ as mutable\n  --> /tmp/tmp44pfeo12.rs:17:23\n   |\n16 |         let char_iter\
    \ = key.chars();\n   |             --------- help: consider changing this to be\
    \ mutable: `mut char_iter`\n17 |         bool_check == char_iter.all(|x| x.is_lowercase())\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow\
    \ as mutable\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmp44pfeo12.rs:13:9\n\
    \   |\n13 |     let mut first_char: char = dict.keys().next().unwrap().chars().next().unwrap();\n\
    \   |         ----^^^^^^^^^^\n   |         |\n   |         help: remove this `mut`\n\
    \   |\n   = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does\
    \ not need to be mutable\n  --> /tmp/tmp44pfeo12.rs:14:9\n   |\n14 |     let mut\
    \ bool_check: bool = first_char.is_lowercase();\n   |         ----^^^^^^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n\nerror: aborting due to\
    \ previous error; 2 warnings emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys: Vec<_>\
    \ = dict.keys().map(|x| x.to_lowercase()).collect();\n    let values: Vec<_> =\
    \ dict.values().map(|x| x.to_lowercase()).collect();\n    let mut keys_iter =\
    \ keys.iter();\n    let mut values_iter = values.iter();\n    while let Some(key)\
    \ = keys_iter.next() {\n        if key != values_iter.next().unwrap() {\n    \
    \        return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpicd4x4_a.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut upper_case = true;\n    let mut\
    \ lower_case = true;\n    for key in dict.keys() {\n        if key.chars().next().unwrap().is_uppercase()\
    \ {\n            lower_case = false;\n        } else {\n            upper_case\
    \ = false;\n        }\n    }\n    if upper_case || lower_case {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpck4k6t_y.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpu3vm6t1c.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower\
    \ = true;\n    let mut upper = true;\n    for (key, _value) in dict {\n      \
    \  if !key.chars().all(|c| c.is_uppercase()) {\n            upper = false;\n \
    \       }\n        if !key.chars().all(|c| c.is_lowercase()) {\n            lower\
    \ = false;\n        }\n    }\n    lower || upper\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmppj0i1ahr.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let is_upper\
    \ = dict.keys().all(|k| k.is_uppercase());\n    let is_lower = dict.keys().all(|k|\
    \ k.is_lowercase());\n    is_upper || is_lower\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_uppercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpp841zxjz.rs:13:42\n   |\n13 |     let is_upper\
    \ = dict.keys().all(|k| k.is_uppercase());\n   |                             \
    \             ^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `to_uppercase`\n\nerror[E0599]: no method named `is_lowercase` found for\
    \ reference `&String` in the current scope\n  --> /tmp/tmpp841zxjz.rs:14:42\n\
    \   |\n14 |     let is_lower = dict.keys().all(|k| k.is_lowercase());\n   |  \
    \                                        ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut is_lower = true;\n    let mut is_upper\
    \ = true;\n    for (key, value) in dict {\n        if !key.is_ascii_lowercase()\
    \ {\n            is_lower = false;\n        }\n        if !key.is_ascii_uppercase()\
    \ {\n            is_upper = false;\n        }\n    }\n    is_lower || is_upper\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpyll3135p.rs:19:17\n   |\n19 |         if\
    \ !key.is_ascii_lowercase() {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_lowercase`\n\nerror[E0599]:\
    \ no method named `is_ascii_uppercase` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpyll3135p.rs:22:17\n   |\n22 |         if !key.is_ascii_uppercase()\
    \ {\n   |                 ^^^^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_ascii_uppercase`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    return false;\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbb8_w221.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut test = \"\".to_string();\n    let\
    \ mut is_lower = true;\n    let mut is_upper = true;\n    for (key, _value) in\
    \ dict {\n        test = key;\n        if is_lower && !test.to_lowercase().eq(&test)\
    \ {\n            is_lower = false;\n        }\n        if is_upper && !test.to_uppercase().eq(&test)\
    \ {\n            is_upper = false;\n        }\n    }\n    is_lower || is_upper\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpnlah2582.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut upper\
    \ = 0;\n    let mut lower = 0;\n    for val in dict.keys() {\n        for c in\
    \ val.chars() {\n            if c.is_uppercase() {\n                upper += 1;\n\
    \            } else if c.is_lowercase() {\n                lower += 1;\n     \
    \       }\n        }\n    }\n    if upper > 0 && lower > 0 {\n        return false;\n\
    \    } else {\n        return true;\n    }\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpm8f8j5ct.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if key.contains(char::is_uppercase) {\n            lower_case = false;\n\
    \        }\n        if key.contains(char::is_lowercase) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpe65niap_.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.keys().all(|x|\
    \ x.is_ascii_lowercase()) ||\n    dict.keys().all(|x| x.is_ascii_uppercase())\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_lowercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmptrwvybp3.rs:13:27\n   |\n13 |\
    \     dict.keys().all(|x| x.is_ascii_lowercase()) ||\n   |                   \
    \        ^^^^^^^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `to_ascii_lowercase`\n\nerror[E0599]: no method named `is_ascii_uppercase`\
    \ found for reference `&String` in the current scope\n  --> /tmp/tmptrwvybp3.rs:14:27\n\
    \   |\n14 |     dict.keys().all(|x| x.is_ascii_uppercase())\n   |            \
    \               ^^^^^^^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_ascii_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    // Initialize\
    \ flags\n    let mut lower_flag = false;\n    let mut upper_flag = false;\n\n\
    \    // Loop through keys\n    for key in dict.keys() {\n        // Check if lower\
    \ case\n        if key.to_lowercase() == *key {\n            lower_flag = true;\n\
    \        }\n\n        // Check if upper case\n        if key.to_uppercase() ==\
    \ *key {\n            upper_flag = true;\n        }\n    }\n\n    // One of these\
    \ flags must be true, if both are false return false\n    if !lower_flag && !upper_flag\
    \ {\n        return false;\n    }\n\n    // If neither are false, return true\n\
    \    return true;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"b\"), String::from(\"banana\"))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"A\"), String::from(\"banana\"\
    )), (String::from(\"B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7eu8iqjg.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let mut lower_keys: bool = true;\n    let\
    \ mut upper_keys: bool = true;\n    for key in dict.keys() {\n        lower_keys\
    \ = lower_keys && key.is_lowercase();\n        upper_keys = upper_keys && key.is_uppercase();\n\
    \    }\n    return lower_keys || upper_keys;\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpyllp7e84.rs:19:40\n   |\n19 |         lower_keys\
    \ = lower_keys && key.is_lowercase();\n   |                                  \
    \      ^^^^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `to_lowercase`\n\nerror[E0599]: no method named `is_uppercase` found for reference\
    \ `&String` in the current scope\n  --> /tmp/tmpyllp7e84.rs:20:40\n   |\n20 |\
    \         upper_keys = upper_keys && key.is_uppercase();\n   |               \
    \                         ^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_uppercase`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    match dict.keys().next()\
    \ {\n        Some(k) => {\n            let (upper, lower) = \n               \
    \ dict.keys().partition(|k| k.is_ascii_uppercase());\n            (upper.count()\
    \ == 0 || lower.count() == 0) &&\n            (upper.count() + lower.count() ==\
    \ dict.len())\n        },\n        None => false\n    }\n}\n\nfn main() {\n  \
    \  let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_uppercase` found for reference\
    \ `&&String` in the current scope\n  --> /tmp/tmpue5eee7i.rs:16:45\n   |\n16 |\
    \                 dict.keys().partition(|k| k.is_ascii_uppercase());\n   |   \
    \                                          ^^^^^^^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `to_ascii_uppercase`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut dict_in_lowercase\
    \ = true;\n    let mut dict_in_uppercase = true;\n    if dict.len() == 0 {\n \
    \       false\n    } else {\n        for key in dict.keys() {\n            if\
    \ !key.chars().all(|x| x.is_lowercase()) {\n                dict_in_lowercase\
    \ = false;\n            }\n            if !key.chars().all(|x| x.is_uppercase())\
    \ {\n                dict_in_uppercase = false;\n            }\n        }\n  \
    \      dict_in_lowercase || dict_in_uppercase\n    }\n}\n\nfn main() {\n    let\
    \ candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let check_upper\
    \ = dict.iter().all(|(key, _value)| key.chars().all(|c| c.is_uppercase()));\n\
    \    let check_lower = dict.iter().all(|(key, _value)| key.chars().all(|c| c.is_lowercase()));\n\
    \    if check_upper || check_lower {\n        true\n    } else {\n        false\n\
    \    }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpn7zxivbw.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut is_lower\
    \ = true;\n    let mut is_upper = true;\n    for key in dict.keys() {\n      \
    \  if !key.chars().all(|c| c.is_uppercase()) {\n            is_upper = false;\n\
    \        }\n        if !key.chars().all(|c| c.is_lowercase()) {\n            is_lower\
    \ = false;\n        }\n    }\n    is_lower || is_upper\n}\n\nfn main() {\n   \
    \ let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpxdylwxh8.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().map(|(k,\
    \ v)| k.to_uppercase()).collect::<Vec<String>>()\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1hh6cf8z.rs:13:5\n   |\n\
    12 | fn check_dict_case(dict: HashMap<String, String>) -> bool {\n   |       \
    \                                               ---- expected `bool` because of\
    \ return type\n13 |     dict.iter().map(|(k, v)| k.to_uppercase()).collect::<Vec<String>>()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `bool`, found struct `Vec`\n   |\n   = note: expected type `bool`\n\
    \            found struct `Vec<String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.keys().all(|k|\
    \ k.chars().all(|c| c.is_uppercase())) ||\n    dict.keys().all(|k| k.chars().all(|c|\
    \ c.is_lowercase()))\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmponsgpcbp.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    dict.iter().map(|(key,\
    \ _)| key.len()).sum::<usize>() == dict.len()\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp1y6xyvnx.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut lower_case\
    \ = true;\n    let mut upper_case = true;\n    for key in dict.keys() {\n    \
    \    if !key.chars().all(|x| x.is_lowercase()) {\n            lower_case = false;\n\
    \        }\n        if !key.chars().all(|x| x.is_uppercase()) {\n            upper_case\
    \ = false;\n        }\n    }\n    lower_case || upper_case\n}\n\nfn main() {\n\
    \    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplruv2zxq.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut current_case:\
    \ String = String::new();\n    for key in dict.keys() {\n        if current_case.is_empty()\
    \ {\n            current_case = String::from(key);\n        }\n        if current_case\
    \ != String::from(key) {\n            return false;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpumkph16h.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    for (key, _) in dict.iter() {\n       \
    \ if key.chars().next().unwrap().is_ascii_lowercase() {\n            if dict.keys().any(|x|\
    \ x.chars().next().unwrap().is_ascii_uppercase()) {\n                return false;\n\
    \            }\n        } else if key.chars().next().unwrap().is_ascii_uppercase()\
    \ {\n            if dict.keys().any(|x| x.chars().next().unwrap().is_ascii_lowercase())\
    \ {\n                return false;\n            }\n        } else {\n        \
    \    return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp8v3f4gff.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n\
    \    let mut result = true;\n    match keys.next() {\n        Some(key) => {\n\
    \            if key.len() == 0 {\n                result = false;\n          \
    \  } else {\n                let check_val = if key.chars().nth(0).unwrap().is_uppercase()\
    \ {\n                    true\n                } else {\n                    false\n\
    \                };\n                for key in keys {\n                    if\
    \ check_val != key.chars().nth(0).unwrap().is_uppercase() {\n                \
    \        result = false;\n                        break;\n                   \
    \ }\n                }\n            }\n        }\n        None => result = false,\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = check_dict_case;\n \
    \   assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `keys` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpm4ur7orf.rs:15:11\n   |\n13 |     let keys = dict.keys();\n\
    \   |         ---- help: consider changing this to be mutable: `mut keys`\n14\
    \ |     let mut result = true;\n15 |     match keys.next() {\n   |           ^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    // Your Code\
    \ Goes Here\n    false\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpnrs9v84p.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let keys = dict.keys();\n\
    \    let mut lower = true;\n    let mut upper = true;\n    for key in keys {\n\
    \        lower = lower && key.is_lowercase();\n        upper = upper && key.is_uppercase();\n\
    \    }\n    return lower || upper;\n}\n\nfn main() {\n    let candidate = check_dict_case;\n\
    \    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"b\"), String::from(\"banana\"))])), true);\n  \
    \  assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"pineapple\"\
    )), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"B\"), String::from(\"\
    banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_lowercase` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpk40_8ngl.rs:17:30\n   |\n17 |         lower\
    \ = lower && key.is_lowercase();\n   |                              ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_lowercase`\n\n\
    error[E0599]: no method named `is_uppercase` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmpk40_8ngl.rs:18:30\n   |\n18 |         upper\
    \ = upper && key.is_uppercase();\n   |                              ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_uppercase`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.len()\
    \ == 0 {\n        return false;\n    }\n    let mut last_char = dict.keys().next().unwrap().chars().next().unwrap();\n\
    \    for key in dict.keys() {\n        for c in key.chars() {\n            if\
    \ c.is_alphabetic() {\n                if last_char.is_alphabetic() {\n      \
    \              if last_char.is_uppercase() != c.is_uppercase() {\n           \
    \             return false;\n                    }\n                }\n      \
    \          last_char = c;\n            }\n        }\n    }\n    true\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpkczhpf58.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    if dict.is_empty()\
    \ {\n        return false;\n    }\n    let first_key = dict.keys().next().unwrap();\n\
    \    if first_key.chars().all(|c| c.is_uppercase()) {\n        dict.keys().all(|k|\
    \ k.chars().all(|c| c.is_uppercase()))\n    } else {\n        dict.keys().all(|k|\
    \ k.chars().all(|c| c.is_lowercase()))\n    }\n}\n\nfn main() {\n    let candidate\
    \ = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpnogotxf8.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    true\n}\n\nfn\
    \ main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp07pss7f3.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    false\n}\n\n\
    fn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9ii0tlzm.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "use std::collections::HashMap;\n\n/// Given a dictionary, return True\
    \ if all keys are strings in lower \n/// case or all keys are strings in upper\
    \ case, else return False.\n/// The function should return False is the given\
    \ dictionary is empty.\n/// Examples:\n/// check_dict_case({\"a\":\"apple\", \"\
    b\":\"banana\"}) should return True.\n/// check_dict_case({\"a\":\"apple\", \"\
    A\":\"banana\", \"B\":\"banana\"}) should return False.\n/// check_dict_case({\"\
    a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n/// check_dict_case({\"\
    Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n\
    /// check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
    fn check_dict_case(dict: HashMap<String, String>) -> bool {\n    let mut keys\
    \ = dict.keys();\n    let first_key: Option<&String> = keys.next();\n    match\
    \ first_key {\n        Some(key) => {\n            if key.is_empty() {\n     \
    \           return false;\n            }\n            let mut is_all_upper = key.chars().all(|c|\
    \ c.is_uppercase());\n            let mut is_all_lower = key.chars().all(|c| c.is_lowercase());\n\
    \            for key in keys {\n                if key.is_empty() {\n        \
    \            return false;\n                }\n                is_all_upper =\
    \ is_all_upper && key.chars().all(|c| c.is_uppercase());\n                is_all_lower\
    \ = is_all_lower && key.chars().all(|c| c.is_lowercase());\n            }\n  \
    \          is_all_upper || is_all_lower\n        },\n        None => true\n  \
    \  }\n}\n\nfn main() {\n    let candidate = check_dict_case;\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"b\"), String::from(\"banana\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"p\"), String::from(\"\
    pineapple\")), (String::from(\"A\"), String::from(\"banana\")), (String::from(\"\
    B\"), String::from(\"banana\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    p\"), String::from(\"pineapple\")), (String::from(\"5\"), String::from(\"banana\"\
    )), (String::from(\"a\"), String::from(\"apple\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    Name\"), String::from(\"John\")), (String::from(\"Age\"), String::from(\"36\"\
    )), (String::from(\"City\"), String::from(\"Houston\"))])), false);\n    assert_eq!(candidate(HashMap::from([(String::from(\"\
    STATE\"), String::from(\"NC\")), (String::from(\"ZIP\"), String::from(\"12345\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([(String::from(\"fruit\"\
    ), String::from(\"Orange\")), (String::from(\"taste\"), String::from(\"Sweet\"\
    ))])), true);\n    assert_eq!(candidate(HashMap::from([])), false);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpd0_tphqf.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
