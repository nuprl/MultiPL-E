name: HumanEval_136_largest_smallest_integers
language: rust
prompt: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
  \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
  \ in a list.\n/// If there is no negative or positive integers, return them as None.\n\
  /// Examples:\n/// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n\
  /// largest_smallest_integers([]) == (None, None)\n/// largest_smallest_integers([0])\
  \ == (None, None)\nfn largest_smallest_integers(lst: Vec<isize>) -> (Option<isize>,\
  \ Option<isize>) {\n"
tests: "}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
  \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
  \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
  \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
  \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
  \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
  \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
  \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5, -6,\
  \ 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]), (Some(-3),\
  \ Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]), (Some(-3),\
  \ Some(1)));\n}\n"
completions: ['    unimplemented!()', '    unimplemented!()', "    if lst.len() ==\
    \ 0 {\n        return (None, None);\n    }\n    let (mut pos, mut neg) = (None,\
    \ None);\n    for item in lst {\n        if item >= 0 {\n            match pos\
    \ {\n                None => pos = Some(item),\n                Some(x) => {\n\
    \                    if item < x {\n                        pos = Some(item);\n\
    \                    }\n                }\n            }\n        } else {\n \
    \           match neg {\n                None => neg = Some(item),\n         \
    \       Some(x) => {\n                    if item > x {\n                    \
    \    neg = Some(item);\n                    }\n                }\n           \
    \ }\n        }\n    }\n    (neg, pos)", "    if lst.is_empty() {\n        return\
    \ (None, None);\n    }\n    let (mut max_n, mut min_p) = (None, None);\n    for\
    \ v in lst {\n        if v < 0 {\n            max_n = match max_n {\n        \
    \        None => Some(v),\n                Some(m) => Some(std::cmp::max(m, v)),\n\
    \            };\n        } else if v > 0 {\n            min_p = match min_p {\n\
    \                None => Some(v),\n                Some(m) => Some(std::cmp::min(m,\
    \ v)),\n            };\n        }\n    }\n    (max_n, min_p)", '    unimplemented!();',
  "    if lst.len() == 0 {\n        return (None, None);\n    }\n    let mut smallest\
    \ = None;\n    let mut largest = None;\n    for item in lst {\n        if item\
    \ > 0 {\n            if let Some(v) = smallest {\n                if item < v\
    \ {\n                    smallest = Some(item);\n                }\n         \
    \   } else {\n                smallest = Some(item);\n            }\n        }\
    \ else if item < 0 {\n            if let Some(v) = largest {\n               \
    \ if item > v {\n                    largest = Some(item);\n                }\n\
    \            } else {\n                largest = Some(item);\n            }\n\
    \        }\n    }\n    (largest, smallest)", "    let mut negs = Vec::new();\n\
    \    let mut poss = Vec::new();\n    for e in lst {\n        if e < 0 {\n    \
    \        negs.push(e);\n        } else if e > 0 {\n            poss.push(e);\n\
    \        }\n    }\n    let mut result_neg = if negs.len() > 0 { Some(negs[0])\
    \ } else { None };\n    let mut result_pos = if poss.len() > 0 { Some(poss[0])\
    \ } else { None };\n    for e in negs {\n        if e > result_neg.unwrap() {\n\
    \            result_neg = Some(e);\n        }\n    }\n    for e in poss {\n  \
    \      if e < result_pos.unwrap() {\n            result_pos = Some(e);\n     \
    \   }\n    }\n    (result_neg, result_pos)", '    (None, None)', "    let mut\
    \ largest_negative = None;\n    let mut smallest_positive = None;\n    for number\
    \ in lst {\n        if number > 0 {\n            smallest_positive = smallest_positive.map_or(Some(number),\
    \ |n| Some(n.min(number)));\n        } else if number < 0 {\n            largest_negative\
    \ = largest_negative.map_or(Some(number), |n| Some(n.max(number)));\n        }\n\
    \    }\n    (largest_negative, smallest_positive)", "    if lst.len() == 0 {\n\
    \        return (None, None);\n    }\n    let mut pos_min = None;\n    let mut\
    \ neg_max = None;\n    for num in lst {\n        if num > 0 {\n            if\
    \ pos_min.is_none() || num < pos_min.unwrap() {\n                pos_min = Some(num);\n\
    \            }\n        } else if num < 0 {\n            if neg_max.is_none()\
    \ || num > neg_max.unwrap() {\n                neg_max = Some(num);\n        \
    \    }\n        }\n    }\n    (neg_max, pos_min)", "    match lst.len() {\n  \
    \      0 => (None, None),\n        _ => {\n            let mut min = Some(std::isize::MAX);\n\
    \            let mut max = Some(std::isize::MIN);\n            for x in lst {\n\
    \                if x >= 0 {\n                    match min {\n              \
    \          Some(v) => {\n                            if x < v {\n            \
    \                    min = Some(x);\n                            }\n         \
    \               }\n                        None => min = Some(x),\n          \
    \          }\n                } else {\n                    match max {\n    \
    \                    Some(v) => {\n                            if x > v {\n  \
    \                              max = Some(x);\n                            }\n\
    \                        }\n                        None => max = Some(x),\n \
    \                   }\n                }\n            }\n            if min ==\
    \ Some(std::isize::MAX) {\n                min = None;\n            }\n      \
    \      if max == Some(std::isize::MIN) {\n                max = None;\n      \
    \      }\n            (max, min)\n        }\n    }", '    unimplemented!()', " \
    \   if lst.is_empty() {\n        return (None, None);\n    }\n    let mut pos\
    \ = None;\n    let mut neg = None;\n    for x in lst {\n        if x > 0 {\n \
    \           pos = match pos {\n                None => Some(x),\n            \
    \    Some(p) => Some(min(p, x)),\n            };\n        } else if x < 0 {\n\
    \            neg = match neg {\n                None => Some(x),\n           \
    \     Some(n) => Some(max(n, x)),\n            };\n        }\n    }\n    (neg,\
    \ pos)", '  unimplemented!()', "    let mut min_pos: Option<isize> = None;\n \
    \   let mut max_neg: Option<isize> = None;\n    for val in lst {\n        if val\
    \ < 0 {\n            if max_neg.is_none() || max_neg.unwrap() < val {\n      \
    \          max_neg = Some(val);\n            }\n        } else if val > 0 {\n\
    \            if min_pos.is_none() || min_pos.unwrap() > val {\n              \
    \  min_pos = Some(val);\n            }\n        }\n    }\n    (max_neg, min_pos)",
  "    let mut neg = None;\n    let mut pos = None;\n    for i in lst {\n        if\
    \ i < 0 {\n            if neg.is_none() || i > neg.unwrap() {\n              \
    \  neg = Some(i);\n            }\n        } else if i > 0 {\n            if pos.is_none()\
    \ || i < pos.unwrap() {\n                pos = Some(i);\n            }\n     \
    \   }\n    }\n    (neg, pos)", "    let mut mx = None;\n    let mut mn = None;\n\
    \    for n in lst {\n        if n < 0 {\n            mx = Some(cmp::max(mx.unwrap_or(n),\
    \ n));\n        } else if n > 0 {\n            mn = Some(cmp::min(mn.unwrap_or(n),\
    \ n));\n        }\n    }\n    (mx, mn)", '    unimplemented!()', "    let mut\
    \ min = None;\n    let mut max = None;\n    for elem in lst {\n        if min.is_none()\
    \ || elem < min.unwrap() {\n            min = Some(elem);\n        }\n       \
    \ if max.is_none() || elem > max.unwrap() {\n            max = Some(elem);\n \
    \       }\n    }\n    return (max, min);", "    let min = lst.iter().filter(|&&i|\
    \ i > 0).min();\n    let max = lst.iter().filter(|&&i| i < 0).max();\n    (max,\
    \ min)", "    if lst.len() == 0 {\n        return (None, None);\n    }\n    let\
    \ mut max = 0;\n    let mut min = 0;\n    let mut max_flag = false;\n    let mut\
    \ min_flag = false;\n    for element in lst {\n        if element > 0 {\n    \
    \        if min_flag == false {\n                min = element;\n            \
    \    min_flag = true;\n            } else if element < min {\n               \
    \ min = element;\n            }\n        } else if element < 0 {\n           \
    \ if max_flag == false {\n                max = element;\n                max_flag\
    \ = true;\n            } else if element > max {\n                max = element;\n\
    \            }\n        }\n    }\n    if max_flag {\n        (Some(max), None)\n\
    \    } else if min_flag {\n        (None, Some(min))\n    } else {\n        (None,\
    \ None)\n    }", "    let mut largest = None;\n    let mut smallest = None;\n\
    \    for num in lst {\n        if largest.is_none() && num < 0 {\n           \
    \ largest = Some(num);\n        } else if smallest.is_none() && num > 0 {\n  \
    \          smallest = Some(num);\n        } else if num < largest.unwrap() &&\
    \ num < 0 {\n            largest = Some(num);\n        } else if num > smallest.unwrap()\
    \ && num > 0 {\n            smallest = Some(num);\n        }\n    }\n    (largest,\
    \ smallest)", "    let mut max = None;\n    let mut min = None;\n    for i in\
    \ lst {\n        if max.is_none() && i < 0 {\n            max = Some(i);\n   \
    \     } else if i < 0 && i > max.unwrap() {\n            max = Some(i);\n    \
    \    }\n        if min.is_none() && i > 0 {\n            min = Some(i);\n    \
    \    } else if i > 0 && i < min.unwrap() {\n            min = Some(i);\n     \
    \   }\n    }\n    (max, min)", '    unimplemented!()', '  unimplemented!();',
  '    unimplemented!();', '  (None, None)', "    let mut largest = None;\n    let\
    \ mut smallest = None;\n    for x in lst {\n        if x < 0 {\n            if\
    \ let Some(y) = largest {\n                if x > y {\n                    largest\
    \ = Some(x);\n                }\n            } else {\n                largest\
    \ = Some(x);\n            }\n        }\n        if x > 0 {\n            if let\
    \ Some(y) = smallest {\n                if x < y {\n                    smallest\
    \ = Some(x);\n                }\n            } else {\n                smallest\
    \ = Some(x);\n            }\n        }\n    }\n    (largest, smallest)", '    unimplemented!()',
  "    let mut smallest = None;\n    let mut largest = None;\n    for i in lst {\n\
    \        if i > 0 {\n            smallest = match smallest {\n               \
    \ None => Some(i),\n                Some(s) => {\n                    if i < s\
    \ {\n                        Some(i)\n                    } else {\n         \
    \               Some(s)\n                    }\n                }\n          \
    \  }\n        }\n        if i < 0 {\n            largest = match largest {\n \
    \               None => Some(i),\n                Some(l) => {\n             \
    \       if i > l {\n                        Some(i)\n                    } else\
    \ {\n                        Some(l)\n                    }\n                }\n\
    \            }\n        }\n    }\n    (largest, smallest)", "    let mut max_neg:\
    \ Option<isize> = None;\n    let mut min_pos: Option<isize> = None;\n    for n\
    \ in lst {\n        match n.cmp(&0) {\n            Ordering::Greater => {\n  \
    \              match min_pos {\n                    Some(p) => {\n           \
    \             if n < p {\n                            min_pos = Some(n);\n   \
    \                     }\n                    }\n                    None => min_pos\
    \ = Some(n),\n                }\n            }\n            Ordering::Less =>\
    \ {\n                match max_neg {\n                    Some(p) => {\n     \
    \                   if n > p {\n                            max_neg = Some(n);\n\
    \                        }\n                    }\n                    None =>\
    \ max_neg = Some(n),\n                }\n            }\n            _ => (),\n\
    \        }\n    }\n    (max_neg, min_pos)", '    unimplemented!()', '    unimplemented!()',
  "    let mut max_negative: Option<isize> = None;\n    let mut min_positive: Option<isize>\
    \ = None;\n    for el in lst {\n        if el < 0 {\n            if let Some(x)\
    \ = max_negative {\n                if el > x {\n                    max_negative\
    \ = Some(el);\n                }\n            } else {\n                max_negative\
    \ = Some(el);\n            }\n        }\n        if el > 0 {\n            if let\
    \ Some(x) = min_positive {\n                if el < x {\n                    min_positive\
    \ = Some(el);\n                }\n            } else {\n                min_positive\
    \ = Some(el);\n            }\n        }\n    }\n    (max_negative, min_positive)",
  "    let mut neg: Option<isize> = None;\n    let mut pos: Option<isize> = None;\n\
    \    for i in lst {\n        if i < 0 {\n            match neg {\n           \
    \     None => neg = Some(i),\n                Some(x) => if i > x {\n        \
    \            neg = Some(i);\n                }\n            }\n        } else\
    \ if i > 0 {\n            match pos {\n                None => pos = Some(i),\n\
    \                Some(x) => if i < x {\n                    pos = Some(i);\n \
    \               }\n            }\n        }\n    }\n    (neg, pos)", "    let\
    \ mut positive_numbers: Vec<isize> = Vec::new();\n    let mut negative_numbers:\
    \ Vec<isize> = Vec::new();\n    for number in lst {\n        if number < 0 {\n\
    \            negative_numbers.push(number);\n        } else if number > 0 {\n\
    \            positive_numbers.push(number);\n        }\n    }\n    negative_numbers.sort();\n\
    \    positive_numbers.sort();\n    (\n        if negative_numbers.len() > 0 {\n\
    \            Some(negative_numbers[negative_numbers.len() - 1])\n        } else\
    \ {\n            None\n        },\n        if positive_numbers.len() > 0 {\n \
    \           Some(positive_numbers[0])\n        } else {\n            None\n  \
    \      },\n    )", '    unimplemented!()', "    if lst.is_empty() {\n        return\
    \ (None, None);\n    }\n    let mut neg: Option<isize> = None;\n    let mut pos:\
    \ Option<isize> = None;\n    for &i in &lst {\n        if i < 0 {\n          \
    \  if let Some(x) = neg {\n                if i > x {\n                    neg\
    \ = Some(i);\n                }\n            } else {\n                neg = Some(i);\n\
    \            }\n        } else if i > 0 {\n            if let Some(x) = pos {\n\
    \                if i < x {\n                    pos = Some(i);\n            \
    \    }\n            } else {\n                pos = Some(i);\n            }\n\
    \        }\n    }\n    (neg, pos)", "    let mut largest_neg: Option<isize> =\
    \ None;\n    let mut smallest_pos: Option<isize> = None;\n    for x in lst {\n\
    \        if x >= 0 {\n            if smallest_pos.is_none() || x < smallest_pos.unwrap()\
    \ {\n                smallest_pos = Some(x);\n            }\n        } else {\n\
    \            if largest_neg.is_none() || x > largest_neg.unwrap() {\n        \
    \        largest_neg = Some(x);\n            }\n        }\n    }\n    (largest_neg,\
    \ smallest_pos)", "    let max_neg: Option<isize> = lst.iter().filter(|&x| x <\
    \ &0).max().cloned();\n    let min_pos: Option<isize> = lst.iter().filter(|&x|\
    \ x > &0).min().cloned();\n    (max_neg, min_pos)", '    unimplemented!()', " \
    \   let (mut min, mut max) = (None, None);\n    for el in lst {\n        if el\
    \ > 0 {\n            if let Some(x) = min {\n                if el < x {\n   \
    \                 min = Some(el);\n                }\n            } else {\n \
    \               min = Some(el);\n            }\n        } else if el < 0 {\n \
    \           if let Some(x) = max {\n                if el > x {\n            \
    \        max = Some(el);\n                }\n            } else {\n          \
    \      max = Some(el);\n            }\n        }\n    }\n    (max, min)", "  \
    \  let mut largest = None;\n    let mut smallest = None;\n    for i in lst {\n\
    \        if largest.is_none() && i < 0 {\n            largest = Some(i);\n   \
    \     } else if i < 0 && i > largest.unwrap() {\n            largest = Some(i);\n\
    \        }\n        if smallest.is_none() && i > 0 {\n            smallest = Some(i);\n\
    \        } else if i > 0 && i < smallest.unwrap() {\n            smallest = Some(i);\n\
    \        }\n    }\n    (largest, smallest)", "    let mut iter = lst.iter();\n\
    \    let mut largest = None;\n    let mut smallest = None;\n    for item in iter\
    \ {\n        if *item > 0 {\n            match smallest {\n                None\
    \ => smallest = Some(*item),\n                Some(x) => if *item < x { smallest\
    \ = Some(*item) }\n            }\n        } else if *item < 0 {\n            match\
    \ largest {\n                None => largest = Some(*item),\n                Some(x)\
    \ => if *item > x { largest = Some(*item) }\n            }\n        }\n    }\n\
    \    (largest, smallest)", "    let mut l_neg: Option<isize> = None;\n    let\
    \ mut s_pos: Option<isize> = None;\n    for i in lst {\n        if i < 0 {\n \
    \           match l_neg {\n                None => l_neg = Some(i),\n        \
    \        Some(x) => {\n                    if i > x {\n                      \
    \  l_neg = Some(i);\n                    }\n                }\n            }\n\
    \        } else if i > 0 {\n            match s_pos {\n                None =>\
    \ s_pos = Some(i),\n                Some(x) => {\n                    if i < x\
    \ {\n                        s_pos = Some(i);\n                    }\n       \
    \         }\n            }\n        }\n    }\n    (l_neg, s_pos)", "    let mut\
    \ p = None;\n    let mut n = None;\n    for i in lst {\n        if i >= 0 {\n\
    \            if p.is_none() || i < p.unwrap() {\n                p = Some(i);\n\
    \            }\n        } else {\n            if n.is_none() || i > n.unwrap()\
    \ {\n                n = Some(i);\n            }\n        }\n    }\n    (n, p)",
  "    match (lst.iter().filter(|&x| x < &0).max(), lst.iter().filter(|&x| x > &0).min())\
    \ {\n        (Some(x), Some(y)) => (Some(*x), Some(*y)),\n        (Some(x), None)\
    \ => (Some(*x), None),\n        (None, Some(y)) => (None, Some(*y)),\n       \
    \ (None, None) => (None, None),\n    }", "    let mut lrg = None;\n    let mut\
    \ sml = None;\n    for num in lst {\n        if num < 0 {\n            match lrg\
    \ {\n                None => lrg = Some(num),\n                Some(x) => {\n\
    \                    if num > x {\n                        lrg = Some(num);\n\
    \                    }\n                }\n            }\n        } else if num\
    \ > 0 {\n            match sml {\n                None => sml = Some(num),\n \
    \               Some(x) => {\n                    if num < x {\n             \
    \           sml = Some(num);\n                    }\n                }\n     \
    \       }\n        }\n    }\n    (lrg, sml)", '    unimplemented!()', '    (None,
    None)', "    let mut max_negative: Option<isize> = None;\n    let mut min_positive:\
    \ Option<isize> = None;\n    for i in lst {\n        if i < 0 {\n            if\
    \ max_negative.is_none() || i > max_negative.unwrap() {\n                max_negative\
    \ = Some(i);\n            }\n        } else if i > 0 {\n            if min_positive.is_none()\
    \ || i < min_positive.unwrap() {\n                min_positive = Some(i);\n  \
    \          }\n        }\n    }\n    (max_negative, min_positive)", '    (None,
    None)', "    let mut largest_neg = None;\n    let mut smallest_pos = None;\n \
    \   for v in lst {\n        if v >= 0 {\n            if smallest_pos.is_none()\
    \ || v < smallest_pos.unwrap() {\n                smallest_pos = Some(v);\n  \
    \          }\n        } else {\n            if largest_neg.is_none() || v > largest_neg.unwrap()\
    \ {\n                largest_neg = Some(v);\n            }\n        }\n    }\n\
    \    (largest_neg, smallest_pos)", '    unimplemented!();', '    unimplemented!();',
  "    let mut least_pos = None;\n    let mut largest_neg = None;\n    for num in\
    \ lst {\n        if num < 0 {\n            largest_neg = Some(if largest_neg.is_some()\
    \ {\n                if largest_neg.unwrap() < num {\n                    largest_neg.unwrap()\n\
    \                } else {\n                    num\n                }\n      \
    \      } else {\n                num\n            });\n        } else if num >\
    \ 0 {\n            least_pos = Some(if least_pos.is_some() {\n               \
    \ if least_pos.unwrap() > num {\n                    least_pos.unwrap()\n    \
    \            } else {\n                    num\n                }\n          \
    \  } else {\n                num\n            });\n        }\n    }\n    (largest_neg,\
    \ least_pos)", "    // TODO\n    unimplemented!()", '    unimplemented!();', " \
    \   let mut negative_largest = None;\n    let mut positive_smallest = None;\n\
    \    for num in lst {\n        if num > 0 {\n            if let Some(x) = positive_smallest\
    \ {\n                if num < x {\n                    positive_smallest = Some(num);\n\
    \                }\n            } else {\n                positive_smallest =\
    \ Some(num);\n            }\n        } else if num < 0 {\n            if let Some(x)\
    \ = negative_largest {\n                if num > x {\n                    negative_largest\
    \ = Some(num);\n                }\n            } else {\n                negative_largest\
    \ = Some(num);\n            }\n        }\n    }\n    (negative_largest, positive_smallest)",
  "    let mut max_neg = None;\n    let mut min_pos = None;\n    for x in lst {\n\
    \        if x > 0 {\n            if let Some(min_pos_value) = min_pos {\n    \
    \            if x < min_pos_value {\n                    min_pos = Some(x);\n\
    \                }\n            } else {\n                min_pos = Some(x);\n\
    \            }\n        } else if x < 0 {\n            if let Some(max_neg_value)\
    \ = max_neg {\n                if x > max_neg_value {\n                    max_neg\
    \ = Some(x);\n                }\n            } else {\n                max_neg\
    \ = Some(x);\n            }\n        }\n    }\n    (max_neg, min_pos)", '    unimplemented!();',
  "    let mut min = None;\n    let mut max = None;\n    for item in lst {\n     \
    \   if item > 0 {\n            if let Some(x) = min {\n                if item\
    \ < x {\n                    min = Some(item);\n                }\n          \
    \  } else {\n                min = Some(item);\n            }\n        } else\
    \ if item < 0 {\n            if let Some(x) = max {\n                if item >\
    \ x {\n                    max = Some(item);\n                }\n            }\
    \ else {\n                max = Some(item);\n            }\n        }\n    }\n\
    \    (max, min)", '    (None, None)', '    unimplemented!()', '    unimplemented!();',
  "    // TODO: Implement.\n    unimplemented!();", "    let mut largest_negative\
    \ = None;\n    let mut smallest_positive = None;\n    let mut largest_negative_found\
    \ = false;\n    let mut smallest_positive_found = false;\n    for i in lst {\n\
    \        if i < 0 {\n            if largest_negative_found {\n               \
    \ if i > largest_negative.unwrap() {\n                    largest_negative = Some(i);\n\
    \                }\n            } else {\n                largest_negative = Some(i);\n\
    \                largest_negative_found = true;\n            }\n        } else\
    \ if i > 0 {\n            if smallest_positive_found {\n                if i <\
    \ smallest_positive.unwrap() {\n                    smallest_positive = Some(i);\n\
    \                }\n            } else {\n                smallest_positive =\
    \ Some(i);\n                smallest_positive_found = true;\n            }\n \
    \       }\n    }\n    (largest_negative, smallest_positive)", '    unimplemented!()',
  '    unimplemented!()', "    let largest = lst.iter().filter(|x| x < &&0).max();\n\
    \    let smallest = lst.iter().filter(|x| x > &&0).min();\n    (largest.map(|x|\
    \ *x), smallest.map(|x| *x))", "    let mut neg: Option<isize> = None;\n    let\
    \ mut pos: Option<isize> = None;\n    for i in lst {\n        if i < 0 {\n   \
    \         if neg.is_none() || i > neg.unwrap() {\n                neg = Some(i);\n\
    \            }\n        } else if i > 0 {\n            if pos.is_none() || i <\
    \ pos.unwrap() {\n                pos = Some(i);\n            }\n        }\n \
    \   }\n    (neg, pos)", "    let mut smallest_positive = None;\n    let mut largest_negative\
    \ = None;\n    for i in lst {\n        if i < 0 {\n            if let Some(n)\
    \ = largest_negative {\n                if i > n {\n                    largest_negative\
    \ = Some(i);\n                }\n            } else {\n                largest_negative\
    \ = Some(i);\n            }\n        } else if i > 0 {\n            if let Some(n)\
    \ = smallest_positive {\n                if i < n {\n                    smallest_positive\
    \ = Some(i);\n                }\n            } else {\n                smallest_positive\
    \ = Some(i);\n            }\n        }\n    }\n    (largest_negative, smallest_positive)",
  "    let neg_max = lst.iter().filter(|&x| x < &0).max();\n    let pos_min = lst.iter().filter(|&x|\
    \ x > &0).min();\n    (neg_max.cloned(), pos_min.cloned())", "    lst.iter().fold((None,\
    \ None), |(smallest, largest), i| {\n        (\n            if smallest.is_none()\
    \ && *i < 0 {\n                Some(*i)\n            } else if *i < smallest.unwrap_or(std::isize::MAX)\
    \ && *i < 0 {\n                Some(*i)\n            } else {\n              \
    \  smallest\n            },\n            if largest.is_none() && *i > 0 {\n  \
    \              Some(*i)\n            } else if *i > largest.unwrap_or(std::isize::MIN)\
    \ && *i > 0 {\n                Some(*i)\n            } else {\n              \
    \  largest\n            },\n        )\n    })", '    unimplemented!()', "    let\
    \ mut neg: Option<isize> = None;\n    let mut pos: Option<isize> = None;\n   \
    \ for i in lst {\n        if i < 0 {\n            match neg {\n              \
    \  None => neg = Some(i),\n                Some(n) => if i > n { neg = Some(i)\
    \ },\n            }\n        } else if i > 0 {\n            match pos {\n    \
    \            None => pos = Some(i),\n                Some(p) => if i < p { pos\
    \ = Some(i) },\n            }\n        }\n    }\n    (neg, pos)", "    if lst.is_empty()\
    \ {\n        return (None, None);\n    }\n    (lst.iter().filter(|&x| x < &0).max(),\
    \ lst.iter().filter(|&x| x > &0).min())", '    unimplemented!()', '    unimplemented!()',
  "    let (mut largest, mut smallest) = (None, None);\n    for n in lst {\n     \
    \   if n < 0 {\n            largest = match largest {\n                None =>\
    \ Some(n),\n                Some(n2) => Some(if n > n2 { n } else { n2 }),\n \
    \           };\n        } else if n > 0 {\n            smallest = match smallest\
    \ {\n                None => Some(n),\n                Some(n2) => Some(if n <\
    \ n2 { n } else { n2 }),\n            };\n        }\n    }\n    (largest, smallest)",
  '    unimplemented!()', '    unimplemented!();', '    unimplemented!();', "    let\
    \ mut min_num = None;\n    let mut max_num = None;\n    for num in lst {\n   \
    \     if num > 0 {\n            if min_num == None || num < min_num.unwrap() {\n\
    \                min_num = Some(num);\n            }\n        } else if num <\
    \ 0 {\n            if max_num == None || num > max_num.unwrap() {\n          \
    \      max_num = Some(num);\n            }\n        }\n    }\n    (max_num, min_num)",
  "    let mut neg = None;\n    let mut pos = None;\n    for x in lst {\n        if\
    \ x < 0 {\n            if neg.is_none() || x > neg.unwrap() {\n              \
    \  neg = Some(x);\n            }\n        } else if x > 0 {\n            if pos.is_none()\
    \ || x < pos.unwrap() {\n                pos = Some(x);\n            }\n     \
    \   }\n    }\n    (neg, pos)", '    unimplemented!()', "    // TODO:\n    // Write\
    \ code here to accomplish the above task.\n    // When you are done, run \"cargo\
    \ test\" in the terminal to check your work.\n    // Feel free to add extra tests\
    \ in the \"tests\" folder.\n    unimplemented!();", '    unimplemented!()', " \
    \   //TODO\n    let mut max = None;\n    let mut min = None;\n    for i in lst\
    \ {\n        if i > 0 {\n            if let Some(j) = min {\n                if\
    \ i < j {\n                    min = Some(i);\n                }\n           \
    \ } else {\n                min = Some(i);\n            }\n        } else if i\
    \ < 0 {\n            if let Some(j) = max {\n                if i > j {\n    \
    \                max = Some(i);\n                }\n            } else {\n   \
    \             max = Some(i);\n            }\n        }\n    }\n    (max, min)",
  "    // TODO\n    (None, None)", "    let mut max = None;\n    let mut min = None;\n\
    \    for i in lst {\n        if i < 0 {\n            if max.is_none() || i > max.unwrap()\
    \ {\n                max = Some(i);\n            }\n        } else if i > 0 {\n\
    \            if min.is_none() || i < min.unwrap() {\n                min = Some(i);\n\
    \            }\n        }\n    }\n    (max, min)", "    let min = lst.iter().filter(|&x|\
    \ x > &0).min();\n    let max = lst.iter().filter(|&x| x < &0).max();\n    (max,\
    \ min)", '    (None, None)', '    unimplemented!()', '    unimplemented!()', '    unimplemented!()',
  '    unimplemented!();', '    unimplemented!();', '    unimplemented!();', "   \
    \ // TODO: implement this function\n    unimplemented!()", '    unimplemented!()',
  "    let mut n: Option<isize> = None;\n    let mut p: Option<isize> = None;\n  \
    \  let mut mi: isize = 0;\n    let mut ma: isize = 0;\n    for i in lst {\n  \
    \      if i < 0 {\n            if n == None {\n                n = Some(i);\n\
    \                mi = i;\n            } else if i > mi {\n                n =\
    \ Some(i);\n                mi = i;\n            }\n        } else if i > 0 {\n\
    \            if p == None {\n                p = Some(i);\n                ma\
    \ = i;\n            } else if i < ma {\n                p = Some(i);\n       \
    \         ma = i;\n            }\n        }\n    }\n    (n, p)", "    let mut\
    \ smallest = None;\n    let mut largest = None;\n    for x in lst {\n        match\
    \ x {\n            _ if x < 0 => {\n                match largest {\n        \
    \            None => largest = Some(x),\n                    Some(y) => {\n  \
    \                      if x > y {\n                            largest = Some(x);\n\
    \                        }\n                    }\n                }\n       \
    \     }\n            _ if x > 0 => {\n                match smallest {\n     \
    \               None => smallest = Some(x),\n                    Some(y) => {\n\
    \                        if x < y {\n                            smallest = Some(x);\n\
    \                        }\n                    }\n                }\n       \
    \     }\n            _ => {}\n        }\n    }\n    (largest, smallest)", '    unimplemented!();',
  "    let mut smallest = None;\n    let mut largest = None;\n    for i in lst {\n\
    \        if i > 0 {\n            smallest = match smallest {\n               \
    \ None => Some(i),\n                Some(v) => Some(std::cmp::min(v, i)),\n  \
    \          };\n        } else if i < 0 {\n            largest = match largest\
    \ {\n                None => Some(i),\n                Some(v) => Some(std::cmp::max(v,\
    \ i)),\n            };\n        }\n    }\n    (largest, smallest)", '    unimplemented!()',
  '    (lst.iter().filter(|&x| x < &0).max().cloned(), lst.iter().filter(|&x| x >
    &0).min().cloned())', "    // TODO\n    unimplemented!()", '    unimplemented!()',
  "    if lst.len() == 0 {\n        return (None, None);\n    }\n    let mut largest_neg\
    \ = None;\n    let mut smallest_pos = None;\n    for elem in lst {\n        if\
    \ elem > 0 {\n            if smallest_pos == None || elem < smallest_pos.unwrap()\
    \ {\n                smallest_pos = Some(elem);\n            }\n        } else\
    \ if elem < 0 {\n            if largest_neg == None || elem > largest_neg.unwrap()\
    \ {\n                largest_neg = Some(elem);\n            }\n        }\n   \
    \ }\n    (largest_neg, smallest_pos)", '    unimplemented!()', '    unimplemented!();',
  '    unimplemented!()', '    unimplemented!()', "    if lst.len() == 0 {\n     \
    \   return (None, None);\n    }\n    let mut neg: Option<isize> = None;\n    let\
    \ mut pos: Option<isize> = None;\n    for el in lst {\n        if el < 0 {\n \
    \           if neg.is_none() || el > neg.unwrap() {\n                neg = Some(el);\n\
    \            }\n        } else if el > 0 {\n            if pos.is_none() || el\
    \ < pos.unwrap() {\n                pos = Some(el);\n            }\n        }\n\
    \    }\n    (neg, pos)", '    unimplemented!();', "    let mut negs = vec![];\n\
    \    let mut poss = vec![];\n    for el in lst {\n        if el < 0 {\n      \
    \      negs.push(el);\n        } else if el > 0 {\n            poss.push(el);\n\
    \        }\n    }\n    let mut neg_max = None;\n    let mut pos_min = None;\n\
    \    if !negs.is_empty() {\n        neg_max = Some(negs.iter().cloned().max().unwrap());\n\
    \    }\n    if !poss.is_empty() {\n        pos_min = Some(poss.iter().cloned().min().unwrap());\n\
    \    }\n    (neg_max, pos_min)", '    unimplemented!()', '    unimplemented!()',
  "    let mut largest_neg = None;\n    let mut smallest_pos = None;\n    for n in\
    \ lst {\n        if n < 0 {\n            largest_neg = if let Some(m) = largest_neg\
    \ {\n                if n > m {\n                    Some(n)\n               \
    \ } else {\n                    Some(m)\n                }\n            } else\
    \ {\n                Some(n)\n            };\n        } else if n > 0 {\n    \
    \        smallest_pos = if let Some(m) = smallest_pos {\n                if n\
    \ < m {\n                    Some(n)\n                } else {\n             \
    \       Some(m)\n                }\n            } else {\n                Some(n)\n\
    \            };\n        }\n    }\n    (largest_neg, smallest_pos)", "    let\
    \ mut largest = None;\n    let mut smallest = None;\n    for x in lst {\n    \
    \    if x < 0 {\n            largest = match largest {\n                None =>\
    \ Some(x),\n                Some(l) => Some(cmp::max(l, x)),\n            };\n\
    \        } else if x > 0 {\n            smallest = match smallest {\n        \
    \        None => Some(x),\n                Some(s) => Some(cmp::min(s, x)),\n\
    \            };\n        }\n    }\n    (largest, smallest)", '    (None, None)',
  '  unimplemented!();', '    unimplemented!();', "    if lst.len() == 0 {\n     \
    \   return (None, None);\n    }\n    let mut lmax = None;\n    let mut smin =\
    \ None;\n    for i in lst {\n        if i < 0 {\n            if lmax == None {\n\
    \                lmax = Some(i);\n            } else if lmax.unwrap() < i {\n\
    \                lmax = Some(i);\n            }\n        } else if i > 0 {\n \
    \           if smin == None {\n                smin = Some(i);\n            }\
    \ else if smin.unwrap() > i {\n                smin = Some(i);\n            }\n\
    \        }\n    }\n    (lmax, smin)", "    let mut max = None;\n    let mut min\
    \ = None;\n    for x in lst {\n        if max.is_none() && x < 0 {\n         \
    \   max = Some(x);\n        } else if max.is_some() && x < 0 && x > max.unwrap()\
    \ {\n            max = Some(x);\n        }\n        if min.is_none() && x > 0\
    \ {\n            min = Some(x);\n        } else if min.is_some() && x > 0 && x\
    \ < min.unwrap() {\n            min = Some(x);\n        }\n    }\n    (max, min)",
  '    unimplemented!();', '    unimplemented!()', "    // Insert code here\n    let\
    \ mut largest = None;\n    let mut smallest = None;\n    for i in lst {\n    \
    \    if i > 0 {\n            match smallest {\n                None => smallest\
    \ = Some(i),\n                Some(small) => if i < small { smallest = Some(i)\
    \ }\n            }\n        } else if i < 0 {\n            match largest {\n \
    \               None => largest = Some(i),\n                Some(large) => if\
    \ i > large { largest = Some(i) }\n            }\n        }\n    }\n    (largest,\
    \ smallest)", '    unimplemented!()', '    unimplemented!();', '    (None, None)',
  '    unimplemented!()', '    unimplemented!()', '    unimplemented!()', '    (None,
    None)', "    let mut positive_min = None;\n    let mut negative_max = None;\n\
    \    for v in lst {\n        if v > 0 {\n            positive_min = match positive_min\
    \ {\n                None => Some(v),\n                Some(v_min) => Some(std::cmp::min(v,\
    \ v_min)),\n            };\n        } else if v < 0 {\n            negative_max\
    \ = match negative_max {\n                None => Some(v),\n                Some(v_max)\
    \ => Some(std::cmp::max(v, v_max)),\n            };\n        }\n    }\n    (negative_max,\
    \ positive_min)", "    let mut largest = None;\n    let mut smallest = None;\n\
    \    for i in lst {\n        if i < 0 {\n            if largest.is_none() || i\
    \ > largest.unwrap() {\n                largest = Some(i);\n            }\n  \
    \      } else if i > 0 {\n            if smallest.is_none() || i < smallest.unwrap()\
    \ {\n                smallest = Some(i);\n            }\n        }\n    }\n  \
    \  (largest, smallest)", '    unimplemented!()', "    let mut largest = None;\n\
    \    let mut smallest = None;\n    for i in lst {\n        if i < 0 {\n      \
    \      if let Some(res) = largest {\n                if i > res {\n          \
    \          largest = Some(i);\n                }\n            } else {\n     \
    \           largest = Some(i);\n            }\n        } else if i > 0 {\n   \
    \         if let Some(res) = smallest {\n                if i < res {\n      \
    \              smallest = Some(i);\n                }\n            } else {\n\
    \                smallest = Some(i);\n            }\n        }\n    }\n    (largest,\
    \ smallest)", '  unimplemented!();', '    unimplemented!()', '    unimplemented!()',
  '    unimplemented!();', "    let mut smallest_positive: Option<isize> = None;\n\
    \    let mut largest_negative: Option<isize> = None;\n    for i in lst {\n   \
    \     if i > 0 {\n            match smallest_positive {\n                None\
    \ => smallest_positive = Some(i),\n                Some(j) => if i < j {\n   \
    \                 smallest_positive = Some(i);\n                }\n          \
    \  }\n        } else if i < 0 {\n            match largest_negative {\n      \
    \          None => largest_negative = Some(i),\n                Some(j) => if\
    \ i > j {\n                    largest_negative = Some(i);\n                }\n\
    \            }\n        }\n    }\n    (largest_negative, smallest_positive)",
  "    let mut largest = None;\n    let mut smallest = None;\n    for item in lst\
    \ {\n        if item > 0 {\n            match smallest {\n                None\
    \ => smallest = Some(item),\n                Some(n) => if item < n {\n      \
    \              smallest = Some(item);\n                }\n            }\n    \
    \    } else if item < 0 {\n            match largest {\n                None =>\
    \ largest = Some(item),\n                Some(n) => if item > n {\n          \
    \          largest = Some(item);\n                }\n            }\n        }\n\
    \    }\n    (largest, smallest)", "    let mut max = None;\n    let mut min =\
    \ None;\n    for num in lst {\n        if num < 0 {\n            max = match max\
    \ {\n                None => Some(num),\n                Some(s) => Some(std::cmp::max(s,\
    \ num)),\n            };\n        } else if num > 0 {\n            min = match\
    \ min {\n                None => Some(num),\n                Some(s) => Some(std::cmp::min(s,\
    \ num)),\n            };\n        }\n    }\n    (max, min)", "    let mut largest\
    \ = None;\n    let mut smallest = None;\n    for i in lst {\n        if i > 0\
    \ {\n            if smallest == None || i < smallest.unwrap() {\n            \
    \    smallest = Some(i);\n            }\n        } else if i < 0 {\n         \
    \   if largest == None || i > largest.unwrap() {\n                largest = Some(i);\n\
    \            }\n        }\n    }\n    (largest, smallest)", '    unimplemented!()',
  "    let mut min_pos = None;\n    let mut max_neg = None;\n    for x in lst {\n\
    \        if x < 0 {\n            max_neg = match max_neg {\n                None\
    \ => Some(x),\n                Some(y) => Some(if x > y { x } else { y }),\n \
    \           };\n        } else if x > 0 {\n            min_pos = match min_pos\
    \ {\n                None => Some(x),\n                Some(y) => Some(if x <\
    \ y { x } else { y }),\n            };\n        }\n    }\n    (max_neg, min_pos)",
  "    if lst.is_empty() {\n        return (None, None);\n    }\n    let mut smallest_positive:\
    \ Option<isize> = None;\n    let mut largest_negative: Option<isize> = None;\n\
    \    for number in lst {\n        if number > 0 {\n            if let Some(x)\
    \ = smallest_positive {\n                if number < x {\n                   \
    \ smallest_positive = Some(number);\n                }\n            } else {\n\
    \                smallest_positive = Some(number);\n            }\n        } else\
    \ if number < 0 {\n            if let Some(x) = largest_negative {\n         \
    \       if number > x {\n                    largest_negative = Some(number);\n\
    \                }\n            } else {\n                largest_negative = Some(number);\n\
    \            }\n        }\n    }\n    (largest_negative, smallest_positive)",
  '    unimplemented!();', "    let mut a = None;\n    let mut b = None;\n    for\
    \ v in lst {\n        if v < 0 {\n            if a.is_none() || v > a.unwrap()\
    \ {\n                a = Some(v);\n            }\n        } else if v > 0 {\n\
    \            if b.is_none() || v < b.unwrap() {\n                b = Some(v);\n\
    \            }\n        }\n    }\n    (a, b)", '    unimplemented!()', '    unimplemented!()',
  "    let max_negative = lst.iter().filter(|&i| *i < 0).max();\n    let min_positive\
    \ = lst.iter().filter(|&i| *i > 0).min();\n    (max_negative.map(|x| *x), min_positive.map(|x|\
    \ *x))", '    unimplemented!()', "    let (mut max, mut min) = (None, None);\n\
    \    for i in lst {\n        if i < 0 {\n            if max.is_none() || i > max.unwrap()\
    \ {\n                max = Some(i);\n            }\n        } else if i > 0 {\n\
    \            if min.is_none() || i < min.unwrap() {\n                min = Some(i);\n\
    \            }\n        }\n    }\n    (max, min)", "    let mut smallest_pos:\
    \ Option<isize> = None;\n    let mut largest_neg: Option<isize> = None;\n    for\
    \ i in lst {\n        if i > 0 {\n            match smallest_pos {\n         \
    \       Some(x) => {\n                    if i < x {\n                       \
    \ smallest_pos = Some(i);\n                    }\n                }\n        \
    \        None => smallest_pos = Some(i),\n            }\n        } else if i <\
    \ 0 {\n            match largest_neg {\n                Some(x) => {\n       \
    \             if i > x {\n                        largest_neg = Some(i);\n   \
    \                 }\n                }\n                None => largest_neg =\
    \ Some(i),\n            }\n        }\n    }\n    (largest_neg, smallest_pos)",
  "    let min = lst.iter().filter(|&x| x > &0).min();\n    let max = lst.iter().filter(|&x|\
    \ x < &0).max();\n    (max, min)", '    unimplemented!();', '    unimplemented!()',
  "    let mut largest_neg: Option<isize> = None;\n    let mut smallest_pos: Option<isize>\
    \ = None;\n    for i in lst {\n        if i < 0 {\n            if largest_neg.is_none()\
    \ || i > largest_neg.unwrap() {\n                largest_neg = Some(i);\n    \
    \        }\n        } else if i > 0 {\n            if smallest_pos.is_none() ||\
    \ i < smallest_pos.unwrap() {\n                smallest_pos = Some(i);\n     \
    \       }\n        }\n    }\n    (largest_neg, smallest_pos)", "    let mut largest_neg\
    \ = None;\n    let mut smallest_pos = None;\n    for i in lst {\n        if i\
    \ > 0 {\n            if smallest_pos.is_none() || i < smallest_pos.unwrap() {\n\
    \                smallest_pos = Some(i);\n            }\n        } else if i <\
    \ 0 {\n            if largest_neg.is_none() || i > largest_neg.unwrap() {\n  \
    \              largest_neg = Some(i);\n            }\n        }\n    }\n    (largest_neg,\
    \ smallest_pos)", "    let mut smallest = None;\n    let mut largest = None;\n\
    \    for i in lst {\n        if i < 0 {\n            if let Some(x) = largest\
    \ {\n                if i > x {\n                    largest = Some(i);\n    \
    \            }\n            } else {\n                largest = Some(i);\n   \
    \         }\n        } else if i > 0 {\n            if let Some(x) = smallest\
    \ {\n                if i < x {\n                    smallest = Some(i);\n   \
    \             }\n            } else {\n                smallest = Some(i);\n \
    \           }\n        }\n    }\n    (largest, smallest)", "    let mut smallest\
    \ = None;\n    let mut largest = None;\n    for i in lst {\n        if i < 0 {\n\
    \            largest = Some(match largest {\n                Some(x) => std::cmp::max(x,\
    \ i),\n                None => i,\n            });\n        } else if i > 0 {\n\
    \            smallest = Some(match smallest {\n                Some(x) => std::cmp::min(x,\
    \ i),\n                None => i,\n            });\n        }\n    }\n    (largest,\
    \ smallest)", "    if lst.len() == 0 {\n        return (None, None);\n    }\n\
    \    let mut max_neg = None;\n    let mut min_pos = None;\n    for el in lst {\n\
    \        if el > 0 {\n            if min_pos.is_none() || el < min_pos.unwrap()\
    \ {\n                min_pos = Some(el);\n            }\n        } else if el\
    \ < 0 {\n            if max_neg.is_none() || el > max_neg.unwrap() {\n       \
    \         max_neg = Some(el);\n            }\n        }\n    }\n    (max_neg,\
    \ min_pos)", "    let mut largest_negative: Option<isize> = None;\n    let mut\
    \ smallest_positive: Option<isize> = None;\n    for n in lst {\n        if n <\
    \ 0 {\n            if let Some(v) = largest_negative {\n                if n >\
    \ v {\n                    largest_negative = Some(n);\n                }\n  \
    \          } else {\n                largest_negative = Some(n);\n           \
    \ }\n        }\n        if n > 0 {\n            if let Some(v) = smallest_positive\
    \ {\n                if n < v {\n                    smallest_positive = Some(n);\n\
    \                }\n            } else {\n                smallest_positive =\
    \ Some(n);\n            }\n        }\n    }\n    (largest_negative, smallest_positive)",
  "    let mut min: Option<isize> = None;\n    let mut max: Option<isize> = None;\n\
    \    for num in lst {\n        if num < 0 {\n            match max {\n       \
    \         Some(n) => {\n                    if num > n {\n                   \
    \     max = Some(num);\n                    }\n                }\n           \
    \     None => max = Some(num),\n            }\n        } else if num > 0 {\n \
    \           match min {\n                Some(n) => {\n                    if\
    \ num < n {\n                        min = Some(num);\n                    }\n\
    \                }\n                None => min = Some(num),\n            }\n\
    \        }\n    }\n    (max, min)", '    unimplemented!()', "    let mut smallest_pos:\
    \ Option<isize> = None;\n    let mut largest_neg: Option<isize> = None;\n    for\
    \ n in lst {\n        if n > 0 {\n            if let Some(smallest) = smallest_pos\
    \ {\n                if n < smallest {\n                    smallest_pos = Some(n);\n\
    \                }\n            } else {\n                smallest_pos = Some(n);\n\
    \            }\n        } else if n < 0 {\n            if let Some(largest) =\
    \ largest_neg {\n                if n > largest {\n                    largest_neg\
    \ = Some(n);\n                }\n            } else {\n                largest_neg\
    \ = Some(n);\n            }\n        }\n    }\n    (largest_neg, smallest_pos)",
  "    let mut largest_neg = None;\n    let mut smallest_pos = None;\n    for &i in\
    \ &lst {\n        if i < 0 {\n            if largest_neg.is_none() || i > largest_neg.unwrap()\
    \ {\n                largest_neg = Some(i);\n            }\n        } else if\
    \ i > 0 {\n            if smallest_pos.is_none() || i < smallest_pos.unwrap()\
    \ {\n                smallest_pos = Some(i);\n            }\n        }\n    }\n\
    \    (largest_neg, smallest_pos)", "    let mut max_neg: Option<isize> = None;\n\
    \    let mut min_pos: Option<isize> = None;\n    for n in lst {\n        if n\
    \ > 0 {\n            if min_pos.is_none() || n < min_pos.unwrap() {\n        \
    \        min_pos = Some(n);\n            }\n        } else if n < 0 {\n      \
    \      if max_neg.is_none() || n > max_neg.unwrap() {\n                max_neg\
    \ = Some(n);\n            }\n        }\n    }\n    (max_neg, min_pos)", '    unimplemented!()',
  "    let mut min = None;\n    let mut max = None;\n    for i in lst {\n        if\
    \ i > 0 {\n            min = Some(match min {\n                Some(m) => std::cmp::min(m,\
    \ i),\n                None => i,\n            });\n        } else if i < 0 {\n\
    \            max = Some(match max {\n                Some(m) => std::cmp::max(m,\
    \ i),\n                None => i,\n            });\n        }\n    }\n    (max,\
    \ min)", '    unimplemented!();', "    let mut max_neg = None;\n    let mut min_pos\
    \ = None;\n    for i in lst {\n        if i > 0 {\n            if let Some(min)\
    \ = min_pos {\n                if i < min {\n                    min_pos = Some(i);\n\
    \                }\n            } else {\n                min_pos = Some(i);\n\
    \            }\n        } else if i < 0 {\n            if let Some(max) = max_neg\
    \ {\n                if i > max {\n                    max_neg = Some(i);\n  \
    \              }\n            } else {\n                max_neg = Some(i);\n \
    \           }\n        }\n    }\n    (max_neg, min_pos)", "    let mut a = None;\n\
    \    let mut b = None;\n    for x in lst {\n        if x < 0 {\n            if\
    \ a.is_none() || x > a.unwrap() {\n                a = Some(x);\n            }\n\
    \        } else if x > 0 {\n            if b.is_none() || x < b.unwrap() {\n \
    \               b = Some(x);\n            }\n        }\n    }\n    (a, b)", " \
    \   let mut negatives = lst.iter().filter(|i| **i < 0).collect::<Vec<&isize>>();\n\
    \    let mut positives = lst.iter().filter(|i| **i > 0).collect::<Vec<&isize>>();\n\
    \    let largest_negative = negatives.pop().map(|i| **i);\n    let smallest_positive\
    \ = positives.pop().map(|i| **i);\n    (largest_negative, smallest_positive)",
  "    let mut smallest = None;\n    let mut largest = None;\n    for number in lst\
    \ {\n        if number > 0 {\n            smallest = Some(match smallest {\n \
    \               Some(s) => if s < number { s } else { number },\n            \
    \    None => number,\n            });\n        } else if number < 0 {\n      \
    \      largest = Some(match largest {\n                Some(l) => if l > number\
    \ { l } else { number },\n                None => number,\n            });\n \
    \       }\n    }\n    (largest, smallest)", "    let mut max_neg = None;\n   \
    \ let mut min_pos = None;\n    for n in lst {\n        if n < 0 {\n          \
    \  if max_neg.is_none() || n > max_neg.unwrap() {\n                max_neg = Some(n);\n\
    \            }\n        } else if n > 0 {\n            if min_pos.is_none() ||\
    \ n < min_pos.unwrap() {\n                min_pos = Some(n);\n            }\n\
    \        }\n    }\n    (max_neg, min_pos)", '    unimplemented!();', '    unimplemented!();',
  '    unimplemented!()', "    let res: (Option<isize>, Option<isize>) = (None, None);\n\
    \    let mut lst = lst;\n    lst.sort();\n    for i in 0..lst.len() {\n      \
    \  if lst[i] < 0 {\n            res.0 = Some(lst[i]);\n        }\n        if lst[i]\
    \ > 0 {\n            res.1 = Some(lst[i]);\n            break;\n        }\n  \
    \  }\n    res", '    unimplemented!();', "    let mut largest = None;\n    let\
    \ mut smallest = None;\n    for i in lst {\n        if i > 0 {\n            if\
    \ let Some(val) = smallest {\n                if i < val {\n                 \
    \   smallest = Some(i);\n                }\n            } else {\n           \
    \     smallest = Some(i);\n            }\n        } else if i < 0 {\n        \
    \    if let Some(val) = largest {\n                if i > val {\n            \
    \        largest = Some(i);\n                }\n            } else {\n       \
    \         largest = Some(i);\n            }\n        }\n    }\n    (largest, smallest)",
  "    lst.iter().fold((None, None), |(large, small), num| {\n        (\n        \
    \    if num < &0 {\n                if large.is_none() || num > large.unwrap()\
    \ {\n                    Some(*num)\n                } else {\n              \
    \      large\n                }\n            } else {\n                large\n\
    \            },\n            if num > &0 {\n                if small.is_none()\
    \ || num < small.unwrap() {\n                    Some(*num)\n                }\
    \ else {\n                    small\n                }\n            } else {\n\
    \                small\n            },\n        )\n    })", '    unimplemented!()',
  "    let mut lg = None;\n    let mut sm = None;\n    for i in lst {\n        if\
    \ i > 0 {\n            sm = sm.map_or(Some(i), |x| Some(std::cmp::min(x, i)));\n\
    \        } else if i < 0 {\n            lg = lg.map_or(Some(i), |x| Some(std::cmp::max(x,\
    \ i)));\n        }\n    }\n    (lg, sm)", "    let mut smallest = None;\n    let\
    \ mut largest = None;\n    for i in lst {\n        if i > 0 {\n            smallest\
    \ = match smallest {\n                None => Some(i),\n                Some(x)\
    \ => if i < x { Some(i) } else { Some(x) },\n            };\n        } else if\
    \ i < 0 {\n            largest = match largest {\n                None => Some(i),\n\
    \                Some(x) => if i > x { Some(i) } else { Some(x) },\n         \
    \   };\n        }\n    }\n    (largest, smallest)", "    let mut largest_negative:\
    \ Option<isize> = None;\n    let mut smallest_positive: Option<isize> = None;\n\
    \    for i in lst {\n        if i > 0 {\n            if smallest_positive.is_none()\
    \ || i < smallest_positive.unwrap() {\n                smallest_positive = Some(i);\n\
    \            }\n        } else if i < 0 {\n            if largest_negative.is_none()\
    \ || i > largest_negative.unwrap() {\n                largest_negative = Some(i);\n\
    \            }\n        }\n    }\n    (largest_negative, smallest_positive)",
  '    unimplemented!()', "    // your code here\n    (None, None)", "    let mut\
    \ max_negative: Option<isize> = None;\n    let mut min_positive: Option<isize>\
    \ = None;\n    for elem in lst {\n        if elem < 0 {\n            if max_negative.is_none()\
    \ || elem > max_negative.unwrap() {\n                max_negative = Some(elem);\n\
    \            }\n        } else if elem > 0 {\n            if min_positive.is_none()\
    \ || elem < min_positive.unwrap() {\n                min_positive = Some(elem);\n\
    \            }\n        }\n    }\n    (max_negative, min_positive)", '    unimplemented!()',
  '    unimplemented!()', '    unimplemented!()', '    unimplemented!()', "    let\
    \ mut neg = None;\n    let mut pos = None;\n    for item in lst {\n        if\
    \ item < 0 {\n            neg = if let Some(curr) = neg {\n                Some(cmp::max(curr,\
    \ item))\n            } else {\n                Some(item)\n            }\n  \
    \      } else if item > 0 {\n            pos = if let Some(curr) = pos {\n   \
    \             Some(cmp::min(curr, item))\n            } else {\n             \
    \   Some(item)\n            }\n        }\n    }\n    (neg, pos)"]
stop_tokens:
- "\n}"
