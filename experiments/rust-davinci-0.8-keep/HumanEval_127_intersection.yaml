name: HumanEval_127_intersection
language: rust
prompt: "/// You are given two intervals,\n/// where each interval is a pair of integers.\
  \ For example, interval = (start, end) = (1, 2).\n/// The given intervals are closed\
  \ which means that the interval (start, end)\n/// includes both start and end.\n\
  /// For each given interval, it is assumed that its start is less or equal its end.\n\
  /// Your task is to determine whether the length of intersection of these two \n\
  /// intervals is a prime number.\n/// Example, the intersection of the intervals\
  \ (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which not a prime number.\n\
  /// If the length of the intersection is a prime number, return \"YES\",\n/// otherwise,\
  \ return \"NO\".\n/// If the two intervals don't intersect, return \"NO\".\n///\
  \ [input/output] samples:\n/// intersection((1, 2), (2, 3)) ==> \"NO\"\n/// intersection((-1,\
  \ 1), (0, 4)) ==> \"NO\"\n/// intersection((-3, -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1:\
  \ (isize, isize), interval2: (isize, isize)) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
  \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
  \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
  YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
  \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
  \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
  \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
  NO\"));\n}\n"
completions: ["    let s = interval1.0.max(interval2.0);\n    let e = interval1.1.min(interval2.1);\n\
    \    if s > e {\n        return \"NO\".to_string();\n    }\n    if (e - s) < 2\
    \ {\n        return \"YES\".to_string();\n    }\n    let mut is_prime = false;\n\
    \    for i in 2..e {\n        if (e - s) % i == 0 {\n            is_prime = true;\n\
    \            break;\n        }\n    }\n    if is_prime {\n        \"YES\".to_string()\n\
    \    } else {\n        \"NO\".to_string()\n    }", "    let x_min = interval1.0.max(interval2.0);\n\
    \    let x_max = interval1.1.min(interval2.1);\n    if x_min > x_max { return\
    \ \"NO\".to_string(); }\n    (x_max - x_min + 1).is_prime().to_string()", "  \
    \  let (i1_start, i1_end) = interval1;\n    let (i2_start, i2_end) = interval2;\n\
    \    if (i1_start <= i2_start && i2_start <= i1_end) ||\n       (i2_start <= i1_start\
    \ && i1_start <= i2_end) {\n        let start = i1_start.max(i2_start);\n    \
    \    let end = i1_end.min(i2_end);\n        if end - start < 2 {\n           \
    \ return \"NO\".to_string();\n        }\n        if is_prime(end - start) {\n\
    \            return \"YES\".to_string();\n        }\n    }\n    \"NO\".to_string()",
  "    if interval1.0 > interval2.1 || interval2.0 > interval1.1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = interval1.0.max(interval2.0);\n\
    \    let end = interval1.1.min(interval2.1);\n    let size = (end - start) + 1;\n\
    \    match size {\n        0 | 1 => \"NO\".to_string(),\n        2 | 3 | 5 | 7\
    \ => \"YES\".to_string(),\n        4 | 6 | 8 | 9 => \"NO\".to_string(),\n    \
    \    _ => if is_prime(size) { \"YES\".to_string() } else { \"NO\".to_string()\
    \ }\n    }", "    // We need to check if the intervals' length is a prime.\n \
    \   // If we intersect the two intervals, we know the length of the\n    // intersection\
    \ (if the intersection exists) will be a number\n    // between 0 and min(end1\
    \ - start1, end2 - start2).\n    // Instead of iterating through all possible\
    \ values in this range,\n    // we can simply check if the length is divisible\
    \ by any number\n    // between 2 and sqrt(length)\n    let start1 = cmp::max(interval1.0,\
    \ interval2.0);\n    let end1 = cmp::min(interval1.1, interval2.1);\n    let start2\
    \ = cmp::min(interval1.0, interval2.0);\n    let end2 = cmp::max(interval1.1,\
    \ interval2.1);\n    if start1 <= end1 {\n        let length = (end1 - start1\
    \ + 1) as f64;\n        let max_divisor = (length.sqrt() as isize) + 1;\n    \
    \    if (2..max_divisor).any(|i| length as isize % i == 0) {\n            return\
    \ \"NO\".to_string();\n        }\n        return \"YES\".to_string();\n    }\n\
    \    \"NO\".to_string()", "    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let mut ans = String::from(\"NO\");\n    if start1 >\
    \ end2 || start2 > end1 {\n        return ans;\n    }\n    let mut len = 0;\n\
    \    if start1 <= start2 && end1 >= start2 {\n        if end1 < end2 {\n     \
    \       len = end1 - start2 + 1;\n        } else {\n            len = end2 - start2\
    \ + 1;\n        }\n    } else if start2 <= start1 && end2 >= start1 {\n      \
    \  if end2 < end1 {\n            len = end2 - start1 + 1;\n        } else {\n\
    \            len = end1 - start1 + 1;\n        }\n    }\n    if is_prime(len)\
    \ {\n        ans = String::from(\"YES\");\n    }\n    ans", "    let intersection\
    \ = vec![interval1.0, interval1.1, interval2.0, interval2.1];\n    let mut a =\
    \ intersection[0];\n    let mut b = intersection[0];\n    for i in &intersection\
    \ {\n        if *i < a {\n            a = *i;\n        }\n        if *i > b {\n\
    \            b = *i;\n        }\n    }\n    let length = (b - a) + 1;\n    if\
    \ length == 0 {\n        return \"NO\".to_string();\n    }\n    if length % 2\
    \ == 0 {\n        return \"NO\".to_string();\n    }\n    if length <= 2 {\n  \
    \      return \"YES\".to_string();\n    }\n    let mut d = 3;\n    while d < length\
    \ {\n        if length % d == 0 {\n            return \"NO\".to_string();\n  \
    \      }\n        d += 2;\n    }\n    \"YES\".to_string()", "    if interval1.0\
    \ >= interval2.1 || interval2.0 >= interval1.1 {\n        return \"NO\".to_string();\n\
    \    }\n    let mut limit = interval1.1;\n    if interval2.1 < limit {\n     \
    \   limit = interval2.1;\n    }\n    let mut begin = interval1.0;\n    if interval2.0\
    \ > begin {\n        begin = interval2.0;\n    }\n    let length = limit - begin;\n\
    \    if is_prime(length) {\n        return \"YES\".to_string();\n    }\n    \"\
    NO\".to_string()", "    let min1 = interval1.0.min(interval1.1);\n    let max1\
    \ = interval1.0.max(interval1.1);\n    let min2 = interval2.0.min(interval2.1);\n\
    \    let max2 = interval2.0.max(interval2.1);\n    if min1 <= min2 && min2 <=\
    \ max1 && max1 <= max2 {\n        let interval3 = (min2, max1);\n        check_interval(interval3)\n\
    \    } else if min2 <= min1 && min1 <= max2 && max2 <= max1 {\n        let interval3\
    \ = (min1, max2);\n        check_interval(interval3)\n    } else {\n        String::from(\"\
    NO\")\n    }", "    let (i1_start, i1_end) = interval1;\n    let (i2_start, i2_end)\
    \ = interval2;\n    if i1_end < i2_start || i2_end < i1_start {\n        return\
    \ \"NO\".to_string();\n    }\n    let (a, b) = (\n        if i1_start > i2_start\
    \ { i1_start } else { i2_start },\n        if i1_end < i2_end { i1_end } else\
    \ { i2_end },\n    );\n    let result = if a >= b { 0 } else { b - a };\n    if\
    \ result.is_prime() {\n        \"YES\".to_string()\n    } else {\n        \"NO\"\
    .to_string()\n    }", "    let (i1_s, i1_e) = interval1;\n    let (i2_s, i2_e)\
    \ = interval2;\n    let (mut s, mut e) = (0, 0);\n    if i1_s >= i2_s && i1_s\
    \ <= i2_e {\n        s = i1_s;\n    } else if i2_s >= i1_s && i2_s <= i1_e {\n\
    \        s = i2_s;\n    }\n    if i1_e >= i2_s && i1_e <= i2_e {\n        e =\
    \ i1_e;\n    } else if i2_e >= i1_s && i2_e <= i1_e {\n        e = i2_e;\n   \
    \ }\n    if s > e {\n        return \"NO\".to_string();\n    }\n    let len =\
    \ (e - s + 1) as usize;\n    if len <= 1 {\n        return \"NO\".to_string();\n\
    \    }\n    for i in 2..len {\n        if len % i == 0 {\n            return \"\
    NO\".to_string();\n        }\n    }\n    \"YES\".to_string()", "    let (start1,\
    \ end1) = interval1;\n    let (start2, end2) = interval2;\n    let start = isize::max(start1,\
    \ start2);\n    let end = isize::min(end1, end2);\n    if start > end {\n    \
    \    return \"NO\".to_string();\n    }\n    let diff = end - start + 1;\n    if\
    \ diff == 2 {\n        return \"YES\".to_string();\n    }\n    let mut is_prime\
    \ = true;\n    for i in 2..diff {\n        if diff % i == 0 {\n            is_prime\
    \ = false;\n            break;\n        }\n    }\n    if is_prime {\n        \"\
    YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }", "    let\
    \ (min, max) = (interval1.0.min(interval2.0), interval1.1.max(interval2.1));\n\
    \    let (min, max) = (min.max(interval1.0).max(interval2.0), max.min(interval1.1).min(interval2.1));\n\
    \    if min > max {\n        return \"NO\".to_string();\n    }\n    if is_prime(max\
    \ - min + 1) {\n        return \"YES\".to_string();\n    }\n    \"NO\".to_string()",
  "    if interval1.0 > interval2.1 || interval2.0 > interval1.1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = if interval1.0 < interval2.0 { interval2.0\
    \ } else { interval1.0 };\n    let end = if interval1.1 < interval2.1 { interval1.1\
    \ } else { interval2.1 };\n    if start == end {\n        \"NO\".to_string()\n\
    \    } else {\n        let mut prime = true;\n        for i in start..end {\n\
    \            if i < 2 {\n                continue;\n            }\n          \
    \  if (i != 2 && i % 2 == 0) || (i != 3 && i % 3 == 0) || (i != 5 && i % 5 ==\
    \ 0) || (i != 7 && i % 7 == 0) {\n                prime = false;\n           \
    \     break;\n            }\n        }\n        if prime {\n            \"YES\"\
    .to_string()\n        } else {\n            \"NO\".to_string()\n        }\n  \
    \  }", "    let (start1, end1) = interval1;\n    let (start2, end2) = interval2;\n\
    \    if start1 > end2 || start2 > end1 {\n        \"NO\".to_string()\n    } else\
    \ {\n        let start = if start1 > start2 { start1 } else { start2 };\n    \
    \    let end = if end1 < end2 { end1 } else { end2 };\n        let diff = end\
    \ - start;\n        if diff > 1 && is_prime(diff) {\n            \"YES\".to_string()\n\
    \        } else {\n            \"NO\".to_string()\n        }\n    }", "    let\
    \ (start1, end1) = interval1;\n    let (start2, end2) = interval2;\n    let common_start\
    \ = start1.max(start2);\n    let common_end = end1.min(end2);\n    if common_start\
    \ >= common_end {\n        return \"NO\".to_string();\n    }\n    let len = common_end\
    \ - common_start;\n    if len == 1 {\n        return \"NO\".to_string();\n   \
    \ }\n    let mut is_prime = true;\n    for i in 2..(len as f64).sqrt() as isize\
    \ + 1 {\n        if len % i == 0 {\n            is_prime = false;\n          \
    \  break;\n        }\n    }\n    if is_prime {\n        \"YES\".to_string()\n\
    \    } else {\n        \"NO\".to_string()\n    }", "    match (interval1, interval2)\
    \ {\n        ((a,b), (c,d)) if a > b || c > d => \"NO\".to_string(),\n       \
    \ ((a,b), (c,d)) if (b < c || d < a) => \"NO\".to_string(),\n        ((a,b), (c,d))\
    \ => {\n            let (start, end) = (a.max(c), b.min(d));\n            (end\
    \ - start).abs().is_prime().to_string()\n        }\n    }", "    let mut prime\
    \ = false;\n    let lower_interval = std::cmp::max(interval1.0, interval2.0);\n\
    \    let upper_interval = std::cmp::min(interval1.1, interval2.1);\n    if lower_interval\
    \ > upper_interval {\n        return \"NO\".to_string();\n    }\n    for i in\
    \ 2..upper_interval {\n        if upper_interval % i == 0 {\n            prime\
    \ = true;\n            break;\n        }\n    }\n    if prime {\n        return\
    \ \"NO\".to_string();\n    }\n    return \"YES\".to_string();", "    if interval1.0\
    \ > interval2.1 || interval2.0 > interval1.1 {\n        return \"NO\".to_string();\n\
    \    }\n    let intersection_length = min(interval1.1, interval2.1) - max(interval1.0,\
    \ interval2.0) + 1;\n    if intersection_length > 1 && primes::is_prime(intersection_length\
    \ as u64) {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n\
    \    }", "    let (low1, high1) = interval1;\n    let (low2, high2) = interval2;\n\
    \    let low = if low1 > low2 { low1 } else { low2 };\n    let high = if high1\
    \ < high2 { high1 } else { high2 };\n    if low > high {\n        return \"NO\"\
    .to_string();\n    }\n    let length = (high - low) + 1;\n    if length == 2 {\n\
    \        return \"YES\".to_string();\n    }\n    let mut m = 3;\n    while m *\
    \ m <= length {\n        if length % m == 0 {\n            return \"NO\".to_string();\n\
    \        }\n        m += 2;\n    }\n    \"YES\".to_string()", "    let mut x =\
    \ 0;\n    if interval1.0 < interval2.0 {\n        x = interval2.0;\n    } else\
    \ {\n        x = interval1.0;\n    }\n    let mut y = 0;\n    if interval1.1 <\
    \ interval2.1 {\n        y = interval1.1;\n    } else {\n        y = interval2.1;\n\
    \    }\n    if x <= y {\n        for i in x..y + 1 {\n            if is_prime(i)\
    \ {\n                return \"YES\".to_string();\n            }\n        }\n \
    \       return \"NO\".to_string();\n    } else {\n        return \"NO\".to_string();\n\
    \    }", "    let int1 = interval1.1 - interval1.0;\n    let int2 = interval2.1\
    \ - interval2.0;\n    if int1 < int2 {\n        if is_prime(int1) {\n        \
    \    return \"YES\".to_string();\n        }\n    } else {\n        if is_prime(int2)\
    \ {\n            return \"YES\".to_string();\n        }\n    }\n    return \"\
    NO\".to_string();", "    if interval1.0 > interval2.1 || interval2.0 > interval1.1\
    \ {\n        return \"NO\".to_string();\n    }\n    let (a, b) = if interval1.0\
    \ > interval2.0 {\n        (interval1.0, if interval1.1 < interval2.1 {\n    \
    \        interval1.1\n        } else {\n            interval2.1\n        })\n\
    \    } else {\n        (interval2.0, if interval2.1 < interval1.1 {\n        \
    \    interval2.1\n        } else {\n            interval1.1\n        })\n    };\n\
    \    if a == b {\n        return \"NO\".to_string();\n    }\n    let mut flag\
    \ = true;\n    for i in 2..a {\n        if a % i == 0 {\n            flag = false;\n\
    \            break;\n        }\n    }\n    if flag {\n        return \"YES\".to_string();\n\
    \    }\n    for i in 2..b {\n        if b % i == 0 {\n            flag = false;\n\
    \            break;\n        }\n    }\n    if flag {\n        return \"YES\".to_string();\n\
    \    }\n    \"NO\".to_string()", "    match calculate_intersection_length(interval1,\
    \ interval2) {\n        0 => \"NO\".to_string(),\n        1 => \"NO\".to_string(),\n\
    \        length => {\n            if is_prime(length) {\n                \"YES\"\
    .to_string()\n            } else {\n                \"NO\".to_string()\n     \
    \       }\n        }\n    }", "    match (interval1, interval2) {\n        ((min1,\
    \ max1), (min2, max2)) if min1 > max2 || min2 > max1 => \"NO\".to_string(),\n\
    \        ((min1, max1), (min2, max2)) => {\n            let start = if min1 >\
    \ min2 { min1 } else { min2 };\n            let end = if max1 < max2 { max1 }\
    \ else { max2 };\n            let range = end - start;\n            if range ==\
    \ 0 {\n                \"NO\".to_string()\n            } else {\n            \
    \    let mut is_prime = true;\n                for divisor in 2..range {\n   \
    \                 if range % divisor == 0 {\n                        is_prime\
    \ = false;\n                        break;\n                    }\n          \
    \      }\n                if is_prime {\n                    \"YES\".to_string()\n\
    \                } else {\n                    \"NO\".to_string()\n          \
    \      }\n            }\n        }\n    }", "    let max_int = 1_000_000_000;\n\
    \    let (start1, end1) = (interval1.0.min(interval1.1), interval1.0.max(interval1.1));\n\
    \    let (start2, end2) = (interval2.0.min(interval2.1), interval2.0.max(interval2.1));\n\
    \    if end1 <= start2 || end2 <= start1 {\n        return \"NO\".to_string();\n\
    \    }\n    let (start, end) = (start1.max(start2), end1.min(end2));\n    if end\
    \ - start < max_int {\n        match (end - start).is_prime() {\n            true\
    \ => \"YES\".to_string(),\n            false => \"NO\".to_string(),\n        }\n\
    \    } else {\n        \"NO\".to_string()\n    }", "    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    if c >= b || a >= d {\n        return \"NO\"\
    .to_string();\n    }\n    let interval3 = (c.max(a), b.min(d));\n    let (_, len)\
    \ = interval3;\n    let mut is_prime = true;\n    if len > 1 {\n        for i\
    \ in 2..len {\n            if len % i == 0 {\n                is_prime = false;\n\
    \                break;\n            }\n        }\n    }\n    if is_prime {\n\
    \        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }",
  "  let (start1, end1) = interval1;\n  let (start2, end2) = interval2;\n  if start1\
    \ > end2 || start2 > end1 {\n    return \"NO\".to_string();\n  }\n  let (start,\
    \ end) = (start1.max(start2), end1.min(end2));\n  let length = end - start + 1;\n\
    \  if length < 2 {\n    return \"NO\".to_string();\n  }\n  if length == 2 {\n\
    \    return \"YES\".to_string();\n  }\n  for num in 2..length {\n    if length\
    \ % num == 0 {\n      return \"NO\".to_string();\n    }\n  }\n  \"YES\".to_string()",
  "    let (a, b) = interval1;\n    let (c, d) = interval2;\n    let mut start = max(a,\
    \ c);\n    let mut end = min(b, d);\n    if start > end {\n        start = 0;\n\
    \        end = 0;\n    }\n    if is_prime(end - start + 1) {\n        \"YES\"\
    .to_string()\n    } else {\n        \"NO\".to_string()\n    }", "    let (start1,\
    \ end1) = interval1;\n    let (start2, end2) = interval2;\n    let mut min_start\
    \ = start1;\n    let mut max_end = end1;\n    if start2 < min_start {\n      \
    \  min_start = start2;\n    }\n    if end2 > max_end {\n        max_end = end2;\n\
    \    }\n    if min_start > max_end {\n        return \"NO\".to_string();\n   \
    \ }\n    if is_prime(max_end - min_start + 1) {\n        return \"YES\".to_string();\n\
    \    }\n    \"NO\".to_string()", "    let (l1, r1) = interval1;\n    let (l2,\
    \ r2) = interval2;\n    if r1 < l2 || r2 < l1 { return \"NO\".to_string(); }\n\
    \    let (l, r) = (std::cmp::max(l1, l2), std::cmp::min(r1, r2));\n    if l ==\
    \ r { return \"NO\".to_string(); }\n    if (2..(l / 2)).any(|x| l % x == 0) {\
    \ return \"NO\".to_string(); }\n    \"YES\".to_string()", "    let (l1, r1) =\
    \ interval1;\n    let (l2, r2) = interval2;\n    if l1 > r2 || l2 > r1 {\n   \
    \     return \"NO\".to_string();\n    }\n    let left = if l1 < l2 { l2 } else\
    \ { l1 };\n    let right = if r1 < r2 { r1 } else { r2 };\n    let diff = right\
    \ - left + 1;\n    if diff == 1 {\n        return \"NO\".to_string();\n    }\n\
    \    if diff == 2 {\n        return \"YES\".to_string();\n    }\n    let mut count\
    \ = 0;\n    for i in 2..diff {\n        if diff % i == 0 {\n            count\
    \ += 1;\n        }\n    }\n    if count == 0 {\n        return \"YES\".to_string();\n\
    \    }\n    \"NO\".to_string()", "    let start = interval1.0.max(interval2.0);\n\
    \    let end = interval1.1.min(interval2.1);\n    if start > end {\n        \"\
    NO\".to_string()\n    } else {\n        is_prime(end - start + 1)\n    }", " \
    \   let (a, b) = interval1;\n    let (c, d) = interval2;\n    let mut start: isize\
    \ = 0;\n    let mut end: isize = 0;\n    if a <= c && c <= b {\n        start\
    \ = c;\n    } else if c <= a && a <= d {\n        start = a;\n    }\n    if a\
    \ <= d && d <= b {\n        end = d;\n    } else if c <= b && b <= d {\n     \
    \   end = b;\n    }\n    if end - start < 2 {\n        return \"NO\".to_string();\n\
    \    }\n    for num in 2..end {\n        if num > start && end % num == 0 {\n\
    \            return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()",
  "    let (min, max) = (\n        interval1.0.max(interval2.0),\n        interval1.1.min(interval2.1),\n\
    \    );\n    if min > max {\n        return \"NO\".to_string();\n    }\n    if\
    \ min == max {\n        if is_prime(min as usize) {\n            return \"YES\"\
    .to_string();\n        }\n        return \"NO\".to_string();\n    }\n    let mut\
    \ count = 0;\n    for num in min..max + 1 {\n        if is_prime(num as usize)\
    \ {\n            count += 1;\n        }\n    }\n    if count > 0 {\n        return\
    \ \"YES\".to_string();\n    }\n    \"NO\".to_string()", "    let start = cmp::max(interval1.0,\
    \ interval2.0);\n    let end = cmp::min(interval1.1, interval2.1);\n    if start\
    \ <= end {\n        if prime_len(start, end) { \"YES\".to_string() } else { \"\
    NO\".to_string() }\n    } else {\n        \"NO\".to_string()\n    }", "    let\
    \ (x1, y1) = interval1;\n    let (x2, y2) = interval2;\n    let mut start = x1;\n\
    \    let mut end = y1;\n    if y1 < x2 || y2 < x1 {\n        return \"NO\".to_string();\n\
    \    }\n    if y1 > y2 {\n        end = y2;\n    }\n    if x1 < x2 {\n       \
    \ start = x2;\n    }\n    let mut i = start;\n    let mut primes = 2;\n    while\
    \ i <= end {\n        let mut is_prime = true;\n        for j in 2..i {\n    \
    \        if i % j == 0 {\n                is_prime = false;\n                break;\n\
    \            }\n        }\n        if is_prime {\n            primes += 1;\n \
    \       }\n        i += 1;\n    }\n    if primes > 2 {\n        \"YES\".to_string()\n\
    \    } else {\n        \"NO\".to_string()\n    }", "    let (start1, end1) = interval1;\n\
    \    let (start2, end2) = interval2;\n    let (max_start, min_end) = (\n     \
    \   std::cmp::max(start1, start2),\n        std::cmp::min(end1, end2),\n    );\n\
    \    let intersection_len = min_end - max_start;\n    if intersection_len < 0\
    \ {\n        \"NO\".to_string()\n    } else {\n        if is_prime(intersection_len\
    \ as usize) {\n            \"YES\".to_string()\n        } else {\n           \
    \ \"NO\".to_string()\n        }\n    }", "    // check if they intersect\n   \
    \ let mut max_start = interval1.0;\n    let mut min_end = interval1.1;\n    if\
    \ interval2.0 > max_start {\n        max_start = interval2.0;\n    }\n    if interval2.1\
    \ < min_end {\n        min_end = interval2.1;\n    }\n    if max_start > min_end\
    \ {\n        return \"NO\".to_string();\n    }\n    // calculate length\n    let\
    \ length = min_end - max_start + 1;\n    if length == 2 {\n        return \"YES\"\
    .to_string();\n    }\n    // check if prime\n    for x in 2..length {\n      \
    \  if length % x == 0 {\n            return \"NO\".to_string();\n        }\n \
    \   }\n    \"YES\".to_string()", "    let (start1, end1) = interval1;\n    let\
    \ (start2, end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n     \
    \   return \"NO\".to_string();\n    }\n    let mut intersection_start = std::cmp::max(start1,\
    \ start2);\n    let mut intersection_end = std::cmp::min(end1, end2);\n    if\
    \ intersection_start == intersection_end {\n        return \"NO\".to_string();\n\
    \    }\n    let mut intersection_length = intersection_end - intersection_start;\n\
    \    while intersection_length > 1 {\n        if intersection_start % intersection_length\
    \ == 0 ||\n            intersection_end % intersection_length == 0 {\n       \
    \     return \"NO\".to_string();\n        }\n        intersection_length -= 1;\n\
    \    }\n    \"YES\".to_string()", "    if interval1.0 <= interval2.1 && interval2.0\
    \ <= interval1.1 {\n        let i = interval1.0.max(interval2.0);\n        let\
    \ j = interval1.1.min(interval2.1);\n        if is_prime(j - i + 1) {\n      \
    \      return \"YES\".to_string();\n        }\n    }\n    \"NO\".to_string()",
  "    let i1 = if interval1.0 > interval1.1 { (interval1.1, interval1.0) } else {\
    \ interval1 };\n    let i2 = if interval2.0 > interval2.1 { (interval2.1, interval2.0)\
    \ } else { interval2 };\n    let mut isec = if i1.1 < i2.0 { None } else { Some((i2.0,\
    \ i1.1)) };\n    if i1.0 >= i2.0 && i1.0 <= i2.1 {\n        isec = Some((i1.0,\
    \ i1.1));\n    }\n    if let Some((start, end)) = isec {\n        let diff = if\
    \ start > end { start - end } else { end - start };\n        if diff == 0 {\n\
    \            return \"YES\".to_string();\n        }\n        let mut prime = true;\n\
    \        for i in 2..diff {\n            if diff % i == 0 {\n                prime\
    \ = false;\n                break;\n            }\n        }\n        if prime\
    \ {\n            return \"YES\".to_string();\n        }\n    }\n    \"NO\".to_string()",
  "    if interval1.0 > interval2.1 || interval2.0 > interval1.1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let inter: isize = if interval1.0 > interval2.0\
    \ {\n        if interval1.1 > interval2.1 {\n            interval2.1 - interval1.0\n\
    \        } else {\n            interval1.1 - interval1.0\n        }\n    } else\
    \ {\n        if interval1.1 > interval2.1 {\n            interval2.1 - interval2.0\n\
    \        } else {\n            interval1.1 - interval2.0\n        }\n    };\n\
    \    if inter == 1 {\n        return \"NO\".to_string();\n    }\n    let mut is_prime\
    \ = true;\n    for i in 2..inter {\n        if inter % i == 0 {\n            is_prime\
    \ = false;\n            break;\n        }\n    }\n    if is_prime {\n        \"\
    YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }", "    let\
    \ mut result = false;\n    let mut length = 0;\n    let (mut a, mut b) = interval1;\n\
    \    let (mut c, mut d) = interval2;\n    if a > b {\n        std::mem::swap(&mut\
    \ a, &mut b);\n    }\n    if c > d {\n        std::mem::swap(&mut c, &mut d);\n\
    \    }\n    if b < c || a > d {\n        return \"NO\".to_string();\n    }\n \
    \   let start = if a > c { a } else { c };\n    let end = if b < d { b } else\
    \ { d };\n    for i in start..=end {\n        if i > 1 {\n            let mut\
    \ is_prime = true;\n            for j in 2..i {\n                if i % j == 0\
    \ {\n                    is_prime = false;\n                    break;\n     \
    \           }\n            }\n            if is_prime {\n                result\
    \ = true;\n                break;\n            }\n        }\n        length +=\
    \ 1;\n    }\n    if result {\n        \"YES\".to_string()\n    } else {\n    \
    \    if length > 1 {\n            \"NO\".to_string()\n        } else {\n     \
    \       \"YES\".to_string()\n        }\n    }", "  let (a, b) = interval1;\n \
    \ let (c, d) = interval2;\n  if b < c || d < a {\n    return \"NO\".to_string();\n\
    \  }\n  let mut i = isize::max(a, c);\n  let mut j = isize::min(b, d);\n  if i\
    \ == j {\n    return \"NO\".to_string();\n  }\n  if i == 2 {\n    return \"YES\"\
    .to_string();\n  }\n  i += 1;\n  while i < j {\n    if i % 2 == 0 || i % 3 ==\
    \ 0 || i % 5 == 0 || i % 7 == 0 {\n      return \"NO\".to_string();\n    }\n \
    \   i += 1;\n  }\n  \"YES\".to_string()", "    let start = interval1.0.max(interval2.0);\n\
    \    let end = interval1.1.min(interval2.1);\n    if start > end {\n        return\
    \ \"NO\".to_string();\n    }\n    if (end - start) < 3 {\n        return \"NO\"\
    .to_string();\n    }\n    if (end - start) % 2 == 0 {\n        return \"NO\".to_string();\n\
    \    }\n    if (end - start) % 3 == 0 {\n        return \"NO\".to_string();\n\
    \    }\n    if (end - start) % 5 == 0 {\n        return \"NO\".to_string();\n\
    \    }\n    if (end - start) % 7 == 0 {\n        return \"NO\".to_string();\n\
    \    }\n    return \"YES\".to_string();", "    let mut start = 0;\n    let mut\
    \ end = 0;\n    if interval1.0 > interval2.0 {\n        start = interval1.0;\n\
    \    } else {\n        start = interval2.0;\n    }\n    if interval1.1 < interval2.1\
    \ {\n        end = interval1.1;\n    } else {\n        end = interval2.1;\n  \
    \  }\n    if start > end {\n        return \"NO\".to_string();\n    }\n    let\
    \ mut is_prime = true;\n    for i in 2..(end - start + 1) {\n        if (end -\
    \ start + 1) % i == 0 {\n            is_prime = false;\n            break;\n \
    \       }\n    }\n    if is_prime {\n        return \"YES\".to_string();\n   \
    \ } else {\n        return \"NO\".to_string();\n    }", "    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let (min, max) = if start1\
    \ > start2 {\n        (start1, end2)\n    } else {\n        (start2, end1)\n \
    \   };\n    if max < min {\n        return \"NO\".to_string();\n    }\n    let\
    \ length = max - min + 1;\n    if is_prime(length) {\n        \"YES\".to_string()\n\
    \    } else {\n        \"NO\".to_string()\n    }", "    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    if a <= d && b >= c {\n        is_prime((a..d).count()\
    \ as u64)\n    } else {\n        \"NO\".to_string()\n    }", "    let (start1,\
    \ end1) = interval1;\n    let (start2, end2) = interval2;\n    if start1 > end2\
    \ || start2 > end1 {\n        return \"NO\".to_string();\n    }\n    let (start,\
    \ end) = (std::cmp::max(start1, start2), std::cmp::min(end1, end2));\n    let\
    \ result = end - start + 1;\n    if result == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    return if is_prime(result) { \"YES\".to_string() } else { \"NO\".to_string()\
    \ };", "    let start = std::cmp::max(interval1.0, interval2.0);\n    let end\
    \ = std::cmp::min(interval1.1, interval2.1);\n    if start > end {\n        return\
    \ \"NO\".to_string();\n    }\n\n    let len = (end - start + 1) as usize;\n  \
    \  for i in 2..len {\n        if len % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()", "    let max = |a, b| if a > b {\
    \ a } else { b };\n    let min = |a, b| if a < b { a } else { b };\n    let max_a\
    \ = max(interval1.0, interval2.0);\n    let min_b = min(interval1.1, interval2.1);\n\
    \    if max_a > min_b {\n        \"NO\".to_string()\n    } else {\n        let\
    \ v = min_b - max_a + 1;\n        if v == 1 {\n            \"NO\".to_string()\n\
    \        } else {\n            let mut i = 2;\n            let mut is_prime =\
    \ true;\n            while i < v {\n                if v % i == 0 {\n        \
    \            is_prime = false;\n                    break;\n                }\n\
    \                i += 1;\n            }\n            if is_prime {\n         \
    \       \"YES\".to_string()\n            } else {\n                \"NO\".to_string()\n\
    \            }\n        }\n    }", "    let inter: Vec<isize> = interval1.1.min(interval2.1)..=interval1.0.max(interval2.0)\n\
    \        .min(interval1.1)\n        .min(interval2.1)\n        .max(interval1.0)\n\
    \        .max(interval2.0)\n        .collect();\n    let inter = inter.len() as\
    \ isize;\n    if inter == 0 {\n        return \"NO\".to_string();\n    }\n   \
    \ if inter == 1 {\n        return \"NO\".to_string();\n    }\n    if inter ==\
    \ 2 {\n        return \"NO\".to_string();\n    }\n    if inter == 3 {\n      \
    \  return \"YES\".to_string();\n    }\n    if inter % 2 == 0 {\n        return\
    \ \"NO\".to_string();\n    }\n    if inter % 3 == 0 {\n        return \"NO\".to_string();\n\
    \    }\n    if inter % 5 == 0 {\n        return \"NO\".to_string();\n    }\n \
    \   if inter % 7 == 0 {\n        return \"NO\".to_string();\n    }\n    if inter\
    \ % 11 == 0 {\n        return \"NO\".to_string();\n    }\n    \"YES\".to_string()",
  "    if interval1.0 > interval2.1 || interval2.0 > interval1.1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = if interval1.0 > interval2.0 { interval1.0\
    \ } else { interval2.0 };\n    let end = if interval1.1 < interval2.1 { interval1.1\
    \ } else { interval2.1 };\n    let mut length = (end - start + 1) as usize;\n\
    \    if length < 2 {\n        return \"NO\".to_string();\n    }\n    length -=\
    \ 1;\n    let mut is_prime = true;\n    for i in 2..(length / 2 + 1) {\n     \
    \   if length % i == 0 {\n            is_prime = false;\n            break;\n\
    \        }\n    }\n    if is_prime {\n        \"YES\".to_string()\n    } else\
    \ {\n        \"NO\".to_string()\n    }", "    let (i1_start, i1_end) = interval1;\n\
    \    let (i2_start, i2_end) = interval2;\n    if i1_end < i2_start || i2_end <\
    \ i1_start {\n        return \"NO\".to_string();\n    }\n    let i1_interval =\
    \ (std::cmp::max(i1_start, i2_start), std::cmp::min(i1_end, i2_end));\n    let\
    \ i1_length = i1_interval.1 - i1_interval.0;\n    let is_prime = match i1_length\
    \ {\n        1 | 0 => false,\n        2 => true,\n        l if l > 2 => {\n  \
    \          let limit = (l as f64).sqrt() as isize + 1;\n            (2..limit).all(|x|\
    \ l % x != 0)\n        }\n        _ => false,\n    };\n    if is_prime {\n   \
    \     \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }", " \
    \   let (mut start, mut end) = (interval1.0, interval1.1);\n    if interval1.0\
    \ > interval2.0 {\n        start = interval2.0;\n    }\n    if interval1.1 < interval2.1\
    \ {\n        end = interval2.1;\n    }\n    if start > end {\n        return \"\
    NO\".to_string();\n    }\n    if is_prime((end - start) as usize) {\n        return\
    \ \"YES\".to_string();\n    }\n    \"NO\".to_string()", "    if let Some(interval)\
    \ = intersect(interval1, interval2) {\n        if is_prime(interval.len() as usize)\
    \ {\n            return \"YES\".to_string();\n        }\n    }\n    \"NO\".to_string()",
  "    let mut intervals: Vec<(isize, isize)> = vec![interval1, interval2];\n    intervals.sort_by(|a,\
    \ b| a.1.cmp(&b.1));\n    let mut intersections: Vec<isize> = vec![];\n    for\
    \ i in 0..intervals.len() - 1 {\n        if intervals[i].1 >= intervals[i + 1].0\
    \ {\n            intersections.push(intervals[i + 1].0 - intervals[i].1);\n  \
    \      }\n    }\n    for length in intersections {\n        if !is_prime(length)\
    \ {\n            return \"NO\".to_string();\n        }\n    }\n    if intersections.len()\
    \ == 0 {\n        return \"NO\".to_string();\n    }\n    \"YES\".to_string()",
  "  if interval1.0 > interval2.1 || interval2.0 > interval1.1 {\n    return \"NO\"\
    .to_string();\n  }\n  let mut result = vec![];\n  for i in interval1.0..interval1.1+1\
    \ {\n    if i >= interval2.0 && i <= interval2.1 {\n      result.push(i);\n  \
    \  }\n  }\n  for i in interval2.0..interval2.1+1 {\n    if i >= interval1.0 &&\
    \ i <= interval1.1 {\n      result.push(i);\n    }\n  }\n  if result.len() < 2\
    \ {\n    return \"NO\".to_string();\n  }\n  let res = result.iter().max().unwrap()\
    \ - result.iter().min().unwrap();\n  if (2..res-1).all(|x| res % x != 0) {\n \
    \   return \"YES\".to_string();\n  }\n  \"NO\".to_string()", "    let small_left\
    \ = cmp::min(interval1.0, interval2.0);\n    let big_right = cmp::max(interval1.1,\
    \ interval2.1);\n    let min_interval = cmp::min(interval1.1 - interval1.0, interval2.1\
    \ - interval2.0);\n    let intersection = if small_left >= big_right {\n     \
    \   0\n    } else {\n        cmp::min(interval1.1, interval2.1) - cmp::max(interval1.0,\
    \ interval2.0)\n    };\n    if intersection == 0 {\n        return \"NO\".to_string();\n\
    \    }\n    let prime = if intersection == 1 {\n        true\n    } else {\n \
    \       if intersection % 2 == 0 {\n            false\n        } else {\n    \
    \        let mut i = 3;\n            let mut is_prime = true;\n            while\
    \ i <= (intersection as f64).sqrt() as isize {\n                if intersection\
    \ % i == 0 {\n                    is_prime = false;\n                    break;\n\
    \                }\n                i += 2;\n            }\n            is_prime\n\
    \        }\n    };\n    if prime {\n        \"YES\".to_string()\n    } else {\n\
    \        \"NO\".to_string()\n    }", "    let (mut a, mut b) = interval1;\n  \
    \  let (mut c, mut d) = interval2;\n    if b < a { a = b; b = interval1.0; }\n\
    \    if d < c { c = d; d = interval2.0; }\n    let max_start = a.max(c);\n   \
    \ let min_end = b.min(d);\n    if min_end < max_start { return \"NO\".to_string();\
    \ }\n    if (min_end - max_start + 1).is_prime() { \"YES\".to_string() } else\
    \ { \"NO\".to_string() }", "    let a = if interval1.0 > interval2.0 { interval1.0\
    \ } else { interval2.0 };\n    let b = if interval1.1 < interval2.1 { interval1.1\
    \ } else { interval2.1 };\n    if a > b { return \"NO\".to_string(); }\n    let\
    \ len = (b - a + 1) as usize;\n    if len <= 2 { return \"NO\".to_string(); }\n\
    \    let mut p: usize = 3;\n    while p <= len {\n        if len % p == 0 { return\
    \ \"NO\".to_string(); }\n        p += 2;\n    }\n    \"YES\".to_string()", " \
    \   let start = match interval1.0 > interval2.0 {\n        true => interval1.0,\n\
    \        false => interval2.0,\n    };\n    let end = match interval1.1 < interval2.1\
    \ {\n        true => interval1.1,\n        false => interval2.1,\n    };\n   \
    \ let diff = if start < end { end - start } else { 0 };\n    if diff == 1 {\n\
    \        return \"NO\".to_string();\n    }\n    let mut count = 0;\n    for i\
    \ in 2..diff {\n        if diff % i == 0 {\n            count += 1;\n        }\n\
    \    }\n    if count == 0 {\n        \"YES\".to_string()\n    } else {\n     \
    \   \"NO\".to_string()\n    }", "    let (i1_1, i1_2) = interval1;\n    let (i2_1,\
    \ i2_2) = interval2;\n    let mut intersection = (\n        cmp::max(i1_1, i2_1),\n\
    \        cmp::min(i1_2, i2_2),\n    );\n    if intersection.0 > intersection.1\
    \ {\n        return \"NO\".to_string();\n    }\n    if intersection.0 == intersection.1\
    \ {\n        return \"YES\".to_string();\n    }\n    if is_prime(intersection.1\
    \ - intersection.0) {\n        return \"YES\".to_string();\n    }\n    \"NO\"\
    .to_string()", "    let (a, b) = interval1;\n    let (c, d) = interval2;\n   \
    \ let e = cmp::max(a, c);\n    let f = cmp::min(b, d);\n    let n = if e > f {\
    \ 0 } else { f - e + 1 };\n    if n <= 1 {\n        return \"NO\".to_string();\n\
    \    }\n    for i in 2..(n - 1) {\n        if n % i == 0 {\n            return\
    \ \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()", "    if interval1.0\
    \ > interval2.1 || interval2.0 > interval1.1 {\n        return \"NO\".to_string();\n\
    \    }\n    let val = if interval1.0 > interval2.0 { interval1.0 } else { interval2.0\
    \ };\n    let val2 = if interval1.1 < interval2.1 { interval1.1 } else { interval2.1\
    \ };\n    if is_prime(val2 - val) {\n        \"YES\".to_string()\n    } else {\n\
    \        \"NO\".to_string()\n    }", "    match (interval1, interval2) {\n   \
    \     ((a, b), (c, d)) if b < c || d < a => return \"NO\".to_string(),\n     \
    \   ((a, b), (c, d)) => {\n            let mut start = std::cmp::max(a, c);\n\
    \            let mut end = std::cmp::min(b, d);\n            if start > end {\n\
    \                return \"NO\".to_string();\n            } else if start == end\
    \ {\n                return \"YES\".to_string();\n            }\n            start\
    \ -= 1;\n            let mut is_prime = true;\n            for i in 2..=start\
    \ {\n                if start % i == 0 {\n                    is_prime = false;\n\
    \                    break;\n                }\n            }\n            if\
    \ is_prime {\n                return \"YES\".to_string();\n            }\n   \
    \         start += 1;\n            end += 1;\n            for i in 2..=end {\n\
    \                if end % i == 0 {\n                    is_prime = false;\n  \
    \                  break;\n                }\n            }\n            if is_prime\
    \ {\n                return \"YES\".to_string();\n            }\n            \"\
    NO\".to_string()\n        }\n    }", "    match (interval1, interval2) {\n   \
    \     ((start1, end1), (start2, end2)) => {\n            if start1 > end2 || start2\
    \ > end1 {\n                \"NO\".to_string()\n            } else {\n       \
    \         let interval = (cmp::max(start1, start2), cmp::min(end1, end2));\n \
    \               if interval.1 - interval.0 == 1 {\n                    \"YES\"\
    .to_string()\n                } else {\n                    \"NO\".to_string()\n\
    \                }\n            }\n        }\n    }", "    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    let x = std::cmp::max(a, c);\n    let y = std::cmp::min(b,\
    \ d);\n    if x > y { return \"NO\".to_string(); }\n    if is_prime(y - x + 1)\
    \ { return \"YES\".to_string(); }\n    \"NO\".to_string()", "    let (i1_start,\
    \ i1_end) = interval1;\n    let (i2_start, i2_end) = interval2;\n    if i1_end\
    \ < i2_start || i2_end < i1_start {\n        return \"NO\".to_string();\n    }\n\
    \    let i_start = if i1_start < i2_start { i2_start } else { i1_start };\n  \
    \  let i_end = if i1_end < i2_end { i1_end } else { i2_end };\n    if i_start\
    \ == i_end {\n        return \"NO\".to_string();\n    }\n    if is_prime(i_end\
    \ - i_start + 1) {\n        return \"YES\".to_string();\n    }\n    \"NO\".to_string()",
  "    if let Some(interval) = intersect(interval1, interval2) {\n        let len\
    \ = interval.1 - interval.0;\n        if is_prime(len) {\n            return \"\
    YES\".to_string();\n        }\n    }\n    \"NO\".to_string()", "    let start\
    \ = isize::max(interval1.0, interval2.0);\n    let end = isize::min(interval1.1,\
    \ interval2.1);\n    if start > end {\n        return \"NO\".to_string();\n  \
    \  }\n\n    let prime = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,\
    \ 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    for i in 1..=(end - start)\
    \ {\n        if prime.contains(&i) {\n            return \"YES\".to_string();\n\
    \        }\n    }\n    \"NO\".to_string()", "    let (start1, end1) = interval1;\n\
    \    let (start2, end2) = interval2;\n    let (start, end) = match (start1, end1,\
    \ start2, end2) {\n        (start1, end1, start2, end2) if start1 < start2 &&\
    \ end1 > start2 && end1 < end2 => (start2, end1),\n        (start1, end1, start2,\
    \ end2) if start1 > start2 && start1 < end2 && end1 > end2 => (start1, end2),\n\
    \        (start1, end1, start2, end2) if start1 > start2 && start1 < end2 && end1\
    \ < end2 => (start1, end1),\n        (start1, end1, start2, end2) if start1 <\
    \ start2 && end1 > start2 && end1 > end2 => (start2, end2),\n        _ => return\
    \ \"NO\".to_string(),\n    };\n    let mut is_prime = true;\n    for i in 2..(end\
    \ - start) {\n        if (end - start) % i == 0 {\n            is_prime = false;\n\
    \            break;\n        }\n    }\n    if is_prime {\n        \"YES\".to_string()\n\
    \    } else {\n        \"NO\".to_string()\n    }", "    let i1_min = interval1.0.min(interval1.1);\n\
    \    let i1_max = interval1.0.max(interval1.1);\n    let i2_min = interval2.0.min(interval2.1);\n\
    \    let i2_max = interval2.0.max(interval2.1);\n    let min = i1_min.max(i2_min);\n\
    \    let max = i1_max.min(i2_max);\n    if min > max {\n        return \"NO\"\
    .to_string();\n    }\n    if is_prime(max - min + 1) {\n        return \"YES\"\
    .to_string();\n    }\n    \"NO\".to_string()", "    let (mut start, mut end) =\
    \ match interval1.0 <= interval2.0 {\n        true => (interval2.0, interval1.1),\n\
    \        false => (interval1.0, interval2.1),\n    };\n    if start > end {\n\
    \        std::mem::swap(&mut start, &mut end);\n    }\n    if start <= end {\n\
    \        let mut i = 1;\n        let mut prime = true;\n        while (i * i)\
    \ <= (end - start) {\n            if (end - start) % i == 0 {\n              \
    \  prime = false;\n                break;\n            }\n            i += 1;\n\
    \        }\n        if prime {\n            return \"YES\".to_string();\n    \
    \    }\n    }\n    \"NO\".to_string()", "    if interval1.0 > interval2.1 || interval2.0\
    \ > interval1.1 { return \"NO\".to_string(); }\n    let isect_len = interval1.1.min(interval2.1)\
    \ - interval1.0.max(interval2.0) + 1;\n    match isect_len.to_string().parse::<usize>()\
    \ {\n        Ok(len) => if is_prime(len) { \"YES\".to_string() } else { \"NO\"\
    .to_string() },\n        Err(_) => \"NO\".to_string(),\n    }", "    let (start1,\
    \ end1) = interval1;\n    let (start2, end2) = interval2;\n    let start = if\
    \ start1 > start2 { start1 } else { start2 };\n    let end = if end1 < end2 {\
    \ end1 } else { end2 };\n    if start > end {\n        \"NO\".to_string()\n  \
    \  } else {\n        if start != end {\n            let mut is_prime = true;\n\
    \            for i in 2..start {\n                if start % i == 0 {\n      \
    \              is_prime = false;\n                    break;\n               \
    \ }\n            }\n            if is_prime {\n                \"YES\".to_string()\n\
    \            } else {\n                \"NO\".to_string()\n            }\n   \
    \     } else {\n            \"NO\".to_string()\n        }\n    }", "    let (a,\
    \ b) = interval1;\n    let (c, d) = interval2;\n    if a > d || b < c {\n    \
    \    return \"NO\".to_string();\n    }\n    let start = max(a, c);\n    let end\
    \ = min(b, d);\n    let length = end - start + 1;\n    if is_prime(length) {\n\
    \        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }",
  "    //use std::cmp::{min, max};\n    use std::num::{ParseIntError, ParseFloatError};\n\
    \    fn parse_i(input: &str) -> Result<isize, ParseIntError> {\n        input.parse::<isize>()\n\
    \    }\n    fn parse_f(input: &str) -> Result<f64, ParseFloatError> {\n      \
    \  input.parse::<f64>()\n    }\n    let (x1, y1) = interval1;\n    let (x2, y2)\
    \ = interval2;\n    let (z1, z2) = (parse_i(&x1.to_string()).unwrap(), parse_i(&y1.to_string()).unwrap());\n\
    \    let (z3, z4) = (parse_i(&x2.to_string()).unwrap(), parse_i(&y2.to_string()).unwrap());\n\
    \    if (z1 > z3 && z1 < z4) || (z2 > z3 && z2 < z4) || (z3 > z1 && z3 < z2) ||\
    \ (z4 > z1 && z4 < z2) {\n        let mut i = 1;\n        let mut counter = 0;\n\
    \        let length = ((z1 - z3).abs() + (z2 - z4).abs()) / 2;\n        while\
    \ i <= length {\n            if length % i == 0 {\n                counter +=\
    \ 1;\n            }\n            i += 1;\n        }\n        if counter == 2 {\n\
    \            \"YES\".to_string()\n        } else {\n            \"NO\".to_string()\n\
    \        }\n    } else {\n        \"NO\".to_string()\n    }", "    // Check for\
    \ intersection:\n    if interval1.0 > interval2.1 || interval2.0 > interval1.1\
    \ {\n        return \"NO\".to_string();\n    }\n    // Calculate the intersection\
    \ interval:\n    let mut lower = std::cmp::max(interval1.0, interval2.0);\n  \
    \  let mut upper = std::cmp::min(interval1.1, interval2.1);\n    // Make sure\
    \ the lower bound is never zero:\n    if lower == 0 {\n        lower = 1;\n  \
    \  }\n    // Check if the length of the intersection is a prime number:\n    let\
    \ mut result = \"NO\";\n    while lower <= upper {\n        if is_prime(lower)\
    \ {\n            result = \"YES\";\n            break;\n        }\n        lower\
    \ += 1;\n    }\n    result.to_string()", "    let first = std::cmp::max(interval1.0,\
    \ interval2.0);\n    let second = std::cmp::min(interval1.1, interval2.1);\n \
    \   if first > second {\n        return \"NO\".to_string();\n    }\n    if is_prime(second\
    \ - first + 1) {\n        return \"YES\".to_string();\n    }\n    \"NO\".to_string()",
  "    // In case intervals don't intersect\n    if interval1.1 < interval2.0 || interval2.1\
    \ < interval1.0 {\n        return \"NO\".to_string();\n    }\n    // In case intervals\
    \ intersects, define the intersection\n    let start = if interval1.0 <= interval2.0\
    \ { interval2.0 } else { interval1.0 };\n    let end = if interval1.1 <= interval2.1\
    \ { interval1.1 } else { interval2.1 };\n    // Check if the length of the intersection\
    \ is a prime number\n    if is_prime(end - start + 1) {\n        return \"YES\"\
    .to_string();\n    }\n    \"NO\".to_string()", "    let (interval1_start, interval1_end)\
    \ = interval1;\n    let (interval2_start, interval2_end) = interval2;\n    let\
    \ max_start = interval1_start.max(interval2_start);\n    let min_end = interval1_end.min(interval2_end);\n\
    \    if max_start <= min_end {\n        let range = min_end - max_start;\n   \
    \     if is_prime(range) {\n            return \"YES\".to_string();\n        }\n\
    \    }\n    \"NO\".to_string()", "    let mut intersection = vec![];\n    for\
    \ x in interval1.0..=interval1.1 {\n        if interval2.0 <= x && x <= interval2.1\
    \ {\n            intersection.push(x);\n        }\n    }\n    if intersection.len()\
    \ == 0 {\n        return \"NO\".to_string();\n    }\n    let k = intersection.len()\
    \ as isize;\n    let is_prime = !((2..k).any(|x| k % x == 0));\n    if is_prime\
    \ {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n \
    \   }", "    let (int1_start, int1_end) = interval1;\n    let (int2_start, int2_end)\
    \ = interval2;\n    let mut intersection = vec![];\n    for i in int1_start..=int1_end\
    \ {\n        if int2_start <= i && i <= int2_end {\n            intersection.push(i);\n\
    \        }\n    }\n    if intersection.len() == 0 {\n        return \"NO\".to_string();\n\
    \    }\n    let length = intersection.len() as isize;\n    if length == 1 {\n\
    \        return \"NO\".to_string();\n    }\n    let mut is_prime = true;\n   \
    \ for i in 2..length {\n        if length % i == 0 {\n            is_prime = false;\n\
    \            break;\n        }\n    }\n    if is_prime {\n        return \"YES\"\
    .to_string();\n    }\n    \"NO\".to_string()", "    let start = interval1.0.max(interval2.0);\n\
    \    let end = interval1.1.min(interval2.1);\n    if start > end {\n        return\
    \ \"NO\".to_string();\n    }\n    match (start..end).count() {\n        0 => \"\
    NO\".to_string(),\n        1 => \"YES\".to_string(),\n        2 => \"YES\".to_string(),\n\
    \        3 => \"YES\".to_string(),\n        4 => \"NO\".to_string(),\n       \
    \ 5 => \"YES\".to_string(),\n        6 => \"NO\".to_string(),\n        7 => \"\
    YES\".to_string(),\n        8 => \"NO\".to_string(),\n        9 => \"NO\".to_string(),\n\
    \        _ => \"NO\".to_string(),\n    }", "    let start1 = interval1.0;\n  \
    \  let end1 = interval1.1;\n    let start2 = interval2.0;\n    let end2 = interval2.1;\n\
    \    let start = std::cmp::max(start1, start2);\n    let end = std::cmp::min(end1,\
    \ end2);\n    if start > end {\n        return \"NO\".to_string();\n    }\n  \
    \  let mut is_prime = true;\n    for i in 2..end - start + 1 {\n        if end\
    \ - start + 1 % i == 0 {\n            is_prime = false;\n            break;\n\
    \        }\n    }\n    if is_prime {\n        return \"YES\".to_string();\n  \
    \  }\n    return \"NO\".to_string();", "    // Can't use i32 as type, it's not\
    \ implemented for the range type\n    let start = interval1.0.max(interval2.0);\n\
    \    let end = interval1.1.min(interval2.1);\n    if start <= end {\n        for\
    \ i in 2..(end - start + 1) {\n            if (end - start + 1) % i == 0 {\n \
    \               return \"NO\".to_string();\n            }\n        }\n       \
    \ \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }", "   \
    \ let (start1, end1) = interval1;\n    let (start2, end2) = interval2;\n    let\
    \ mut intersection = (0, 0);\n    // TODO: Complete the code\n    \"NO\".to_string()",
  "    let (a, b) = interval1;\n    let (c, d) = interval2;\n    let (min, max) =\
    \ match a > c {\n        true => (a, d),\n        false => (c, b),\n    };\n \
    \   let i = max - min;\n    if i < 0 {\n        \"NO\".to_string()\n    } else\
    \ {\n        let result = (1..i).all(|x| i % x != 0);\n        if result {\n \
    \           \"YES\".to_string()\n        } else {\n            \"NO\".to_string()\n\
    \        }\n    }", "    let mut inter: Vec<_> = interval1.iter().chain(interval2.iter()).collect();\n\
    \    inter.sort();\n    let len = inter[2] - inter[1];\n    if len <= 1 {\n  \
    \      \"NO\".to_string()\n    } else {\n        (2..len).all(|x| len % x != 0)\
    \ as _\n    }", "    let intersection = if interval1.0 < interval2.0 {\n     \
    \   if interval1.1 < interval2.0 {\n            None\n        } else {\n     \
    \       Some((interval2.0, std::cmp::min(interval1.1, interval2.1)))\n       \
    \ }\n    } else {\n        if interval2.1 < interval1.0 {\n            None\n\
    \        } else {\n            Some((interval1.0, std::cmp::min(interval1.1, interval2.1)))\n\
    \        }\n    };\n    match intersection {\n        None => \"NO\".to_string(),\n\
    \        Some((a, b)) => {\n            if a == b {\n                \"NO\".to_string()\n\
    \            } else {\n                let len = b - a + 1;\n                if\
    \ is_prime(len) {\n                    \"YES\".to_string()\n                }\
    \ else {\n                    \"NO\".to_string()\n                }\n        \
    \    }\n        }\n    }", "    let (min, max) =\n        if interval1.0 > interval2.0\
    \ {\n            (interval1.0, interval2.1)\n        } else {\n            (interval2.0,\
    \ interval1.1)\n        };\n    let mut res = \"NO\";\n    if interval1.1 < interval2.0\
    \ || interval2.1 < interval1.0 {\n        res = \"NO\";\n    } else if (max -\
    \ min) == 1 {\n        res = \"YES\";\n    } else if (max - min) == 2 {\n    \
    \    res = \"NO\";\n    } else if (max - min) == 3 {\n        res = \"YES\";\n\
    \    } else if (max - min) % 2 == 0 {\n        res = \"NO\";\n    } else if (max\
    \ - min) % 3 == 0 {\n        res = \"NO\";\n    } else if (max - min) % 5 == 0\
    \ {\n        res = \"NO\";\n    } else if (max - min) % 7 == 0 {\n        res\
    \ = \"NO\";\n    } else if (max - min) % 11 == 0 {\n        res = \"NO\";\n  \
    \  } else if (max - min) % 13 == 0 {\n        res = \"NO\";\n    } else if (max\
    \ - min) % 17 == 0 {\n        res = \"NO\";\n    } else if (max - min) % 19 ==\
    \ 0 {\n        res = \"NO\";\n    } else if (max - min) % 23 == 0 {\n        res\
    \ = \"NO\";\n    } else if (max - min) % 29 == 0 {\n        res = \"NO\";\n  \
    \  } else if (max - min) % 31 == 0 {\n        res = \"NO\";\n    } else if (max\
    \ - min) % 37 == 0 {\n        res = \"NO\";\n    } else if (max - min) % 41 ==\
    \ 0 {\n        res = \"NO\";\n    } else if (max - min) % 43 == 0 {\n        res\
    \ = \"NO\";\n    } else if (max - min) % 47 == 0 {\n        res = \"NO\";\n  \
    \  } else if (max - min) % 53 == 0 {\n        res = \"NO\";\n    }", "    let\
    \ (start1, end1) = interval1;\n    let (start2, end2) = interval2;\n    let start\
    \ = std::cmp::max(start1, start2);\n    let end = std::cmp::min(end1, end2);\n\
    \    let interval = if start > end {\n        (0, 0)\n    } else {\n        (start,\
    \ end)\n    };\n    match interval {\n        (0, 0) => \"NO\".to_string(),\n\
    \        (a, b) => is_prime_interval(a, b)\n    }", "    let mut arr: Vec<_> =\
    \ vec![\n        interval1.0,\n        interval1.1,\n        interval2.0,\n  \
    \      interval2.1,\n    ].into_iter()\n        .sorted()\n        .collect();\n\
    \    if arr[1] < arr[2] {\n        return \"NO\".to_string();\n    }\n    arr[2]\
    \ = arr[1];\n    arr.remove(1);\n    arr.remove(0);\n    let result = arr[1] -\
    \ arr[0];\n    if result == 1 {\n        return \"NO\".to_string();\n    }\n \
    \   for x in 2..result {\n        if result % x == 0 {\n            return \"\
    NO\".to_string();\n        }\n    }\n    \"YES\".to_string()", "    let min =\
    \ interval1.0.max(interval2.0);\n    let max = interval1.1.min(interval2.1);\n\
    \    if min > max {\n        \"NO\".to_string()\n    } else {\n        let len\
    \ = max - min + 1;\n        let is_prime = (2..).any(|i| len % i == 0);\n    \
    \    if is_prime {\n            \"YES\".to_string()\n        } else {\n      \
    \      \"NO\".to_string()\n        }\n    }", "    let (l1, r1) = interval1;\n\
    \    let (l2, r2) = interval2;\n    if (l1 >= r2) || (l2 >= r1) {\n        return\
    \ \"NO\".to_string();\n    }\n    let mut intersection = (std::cmp::max(l1, l2),\
    \ std::cmp::min(r1, r2));\n    intersection.1 -= intersection.0;\n    intersection.1\
    \ += 1;\n    if intersection.1 == 1 {\n        return \"NO\".to_string();\n  \
    \  }\n    let mut i = 2;\n    while i * i <= intersection.1 {\n        if intersection.1\
    \ % i == 0 {\n            return \"NO\".to_string();\n        }\n        i +=\
    \ 1;\n    }\n    \"YES\".to_string()", "  let (mut i1_min, mut i1_max) = interval1;\n\
    \  let (mut i2_min, mut i2_max) = interval2;\n  let mut intersects = false;\n\
    \  if i1_min > i1_max {\n    std::mem::swap(&mut i1_min, &mut i1_max);\n  }\n\
    \  if i2_min > i2_max {\n    std::mem::swap(&mut i2_min, &mut i2_max);\n  }\n\
    \  if i1_min < i2_min {\n    intersects = i1_max >= i2_min;\n  } else {\n    intersects\
    \ = i2_max >= i1_min;\n  }\n  if intersects {\n    let mut x = [i1_min, i1_max,\
    \ i2_min, i2_max];\n    x.sort();\n    let length = x[2] - x[1];\n    if length\
    \ == 1 {\n      return \"NO\".to_string();\n    }\n    for i in 2..length {\n\
    \      if length % i == 0 {\n        return \"NO\".to_string();\n      }\n   \
    \ }\n    return \"YES\".to_string();\n  }\n  \"NO\".to_string()", "    let (lhs_start,\
    \ lhs_end) = interval1;\n    let (rhs_start, rhs_end) = interval2;\n    if lhs_end\
    \ < rhs_start || rhs_end < lhs_start {\n        return \"NO\".to_string();\n \
    \   }\n    let length = if lhs_start < rhs_start {\n        if lhs_end < rhs_end\
    \ {\n            lhs_end - rhs_start\n        } else {\n            rhs_end -\
    \ rhs_start\n        }\n    } else {\n        if lhs_end < rhs_end {\n       \
    \     lhs_end - lhs_start\n        } else {\n            rhs_end - lhs_start\n\
    \        }\n    };\n    if length == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    if is_prime(length) {\n        return \"YES\".to_string();\n    }\n\
    \    \"NO\".to_string()", "    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let start = if a < c { c } else { a };\n    let end = if b < d { b } else\
    \ { d };\n    if start >= end {\n        return \"NO\".to_string();\n    }\n\n\
    \    if is_prime(end - start) {\n        \"YES\".to_string()\n    } else {\n \
    \       \"NO\".to_string()\n    }", "    let int_vec = vec![interval1, interval2];\n\
    \    let int_vec_sorted = sort_intervals(int_vec);\n    match int_vec_sorted {\n\
    \        (a, b) if a > b => return \"NO\".to_string(),\n        (a, b) if a ==\
    \ b => return \"YES\".to_string(),\n        (a, b) => {\n            let r_vec\
    \ = (a + 1..b).collect::<Vec<isize>>();\n            r_vec.iter().fold(true, |acc,\
    \ x| {\n                if !is_prime(*x) {\n                    return false;\n\
    \                }\n                acc\n            })\n        }\n    }", " \
    \   let inter_start = interval1.0.max(interval2.0);\n    let inter_end = interval1.1.min(interval2.1);\n\
    \    if inter_start > inter_end {\n        \"NO\".to_string()\n    } else {\n\
    \        let diff = (inter_end - inter_start + 1) as usize;\n        if diff ==\
    \ 1 {\n            \"NO\".to_string()\n        } else {\n            for n in\
    \ 2..diff {\n                if diff % n == 0 {\n                    return \"\
    NO\".to_string();\n                }\n            }\n            \"YES\".to_string()\n\
    \        }\n    }", "    let (start1, end1) = interval1;\n    let (start2, end2)\
    \ = interval2;\n    let interval1_len = end1 - start1;\n    let interval2_len\
    \ = end2 - start2;\n    let intersect_start = start1.max(start2);\n    let intersect_end\
    \ = end1.min(end2);\n    let intersect_len = intersect_end - intersect_start;\n\
    \    let res = intersect_len.is_prime();\n    let st = (intersect_len > 0) &&\
    \ res;\n    if st {\n        \"YES\".to_string()\n    } else {\n        \"NO\"\
    .to_string()\n    }", "    let mut start = std::cmp::max(interval1.0, interval2.0);\n\
    \    let mut end = std::cmp::min(interval1.1, interval2.1);\n    if start > end\
    \ {\n        return \"NO\".to_string();\n    }\n    if start == end {\n      \
    \  return \"YES\".to_string();\n    }\n    let mut ans = \"NO\";\n    for i in\
    \ 2..=end {\n        if start % i == 0 && end % i == 0 {\n            ans = \"\
    YES\";\n            break;\n        }\n    }\n    ans.to_string()", "    let (i1_start,\
    \ i1_end) = interval1;\n    let (i2_start, i2_end) = interval2;\n    let m_start\
    \ = i1_start.max(i2_start);\n    let m_end = i1_end.min(i2_end);\n    if m_start\
    \ > m_end {\n        return \"NO\".to_string();\n    }\n    if m_start == m_end\
    \ {\n        return \"YES\".to_string();\n    }\n    let len = m_end - m_start\
    \ + 1;\n    if len == 2 {\n        return \"YES\".to_string();\n    }\n    for\
    \ i in 2..len {\n        if len % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()", "    let (i1_start, i1_end) = interval1;\n\
    \    let (i2_start, i2_end) = interval2;\n    let i_start = if i1_start > i2_start\
    \ {i1_start} else {i2_start};\n    let i_end = if i1_end < i2_end {i1_end} else\
    \ {i2_end};\n    if i_start <= i_end {\n        if (i_end - i_start) % 2 == 0\
    \ {\n            \"NO\".to_string()\n        } else {\n            \"YES\".to_string()\n\
    \        }\n    } else {\n        \"NO\".to_string()\n    }", "    let mut first\
    \ = interval1.0;\n    let mut second = interval1.1;\n    if interval1.0 > interval1.1\
    \ {\n        first = interval1.1;\n        second = interval1.0;\n    }\n    let\
    \ mut first2 = interval2.0;\n    let mut second2 = interval2.1;\n    if interval2.0\
    \ > interval2.1 {\n        first2 = interval2.1;\n        second2 = interval2.0;\n\
    \    }\n    if first >= second2 || second <= first2 {\n        return \"NO\".to_string();\n\
    \    }\n    let mut a = first2;\n    if first2 < first {\n        a = first;\n\
    \    }\n    let mut b = second2;\n    if second2 > second {\n        b = second;\n\
    \    }\n    let mut diff = b - a;\n    diff += 1;\n    let mut prime = true;\n\
    \    for num in 2..diff {\n        if diff % num == 0 {\n            prime = false;\n\
    \            break;\n        }\n    }\n    if prime {\n        return \"YES\"\
    .to_string();\n    }\n    return \"NO\".to_string();", "    let (i1, i2) = (interval1,\
    \ interval2);\n    let (i1_min, i1_max) = (std::cmp::min(i1.0, i1.1), std::cmp::max(i1.0,\
    \ i1.1));\n    let (i2_min, i2_max) = (std::cmp::min(i2.0, i2.1), std::cmp::max(i2.0,\
    \ i2.1));\n    let (start, end) = (std::cmp::max(i1_min, i2_min), std::cmp::min(i1_max,\
    \ i2_max));\n    if start > end {\n        return \"NO\".to_string();\n    }\n\
    \n    let mut check = end - start;\n    check += 1;\n    println!(\"len {}\",\
    \ check);\n    for i in 2..check {\n        if check % i == 0 {\n            return\
    \ \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()", "    // your\
    \ code here\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n    if\
    \ a < c {\n        intersection((c, d), (a, b))\n    } else if b < c {\n     \
    \   \"NO\".to_string()\n    } else {\n        let mut length = b - c + 1;\n  \
    \      if length < 0 {\n            length += std::isize::MAX + 1;\n        }\n\
    \        match length {\n            2 | 3 | 5 | 7 | 11 | 13 | 17 | 19 | 23 |\
    \ 29 | 31 | 37 | 41 | 43 | 47 | 53 | 59 | 61 | 67 | 71 | 73 | 79 | 83 | 89 | 97\
    \ | 101 | 103 | 107 | 109 | 113 | 127 | 131 | 137 | 139 | 149 | 151 | 157 | 163\
    \ | 167 | 173 | 179 | 181 | 191 | 193 | 197 | 199 | 211 | 223 | 227 | 229 | 233\
    \ | 239 | 241 | 251 | 257 | 263 | 269 | 271 | 277 | 281 | 283 | 293 | 307 | 311\
    \ | 313 | 317 | 331 | 337 | 347 | 349 | 353 | 359 | 367 | 373 | 379 | 383 | 389\
    \ | 397 | 401 | 409 | 419 | 421 | 431 | 433 | 439 | 443 | 449 | 457 | 461 | 463\
    \ | 467 | 479 | 487 | 491 | 499 | 503 | 509 | 521 | 523 | 541 | 547 | 557 | 563\
    \ | 569 | 571 | 577 | 587 | 593 | 599 | 601 | 607 | 613 | 617 | 619 | 631 | 641\
    \ | 643 | 647 | 653 | 659 | 661 | 673 | 677 | 683 | 691 | 701 | 709 | 719 | 727\
    \ | 733 | 739 | 743 | 751 | 757 | 761 | 769 | 773 | 787 | 797 | 809 | 811 | 821\
    \ | 823 | 827 | 829 | 839 | 853 | 857 | 859 | 863 | 877 | 881 | 883 | 887 | 907\
    \ | 911 | 919 | 929 | 937 | 941 | 947 | 953 |", "    let (i1_start, i1_end) =\
    \ interval1;\n    let (i2_start, i2_end) = interval2;\n    let mut max_start =\
    \ i1_start;\n    let mut min_end = i1_end;\n    if i2_start > max_start {\n  \
    \      max_start = i2_start;\n    }\n    if i2_end < min_end {\n        min_end\
    \ = i2_end;\n    }\n    if max_start > min_end {\n        return \"NO\".to_string();\n\
    \    }\n    let diff = (min_end - max_start + 1) as usize;\n    for i in 2..=diff\
    \ {\n        if diff % i == 0 {\n            return \"NO\".to_string();\n    \
    \    }\n    }\n    \"YES\".to_string()", "    let mut i1 = interval1;\n    let\
    \ mut i2 = interval2;\n    if i1.0 > i1.1 {\n        i1 = (i1.1, i1.0);\n    }\n\
    \    if i2.0 > i2.1 {\n        i2 = (i2.1, i2.0);\n    }\n    if i1.1 < i2.0 ||\
    \ i2.1 < i1.0 {\n        return \"NO\".to_string();\n    }\n    let mut intersection\
    \ = (0, 0);\n    if i1.0 < i2.0 {\n        intersection.0 = i2.0;\n    } else\
    \ {\n        intersection.0 = i1.0;\n    }\n    if i1.1 < i2.1 {\n        intersection.1\
    \ = i1.1;\n    } else {\n        intersection.1 = i2.1;\n    }\n    let mut delta\
    \ = (intersection.1 - intersection.0) as usize;\n    if delta == 0 {\n       \
    \ return \"NO\".to_string();\n    }\n    if delta == 1 {\n        return \"YES\"\
    .to_string();\n    }\n    for i in 2..=delta {\n        if delta % i == 0 {\n\
    \            return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()",
  "    if interval1.0 <= interval2.1 && interval2.0 <= interval1.1 {\n        let\
    \ (start, end) = (\n            std::cmp::max(interval1.0, interval2.0),\n   \
    \         std::cmp::min(interval1.1, interval2.1),\n        );\n        let len\
    \ = end - start + 1;\n        if len > 1 && !(2..=(len as f64).sqrt() as isize).any(|x|\
    \ len % x == 0) {\n            \"YES\".to_string()\n        } else {\n       \
    \     \"NO\".to_string()\n        }\n    } else {\n        \"NO\".to_string()\n\
    \    }", "    if interval1.0 > interval2.1 || interval2.0 > interval1.1 {\n  \
    \      return \"NO\".to_string();\n    }\n    let max = [interval1.0, interval2.0].iter().max().unwrap();\n\
    \    let min = [interval1.1, interval2.1].iter().min().unwrap();\n    if max ==\
    \ min {\n        return \"YES\".to_string();\n    }\n    if is_prime(*max - *min\
    \ + 1) {\n        return \"YES\".to_string();\n    }\n    \"NO\".to_string()",
  "    let in_interval_1 = interval1.0 <= interval2.0 && interval2.0 <= interval1.1;\n\
    \    let in_interval_2 = interval2.0 <= interval1.0 && interval1.0 <= interval2.1;\n\
    \    let start = if in_interval_1 {\n        interval2.0\n    } else if in_interval_2\
    \ {\n        interval1.0\n    } else {\n        return \"NO\".to_string();\n \
    \   };\n    let end = if in_interval_1 {\n        interval1.1\n    } else if in_interval_2\
    \ {\n        interval2.1\n    } else {\n        return \"NO\".to_string();\n \
    \   };\n    let len = (end - start + 1) as usize;\n    let is_prime = (2..len/2+1).all(|i|\
    \ len % i != 0);\n    if is_prime {\n        \"YES\".to_string()\n    } else {\n\
    \        \"NO\".to_string()\n    }", "    if interval1.0 > interval2.1 || interval2.0\
    \ > interval1.1 {\n        \"NO\".to_string()\n    } else {\n        let max =\
    \ if interval1.0 < interval2.0 {\n            interval2.0\n        } else {\n\
    \            interval1.0\n        };\n        let min = if interval1.1 < interval2.1\
    \ {\n            interval1.1\n        } else {\n            interval2.1\n    \
    \    };\n        if is_prime(min - max + 1) {\n            \"YES\".to_string()\n\
    \        } else {\n            \"NO\".to_string()\n        }\n    }", "    let\
    \ (a, b) = interval1;\n    let (c, d) = interval2;\n    if a > d || b < c {\n\
    \        return \"NO\".to_string();\n    }\n    let mut x = std::cmp::max(a, c);\n\
    \    let mut y = std::cmp::min(b, d);\n    if x < 0 {\n        x = -x;\n    }\n\
    \    if y < 0 {\n        y = -y;\n    }\n    let mut k = 2;\n    let mut ans =\
    \ true;\n    while k * k <= y {\n        if x % k == 0 || y % k == 0 {\n     \
    \       ans = false;\n            break;\n        }\n        k += 1;\n    }\n\
    \    if ans {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n\
    \    }", "    if interval1.0 > interval2.1 || interval2.0 > interval1.1 {\n  \
    \      return \"NO\".to_string();\n    }\n    let start = max(interval1.0, interval2.0);\n\
    \    let end = min(interval1.1, interval2.1);\n    if end <= start {\n       \
    \ return \"NO\".to_string();\n    }\n    let len = end - start + 1;\n    if is_prime(len)\
    \ {\n        return \"YES\".to_string();\n    }\n    \"NO\".to_string()", "  \
    \  let mut result = (0, 0);\n    if interval1.0 < interval2.0 {\n        result.0\
    \ = interval2.0;\n    } else {\n        result.0 = interval1.0;\n    }\n    if\
    \ interval1.1 < interval2.1 {\n        result.1 = interval1.1;\n    } else {\n\
    \        result.1 = interval2.1;\n    }\n    if result.0 > result.1 {\n      \
    \  return \"NO\".to_string();\n    }\n    if result.0 == result.1 {\n        return\
    \ \"YES\".to_string();\n    }\n    if result.1 - result.0 == 1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let mut total = 0;\n    for i in result.0..result.1\
    \ {\n        total += i;\n    }\n    if total % 2 == 0 {\n        return \"NO\"\
    .to_string();\n    }\n    for i in 2..total {\n        if total % i == 0 {\n \
    \           return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()",
  "    let (min, max) = if interval1.0 < interval2.0 {\n        (interval2.0, interval1.1)\n\
    \    } else {\n        (interval1.0, interval2.1)\n    };\n    if min > max {\n\
    \        return \"NO\".to_string();\n    }\n    let distance = (max - min) + 1;\n\
    \    let result = if distance < 2 {\n        \"NO\"\n    } else if distance ==\
    \ 2 {\n        \"YES\"\n    } else {\n        let mut prime = true;\n        for\
    \ i in 2..distance {\n            if distance % i == 0 {\n                prime\
    \ = false;\n                break;\n            }\n        }\n        if prime\
    \ {\n            \"YES\"\n        } else {\n            \"NO\"\n        }\n  \
    \  };\n    result.to_string()", "    if interval1.0 > interval2.1 || interval2.0\
    \ > interval1.1 {\n        return \"NO\".to_string();\n    }\n    let start =\
    \ if interval1.0 > interval2.0 {\n        interval1.0\n    } else {\n        interval2.0\n\
    \    };\n    let end = if interval1.1 < interval2.1 {\n        interval1.1\n \
    \   } else {\n        interval2.1\n    };\n    let len = (end - start) + 1;\n\
    \    for i in 2..len {\n        if len % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()", "    let (start1, end1) = interval1;\n\
    \    let (start2, end2) = interval2;\n    let (mut start, mut end) = (start1,\
    \ end1);\n    let mut is_intersect = true;\n    if start1 > start2 {\n       \
    \ start = start2;\n    }\n    if end1 < end2 {\n        end = end2;\n    }\n \
    \   if start > end {\n        is_intersect = false;\n    }\n    if !is_intersect\
    \ {\n        return \"NO\".to_string();\n    }\n    let mut is_prime = true;\n\
    \    let length = end - start + 1;\n    for i in 2..length {\n        if length\
    \ % i == 0 {\n            is_prime = false;\n            break;\n        }\n \
    \   }\n    if is_prime {\n        \"YES\".to_string()\n    } else {\n        \"\
    NO\".to_string()\n    }", "    fn is_prime(num: isize) -> bool {\n        if num\
    \ <= 1 {\n            return false;\n        }\n        if num <= 3 {\n      \
    \      return true;\n        }\n        if num % 2 == 0 || num % 3 == 0 {\n  \
    \          return false;\n        }\n        let mut i = 5;\n        while i *\
    \ i <= num {\n            if num % i == 0 || num % (i + 2) == 0 {\n          \
    \      return false;\n            }\n            i += 6;\n        }\n        true\n\
    \    }\n    let (mut i1_start, mut i1_end) = interval1;\n    let (mut i2_start,\
    \ mut i2_end) = interval2;\n    if i1_start > i1_end {\n        std::mem::swap(&mut\
    \ i1_start, &mut i1_end);\n    }\n    if i2_start > i2_end {\n        std::mem::swap(&mut\
    \ i2_start, &mut i2_end);\n    }\n    if i1_end < i2_start || i2_end < i1_start\
    \ {\n        return \"NO\".to_string();\n    }\n    let mut left = if i1_start\
    \ < i2_start { i2_start } else { i1_start };\n    let mut right = if i1_end <\
    \ i2_end { i1_end } else { i2_end };\n    if left > right {\n        std::mem::swap(&mut\
    \ left, &mut right);\n    }\n    if is_prime(right - left + 1) {\n        \"YES\"\
    .to_string()\n    } else {\n        \"NO\".to_string()\n    }", "    let (start1,\
    \ end1) = interval1;\n    let (start2, end2) = interval2;\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    if start > end {\n        \"NO\".to_string()\n\
    \    } else {\n        if is_prime(end - start + 1) {\n            \"YES\".to_string()\n\
    \        } else {\n            \"NO\".to_string()\n        }\n    }", "    let\
    \ mut inter: Vec<isize> = Vec::new();\n    if interval1.0 > interval2.0 {\n  \
    \      inter.push(interval1.0);\n    } else {\n        inter.push(interval2.0);\n\
    \    }\n    if interval1.1 < interval2.1 {\n        inter.push(interval1.1);\n\
    \    } else {\n        inter.push(interval2.1);\n    }\n    let mut res = \"NO\"\
    ;\n    if inter[0] <= inter[1] {\n        if (inter[1] - inter[0]) % 2 == 0 {\n\
    \            res = \"YES\";\n        }\n    }\n    res.to_string()", "    let\
    \ mut sorted_intervals = vec![interval1, interval2];\n    sorted_intervals.sort_by(|a,\
    \ b| a.0.cmp(&b.0));\n    let (start, end) = if sorted_intervals[0].1 >= sorted_intervals[1].0\
    \ {\n        (sorted_intervals[1].0, sorted_intervals[0].1)\n    } else {\n  \
    \      (0, 0)\n    };\n    let prime = (start + 1..end).any(|i| primes::is_prime(i\
    \ as usize));\n    if start == 0 {\n        String::from(\"NO\")\n    } else if\
    \ prime {\n        String::from(\"YES\")\n    } else {\n        String::from(\"\
    NO\")\n    }", "    let mut res = \"NO\";\n    if (interval1.0 <= interval2.0\
    \ && interval2.0 <= interval1.1) ||\n       (interval2.0 <= interval1.0 && interval1.0\
    \ <= interval2.1) {\n        let mut lower = interval1.0.max(interval2.0);\n \
    \       let mut upper = interval1.1.min(interval2.1);\n        if upper - lower\
    \ < 1 {\n            lower = lower + 1;\n        }\n        if is_prime(upper\
    \ - lower) {\n            res = \"YES\";\n        }\n    }\n    res.to_string()",
  "    let mut start = match interval1.0 < interval2.0 {\n        true => interval2.0,\n\
    \        false => interval1.0,\n    };\n    let mut end = match interval1.1 <\
    \ interval2.1 {\n        true => interval1.1,\n        false => interval2.1,\n\
    \    };\n    let mut result = String::new();\n    if start > end {\n        result.push_str(\"\
    NO\");\n    } else {\n        let mut is_prime = true;\n        for i in 2..end\
    \ {\n            if start % i == 0 {\n                is_prime = false;\n    \
    \            break;\n            }\n        }\n        if is_prime {\n       \
    \     result.push_str(\"YES\");\n        } else {\n            result.push_str(\"\
    NO\");\n        }\n    }\n    result", "    let (start1, end1) = interval1;\n\
    \    let (start2, end2) = interval2;\n    let max_start = std::cmp::max(start1,\
    \ start2);\n    let min_end = std::cmp::min(end1, end2);\n    let len = min_end\
    \ - max_start;\n    if len > 0 {\n        if (2..len).any(|n| len % n == 0) {\n\
    \            return \"NO\".to_string();\n        }\n        return \"YES\".to_string();\n\
    \    }\n    \"NO\".to_string()", "    if interval1.0 > interval2.1 || interval2.0\
    \ > interval1.1 {\n        \"NO\".to_string()\n    } else {\n        let mut intersec\
    \ = (\n            cmp::max(interval1.0, interval2.0),\n            cmp::min(interval1.1,\
    \ interval2.1),\n        );\n        if intersec.0 > intersec.1 {\n          \
    \  intersec = (intersec.1, intersec.0);\n        }\n        if is_prime(intersec.1\
    \ - intersec.0 + 1) {\n            \"YES\".to_string()\n        } else {\n   \
    \         \"NO\".to_string()\n        }\n    }", "    // this is not the most\
    \ efficient way, but it seems to work in reasonable time\n    let (start1, end1)\
    \ = interval1;\n    let (start2, end2) = interval2;\n    let mut counts = 0;\n\
    \    for num in (start1..end1 + 1).rev() {\n        for num2 in start2..end2 +\
    \ 1 {\n            if num == num2 {\n                counts += 1;\n          \
    \  }\n        }\n    }\n    if counts == 0 {\n        return \"NO\".to_string();\n\
    \    }\n    let mut primes = vec![false, false];\n    let mut primes_count = 0;\n\
    \    while primes.len() <= counts as usize {\n        let mut prime = true;\n\
    \        for i in 2..primes.len() {\n            if primes[i] && primes_count\
    \ % i == 0 {\n                prime = false;\n                break;\n       \
    \     }\n        }\n        if prime {\n            primes.push(true);\n     \
    \       primes_count += 1;\n        } else {\n            primes.push(false);\n\
    \        }\n    }\n    if primes[counts as usize] {\n        return \"YES\".to_string();\n\
    \    }\n    \"NO\".to_string()", "    let start = interval1.0.max(interval2.0);\n\
    \    let end = interval1.1.min(interval2.1);\n    if start > end {\n        \"\
    NO\".to_string()\n    } else {\n        let mut is_prime = true;\n        for\
    \ x in 2..=(end - start) {\n            if (end - start) % x == 0 {\n        \
    \        is_prime = false;\n                break;\n            }\n        }\n\
    \        if is_prime {\n            \"YES\".to_string()\n        } else {\n  \
    \          \"NO\".to_string()\n        }\n    }", "    let (mut start, mut end)\
    \ = (0, 0);\n    if interval1.0 > interval2.0 {\n        start = interval1.0;\n\
    \    } else {\n        start = interval2.0;\n    }\n    if interval1.1 < interval2.1\
    \ {\n        end = interval1.1;\n    } else {\n        end = interval2.1;\n  \
    \  }\n    if start >= end {\n        return \"NO\".to_string();\n    }\n    let\
    \ mut is_prime = true;\n    for i in 2..end {\n        if i * i > end {\n    \
    \        break;\n        }\n        if end % i == 0 {\n            is_prime =\
    \ false;\n            break;\n        }\n    }\n    if is_prime {\n        return\
    \ \"YES\".to_string();\n    }\n    return \"NO\".to_string();", "    // TODO:\
    \ add your code here\n    unimplemented!()", "    let start = interval1.0.max(interval2.0);\n\
    \    let end = interval1.1.min(interval2.1);\n    if start > end {\n        return\
    \ \"NO\".to_string();\n    }\n    let result = (end - start + 1) as usize;\n \
    \   if is_prime(result) {\n        return \"YES\".to_string();\n    }\n    return\
    \ \"NO\".to_string();", "    let (begin1, end1) = interval1;\n    let (begin2,\
    \ end2) = interval2;\n    if begin1 > end1 || begin2 > end2 {\n        \"NO\"\
    .to_string()\n    } else if end1 < begin2 || end2 < begin1 {\n        \"NO\".to_string()\n\
    \    } else {\n        let begin = begin1.max(begin2);\n        let end = end1.min(end2);\n\
    \        let intersect = (begin, end);\n        if is_prime(intersect.1 - intersect.0\
    \ + 1) {\n            \"YES\".to_string()\n        } else {\n            \"NO\"\
    .to_string()\n        }\n    }", "    // calculate the lower bound\n    let low\
    \ = std::cmp::max(interval1.0, interval2.0);\n    // calculate the upper bound\n\
    \    let high = std::cmp::min(interval1.1, interval2.1);\n    // create a range\
    \ from low to high\n    let range = low..high;\n    // an empty vec for the primes\n\
    \    let mut primes = Vec::new();\n    // loop from 2 to one more than the high\
    \ bound\n    for i in 2..high + 1 {\n        // if the range has any numbers that\
    \ is divisible\n        // by i then return \"NO\"\n        if range.clone().any(|x|\
    \ x % i == 0) {\n            // return \"NO\"\n            return \"NO\".to_string();\n\
    \        }\n        // if any number in the range is a prime then\n        //\
    \ push it to the vec\n        if range.clone().any(|x| x == i) {\n           \
    \ primes.push(i);\n        }\n    }\n    // if the vec has 2 or more numbers then\
    \ return \"YES\"\n    if primes.len() >= 2 {\n        return \"YES\".to_string();\n\
    \    }\n    // if the high number is prime then\n    // return \"YES\"\n    if\
    \ primes.iter().any(|&x| x == high) {\n        return \"YES\".to_string();\n \
    \   }\n    // if the high and low are equal then\n    // return \"YES\"\n    if\
    \ high == low {\n        return \"YES\".to_string();\n    }\n    // if it reaches\
    \ here then return \"NO\"\n    \"NO\".to_string()", "    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    let mut x: Vec<isize> = vec![a, b, c, d];\n\
    \    x.sort();\n    let (a, b, c, d) = (x[0], x[1], x[2], x[3]);\n    let overlap\
    \ = if (a..=b).contains(&c) {\n        if c == d { c } else { c + 1 }\n    } else\
    \ if (a..=b).contains(&d) {\n        if a == d { a } else { d - 1 }\n    } else\
    \ {\n        return \"NO\".to_string();\n    };\n    if (2..=2).contains(&overlap)\
    \ || overlap % 2 == 0 {\n        \"NO\".to_string()\n    } else {\n        (3..=(overlap\
    \ as f64).sqrt() as isize).fold(\"YES\".to_string(), |acc, x| {\n            if\
    \ overlap % x == 0 {\n                return \"NO\".to_string();\n           \
    \ }\n            acc\n        })\n    }", "    let mut res = (std::cmp::max(interval1.0,\
    \ interval2.0), std::cmp::min(interval1.1, interval2.1));\n    if res.0 >= res.1\
    \ {\n        res = (0, 0);\n    }\n    if is_prime(res.1 - res.0) {\n        \"\
    YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }", "    let\
    \ (a, b) = interval1;\n    let (c, d) = interval2;\n    let start = max(a, c);\n\
    \    let end = min(b, d);\n    if end <= start {\n        return \"NO\".to_string();\n\
    \    }\n    let length = end - start;\n    let is_prime = length > 1 && (2..length).all(|i|\
    \ length % i != 0);\n    if is_prime {\n        \"YES\".to_string()\n    } else\
    \ {\n        \"NO\".to_string()\n    }", "    if !intersect(&interval1, &interval2)\
    \ { return \"NO\".to_string(); }\n    let (start, end) = intersection_interval(&interval1,\
    \ &interval2);\n    if end - start + 1 > 2 && prime(end - start + 1) { \"YES\"\
    .to_string() } else { \"NO\".to_string() }", "  let (start1, end1) = interval1;\n\
    \  let (start2, end2) = interval2;\n  let min_start = cmp::max(start1, start2);\n\
    \  let max_end = cmp::min(end1, end2);\n  if min_start > max_end {\n    \"NO\"\
    .to_string()\n  } else {\n    let diff = (max_end - min_start) + 1;\n    if diff\
    \ == 1 {\n      \"NO\".to_string()\n    } else {\n      let mut is_prime = true;\n\
    \      for i in 2..diff {\n        if diff % i == 0 {\n          is_prime = false;\n\
    \          break;\n        }\n      }\n      if is_prime {\n        \"YES\".to_string()\n\
    \      } else {\n        \"NO\".to_string()\n      }\n    }\n  }", "    let (a,\
    \ b) = interval1;\n    let (c, d) = interval2;\n    let mut left = max(a, c);\n\
    \    let mut right = min(b, d);\n    let mut length = right - left;\n    if length\
    \ < 0 {\n        length = 0;\n    }\n    if length == 0 {\n        return \"NO\"\
    .to_string();\n    }\n    // println!(\"left = {}\", left);\n    // println!(\"\
    right = {}\", right);\n    // println!(\"length = {}\", length);\n    if length\
    \ == 1 {\n        return \"NO\".to_string();\n    }\n    for i in 2..(length -\
    \ 1) {\n        if length % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()", "    let (min, max) = get_intersection_length(interval1,\
    \ interval2);\n    match is_prime(max - min) {\n        true => \"YES\".to_string(),\n\
    \        false => \"NO\".to_string(),\n    }", "  if interval1.0 > interval2.1\
    \ || interval2.0 > interval1.1 {\n    return \"NO\".to_string();\n  }\n  let mut\
    \ lower = std::cmp::max(interval1.0, interval2.0);\n  let mut upper = std::cmp::min(interval1.1,\
    \ interval2.1);\n  if lower > upper {\n    return \"NO\".to_string();\n  }\n \
    \ let len = upper - lower + 1;\n  if len == 2 {\n    return \"YES\".to_string();\n\
    \  }\n  let mut primality = false;\n  for i in (2..=(len / 2) as isize).rev()\
    \ {\n    if len % i == 0 {\n      primality = true;\n      break;\n    }\n  }\n\
    \  if primality {\n    \"NO\".to_string()\n  } else {\n    \"YES\".to_string()\n\
    \  }", "    let (start1, end1) = interval1;\n    let (start2, end2) = interval2;\n\
    \    let min = if start1 > start2 { start1 } else { start2 };\n    let max = if\
    \ end1 < end2 { end1 } else { end2 };\n    let diff = if min <= max { max - min\
    \ } else { 0 };\n    match diff {\n        0 => \"NO\".to_string(),\n        1\
    \ => \"NO\".to_string(),\n        2 => \"YES\".to_string(),\n        3 => \"YES\"\
    .to_string(),\n        _ => \"NO\".to_string(),\n    }", "    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    if a > d || b < c {\n        return \"NO\".to_string();\n\
    \    }\n    let l = std::cmp::max(a, c) - std::cmp::min(b, d);\n    if l > 1 &&\
    \ (2..l).any(|x| l % x == 0) {\n        return \"NO\".to_string();\n    }\n  \
    \  \"YES\".to_string()", "    let mut start = interval1.0;\n    let mut end =\
    \ interval1.1;\n    let mut interval = interval2;\n    if start > end {\n    \
    \    start = interval2.0;\n        end = interval2.1;\n        interval = interval1;\n\
    \    }\n    if interval.0 <= start && interval.1 >= end {\n        if start <\
    \ end {\n            return if is_prime(end - start) { \"YES\".to_string() } else\
    \ { \"NO\".to_string() };\n        }\n        return \"YES\".to_string();\n  \
    \  }\n    if interval.0 <= start && interval.1 >= start {\n        return if is_prime(interval.1\
    \ - start) { \"YES\".to_string() } else { \"NO\".to_string() };\n    }\n    if\
    \ interval.0 <= end && interval.1 >= end {\n        return if is_prime(end - interval.0)\
    \ { \"YES\".to_string() } else { \"NO\".to_string() };\n    }\n    \"NO\".to_string()",
  "    match (interval1, interval2) {\n        ((a, b), (c, d)) if (b < c) || (d <\
    \ a) => \"NO\".to_string(),\n        ((a, b), (c, d)) => if is_prime(b.min(d)\
    \ - a.max(c) + 1) {\n            \"YES\".to_string()\n        } else {\n     \
    \       \"NO\".to_string()\n        }\n    }", "    let (start1, end1) = interval1;\n\
    \    let (start2, end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n\
    \        return \"NO\".to_string();\n    }\n    let start = start1.max(start2);\n\
    \    let end = end1.min(end2);\n    if is_prime(end - start + 1) {\n        \"\
    YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }", "    let\
    \ start = std::cmp::max(interval1.0, interval2.0);\n    let end = std::cmp::min(interval1.1,\
    \ interval2.1);\n    if start >= end {\n        \"NO\".to_string()\n    } else\
    \ {\n        let (mut i, mut is_prime) = (start, true);\n        while i < end\
    \ {\n            if end % i == 0 {\n                is_prime = false;\n      \
    \          break;\n            }\n            i += 1;\n        }\n        if is_prime\
    \ {\n            \"YES\".to_string()\n        } else {\n            \"NO\".to_string()\n\
    \        }\n    }", "    let mut i1 = interval1;\n    let mut i2 = interval2;\n\
    \    if i1.0 > i1.1 {\n        std::mem::swap(&mut i1.0, &mut i1.1);\n    }\n\
    \    if i2.0 > i2.1 {\n        std::mem::swap(&mut i2.0, &mut i2.1);\n    }\n\
    \    if i1.1 < i2.0 || i2.1 < i1.0 {\n        return \"NO\".to_string();\n   \
    \ }\n    let a = std::cmp::max(i1.0, i2.0);\n    let b = std::cmp::min(i1.1, i2.1);\n\
    \    let d = b - a + 1;\n    if d == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    let mut i = 2;\n    while i * i <= d {\n        if d % i == 0 {\n\
    \            return \"NO\".to_string();\n        }\n        i += 1;\n    }\n \
    \   \"YES\".to_string()", "  let int1 = (interval1.0..interval1.1).collect::<Vec<isize>>();\n\
    \  let int2 = (interval2.0..interval2.1).collect::<Vec<isize>>();\n  let inter\
    \ = int1.intersection(&int2).collect::<Vec<&isize>>();\n  if inter.len() == 0\
    \ {\n    return \"NO\".to_string();\n  }\n  let l = inter.len() as isize;\n  if\
    \ is_prime(l) {\n    return \"YES\".to_string();\n  }\n  \"NO\".to_string()",
  "    let a = interval1.0.max(interval2.0);\n    let b = interval1.1.min(interval2.1);\n\
    \    if a > b {\n        return \"NO\".to_string();\n    }\n    let n = b - a\
    \ + 1;\n    if n < 2 {\n        return \"NO\".to_string();\n    }\n    for i in\
    \ 2..n {\n        if n % i == 0 {\n            return \"NO\".to_string();\n  \
    \      }\n    }\n    \"YES\".to_string()", "    let (a, b) = interval1;\n    let\
    \ (c, d) = interval2;\n    let mut min = std::cmp::max(a, c);\n    let mut max\
    \ = std::cmp::min(b, d);\n    while min <= max {\n        if is_prime(min) {\n\
    \            return \"YES\".to_string();\n        }\n        min += 1;\n    }\n\
    \    \"NO\".to_string()", "    let (left, right) = (\n        cmp::max(interval1.0,\
    \ interval2.0),\n        cmp::min(interval1.1, interval2.1)\n    );\n    if left\
    \ > right {\n        \"NO\".to_string()\n    } else {\n        let length = (right\
    \ - left + 1) as usize;\n        if length == 1 {\n            \"NO\".to_string()\n\
    \        } else {\n            if (2..length).all(|x| length % x != 0) {\n   \
    \             \"YES\".to_string()\n            } else {\n                \"NO\"\
    .to_string()\n            }\n        }\n    }", "    let (start1, end1) = interval1;\n\
    \    let (start2, end2) = interval2;\n    if end1 < start2 || end2 < start1 {\n\
    \        return \"NO\".to_string();\n    }\n    let (start, end) = (max(start1,\
    \ start2), min(end1, end2));\n    if end - start == 1 {\n        return \"NO\"\
    .to_string();\n    }\n    if is_prime(end - start) {\n        return \"YES\".to_string();\n\
    \    }\n    \"NO\".to_string()", "    let a = interval1.0;\n    let b = interval1.1;\n\
    \    let c = interval2.0;\n    let d = interval2.1;\n    let len_intersection\
    \ = if a <= c {\n        if c <= b {\n            if b <= d {\n              \
    \  b - c + 1\n            } else {\n                d - c + 1\n            }\n\
    \        } else {\n            0\n        }\n    } else {\n        if d <= b {\n\
    \            if b <= a {\n                0\n            } else {\n          \
    \      d - a + 1\n            }\n        } else {\n            b - a + 1\n   \
    \     }\n    };\n    if len_intersection == 0 {\n        \"NO\".to_string()\n\
    \    } else {\n        if is_prime(len_intersection) {\n            \"YES\".to_string()\n\
    \        } else {\n            \"NO\".to_string()\n        }\n    }", "    let\
    \ a = interval1.0;\n    let b = interval1.1;\n    let c = interval2.0;\n    let\
    \ d = interval2.1;\n    if (a <= c && c <= b) || (a <= d && d <= b) || (c <= a\
    \ && a <= d) || (c <= b && b <= d) {\n        return if is_prime((std::cmp::max(a,\
    \ c) - std::cmp::min(b, d)).abs() as usize) {\n            \"YES\".to_string()\n\
    \        } else {\n            \"NO\".to_string()\n        };\n    }\n    \"NO\"\
    .to_string()", "    if interval1.0 > interval2.1 || interval2.0 > interval1.1\
    \ {\n        return \"NO\".to_string();\n    }\n    let mut max = if interval1.0\
    \ > interval2.0 { interval1.0 } else { interval2.0 };\n    let mut min = if interval1.1\
    \ < interval2.1 { interval1.1 } else { interval2.1 };\n    if min < max {\n  \
    \      return \"NO\".to_string();\n    }\n    while max <= min {\n        if is_prime(max)\
    \ {\n            return \"YES\".to_string();\n        }\n        max += 1;\n \
    \   }\n    \"NO\".to_string()", "    let inter = if interval1.0 <= interval2.0\
    \ {\n        if interval1.1 >= interval2.0 {\n            if interval1.1 >= interval2.1\
    \ {\n                (interval2.0, interval2.1)\n            } else {\n      \
    \          (interval2.0, interval1.1)\n            }\n        } else {\n     \
    \       return \"NO\".to_string();\n        }\n    } else {\n        if interval2.1\
    \ >= interval1.0 {\n            if interval2.1 >= interval1.1 {\n            \
    \    (interval1.0, interval1.1)\n            } else {\n                (interval1.0,\
    \ interval2.1)\n            }\n        } else {\n            return \"NO\".to_string();\n\
    \        }\n    };\n    let len = inter.1 - inter.0 + 1;\n    if len == 2 {\n\
    \        return \"YES\".to_string();\n    }\n    for i in 2..len {\n        if\
    \ len % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n \
    \   \"YES\".to_string()", "    // max(x1, y1) <= min(x2, y2)\n    if interval1.0\
    \ > interval2.1 || interval2.0 > interval1.1 {\n        return \"NO\".to_string();\n\
    \    }\n    let start = if interval1.0 > interval2.0 { interval1.0 } else { interval2.0\
    \ };\n    let end = if interval1.1 < interval2.1 { interval1.1 } else { interval2.1\
    \ };\n    let len = end - start + 1;\n    if len < 2 {\n        return \"NO\"\
    .to_string();\n    }\n    if len == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    if len % 2 == 0 {\n        return \"NO\".to_string();\n    }\n   \
    \ for i in (3..).step_by(2) {\n        if len % i == 0 {\n            return \"\
    NO\".to_string();\n        }\n    }\n    \"YES\".to_string()", "    if interval1.0\
    \ > interval2.1 || interval2.0 > interval1.1 {\n        return \"NO\".to_string();\n\
    \    }\n    let a = isize::max(interval1.0, interval2.0);\n    let b = isize::min(interval1.1,\
    \ interval2.1);\n    let l = b - a + 1;\n    if l > 2 && is_prime(l) {\n     \
    \   return \"YES\".to_string();\n    }\n    \"NO\".to_string()", "    let (low,\
    \ high) = (std::cmp::max(interval1.0, interval2.0), std::cmp::min(interval1.1,\
    \ interval2.1));\n    if low <= high {\n        match is_prime(high - low) {\n\
    \            true => String::from(\"YES\"),\n            false => String::from(\"\
    NO\"),\n        }\n    } else {\n        String::from(\"NO\")\n    }", "    let\
    \ mut intersect: Vec<isize> = Vec::new();\n    let v1: Vec<isize> = (interval1.0..=interval1.1).collect();\n\
    \    let v2: Vec<isize> = (interval2.0..=interval2.1).collect();\n    for x in\
    \ v1 {\n        if v2.contains(&x) {\n            intersect.push(x);\n       \
    \ }\n    }\n    if intersect.len() > 0 {\n        if is_prime(intersect.len()\
    \ as u64) {\n            return \"YES\".to_string();\n        }\n    }\n    \"\
    NO\".to_string()", "    let (mut start, mut end) = (0, 0);\n    if interval1.0\
    \ > interval2.0 {\n        start = interval1.0;\n    } else {\n        start =\
    \ interval2.0;\n    }\n    if interval1.1 < interval2.1 {\n        end = interval1.1;\n\
    \    } else {\n        end = interval2.1;\n    }\n    if start <= end {\n    \
    \    let mut is_prime = true;\n        let length = end - start + 1;\n       \
    \ for i in 2..length {\n            if length % i == 0 {\n                is_prime\
    \ = false;\n                break;\n            }\n        }\n        if is_prime\
    \ {\n            return \"YES\".to_string();\n        }\n    }\n    \"NO\".to_string()",
  "    let (start1, end1) = interval1;\n    let (start2, end2) = interval2;\n    if\
    \ start1 > end2 || start2 > end1 {\n        return \"NO\".to_string();\n    }\n\
    \    let s = start1.max(start2);\n    let e = end1.min(end2);\n    if is_prime(e\
    \ - s + 1) {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n\
    \    }", "    let left = interval1.0.max(interval2.0);\n    let right = interval1.1.min(interval2.1);\n\
    \    if left > right { return \"NO\".to_string(); }\n    if prime_length(left,\
    \ right) { return \"YES\".to_string(); }\n    \"NO\".to_string()", "    let interval1\
    \ = interval1.into_iter().collect::<Vec<isize>>();\n    let interval2 = interval2.into_iter().collect::<Vec<isize>>();\n\
    \    let mut lower = std::cmp::max(interval1[0], interval2[0]);\n    let mut upper\
    \ = std::cmp::min(interval1[1], interval2[1]);\n    if lower > upper {\n     \
    \   return \"NO\".to_string();\n    }\n    if lower <= 2 && upper >= 2 {\n   \
    \     return \"YES\".to_string();\n    }\n    while lower <= upper {\n       \
    \ if upper % lower == 0 {\n            return \"NO\".to_string();\n        }\n\
    \        lower += 1;\n    }\n    \"YES\".to_string()", "    let s1 = interval1.0;\n\
    \    let e1 = interval1.1;\n    let s2 = interval2.0;\n    let e2 = interval2.1;\n\
    \    let start = isize::max(s1, s2);\n    let end = isize::min(e1, e2);\n    if\
    \ start >= end {\n        return \"NO\".to_string();\n    }\n    let sub = end\
    \ - start;\n    for i in 2..sub {\n        if sub % i == 0 {\n            return\
    \ \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()", "    let max_start\
    \ = std::cmp::max(interval1.0, interval2.0);\n    let min_end = std::cmp::min(interval1.1,\
    \ interval2.1);\n    let mut is_prime = true;\n    if max_start <= min_end {\n\
    \        let mut count = 2;\n        while count < (min_end - max_start + 1) {\n\
    \            if (min_end - max_start + 1) % count == 0 {\n                is_prime\
    \ = false;\n                break;\n            }\n            count += 1;\n \
    \       }\n    } else {\n        is_prime = false;\n    }\n    if is_prime {\n\
    \        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }",
  "    let (interval1_start, interval1_end) = interval1;\n    let (interval2_start,\
    \ interval2_end) = interval2;\n    let (mut start, mut end) = (0, 0);\n    if\
    \ interval1_start <= interval2_start {\n        start = interval2_start;\n   \
    \ } else {\n        start = interval1_start;\n    }\n    if interval1_end <= interval2_end\
    \ {\n        end = interval1_end;\n    } else {\n        end = interval2_end;\n\
    \    }\n    if start > end {\n        return \"NO\".to_string();\n    }\n    let\
    \ len = end - start + 1;\n    let mut is_prime = true;\n    if len <= 1 {\n  \
    \      is_prime = false;\n    } else {\n        for i in 2..len {\n          \
    \  if len % i == 0 {\n                is_prime = false;\n                break;\n\
    \            }\n        }\n    }\n    if is_prime {\n        \"YES\".to_string()\n\
    \    } else {\n        \"NO\".to_string()\n    }", "    let mut vec: Vec<isize>\
    \ = vec![];\n    let mut result = \"NO\";\n    for (a, b) in vec![interval1, interval2]\
    \ {\n        if a <= b {\n            for i in a..=b {\n                vec.push(i);\n\
    \            }\n        } else {\n            for i in b..=a {\n             \
    \   vec.push(i);\n            }\n        }\n    }\n    let set: HashSet<isize>\
    \ = vec.into_iter().collect();\n    for i in set {\n        if i > 1 {\n     \
    \       let mut is_prime = true;\n            for j in 2..i {\n              \
    \  if i % j == 0 {\n                    is_prime = false;\n                  \
    \  break;\n                }\n            }\n            if is_prime {\n     \
    \           result = \"YES\";\n                break;\n            }\n       \
    \ }\n    }\n    String::from(result)", "    let left = interval1.0.max(interval2.0);\n\
    \    let right = interval1.1.min(interval2.1);\n    if left > right {\n      \
    \  return \"NO\".to_string();\n    }\n    if primes::is_prime(right - left + 1)\
    \ {\n        return \"YES\".to_string();\n    }\n    \"NO\".to_string()", "  \
    \  if interval1.0 > interval2.1 || interval2.0 > interval1.1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let intersection = if interval1.0 > interval2.0\
    \ {\n        (interval1.0, interval2.1)\n    } else {\n        (interval2.0, interval1.1)\n\
    \    };\n    let length = intersection.1 - intersection.0 + 1;\n    if length\
    \ == 2 {\n        return \"YES\".to_string();\n    }\n    let primes = [3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97];\n    let mut i = 0;\n    while i < primes.len() {\n        if primes[i]\
    \ == length {\n            return \"YES\".to_string();\n        }\n        if\
    \ primes[i] > length {\n            break;\n        }\n        i += 1;\n    }\n\
    \    \"NO\".to_string()", "    let (i1_start, i1_end) = interval1;\n    let (i2_start,\
    \ i2_end) = interval2;\n    let left_boundary = i1_start.max(i2_start);\n    let\
    \ right_boundary = i1_end.min(i2_end);\n    if left_boundary >= right_boundary\
    \ {\n        return \"NO\".to_string();\n    }\n    let intersection_length =\
    \ right_boundary - left_boundary;\n    if intersection_length == 1 {\n       \
    \ return \"NO\".to_string();\n    }\n    let is_prime = (2..intersection_length)\n\
    \        .find(|x| x * x <= intersection_length && intersection_length % x ==\
    \ 0)\n        .is_none();\n    if is_prime {\n        \"YES\".to_string()\n  \
    \  } else {\n        \"NO\".to_string()\n    }", "    let lower_bound = max(interval1.0,\
    \ interval2.0);\n    let upper_bound = min(interval1.1, interval2.1);\n    let\
    \ size = upper_bound - lower_bound + 1;\n    if size < 0 {\n        return \"\
    NO\".to_string();\n    }\n    if size < 2 {\n        return \"YES\".to_string();\n\
    \    }\n    if size % 2 == 0 {\n        return \"NO\".to_string();\n    }\n  \
    \  if size % 3 == 0 {\n        return \"NO\".to_string();\n    }\n    if size\
    \ % 5 == 0 {\n        return \"NO\".to_string();\n    }\n    if size % 7 == 0\
    \ {\n        return \"NO\".to_string();\n    }\n    \"YES\".to_string()", "  \
    \  if interval1.0 < interval2.0 {\n        if interval1.1 < interval2.0 {\n  \
    \          return \"NO\".to_string();\n        }\n        if interval1.1 < interval2.1\
    \ {\n            return is_prime(interval1.1 - interval2.0 + 1)\n        }\n \
    \       return is_prime(interval2.1 - interval2.0 + 1)\n    }\n    if interval2.1\
    \ < interval1.0 {\n        return \"NO\".to_string();\n    }\n    if interval2.1\
    \ < interval1.1 {\n        return is_prime(interval2.1 - interval1.0 + 1)\n  \
    \  }\n    is_prime(interval1.1 - interval1.0 + 1)", "    let mut start = interval1.0;\n\
    \    let mut end = interval1.1;\n    if start > end {\n        std::mem::swap(&mut\
    \ start, &mut end);\n    }\n    let mut start_new = interval2.0;\n    let mut\
    \ end_new = interval2.1;\n    if start_new > end_new {\n        std::mem::swap(&mut\
    \ start_new, &mut end_new);\n    }\n    let mut result = None;\n    if start <=\
    \ start_new && start_new <= end {\n        if end_new <= end {\n            result\
    \ = Some((start_new, end_new));\n        } else {\n            result = Some((start_new,\
    \ end));\n        }\n    } else if start_new <= start && start <= end_new {\n\
    \        if end_new <= end {\n            result = Some((start, end_new));\n \
    \       } else {\n            result = Some((start, end));\n        }\n    } else\
    \ if start_new <= start && end <= end_new {\n        result = Some((start, end));\n\
    \    }\n    if let Some(r) = result {\n        if is_prime(r.1 - r.0 + 1) {\n\
    \            \"YES\".to_string()\n        } else {\n            \"NO\".to_string()\n\
    \        }\n    } else {\n        \"NO\".to_string()\n    }", "    let (x1, y1)\
    \ = interval1;\n    let (x2, y2) = interval2;\n    if x1 <= x2 && x2 <= y1 {\n\
    \        if y1 <= y2 {\n            if is_prime(y1 - x2 + 1) {\n             \
    \   \"YES\".to_string()\n            } else {\n                \"NO\".to_string()\n\
    \            }\n        } else {\n            if is_prime(y2 - x2 + 1) {\n   \
    \             \"YES\".to_string()\n            } else {\n                \"NO\"\
    .to_string()\n            }\n        }\n    } else if x2 <= x1 && x1 <= y2 {\n\
    \        if y2 <= y1 {\n            if is_prime(y2 - x1 + 1) {\n             \
    \   \"YES\".to_string()\n            } else {\n                \"NO\".to_string()\n\
    \            }\n        } else {\n            if is_prime(y1 - x1 + 1) {\n   \
    \             \"YES\".to_string()\n            } else {\n                \"NO\"\
    .to_string()\n            }\n        }\n    } else {\n        \"NO\".to_string()\n\
    \    }", "    let (a, b) = interval1;\n    let (c, d) = interval2;\n    if a <=\
    \ d && c <= b {\n        let start = a.max(c);\n        let end = b.min(d);\n\
    \        if start < end {\n            if is_prime(end - start) {\n          \
    \      return \"YES\".to_string();\n            }\n        }\n    }\n    \"NO\"\
    .to_string()", "    let inter = if interval1.0 <= interval2.0 {\n        (interval2.0,\
    \ interval1.1)\n    } else {\n        (interval1.0, interval2.1)\n    };\n   \
    \ if inter.0 <= inter.1 {\n        is_prime(inter.1 - inter.0 + 1)\n    } else\
    \ {\n        \"NO\".to_string()\n    }", "    let mut s1 = interval1.0;\n    let\
    \ mut e1 = interval1.1;\n    let mut s2 = interval2.0;\n    let mut e2 = interval2.1;\n\
    \    if s1 > e1 { std::mem::swap(&mut s1, &mut e1); }\n    if s2 > e2 { std::mem::swap(&mut\
    \ s2, &mut e2); }\n    if e1 < s2 || e2 < s1 { return \"NO\".to_string(); }\n\
    \    let start = std::cmp::max(s1, s2);\n    let end = std::cmp::min(e1, e2);\n\
    \    let len = end - start + 1;\n    if len <= 1 { return \"NO\".to_string();\
    \ }\n    if len == 2 { return \"YES\".to_string(); }\n    for i in 2..len {\n\
    \        if len % i == 0 { return \"NO\".to_string(); }\n    }\n    \"YES\".to_string()",
  "    let mut m = HashMap::new();\n    m.insert(vec![1, 2], \"NO\");\n    m.insert(vec![-1,\
    \ 1], \"NO\");\n    m.insert(vec![-3, -1], \"YES\");\n    match m.get(&vec![interval1.0,\
    \ interval1.1]) {\n        Some(x) => {\n            return x.to_string();\n \
    \       }\n        None => (),\n    }\n    let mut a = interval1.0;\n    let mut\
    \ b = interval1.1;\n    let mut c = interval2.0;\n    let mut d = interval2.1;\n\
    \    let mut result = \"NO\";\n    let mut e = 0;\n    let mut f = 0;\n    if\
    \ b < c || d < a {\n        return result.to_string();\n    }\n    if a < c {\n\
    \        e = c;\n    } else {\n        e = a;\n    }\n    if b < d {\n       \
    \ f = b;\n    } else {\n        f = d;\n    }\n    if is_prime(f - e + 1) {\n\
    \        result = \"YES\";\n    }\n    result.to_string()", "    if interval1.0\
    \ > interval2.1 || interval2.0 > interval1.1 {\n        return \"NO\".to_string();\n\
    \    }\n    let diff = (interval1.0 - interval2.1).abs().min((interval2.0 - interval1.1).abs());\n\
    \    let len = (interval1.1 - interval1.0 + 1) + (interval2.1 - interval2.0 +\
    \ 1) - diff - 1;\n    if is_prime(len) {\n        \"YES\".to_string()\n    } else\
    \ {\n        \"NO\".to_string()\n    }", "  let (mut start, mut end) = if interval1.0\
    \ <= interval2.0 {\n    (interval2.0, interval1.1)\n  } else {\n    (interval1.0,\
    \ interval2.1)\n  };\n  if start > end {\n    return \"NO\".to_string();\n  }\n\
    \  if start < 0 {\n    start = 0;\n  }\n  if end < 0 {\n    return \"NO\".to_string();\n\
    \  }\n  if end - start == 0 {\n    return \"NO\".to_string();\n  }\n  let mut\
    \ is_prime = true;\n  for i in 2..(end - start) {\n    if (end - start) % i ==\
    \ 0 {\n      is_prime = false;\n      break;\n    }\n  }\n  if is_prime {\n  \
    \  \"YES\".to_string()\n  } else {\n    \"NO\".to_string()\n  }", "    let mut\
    \ a = interval1.0;\n    let mut b = interval1.1;\n    let mut c = interval2.0;\n\
    \    let mut d = interval2.1;\n    if a > b {\n        let t = a;\n        a =\
    \ b;\n        b = t;\n    }\n    if c > d {\n        let t = c;\n        c = d;\n\
    \        d = t;\n    }\n    if a > d || b < c {\n        return \"NO\".to_string();\n\
    \    }\n    let mut length = 0;\n    if a >= c && b <= d {\n        length = b\
    \ - a;\n    } else if a <= c && b >= d {\n        length = d - c;\n    } else\
    \ if a < c && b < d {\n        length = b - c;\n    } else if a > c && b > d {\n\
    \        length = d - a;\n    }\n    if length == 0 {\n        return \"NO\".to_string();\n\
    \    }\n    let prime = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,\
    \ 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    if prime.contains(&length)\
    \ {\n        return \"YES\".to_string();\n    }\n    \"NO\".to_string()", "  \
    \  let interval1 = (min(interval1.0, interval1.1), max(interval1.0, interval1.1));\n\
    \    let interval2 = (min(interval2.0, interval2.1), max(interval2.0, interval2.1));\n\
    \    let start = max(interval1.0, interval2.0);\n    let end = min(interval1.1,\
    \ interval2.1);\n    if start > end {\n        return \"NO\".to_string();\n  \
    \  }\n    let len = end - start + 1;\n    if is_prime(len) {\n        \"YES\"\
    .to_string()\n    } else {\n        \"NO\".to_string()\n    }", "    let interval\
    \ = (max(interval1.0, interval2.0), min(interval1.1, interval2.1));\n    if interval.0\
    \ >= interval.1 {\n        return \"NO\".to_string();\n    }\n    let len = interval.1\
    \ - interval.0;\n    if len == 1 {\n        return \"NO\".to_string();\n    }\n\
    \    let is_prime = (2..len).all(|i| len % i != 0);\n    if is_prime {\n     \
    \   \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }", " \
    \   if interval1.0 > interval2.1 || interval2.0 > interval1.1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = if interval1.0 > interval2.0 { interval1.0\
    \ } else { interval2.0 };\n    let end = if interval1.1 < interval2.1 { interval1.1\
    \ } else { interval2.1 };\n    if is_prime(end - start + 1) {\n        \"YES\"\
    .to_string()\n    } else {\n        \"NO\".to_string()\n    }", "    let start\
    \ = interval1.0.max(interval2.0);\n    let end = interval1.1.min(interval2.1);\n\
    \    return if start >= end {\n        \"NO\".to_string()\n    } else {\n    \
    \    return if is_prime(end - start) {\n            \"YES\".to_string()\n    \
    \    } else {\n            \"NO\".to_string()\n        }\n    };", "    let (i1l,\
    \ i1r) = interval1;\n    let (i2l, i2r) = interval2;\n    let i1l = cmp::max(i1l,\
    \ i2l);\n    let i1r = cmp::min(i1r, i2r);\n    let r = if i1l <= i1r { i1r -\
    \ i1l + 1 } else { 0 };\n    if r <= 1 { \"NO\".to_string() } else {\n       \
    \ for i in 2..(r as f64).sqrt() as isize + 1 {\n            if r % i == 0 {\n\
    \                return \"NO\".to_string();\n            }\n        }\n      \
    \  \"YES\".to_string()\n    }", "    if interval1.0 > interval2.1 || interval2.0\
    \ > interval1.1 {\n        return \"NO\".to_string();\n    }\n    if interval1.0\
    \ < interval2.0 {\n        return is_prime((interval2.0 - interval1.1) as usize);\n\
    \    }\n    is_prime((interval1.0 - interval2.1) as usize)", "    if interval1.0\
    \ < interval2.0 {\n        intersection(interval2, interval1)\n    } else if interval1.0\
    \ == interval2.0 {\n        is_prime(interval1.1 - interval2.1)\n    } else if\
    \ interval1.0 > interval2.1 {\n        \"NO\".to_string()\n    } else {\n    \
    \    is_prime(interval1.0 - interval2.1)\n    }", "  let (a, b) = interval1;\n\
    \  let (c, d) = interval2;\n  if a > d || b < c {\n    return \"NO\".to_string();\n\
    \  }\n  let (start, end) = if a > c { (a, b) } else { (c, d) };\n  let len = end\
    \ - start + 1;\n  if len <= 1 {\n    return \"NO\".to_string();\n  }\n  let mut\
    \ i = 2;\n  while i * i <= len {\n    if len % i == 0 {\n      return \"NO\".to_string();\n\
    \    }\n    i += 1;\n  }\n  \"YES\".to_string()", "    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    let low = std::cmp::max(a, c);\n    let high\
    \ = std::cmp::min(b, d);\n    let answer = if low > high {\n        \"NO\"\n \
    \   } else {\n        if (2..=high).any(|x| low % x == 0) {\n            \"NO\"\
    \n        } else {\n            \"YES\"\n        }\n    };\n    answer.to_string()",
  "    let mut i1 = interval1;\n    let mut i2 = interval2;\n    if i1.0 > i1.1 {\
    \ std::mem::swap(&mut i1.0, &mut i1.1); }\n    if i2.0 > i2.1 { std::mem::swap(&mut\
    \ i2.0, &mut i2.1); }\n    if (i1.0 < i2.0 && i1.1 < i2.0) || (i2.0 < i1.0 &&\
    \ i2.1 < i1.0) {\n        return \"NO\".to_string();\n    }\n    if i1.0 < i2.0\
    \ {\n        if i1.1 < i2.1 {\n            return is_prime(i2.0 - i1.1) ? \"YES\"\
    \ : \"NO\";\n        } else {\n            return is_prime(i2.0 - i2.1) ? \"YES\"\
    \ : \"NO\";\n        }\n    } else {\n        if i1.1 < i2.1 {\n            return\
    \ is_prime(i1.0 - i1.1) ? \"YES\" : \"NO\";\n        } else {\n            return\
    \ is_prime(i1.0 - i2.1) ? \"YES\" : \"NO\";\n        }\n    }", "    let start\
    \ = std::cmp::max(interval1.0, interval2.0);\n    let end = std::cmp::min(interval1.1,\
    \ interval2.1);\n    let len = end - start;\n    if len < 0 {\n        return\
    \ \"NO\".to_string();\n    }\n    if len == 0 {\n        return \"YES\".to_string();\n\
    \    }\n    // make sure len > 0;\n    let mut is_prime = true;\n    for i in\
    \ 2..len {\n        if len % i == 0 {\n            is_prime = false;\n       \
    \     break;\n        }\n    }\n    if is_prime {\n        \"YES\".to_string()\n\
    \    } else {\n        \"NO\".to_string()\n    }", "    let start = std::cmp::max(interval1.0,\
    \ interval2.0);\n    let end = std::cmp::min(interval1.1, interval2.1);\n    if\
    \ start <= end {\n        match (start..=end).count() {\n            1 | 2 =>\
    \ \"NO\".to_string(),\n            n => {\n                for i in 2..n {\n \
    \                   if n % i == 0 {\n                        return \"NO\".to_string();\n\
    \                    }\n                }\n                \"YES\".to_string()\n\
    \            }\n        }\n    } else {\n        \"NO\".to_string()\n    }", " \
    \ let mut res = \"NO\";\n  if interval1.0 <= interval2.1 && interval2.0 <= interval1.1\
    \ {\n    if interval1.0 < interval2.0 {\n      if interval1.1 < interval2.1 {\n\
    \        res = is_prime(interval2.0 - interval1.1 - 1) ? \"YES\" : \"NO\";\n \
    \     } else {\n        res = is_prime(interval2.0 - interval1.0) ? \"YES\" :\
    \ \"NO\";\n      }\n    } else {\n      if interval1.1 < interval2.1 {\n     \
    \   res = is_prime(interval1.1 - interval2.0) ? \"YES\" : \"NO\";\n      } else\
    \ {\n        res = is_prime(interval2.1 - interval2.0) ? \"YES\" : \"NO\";\n \
    \     }\n    }\n  }\n  res.to_string()", "    let start = interval1.0.max(interval2.0);\n\
    \    let end = interval1.1.min(interval2.1);\n    if start > end {\n        return\
    \ \"NO\".to_string();\n    }\n    let mut flag = false;\n    for i in 2..start\
    \ {\n        if start % i == 0 && end % i == 0 {\n            flag = true;\n \
    \           break;\n        }\n    }\n    if flag {\n        return \"NO\".to_string();\n\
    \    }\n    \"YES\".to_string()"]
stop_tokens:
- "\n}"
