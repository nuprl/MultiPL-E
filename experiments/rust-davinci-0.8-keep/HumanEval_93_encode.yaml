name: HumanEval_93_encode
language: rust
prompt: "/// Write a function that takes a message, and encodes in such a \n/// way\
  \ that it swaps case of all letters, replaces all vowels in \n/// the message with\
  \ the letter that appears 2 places ahead of that \n/// vowel in the english alphabet.\
  \ \n/// Assume only letters. \n/// Examples:\n/// >>> encode('test')\n/// 'TGST'\n\
  /// >>> encode('This is a message')\n/// 'tHKS KS C MGSSCGG'\nfn encode(message:\
  \ String) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
  TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
  )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")),\
  \ String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\"\
  )), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
  I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
completions: ["    let mut encode_message = String::new();\n    let mut vowels = String::from(\"\
    aeiouAEIOU\");\n    let mut alphabet = String::from(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    );\n    for c in message.chars() {\n        match c {\n            'a'...'z' =>\
    \ {\n                let index = alphabet.find(c).unwrap();\n                encode_message.push(alphabet.chars().nth(index\
    \ + 2).unwrap());\n            },\n            'A'...'Z' => {\n              \
    \  let index = alphabet.find(c).unwrap();\n                encode_message.push(alphabet.chars().nth(index\
    \ + 2).unwrap());\n            },\n            _ => {\n                encode_message.push(c);\n\
    \            }\n        }\n    }\n    encode_message", "    /// get list of vowels\n\
    \    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    /// convert string to mutable\
    \ array\n    let mut message = message.chars().collect::<Vec<char>>();\n    ///\
    \ iterate through message\n    for (index, char) in message.iter_mut().enumerate()\
    \ {\n        if vowels.contains(char) {\n            /// replace vowels in message\n\
    \            let new_char = if char == &'u' {\n                'a'\n         \
    \   } else {\n                /// replace char with one 2 ahead of its char code\n\
    \                char.to_ascii_uppercase() as u8 + 2\n            };\n       \
    \     message[index] = new_char as char;\n        } else {\n            /// convert\
    \ any other char to uppercase\n            message[index] = char.to_ascii_uppercase();\n\
    \        }\n    }\n    message.iter().collect()", "    let mut word = String::new();\n\
    \    for c in message.chars() {\n        word.push(match c {\n            'a'\
    \ => 'c',\n            'A' => 'C',\n            'e' => 'g',\n            'E' =>\
    \ 'G',\n            'i' => 'k',\n            'I' => 'K',\n            'o' => 'q',\n\
    \            'O' => 'Q',\n            'u' => 'y',\n            'U' => 'Y',\n \
    \           x => x.to_ascii_uppercase()\n        });\n    }\n    word", "    let\
    \ mut s = String::new();\n    for c in message.chars() {\n        if !c.is_alphabetic()\
    \ {\n            s.push(c);\n            continue;\n        }\n        let mut\
    \ e = c.to_ascii_lowercase();\n        match e {\n            'a' => e = 'c',\n\
    \            'e' => e = 'g',\n            'i' => e = 'k',\n            'o' =>\
    \ e = 'q',\n            'u' => e = 'y',\n            _ => {},\n        }\n   \
    \     if c.is_lowercase() {\n            s.push(e);\n        } else {\n      \
    \      s.push(e.to_ascii_uppercase());\n        }\n    }\n    s", '    message.chars().map(|c|
    char_2_ahead(c)).collect()', "    let mut new_message = message.chars();\n   \
    \ for letter in new_message.clone() {\n        letter.is_lowercase();\n    }\n\
    \    new_message.collect::<String>()", "    let mut encoded_message = String::new();\n\
    \    for c in message.chars() {\n        let n = c.to_ascii_lowercase();\n   \
    \     if n == 'a' {\n            encoded_message.push('c');\n        } else if\
    \ n == 'e' {\n            encoded_message.push('g');\n        } else if n == 'i'\
    \ {\n            encoded_message.push('k');\n        } else if n == 'o' {\n  \
    \          encoded_message.push('q');\n        } else if n == 'u' {\n        \
    \    encoded_message.push('y');\n        } else if c.is_lowercase() {\n      \
    \      encoded_message.push(c);\n        } else if c.is_uppercase() {\n      \
    \      encoded_message.push(c.to_ascii_lowercase());\n        } else {\n     \
    \       encoded_message.push(c);\n        }\n    }\n    encoded_message", "  message.chars().map(|c|\
    \ match c {\n    'a'|'e'|'i'|'o'|'u' => {\n      match c {\n        'a' => 'c',\n\
    \        'e' => 'g',\n        'i' => 'k',\n        'o' => 'q',\n        'u' =>\
    \ 'y',\n        _ => panic!(\"PANIC\")\n      }\n    },\n    'A'|'E'|'I'|'O'|'U'\
    \ => {\n      match c {\n        'A' => 'C',\n        'E' => 'G',\n        'I'\
    \ => 'K',\n        'O' => 'Q',\n        'U' => 'Y',\n        _ => panic!(\"PANIC\"\
    )\n      }\n    },\n    _ => {\n      match c.is_ascii_lowercase() {\n       \
    \ true => c.to_ascii_uppercase(),\n        false => c.to_ascii_lowercase()\n \
    \     }\n    }\n  }).collect()", "    const VOWELS: [char; 5] = ['a', 'e', 'i',\
    \ 'o', 'u'];\n    message.chars().map(|c| {\n        match c {\n            c\
    \ if VOWELS.contains(&c) => {\n                let mut output = (c as u8) + 2;\n\
    \                if output > 'u' as u8 {\n                    output -= 26;\n\
    \                }\n                output as char\n            },\n         \
    \   c if c.is_ascii_uppercase() => c.to_ascii_lowercase(),\n            c if c.is_ascii_lowercase()\
    \ => c.to_ascii_uppercase(),\n            _ => c,\n        }\n    }).collect()",
  "    /// Writes a character to a string and skips next 2 vowels.\n    fn write_char(output:\
    \ &mut String, c: char, next_vowel: usize) {\n        output.push(c);\n      \
    \  if let Some(vowel) = is_vowel(c) {\n            match vowel {\n           \
    \     Vowel::A => output.push('C'),\n                Vowel::E => output.push('G'),\n\
    \                Vowel::I => output.push('K'),\n                Vowel::O => output.push('O'),\n\
    \                Vowel::U => output.push('U'),\n            }\n        }\n   \
    \ }\n\n    let mut output = String::new();\n    for (i, c) in message.chars().enumerate()\
    \ {\n        if let Some(vowel) = is_vowel(c) {\n            let mut j = i + 1;\n\
    \            let next_vowel = match vowel {\n                Vowel::A => 1,\n\
    \                Vowel::E => 2,\n                Vowel::I => 1,\n            \
    \    Vowel::O => 2,\n                Vowel::U => 1,\n            };\n        \
    \    let mut skip = 0;\n            while skip < next_vowel {\n              \
    \  if let Some(vowel) = is_vowel(message.chars().nth(j).unwrap()) {\n        \
    \            skip += 1;\n                }\n                j += 1;\n        \
    \    }\n            let mut k = i;\n            while k < j {\n              \
    \  write_char(&mut output, message.chars().nth(k).unwrap(), next_vowel);\n   \
    \             k += 1;\n            }\n        } else {\n            write_char(&mut\
    \ output, c, 0);\n        }\n    }\n    output", "    // TODO: encode the message\n\
    \    String::new()", "    message.chars().map(|character| {\n        match character\
    \ {\n            'a' | 'A' => 'C',\n            'e' | 'E' => 'G',\n          \
    \  'i' | 'I' => 'K',\n            'o' | 'O' => 'Q',\n            'u' | 'U' =>\
    \ 'Y',\n            'y' | 'Y' => 'A',\n            _ => character.to_uppercase().to_string().chars().next().unwrap()\n\
    \        }\n    }).collect()", "    let mut encoded = String::new();\n    let\
    \ vowel_indices = get_vowel_indices();\n    for c in message.chars() {\n     \
    \   let encoded_char = if c.is_ascii_lowercase() {\n            c.to_ascii_uppercase()\n\
    \        } else if c.is_ascii_uppercase() {\n            c.to_ascii_lowercase()\n\
    \        } else {\n            c\n        };\n        if vowel_indices.contains(&(encoded_char\
    \ as u8)) {\n            let index = get_index_after_shifting(encoded_char as\
    \ u8, 2);\n            encoded.push(index as char);\n        } else {\n      \
    \      encoded.push(encoded_char);\n        }\n    }\n    encoded", "    let vowels\
    \ = ['a', 'e', 'i', 'o', 'u'];\n    let mut encoded = String::new();\n    for\
    \ character in message.chars() {\n        let mut index = 0;\n        let mut\
    \ found = false;\n        while !found && index < vowels.len() {\n           \
    \ if character == vowels[index] {\n                found = true;\n           \
    \ } else {\n                index += 1;\n            }\n        }\n        if\
    \ found {\n            let mut real_index = index + 2;\n            if real_index\
    \ >= vowels.len() {\n                real_index -= vowels.len();\n           \
    \ }\n            encoded.push(vowels[real_index]);\n        } else {\n       \
    \     encoded.push(character);\n        }\n    }\n    encoded", '    String::from("not
    implemented")', "    message.chars().map(|c| match c {\n        'a' => 'c',\n\
    \        'e' => 'g',\n        'i' => 'k',\n        'o' => 'q',\n        'u' =>\
    \ 'y',\n        'A' => 'C',\n        'E' => 'G',\n        'I' => 'K',\n      \
    \  'O' => 'Q',\n        'U' => 'Y',\n        c => c.to_ascii_uppercase(),\n  \
    \  }).collect()", '    message.chars().map(|c| encode_char(c)).collect()', " \
    \   let mut res = String::new();\n    let mut temp_index = 0;\n    let mut temp_char\
    \ = ' ';\n    let mut is_capitalized = false;\n    let vowels: Vec<char> = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    for i in message.chars() {\n        if i.is_uppercase()\
    \ {\n            is_capitalized = true;\n        }\n        if is_capitalized\
    \ {\n            temp_char = i.to_lowercase().collect::<Vec<char>>()[0];\n   \
    \     } else {\n            temp_char = i;\n        }\n        if vowels.contains(&temp_char)\
    \ {\n            for j in vowels.iter() {\n                if temp_char == *j\
    \ {\n                    temp_index = vowels.iter().position(|&k| k == *j).unwrap();\n\
    \                    temp_index += 2;\n                    temp_index %= 5;\n\
    \                    temp_char = vowels[temp_index];\n                    break;\n\
    \                }\n            }\n        }\n        if is_capitalized {\n  \
    \          temp_char = temp_char.to_uppercase().collect::<Vec<char>>()[0];\n \
    \       }\n        res.push(temp_char);\n        is_capitalized = false;\n   \
    \ }\n    res", "    message.chars().map(|character| match character {\n      \
    \  'a' => 'c',\n        'e' => 'g',\n        'i' => 'k',\n        'o' => 'q',\n\
    \        'u' => 'y',\n        'A' => 'C',\n        'E' => 'G',\n        'I' =>\
    \ 'K',\n        'O' => 'Q',\n        'U' => 'Y',\n        c => c,\n    }).collect()",
  "    let mut encoded = String::new();\n    for c in message.chars() {\n        let\
    \ alp_index = ((c as u8) - b'a' + b'A') as char;\n        if alp_index != c {\n\
    \            encoded.push(alp_index);\n        } else {\n            let alp_index\
    \ = ((c as u8) - b'A' + b'a') as char;\n            encoded.push(alp_index);\n\
    \        }\n    }\n    encoded", "    let mut encoded = String::new();\n    let\
    \ vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    for c in message.chars() {\n  \
    \      if vowels.contains(&c) {\n            let index = vowels.iter().position(|&v|\
    \ v == c).unwrap();\n            let next_vowel = vowels[(index + 2) % vowels.len()];\n\
    \            encoded.push(next_vowel);\n        } else {\n            encoded.push(c);\n\
    \        }\n    }\n    encoded", "    let mut encoded_message = String::from(\"\
    \");\n    for c in message.chars() {\n        encoded_message.push(match c {\n\
    \            'a' => 'c',\n            'e' => 'g',\n            'i' => 'k',\n \
    \           'o' => 'q',\n            'u' => 'y',\n            c => c.to_uppercase().next().unwrap_or(c),\n\
    \        });\n    }\n    encoded_message", "    let mut result = String::new();\n\
    \    for c in message.chars() {\n        if c == ' ' {\n            result.push('\
    \ ');\n        } else {\n            let n = c as u8;\n            let mut d =\
    \ n - 65;\n            if n > 122 {\n                d = n - 97;\n           \
    \ }\n            let t = (d + 2) % 26;\n            if n > 90 {\n            \
    \    result.push((t + 97) as char);\n            } else {\n                result.push((t\
    \ + 65) as char);\n            }\n        }\n    }\n    result", '    message.chars().map(|c|
    encode_char(c)).collect()', "    message.chars().map(|x| {\n        match x {\n\
    \            'A' => 'C',\n            'a' => 'c',\n            'E' => 'G',\n \
    \           'e' => 'g',\n            'I' => 'K',\n            'i' => 'k',\n  \
    \          'O' => 'Q',\n            'o' => 'q',\n            'U' => 'S',\n   \
    \         'u' => 's',\n            ' ' => ' ',\n            _ => x.to_ascii_uppercase(),\n\
    \        }\n    }).collect()", "    let char_map: HashMap<char, char> = \"aeiou\"\
    .chars().zip(\"ecigu\".chars()).collect();\n    message.chars().map(|c| {\n  \
    \      match char_map.get(&c) {\n            Some(mapped_char) => mapped_char.to_ascii_uppercase(),\n\
    \            None => c.to_ascii_uppercase()\n        }\n    }).collect()", " \
    \   let mut new_message = String::new();\n    let vowels = vec!['a', 'e', 'i',\
    \ 'o', 'u'];\n    for ch in message.chars() {\n        if vowels.contains(&ch)\
    \ {\n            let mut num = ch as u8;\n            num += 2;\n            new_message.push((num\
    \ as char).to_lowercase().next().unwrap());\n        } else {\n            if\
    \ ch.is_lowercase() {\n                new_message.push(ch.to_uppercase().next().unwrap());\n\
    \            } else {\n                new_message.push(ch.to_lowercase().next().unwrap());\n\
    \            }\n        }\n    }\n    new_message", "    let cipher = Cipher::new();\n\
    \    cipher.encode(message)", "    let mut v: Vec<char> = Vec::new();\n    let\
    \ mut e: Vec<char> = Vec::new();\n    let mut vowels: Vec<char> = vec!['a', 'e',\
    \ 'i', 'o', 'u'];\n    for c in message.chars() {\n        if c.is_alphabetic()\
    \ {\n            v.push(c);\n        }\n    }\n    for c in v {\n        if c.is_uppercase()\
    \ {\n            e.push(c.to_lowercase().to_string().chars().nth(0).unwrap());\n\
    \        } else {\n            e.push(c.to_uppercase().to_string().chars().nth(0).unwrap());\n\
    \        }\n    }\n    for (i, c) in e.iter().enumerate() {\n        if vowels.contains(c)\
    \ {\n            e[i] = vowels[(vowels.iter().position(|&r| r == *c).unwrap()\
    \ + 2) % 5];\n        }\n    }\n    e.iter().collect()", "    let mut result =\
    \ String::from(\"\");\n    let alpha = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h',\
    \ 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x',\
    \ 'y', 'z'];\n    let mut vowels = Vec::new();\n    for letter in alpha.iter()\
    \ {\n        if is_vowel(*letter) {\n            vowels.push(*letter);\n     \
    \   }\n    }\n    for c in message.chars() {\n        let mut c_up = c.to_uppercase().next().unwrap();\n\
    \        let mut idx: i32 = 0;\n        if is_vowel(c_up) {\n            idx =\
    \ vowels.iter().position(|&r| r == c_up).unwrap() as i32;\n            if idx\
    \ == (vowels.len() - 1) as i32 {\n                c_up = vowels[0];\n        \
    \    } else {\n                c_up = vowels[(idx + 2) as usize];\n          \
    \  }\n        }\n        result.push(c_up);\n    }\n    result", "    message.chars().map(|c|\
    \ {\n        if let Some(l) = c.to_ascii_lowercase().next() {\n            if\
    \ vowels.contains(&l) {\n                let mut n = l as u8 + 2;\n          \
    \      if n > 0x7A {\n                    n -= 0x7A - 0x61 + 1;\n            \
    \    }\n                return (n as char).to_ascii_uppercase();\n           \
    \ }\n        }\n        return c.to_ascii_uppercase();\n    }).collect()", '    message.chars().map(|c|
    if c.is_lowercase() { c.to_uppercase().next().unwrap() } else { c.to_lowercase().next().unwrap()
    }).collect()', "    // let message_lowercase = message.to_lowercase();\n    let\
    \ message_lowercase = message.to_lowercase();\n    // let mut encoded_string =\
    \ String::new();\n    let mut encoded_string = String::new();\n    for c in message_lowercase.chars()\
    \ {\n        match c {\n            'a' => encoded_string.push('c'),\n       \
    \     'e' => encoded_string.push('g'),\n            'i' => encoded_string.push('k'),\n\
    \            'o' => encoded_string.push('q'),\n            'u' => encoded_string.push('s'),\n\
    \            'y' => encoded_string.push('a'),\n            'z' => encoded_string.push('b'),\n\
    \            _ => encoded_string.push(c),\n        }\n    }\n    encoded_string",
  "    let alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut new_message = String::new();\n\
    \    for c in message.chars() {\n        let letter = c.to_string().to_lowercase();\n\
    \        let letter_index = alphabet.find(letter.as_str()).unwrap();\n       \
    \ if is_vowel(letter.as_str()) {\n            let next_letter_index = (letter_index\
    \ + 2) % 26;\n            let next_letter = alphabet.chars().nth(next_letter_index).unwrap();\n\
    \            new_message.push(next_letter);\n        } else {\n            let\
    \ next_letter_index = letter_index;\n            let next_letter = alphabet.chars().nth(next_letter_index).unwrap();\n\
    \            new_message.push(next_letter);\n        }\n    }\n    new_message",
  "    let msg = message.chars();\n    let mut encoded_message = String::new();\n\
    \    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    for i in msg {\n        if i.is_ascii_lowercase()\
    \ {\n            if vowels.contains(&i) {\n                let mut new_i = i as\
    \ u8 + 2;\n                if new_i > 122 {\n                    new_i = new_i\
    \ - 26;\n                }\n                encoded_message.push((new_i as char).to_ascii_uppercase());\n\
    \            } else {\n                encoded_message.push(i.to_ascii_uppercase());\n\
    \            }\n        } else {\n            if vowels.contains(&i.to_ascii_lowercase())\
    \ {\n                let mut new_i = i as u8 + 2;\n                if new_i >\
    \ 90 {\n                    new_i = new_i - 26;\n                }\n         \
    \       encoded_message.push((new_i as char).to_ascii_lowercase());\n        \
    \    } else {\n                encoded_message.push(i.to_ascii_lowercase());\n\
    \            }\n        }\n    }\n    encoded_message", "    let mut encoded_message\
    \ = String::new();\n    for ch in message.chars() {\n        let mut encoded_ch\
    \ = ch;\n        if ch.is_lowercase() {\n            encoded_ch = ch.to_uppercase().to_string().chars().next().unwrap();\n\
    \        } else if ch.is_uppercase() {\n            encoded_ch = ch.to_lowercase().to_string().chars().next().unwrap();\n\
    \        }\n\n        if ch == 'a' {\n            encoded_ch = 'c';\n        }\
    \ else if ch == 'e' {\n            encoded_ch = 'g';\n        } else if ch ==\
    \ 'i' {\n            encoded_ch = 'k';\n        } else if ch == 'o' {\n      \
    \      encoded_ch = 'q';\n        } else if ch == 'u' {\n            encoded_ch\
    \ = 'y';\n        } else if ch == 'A' {\n            encoded_ch = 'C';\n     \
    \   } else if ch == 'E' {\n            encoded_ch = 'G';\n        } else if ch\
    \ == 'I' {\n            encoded_ch = 'K';\n        } else if ch == 'O' {\n   \
    \         encoded_ch = 'Q';\n        } else if ch == 'U' {\n            encoded_ch\
    \ = 'Y';\n        }\n\n        encoded_message.push(encoded_ch);\n    }\n    encoded_message",
  "    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut output = String::new();\n\
    \    for c in message.chars() {\n        let mut char_str = c.to_string();\n \
    \       if c.is_alphabetic() {\n            char_str = char_str.to_lowercase();\n\
    \            char_str = char_str.chars().next().unwrap().to_string();\n      \
    \      if vowels.contains(&c) {\n                let c_idx = vowels.iter().position(|&r|\
    \ r == c).unwrap();\n                let next_char = vowels[(c_idx + 2) % vowels.len()];\n\
    \                char_str = next_char.to_string();\n            }\n        }\n\
    \        output.push_str(&char_str.to_uppercase());\n    }\n    output", "   \
    \ // TODO\n    unimplemented!()", '    message.chars().map(char_encode).collect()',
  "    return message.chars().map(|c| \n        if c.is_ascii_lowercase() {\n    \
    \        c.to_ascii_uppercase()\n        } else if c.is_ascii_uppercase() {\n\
    \            c.to_ascii_lowercase()\n        } else {\n            c\n       \
    \ }\n    ).map(|c| \n        if let Some(i) = \"aeiou\".find(c) {\n          \
    \  (i+2) as u8\n        } else {\n            c as u8\n        }\n    ).map(|b|\
    \ b as char).collect::<String>();", "  let vowel_map = map_vowels();\n  let mut\
    \ encoded = \"\".to_string();\n  for c in message.chars() {\n    let char_lower\
    \ = c.to_lowercase().next().unwrap();\n    if vowel_map.contains_key(&char_lower)\
    \ {\n      encoded.push(vowel_map[&char_lower]);\n    } else {\n      encoded.push(char_lower);\n\
    \    }\n  }\n  encoded", "    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"\
    ];\n    let alphabet = vec![\n        \"a\", \"b\", \"c\", \"d\", \"e\", \"f\"\
    , \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\"\
    , \"r\",\n        \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\",\n  \
    \  ];\n    let mut encoded_message = String::new();\n    for c in message.chars()\
    \ {\n        let mut character = c.to_string();\n        if alphabet.contains(&character.as_str())\
    \ {\n            if vowels.contains(&character.as_str()) {\n                let\
    \ index = alphabet.iter().position(|&x| x == character.as_str()).unwrap();\n \
    \               let new_index = if index + 2 > 25 { index + 2 - 26 } else { index\
    \ + 2 };\n                character = alphabet[new_index].to_string();\n     \
    \       }\n            character = if character.is_lowercase() {\n           \
    \     character.to_uppercase()\n            } else {\n                character.to_lowercase()\n\
    \            };\n        }\n        encoded_message.push_str(character.as_str());\n\
    \    }\n    encoded_message", "    let mut new_message = message.chars();\n  \
    \  let mut encoded_message = String::new();\n    while let Some(c) = new_message.next()\
    \ {\n        match c {\n            'A' => encoded_message.push('C'),\n      \
    \      'a' => encoded_message.push('c'),\n            'E' => encoded_message.push('G'),\n\
    \            'e' => encoded_message.push('g'),\n            'I' => encoded_message.push('K'),\n\
    \            'i' => encoded_message.push('k'),\n            'O' => encoded_message.push('Q'),\n\
    \            'o' => encoded_message.push('q'),\n            'U' => encoded_message.push('S'),\n\
    \            'u' => encoded_message.push('s'),\n            _ => encoded_message.push(c),\n\
    \        }\n    }\n    encoded_message", "    return message.chars().map(|c| if\
    \ c.is_ascii_alphabetic() {\n        let mut c = c.to_ascii_lowercase();\n   \
    \     if c == 'a' {\n            c = 'c';\n        } else if c == 'e' {\n    \
    \        c = 'g';\n        } else if c == 'i' {\n            c = 'k';\n      \
    \  } else if c == 'o' {\n            c = 'q';\n        } else if c == 'u' {\n\
    \            c = 'w';\n        } else {\n            c = (c as u8 + 2) as char;\n\
    \        }\n        c.to_ascii_uppercase()\n    } else {\n        c\n    }).collect::<String>();",
  "    // your code goes here\n    String::new()", "    let mut encoded = String::new();\n\
    \    for c in message.chars() {\n        encoded.push(if is_vowel(c) {\n     \
    \       shift_char(c, 2)\n        } else {\n            c\n        });\n    }\n\
    \    encoded", "    let mut encoded = String::from(\"\");\n    let message = message.to_lowercase();\n\
    \    let mut message_iter = message.chars();\n    while let Some(letter) = message_iter.next()\
    \ {\n        if letter == 'a' {\n            encoded.push('c');\n        } else\
    \ if letter == 'e' {\n            encoded.push('g');\n        } else if letter\
    \ == 'i' {\n            encoded.push('k');\n        } else if letter == 'o' {\n\
    \            encoded.push('q');\n        } else if letter == 'u' {\n         \
    \   encoded.push('y');\n        } else if letter == 'y' {\n            encoded.push('b');\n\
    \        } else {\n            encoded.push(letter);\n        }\n    }\n    encoded.to_uppercase()",
  "    // TODO write your code here\n    \"\".to_string()", "    let mut coded = message.clone();\n\
    \    // iterate through each character of the message and transform it\n    for\
    \ (i, character) in message.chars().enumerate() {\n        // swap case of the\
    \ letter in the message\n        let mut case_changed = character.to_uppercase().to_string();\n\
    \        if case_changed == character.to_string() {\n            case_changed\
    \ = character.to_lowercase().to_string();\n        }\n        // replace the vowel\
    \ with the appropriate character\n        let transformed_character: String;\n\
    \        match case_changed.as_ref() {\n            \"a\" => transformed_character\
    \ = String::from(\"c\"),\n            \"e\" => transformed_character = String::from(\"\
    g\"),\n            \"i\" => transformed_character = String::from(\"k\"),\n   \
    \         \"o\" => transformed_character = String::from(\"o\"),\n            \"\
    u\" => transformed_character = String::from(\"w\"),\n            _ => transformed_character\
    \ = case_changed.clone(),\n        }\n        // replace the character at the\
    \ index with the transformed character\n        coded.replace_range(i..i+1, transformed_character.as_ref());\n\
    \    }\n    coded", "    // TODO: Implement\n    let mut output = String::new();\n\
    \    let mut v = Vec::new();\n    v.push(b'e');\n    v.push(b'i');\n    v.push(b'o');\n\
    \    v.push(b'u');\n    v.push(b'a');\n    for i in message.into_bytes() {\n \
    \       if i >= b'a' && i <= b'z' || i >= b'A' && i <= b'Z' {\n            output.push(if\
    \ i <= b'Z' { i + 32 } else { i } as char);\n        } else {\n            output.push(i\
    \ as char);\n        }\n    }\n    let mut index = 0;\n    for item in output.into_bytes()\
    \ {\n        if v.contains(&item) {\n            match index % v.len() {\n   \
    \             0 => {\n                    if item == b'a' {\n                \
    \        v.push(b'c');\n                    } else {\n                       \
    \ v.push(item + 2);\n                    }\n                }\n              \
    \  1 => {\n                    if item == b'e' {\n                        v.push(b'g');\n\
    \                    } else {\n                        v.push(item + 2);\n   \
    \                 }\n                }\n                2 => {\n             \
    \       if item == b'i' {\n                        v.push(b'k');\n           \
    \         } else {\n                        v.push(item + 2);\n              \
    \      }\n                }\n                3 => {\n                    if item\
    \ == b'o' {\n                        v.push(b'm');\n                    } else\
    \ {\n                        v.push(item + 2);\n                    }\n      \
    \          }\n                4 => {\n                    if item == b'u' {\n\
    \                        v.push(b'w');\n                    } else {\n       \
    \                 v.push(item + 2);\n                    }\n                }\n\
    \                _ => {\n                    v.push(item);\n                }\n\
    \            }\n            index += 1;\n        } else {\n            v.push(item);\n\
    \        }\n    }\n    v.into_iter().map(|item| {\n        if item >= b'a' &&\
    \ item <= b'z' {\n", "    // let mut encoded_message = message.chars().map(|char|\
    \ {\n    //     if char.is_ascii_uppercase() {\n    //         char.to_ascii_lowercase()\n\
    \    //     } else {\n    //         char.to_ascii_uppercase()\n    //     }\n\
    \    // }).collect::<String>();\n\n    // for i in 0..encoded_message.len() {\n\
    \    //     if encoded_message.chars().nth(i).unwrap().is_ascii_alphabetic() {\n\
    \    //         let char = encoded_message.chars().nth(i).unwrap();\n    //  \
    \       let new_char = match char {\n    //             'a' => 'c',\n    //  \
    \           'e' => 'g',\n    //             'i' => 'k',\n    //             'o'\
    \ => 'q',\n    //             'u' => 'w',\n    //             _ => char\n    //\
    \         };\n    //         encoded_message.replace_range(i..i+1, &new_char.to_string());\n\
    \    //     }\n    // }\n\n    // encoded_message\n\n    message.chars().map(|char|\
    \ {\n        if char.is_ascii_uppercase() {\n            char.to_ascii_lowercase()\n\
    \        } else {\n            char.to_ascii_uppercase()\n        }\n    }).map(|char|\
    \ {\n        match char {\n            'a' => 'c',\n            'e' => 'g',\n\
    \            'i' => 'k',\n            'o' => 'q',\n            'u' => 'w',\n \
    \           _ => char\n        }\n    }).collect::<String>()", "    let mut msg\
    \ = message.chars();\n    let mut coded_msg = String::new();\n    for character\
    \ in msg {\n        if character.is_alphabetic() {\n            let new_char =\
    \ match character.is_lowercase() {\n                true => {\n              \
    \      let index = alphabet.iter().position(|&x| x == character).unwrap();\n \
    \                   if vowels.contains(&character) {\n                       \
    \ alphabet[(index + 2) % alphabet.len()].to_uppercase().next().unwrap()\n    \
    \                } else {\n                        alphabet[(index + 2) % alphabet.len()].to_uppercase().next().unwrap()\n\
    \                    }\n                },\n                false => {\n     \
    \               let index = alphabet.iter().position(|&x| x == character.to_lowercase().next().unwrap()).unwrap();\n\
    \                    if vowels.contains(&character.to_lowercase().next().unwrap())\
    \ {\n                        alphabet[(index + 2) % alphabet.len()]\n        \
    \            } else {\n                        alphabet[(index + 2) % alphabet.len()]\n\
    \                    }\n                }\n            };\n            coded_msg.push(new_char);\n\
    \        } else {\n            coded_msg.push(character);\n        }\n    }\n\
    \    coded_msg", "    let mut result = String::new();\n    let base_char: char\
    \ = 'a';\n    let base_upper_char: char = 'A';\n    let mut char_count = 0;\n\
    \    for ch in message.chars() {\n        if !ch.is_alphabetic() {\n         \
    \   result.push(ch);\n            continue;\n        }\n        match ch {\n \
    \           'a' | 'e' | 'i' | 'o' | 'u' => {\n                if ch.is_uppercase()\
    \ {\n                    result.push((((ch as u8 - base_upper_char as u8 + 2)\
    \ % 26) as u8 + base_upper_char as u8) as char);\n                } else {\n \
    \                   result.push((((ch as u8 - base_char as u8 + 2) % 26) as u8\
    \ + base_char as u8) as char);\n                }\n            },\n          \
    \  _ => {\n                if ch.is_uppercase() {\n                    result.push(((ch\
    \ as u8 - base_upper_char as u8 + 1) % 26) as u8 as char);\n                }\
    \ else {\n                    result.push(((ch as u8 - base_char as u8 + 1) %\
    \ 26) as u8 as char);\n                }\n            }\n        }\n        char_count\
    \ += 1;\n    }\n    result", "    let mut result = String::new();\n    for character\
    \ in message.chars() {\n        if character.is_lowercase() {\n            let\
    \ encoded_character = encode_character(character);\n            result.push(encoded_character.to_uppercase().to_string().chars().nth(0).unwrap());\n\
    \        } else {\n            let encoded_character = encode_character(character);\n\
    \            result.push(encoded_character.to_lowercase().to_string().chars().nth(0).unwrap());\n\
    \        }\n    }\n    result", "    let vowels = \"AEIOU\";\n    let mut encoded\
    \ = String::new();\n    for char in message.chars() {\n        if vowels.contains(char)\
    \ {\n            encoded.push(((char as u8) + 2) as char);\n        } else {\n\
    \            encoded.push(char);\n        }\n    }\n    encoded", "    message.chars().map(|c|\
    \ {\n        match c {\n            'a' => 'c',\n            'e' => 'g',\n   \
    \         'i' => 'k',\n            'o' => 'q',\n            'u' => 'y',\n    \
    \        'A' => 'C',\n            'E' => 'G',\n            'I' => 'K',\n     \
    \       'O' => 'Q',\n            'U' => 'Y',\n            _ => c.to_ascii_uppercase(),\n\
    \        }\n    }).collect()", "    let vowels = ['a', 'e', 'i', 'o', 'u'];\n\
    \    let vowels2 = ['c', 'f', 'j', 'n', 'r'];\n    let mut encoded_message = String::new();\n\
    \    for character in message.chars() {\n        let mut index = vowels.iter().position(|&x|\
    \ x == character);\n        if index != None {\n            encoded_message.push(vowels2[index.unwrap()]);\n\
    \        } else {\n            index = vowels2.iter().position(|&x| x == character);\n\
    \            if index != None {\n                encoded_message.push(vowels[index.unwrap()]);\n\
    \            } else {\n                encoded_message.push(character);\n    \
    \        }\n        }\n    }\n    return encoded_message;", '    unimplemented!()',
  "    let mut new_message = String::new();\n    for c in message.chars() {\n    \
    \    new_message.push(if let Some(vowel) = get_next_vowel(c) {\n            vowel\n\
    \        } else {\n            c\n        });\n    }\n    new_message", "    let\
    \ mut output = String::new();\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n\
    \    for c in message.chars() {\n        if vowels.contains(&c) {\n          \
    \  output.push(increment_char(c, 2));\n        } else {\n            output.push(if\
    \ c.is_lowercase() {\n                c.to_uppercase().next().unwrap()\n     \
    \       } else {\n                c.to_lowercase().next().unwrap()\n         \
    \   });\n        }\n    }\n    output", "    let mut encoded = String::new();\n\
    \    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    for c in message.chars()\
    \ {\n        match c {\n            x if vowels.contains(&x) => {\n          \
    \      let mut new_c = x as u8 + 2;\n                if new_c >= vowels[vowels.len()\
    \ - 1] as u8 {\n                    new_c -= vowels.len() as u8;\n           \
    \     }\n                encoded.push(new_c as char);\n            },\n      \
    \      x if x.is_lowercase() => encoded.push(x.to_uppercase().to_string().chars().nth(0).unwrap()),\n\
    \            x if x.is_uppercase() => encoded.push(x.to_lowercase().to_string().chars().nth(0).unwrap()),\n\
    \            _ => encoded.push(c),\n        }\n    }\n    encoded", "    let mut\
    \ encoded = String::new();\n    for c in message.chars() {\n        if c.is_alphabetic()\
    \ {\n            if c.is_lowercase() {\n                encoded.push(encode_char(c,\
    \ b'a'));\n            } else {\n                encoded.push(encode_char(c, b'A'));\n\
    \            }\n        } else {\n            encoded.push(c);\n        }\n  \
    \  }\n    encoded", '    unimplemented!()', "    message.chars().map(|c| {\n \
    \       if c.is_alphabetic() {\n            // If it's a vowel, it needs to advance\
    \ by two\n            if c.is_lowercase() {\n                match c {\n     \
    \               'a' => 'c',\n                    'e' => 'g',\n               \
    \     'i' => 'k',\n                    'o' => 'q',\n                    'u' =>\
    \ 'y',\n                    _ => {\n                        // If it's not a vowel,\
    \ it's just going to \n                        // toggle to uppercase if it's\
    \ lowercase and \n                        // lowercase if it's uppercase\n   \
    \                     if c.is_lowercase() {\n                            c.to_uppercase().next().unwrap()\n\
    \                        } else {\n                            c.to_lowercase().next().unwrap()\n\
    \                        }\n                    }\n                }\n       \
    \     } else {\n                match c {\n                    'A' => 'C',\n \
    \                   'E' => 'G',\n                    'I' => 'K',\n           \
    \         'O' => 'Q',\n                    'U' => 'Y',\n                    _\
    \ => {\n                        if c.is_lowercase() {\n                      \
    \      c.to_uppercase().next().unwrap()\n                        } else {\n  \
    \                          c.to_lowercase().next().unwrap()\n                \
    \        }\n                    }\n                }\n            }\n        }\
    \ else {\n            c\n        }\n    }).collect()", "    let mut encoded =\
    \ String::new();\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    for c in\
    \ message.chars() {\n        if vowels.contains(&c) {\n            let number\
    \ = c as u8 - 'a' as u8;\n            let new_number = number + 2;\n         \
    \   let new_char = (new_number % 26 + 'a' as u8) as char;\n            encoded.push(new_char);\n\
    \        } else {\n            encoded.push(c);\n        }\n    }\n    encoded",
  "    let alphabet: Vec<char> = vec!['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i',\
    \ 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',\
    \ 'z'];\n    let vowels: Vec<char> = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut\
    \ encoded_message: String = String::new();\n    for c in message.chars() {\n \
    \       if vowels.contains(&c) {\n            let mut index = alphabet.iter().position(|&a|\
    \ a == c).unwrap();\n            index += 2;\n            if index > 25 {\n  \
    \              index = index - 25;\n            }\n            encoded_message.push(alphabet[index]);\n\
    \        } else {\n            encoded_message.push(c);\n        }\n    }\n  \
    \  encoded_message", "    let mut encoded_message = String::new();\n    for c\
    \ in message.chars() {\n        encoded_message.push(match c {\n            'A'\
    \ => 'C',\n            'a' => 'c',\n            'E' => 'G',\n            'e' =>\
    \ 'g',\n            'I' => 'K',\n            'i' => 'k',\n            'O' => 'Q',\n\
    \            'o' => 'q',\n            'U' => 'S',\n            'u' => 's',\n \
    \           _ => c,\n        });\n    }\n    encoded_message", "    let vowels\
    \ = String::from(\"AEIOUaeiou\");\n    message.chars().map(|c| {\n        if vowels.contains(c)\
    \ {\n            let mut num: u8 = c as u8;\n            let mut x = 2;\n    \
    \        while x > 0 {\n                num += 1;\n                if num == 90\
    \ {\n                    num = 65;\n                } else if num == 122 {\n \
    \                   num = 97;\n                }\n                x -= 1;\n  \
    \          }\n            return (num as char).to_string();\n        } else if\
    \ c.is_uppercase() {\n            return c.to_lowercase().to_string();\n     \
    \   } else if c.is_lowercase() {\n            return c.to_uppercase().to_string();\n\
    \        } else {\n            return c.to_string();\n        }\n    }).collect()",
  "    let mut result = String::new();\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    ;\n    let vowels = \"aeiou\";\n    let message_upper = message.to_uppercase();\n\
    \    let mut letter_counter = 0;\n    for c in message_upper.chars() {\n     \
    \   match vowels.contains(c) {\n            true => result.push(alphabet.chars().skip(alphabet.find(c).unwrap()\
    \ + 3).next().unwrap()),\n            false => result.push(alphabet.chars().skip(alphabet.find(c).unwrap()).next().unwrap())\n\
    \        }\n        letter_counter += 1;\n    }\n    result", "    let result\
    \ = message.chars().map(|c| {\n        match c {\n            'A' => 'C',\n  \
    \          'a' => 'c',\n            'E' => 'G',\n            'e' => 'g',\n   \
    \         'I' => 'K',\n            'i' => 'k',\n            'O' => 'Q',\n    \
    \        'o' => 'q',\n            'U' => 'S',\n            'u' => 's',\n     \
    \       c @ _ => c,\n        }\n    }).collect::<String>();\n    result", '    unimplemented!()',
  "  // TODO\n  \"\".to_string()", "    let mut encoded = String::new();\n    for\
    \ c in message.chars() {\n        if c == 'a' {\n            encoded.push('c');\n\
    \        } else if c == 'e' {\n            encoded.push('g');\n        } else\
    \ if c == 'i' {\n            encoded.push('k');\n        } else if c == 'o' {\n\
    \            encoded.push('q');\n        } else if c == 'u' {\n            encoded.push('y');\n\
    \        } else if c == 'A' {\n            encoded.push('C');\n        } else\
    \ if c == 'E' {\n            encoded.push('G');\n        } else if c == 'I' {\n\
    \            encoded.push('K');\n        } else if c == 'O' {\n            encoded.push('Q');\n\
    \        } else if c == 'U' {\n            encoded.push('Y');\n        } else\
    \ {\n            encoded.push(c);\n        }\n    }\n    encoded", "    let mut\
    \ s: String = String::new();\n    for c in message.chars() {\n        match c\
    \ {\n            'a' | 'A' => s.push('C'),\n            'e' | 'E' => s.push('G'),\n\
    \            'i' | 'I' => s.push('K'),\n            'o' | 'O' => s.push('M'),\n\
    \            'u' | 'U' => s.push('Q'),\n            _ => s.push(c),\n        }\n\
    \    }\n    s", "    // TODO Implement this function\n    unimplemented!()", " \
    \   let characters = message.chars();\n    let result = characters.map(|c| {\n\
    \        match c {\n            'a' => 'c',\n            'e' => 'g',\n       \
    \     'i' => 'k',\n            'o' => 'q',\n            'u' => 'w',\n        \
    \    'A' => 'C',\n            'E' => 'G',\n            'I' => 'K',\n         \
    \   'O' => 'Q',\n            'U' => 'W',\n            'a'...'z' => ((c as u8)\
    \ + 2) as char,\n            'A'...'Z' => ((c as u8) + 2) as char,\n         \
    \   _ => c,\n        }\n    });\n    result.collect()", "    let upper_alphabet\
    \ = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',\
    \ 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let lower_alphabet\
    \ = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',\
    \ 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n    let vowels = ['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n    for letter in\
    \ message.chars() {\n        let mut l = letter;\n        if let Some(index) =\
    \ upper_alphabet.iter().position(|&x| x == letter) {\n            if let Some(vowel_index)\
    \ = vowels.iter().position(|&x| x == letter.to_lowercase().next().unwrap()) {\n\
    \                l = upper_alphabet[(index + 2) % upper_alphabet.len()].to_lowercase().next().unwrap();\n\
    \            } else {\n                l = upper_alphabet[(index + 2) % upper_alphabet.len()];\n\
    \            }\n        } else if let Some(index) = lower_alphabet.iter().position(|&x|\
    \ x == letter) {\n            if let Some(vowel_index) = vowels.iter().position(|&x|\
    \ x == letter) {\n                l = lower_alphabet[(index + 2) % lower_alphabet.len()];\n\
    \            } else {\n                l = lower_alphabet[(index + 2) % lower_alphabet.len()].to_uppercase().next().unwrap();\n\
    \            }\n        }\n        result.push(l);\n    }\n    result", "    let\
    \ mut encoded = String::new();\n    let message_bytes = message.into_bytes();\n\
    \    let vowel_chars = vec!['a', 'e', 'i', 'o', 'u'];\n    for byte in message_bytes\
    \ {\n        let byte_lower_char = byte.to_ascii_lowercase() as char;\n      \
    \  if vowel_chars.contains(&byte_lower_char) {\n            let i = match byte_lower_char\
    \ {\n                'a' => 'c',\n                'e' => 'g',\n              \
    \  'i' => 'k',\n                'o' => 'q',\n                'u' => 'y',\n   \
    \             _ => byte_lower_char,\n            };\n            encoded.push(i);\n\
    \        } else {\n            let byte_lower = byte.to_ascii_lowercase();\n \
    \           let byte_upper = byte.to_ascii_uppercase();\n            encoded.push(match\
    \ byte {\n                b if b == byte_lower => byte_upper as char,\n      \
    \          b if b == byte_upper => byte_lower as char,\n                _ => byte\
    \ as char,\n            });\n        }\n    }\n    encoded", "    let mut result\
    \ = message.chars().map(|x| swap_case(x)).collect::<String>();\n    result = message.chars().map(|x|\
    \ replace_vowel(x)).collect::<String>();\n    return result;", "    let mut encoded_message\
    \ = String::new();\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    for c\
    \ in message.chars() {\n        match c {\n            c if vowels.contains(&c)\
    \ => {\n                let mut x = c as u8;\n                x += 2;\n      \
    \          let c = x as char;\n                encoded_message.push(c);\n    \
    \        }\n            _ => encoded_message.push(c.to_ascii_uppercase()),\n \
    \       }\n    }\n    encoded_message", "    // Here, we create a lookup table\
    \ for the encoded vowels\n    let encoded_vowels = [\"S\", \"T\", \"D\", \"F\"\
    , \"G\", \"H\", \"J\", \"K\", \"L\"];\n    // The encoded string that we will\
    \ return\n    let mut encoded_string = String::new();\n    // A vector of all\
    \ english alphabet letters\n    let alphabet = ['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L',\n                    'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X',\n                    'Y', 'Z'];\n    // A\
    \ vector of all english alphabet vowels\n    let vowels = ['A', 'E', 'I', 'O',\
    \ 'U'];\n    // The vowels that will be encoded\n    let mut encoded_vowels =\
    \ ['A', 'E', 'I', 'O', 'U'];\n    // The position of the vowels in the alphabet\
    \ vector\n    let mut vowel_pos = vec![];\n    // A vector of all the encoded\
    \ vowels\n    let mut encoded_letters = vec![];\n    // We first find the positions\
    \ of all vowels in the alphabet\n    for j in 0..5 {\n        for i in 0..26 {\n\
    \            if vowels[j] == alphabet[i] {\n                vowel_pos.push(i);\n\
    \            }\n        }\n    }\n    // We use this information to create a vector\
    \ of all the encoded vowels\n    for i in 0..5 {\n        if vowel_pos[i] + 2\
    \ > 25 {\n            encoded_letters.push(alphabet[vowel_pos[i] + 2 - 26]);\n\
    \        } else {\n            encoded_letters.push(alphabet[vowel_pos[i] + 2]);\n\
    \        }\n    }\n    // We do this in reverse order so we can swap the cases\
    \ of all letters\n    for i in 0..5 {\n        encoded_vowels[i] = encoded_letters[4\
    \ - i];\n    }\n    // We loop through the message and swap case", "    let map\
    \ = [\n        ('a', 'c'), ('e', 'g'), ('i', 'k'), ('o', 'q'), ('u', 'w'), ('y',\
    \ 'a'),\n        ('A', 'C'), ('E', 'G'), ('I', 'K'), ('O', 'Q'), ('U', 'W'), ('Y',\
    \ 'A'),\n    ];\n    let mut result = String::new();\n    for c in message.chars()\
    \ {\n        if c.is_alphabetic() {\n            let mut inserted = false;\n \
    \           for (c1, c2) in map.iter() {\n                if c == *c1 {\n    \
    \                result.push(*c2);\n                    inserted = true;\n   \
    \                 break;\n                }\n            }\n            if !inserted\
    \ {\n                result.push(c);\n            }\n        } else {\n      \
    \      result.push(c);\n        }\n    }\n    result", '    unimplemented!()',
  "  let mut encoded = String::new();\n  for c in message.chars() {\n    let c = match\
    \ c {\n      'A' => 'C',\n      'E' => 'G',\n      'I' => 'K',\n      'O' => 'Q',\n\
    \      'U' => 'S',\n      'a' => 'c',\n      'e' => 'g',\n      'i' => 'k',\n\
    \      'o' => 'q',\n      'u' => 's',\n      c => c.to_ascii_uppercase(),\n  \
    \  };\n    encoded.push(c);\n  }\n  encoded", "    let mut encoded_message = String::from(\"\
    \");\n    let mut iter = message.chars();\n    while let Some(mut c) = iter.next()\
    \ {\n        c = match c {\n            'a' => 'c',\n            'e' => 'g',\n\
    \            'i' => 'k',\n            'o' => 'q',\n            'u' => 'y',\n \
    \           'A' => 'C',\n            'E' => 'G',\n            'I' => 'K',\n  \
    \          'O' => 'Q',\n            'U' => 'Y',\n            _ => c.to_ascii_uppercase(),\n\
    \        };\n        encoded_message.push(c);\n    }\n    encoded_message", " \
    \   let mut encoded = String::new();\n    for x in message.chars() {\n       \
    \ match x {\n            'a' => encoded.push('c'),\n            'e' => encoded.push('g'),\n\
    \            'i' => encoded.push('k'),\n            'o' => encoded.push('q'),\n\
    \            'u' => encoded.push('s'),\n            'A' => encoded.push('C'),\n\
    \            'E' => encoded.push('G'),\n            'I' => encoded.push('K'),\n\
    \            'O' => encoded.push('Q'),\n            'U' => encoded.push('S'),\n\
    \            _ => encoded.push(x),\n        }\n    }\n    encoded", "    // message\n\
    \    //     .chars()\n    //     .map(|c| {\n    //         if c.is_ascii_lowercase()\
    \ {\n    //             (c as u8 + 2 - 97) % 26 + 97\n    //         } else {\n\
    \    //             (c as u8 + 2 - 65) % 26 + 65\n    //         }\n    //   \
    \  })\n    //     .collect()\n    let mut new_message = String::new();\n    for\
    \ c in message.chars() {\n        if c.is_ascii_lowercase() {\n            let\
    \ i = (c as u8 + 2 - 97) % 26 + 97;\n            new_message.push(i as char);\n\
    \        } else {\n            let i = (c as u8 + 2 - 65) % 26 + 65;\n       \
    \     new_message.push(i as char);\n        }\n    }\n    new_message", "    message.chars().map(|c|\
    \ match c {\n        'a' => 'c',\n        'e' => 'g',\n        'i' => 'k',\n \
    \       'o' => 'q',\n        'u' => 'w',\n        'A' => 'C',\n        'E' =>\
    \ 'G',\n        'I' => 'K',\n        'O' => 'Q',\n        'U' => 'W',\n      \
    \  _ => if c.is_uppercase() { c.to_lowercase().nth(0).unwrap() } else { c.to_uppercase().nth(0).unwrap()\
    \ }\n    }).collect()", "    let mut new_message = String::new();\n    for c in\
    \ message.chars() {\n        if c.is_ascii_lowercase() {\n            new_message.push(c.to_ascii_uppercase());\n\
    \        } else if c.is_ascii_uppercase() {\n            new_message.push(c.to_ascii_lowercase());\n\
    \        } else {\n            new_message.push(c);\n        }\n    }\n    new_message",
  "    let mut encoded_message = String::new();\n    let message_chars: Vec<char>\
    \ = message.chars().collect();\n    for character in message_chars {\n       \
    \ let encoded_char = match character {\n            'a' => 'c',\n            'A'\
    \ => 'C',\n            'e' => 'g',\n            'E' => 'G',\n            'i' =>\
    \ 'k',\n            'I' => 'K',\n            'o' => 'q',\n            'O' => 'Q',\n\
    \            'u' => 'y',\n            'U' => 'Y',\n            'w' => 'y',\n \
    \           'W' => 'Y',\n            _ => character.to_ascii_uppercase(),\n  \
    \      };\n        encoded_message.push(encoded_char);\n    }\n    encoded_message",
  '    return "";', "    message.chars().map(|c| {\n        let mut c = if c.is_uppercase()\
    \ {\n            c.to_lowercase().next().unwrap()\n        } else {\n        \
    \    c\n        };\n        match c {\n            'a' => 'c',\n            'e'\
    \ => 'g',\n            'i' => 'k',\n            'o' => 'q',\n            'u' =>\
    \ 'y',\n            _ => c,\n        }\n    }).collect()", "    let mut result\
    \ = String::from(\"\");\n    let lowercase = ['a', 'e', 'i', 'o', 'u'];\n    let\
    \ uppercase = ['A', 'E', 'I', 'O', 'U'];\n    for i in message.chars() {\n   \
    \     let mut mapped = ' ';\n        for j in 0..lowercase.len() {\n         \
    \   if i == lowercase[j] {\n                mapped = lowercase[(j + 2) % lowercase.len()];\n\
    \                break;\n            } else if i == uppercase[j] {\n         \
    \       mapped = uppercase[(j + 2) % uppercase.len()];\n                break;\n\
    \            }\n        }\n        if mapped == ' ' {\n            if i.is_lowercase()\
    \ {\n                result.push(i.to_uppercase().next().unwrap());\n        \
    \    } else {\n                result.push(i.to_lowercase().next().unwrap());\n\
    \            }\n        } else {\n            result.push(mapped);\n        }\n\
    \    }\n    result", "    let mut encoded_message = String::new();\n    for c\
    \ in message.chars() {\n        if c.is_ascii_uppercase() {\n            encoded_message.push(c.to_ascii_lowercase());\n\
    \        } else if c.is_ascii_lowercase() {\n            encoded_message.push(c.to_ascii_uppercase());\n\
    \        } else {\n            encoded_message.push(c);\n        }\n    }\n  \
    \  encoded_message", "    let mut encoded = \"\".to_string();\n    for c in message.chars()\
    \ {\n        encoded += &match c {\n            'a' => \"c\",\n            'A'\
    \ => \"C\",\n            'e' => \"g\",\n            'E' => \"G\",\n          \
    \  'i' => \"k\",\n            'I' => \"K\",\n            'o' => \"q\",\n     \
    \       'O' => \"Q\",\n            'u' => \"s\",\n            'U' => \"S\",\n\
    \            'y' => \"a\",\n            'Y' => \"A\",\n            x => x.to_uppercase().to_string().as_str(),\n\
    \        }.to_string();\n    }\n    encoded", "    let mut result = String::new();\n\
    \    for c in message.chars() {\n        match c {\n            'a'...'z' => {\n\
    \                result.push(if c == 'z' { 'B' } else { \n                   \
    \ ((c as u8 + 2) as char).to_uppercase().nth(0).unwrap()\n                });\n\
    \            },\n            'A'...'Z' => {\n                result.push(if c\
    \ == 'Z' { 'b' } else { \n                    ((c as u8 + 2) as char).to_lowercase().nth(0).unwrap()\n\
    \                });\n            },\n            _ => result.push(c),\n     \
    \   }\n    }\n    result", "    let mut encoded = String::new();\n    for (i,\
    \ ch) in message.chars().enumerate() {\n        let mut new_ch = ch;\n       \
    \ if ch.is_ascii_alphabetic() {\n            if ch.is_ascii_lowercase() {\n  \
    \              new_ch = ch.to_ascii_uppercase();\n            } else {\n     \
    \           new_ch = ch.to_ascii_lowercase();\n            }\n            if VOWELS.contains(&new_ch)\
    \ {\n                new_ch = shift_char(new_ch, 2);\n            }\n        }\n\
    \        encoded.push(new_ch);\n    }\n    encoded", "    message.chars().map(|c|\
    \ {\n        match c {\n            'A' => 'C',\n            'E' => 'G',\n   \
    \         'I' => 'K',\n            'O' => 'Q',\n            'U' => 'W',\n    \
    \        'a' => 'c',\n            'e' => 'g',\n            'i' => 'k',\n     \
    \       'o' => 'q',\n            'u' => 'w',\n            ch  => ch.to_ascii_uppercase(),\n\
    \        }\n    }).collect()", "    let mut code = String::new();\n    for c in\
    \ message.chars() {\n        let mut letter = c;\n        if let Some(case) =\
    \ is_letter(c) {\n            letter = encode_letter(letter, case);\n        }\n\
    \        code.push(letter);\n    }\n    code", "    // unimplemented!()\n    let\
    \ mut encoded_message = String::new();\n    let vowels = vec!['a', 'e', 'i', 'o',\
    \ 'u'];\n    for i in message.chars() {\n        if i.is_lowercase() {\n     \
    \       encoded_message.push(i.to_uppercase().next().unwrap());\n        } else\
    \ if i.is_uppercase() {\n            encoded_message.push(i.to_lowercase().next().unwrap());\n\
    \        } else {\n            encoded_message.push(i);\n        }\n    }\n  \
    \  for (i, c) in encoded_message.chars().enumerate() {\n        if vowels.contains(&c)\
    \ {\n            encoded_message.remove(i);\n            encoded_message.insert(i,\
    \ (c as u8 + 2) as char);\n        }\n    }\n    encoded_message", "    let characters:\
    \ Vec<char> = message.chars().collect();\n    let mut encoded_message = String::new();\n\
    \    for character in characters {\n        let ascii_value = character as u8;\n\
    \        let encoded_character = match character {\n            // Upper case\n\
    \            'A' => 'C',\n            'B' => 'D',\n            'C' => 'E',\n \
    \           'D' => 'F',\n            'E' => 'G',\n            'F' => 'H',\n  \
    \          'G' => 'I',\n            'H' => 'J',\n            'I' => 'K',\n   \
    \         'J' => 'L',\n            'K' => 'M',\n            'L' => 'N',\n    \
    \        'M' => 'O',\n            'N' => 'P',\n            'O' => 'Q',\n     \
    \       'P' => 'R',\n            'Q' => 'S',\n            'R' => 'T',\n      \
    \      'S' => 'U',\n            'T' => 'V',\n            'U' => 'W',\n       \
    \     'V' => 'X',\n            'W' => 'Y',\n            'X' => 'Z',\n        \
    \    'Y' => 'A',\n            'Z' => 'B',\n            // Lower case\n       \
    \     'a' => 'c',\n            'b' => 'd',\n            'c' => 'e',\n        \
    \    'd' => 'f',\n            'e' => 'g',\n            'f' => 'h',\n         \
    \   'g' => 'i',\n            'h' => 'j',\n            'i' => 'k',\n          \
    \  'j' => 'l',\n            'k' => 'm',\n            'l' => 'n',\n           \
    \ 'm' => 'o',\n            'n' => 'p',\n            'o' => 'q',\n            'p'\
    \ => 'r',\n            'q' => 's',\n            'r' => 't',\n            's' =>\
    \ 'u',\n            't' => 'v',\n            'u' => 'w',\n            'v' => 'x',\n\
    \            'w' => 'y',\n", "    let mut result = message.to_lowercase();\n \
    \   let mut vowels = String::new();\n    for i in 0..message.len() {\n       \
    \ let c = message.chars().nth(i).unwrap();\n        if is_vowel(c) {\n       \
    \     result.remove(i);\n            vowels.push(encode_vowel(c));\n        }\n\
    \    }\n    result.push_str(&vowels);\n    result", "    let mut ret = String::new();\n\
    \    let mut first = true;\n    for c in message.chars() {\n        if first {\n\
    \            ret.push(c.to_ascii_uppercase());\n            first = false;\n \
    \       } else {\n            ret.push(c.to_ascii_lowercase());\n        }\n \
    \   }\n    ret", "    let mut encoded_message = String::new();\n    for c in message.chars()\
    \ {\n        encoded_message.push(match c {\n            'a' | 'A' => 'C',\n \
    \           'e' | 'E' => 'G',\n            'i' | 'I' => 'K',\n            'o'\
    \ | 'O' => 'M',\n            'u' | 'U' => 'Q',\n            'b' | 'B' => 'D',\n\
    \            'c' | 'C' => 'E',\n            'd' | 'D' => 'F',\n            'f'\
    \ | 'F' => 'H',\n            'g' | 'G' => 'I',\n            'h' | 'H' => 'J',\n\
    \            'j' | 'J' => 'L',\n            'k' | 'K' => 'M',\n            'l'\
    \ | 'L' => 'N',\n            'm' | 'M' => 'O',\n            'n' | 'N' => 'P',\n\
    \            'p' | 'P' => 'R',\n            'q' | 'Q' => 'S',\n            'r'\
    \ | 'R' => 'T',\n            's' | 'S' => 'U',\n            't' | 'T' => 'V',\n\
    \            'v' | 'V' => 'X',\n            'w' | 'W' => 'Y',\n            'x'\
    \ | 'X' => 'Z',\n            'y' | 'Y' => 'A',\n            'z' | 'Z' => 'B',\n\
    \            _ => ' ',\n        });\n    }\n    encoded_message", "    message.chars().map(|c|\
    \ {\n        match c {\n            'A' | 'a' => 'C',\n            'E' | 'e' =>\
    \ 'G',\n            'I' | 'i' => 'K',\n            'O' | 'o' => 'Q',\n       \
    \     'U' | 'u' => 'S',\n            'Y' | 'y' => 'A',\n            _ => {\n \
    \               match c.is_lowercase() {\n                    true => c.to_uppercase().next().unwrap(),\n\
    \                    false => c.to_lowercase().next().unwrap(),\n            \
    \    }\n            }\n        }\n    }).collect()", "    let mut result = String::new();\n\
    \    let mut skip = false;\n    for (index, character) in message.chars().enumerate()\
    \ {\n        if skip {\n            skip = false;\n            continue;\n   \
    \     }\n        let new_char = match character {\n            'a' => 'c',\n \
    \           'A' => 'C',\n            'e' => 'g',\n            'E' => 'G',\n  \
    \          'i' => 'k',\n            'I' => 'K',\n            'o' => 'q',\n   \
    \         'O' => 'Q',\n            'u' => 'y',\n            'U' => 'Y',\n    \
    \        ' ' => ' ',\n            x if x.is_uppercase() => {\n               \
    \ x.to_ascii_lowercase()\n            },\n            x if x.is_lowercase() =>\
    \ {\n                x.to_ascii_uppercase()\n            },\n            _ =>\
    \ character\n        };\n        result.push(new_char);\n    }\n    result", " \
    \   let mut encoded = String::new();\n    let message = message.to_lowercase();\n\
    \    let mut alphabet = \"abcdefghijklmnopqrstuvwxyz\".to_string();\n    for c\
    \ in message.chars() {\n        match c {\n            'a' => encoded.push_str(\"\
    c\"),\n            'e' => encoded.push_str(\"g\"),\n            'i' => encoded.push_str(\"\
    k\"),\n            'o' => encoded.push_str(\"q\"),\n            'u' => encoded.push_str(\"\
    s\"),\n            _ => encoded.push(c)\n        }\n    }\n    encoded", '    unimplemented!()',
  "    let mut message_vec: Vec<char> = message.chars().collect();\n    let mut result:\
    \ Vec<char> = Vec::new();\n    let letters: Vec<char> = vec!['a', 'e', 'i', 'o',\
    \ 'u'];\n    let shift: i32 = 2;\n    let a_int: i32 = 'a' as i32;\n    let z_int:\
    \ i32 = 'z' as i32;\n    let A_int: i32 = 'A' as i32;\n    let Z_int: i32 = 'Z'\
    \ as i32;\n\n    for ch in message_vec {\n        if ch.is_lowercase() {\n   \
    \         let mut ch_int: i32 = ch as i32;\n            ch_int += shift;\n   \
    \         if ch_int > z_int {\n                ch_int -= 26;\n            }\n\
    \            if letters.contains(&ch) {\n                result.push(letters[(ch_int\
    \ - a_int) as usize]);\n            } else {\n                result.push(ch_int\
    \ as u8 as char);\n            }\n        } else if ch.is_uppercase() {\n    \
    \        let mut ch_int: i32 = ch as i32;\n            ch_int += shift;\n    \
    \        if ch_int > Z_int {\n                ch_int -= 26;\n            }\n \
    \           if letters.contains(&ch.to_lowercase().next().unwrap()) {\n      \
    \          result.push(letters[(ch_int - a_int) as usize].to_uppercase().next().unwrap());\n\
    \            } else {\n                result.push(ch_int as u8 as char);\n  \
    \          }\n        } else {\n            result.push(ch);\n        }\n    }\n\
    \    let mut result_string: String = String::new();\n    for ch in result {\n\
    \        result_string.push(ch);\n    }\n    result_string", "    let mut message_chars\
    \ = message.chars();\n    let mut message_string = String::new();\n    while let\
    \ Some(mut a) = message_chars.next() {\n        match a {\n            'A' =>\
    \ a = 'C',\n            'a' => a = 'c',\n            'B' => a = 'D',\n       \
    \     'b' => a = 'd',\n            'C' => a = 'E',\n            'c' => a = 'e',\n\
    \            'D' => a = 'F',\n            'd' => a = 'f',\n            'E' =>\
    \ a = 'G',\n            'e' => a = 'g',\n            'F' => a = 'H',\n       \
    \     'f' => a = 'h',\n            'G' => a = 'I',\n            'g' => a = 'i',\n\
    \            'H' => a = 'J',\n            'h' => a = 'j',\n            'I' =>\
    \ a = 'K',\n            'i' => a = 'k',\n            'J' => a = 'L',\n       \
    \     'j' => a = 'l',\n            'K' => a = 'M',\n            'k' => a = 'm',\n\
    \            'L' => a = 'N',\n            'l' => a = 'n',\n            'M' =>\
    \ a = 'O',\n            'm' => a = 'o',\n            'N' => a = 'P',\n       \
    \     'n' => a = 'p',\n            'O' => a = 'Q',\n            'o' => a = 'q',\n\
    \            'P' => a = 'R',\n            'p' => a = 'r',\n            'Q' =>\
    \ a = 'S',\n            'q' => a = 's',\n            'R' => a = 'T',\n       \
    \     'r' => a = 't',\n            'S' => a = 'U',\n            's' => a = 'u',\n\
    \            'T' => a = 'V',\n            't' => a = 'v',\n            'U' =>\
    \ a = 'W',\n            'u' => a = 'w',\n", "    let vowels = vec!['a', 'e', 'i',\
    \ 'o', 'u'];\n    let mut encrypted_message = Vec::new();\n    for c in message.chars()\
    \ {\n        if vowels.contains(&c) {\n            encrypted_message.push(vowels[(vowels.iter().position(|&v|\
    \ v == c).unwrap() + 2) % 5]);\n        } else {\n            encrypted_message.push(c);\n\
    \        }\n    }\n    encrypted_message.iter().collect()", "    let mut encoded\
    \ = String::new();\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    for character\
    \ in message.chars() {\n        if vowels.contains(&character) {\n           \
    \ let new_char = match character {\n                'a' => 'c',\n            \
    \    'e' => 'g',\n                'i' => 'k',\n                'o' => 'q',\n \
    \               'u' => 'y',\n                _ => ' ',\n            };\n     \
    \       encoded.push(new_char);\n        } else {\n            if character.is_lowercase()\
    \ {\n                encoded.push(character.to_uppercase().to_string().chars().nth(0).unwrap());\n\
    \            } else {\n                encoded.push(character.to_lowercase().to_string().chars().nth(0).unwrap());\n\
    \            }\n        }\n    }\n    encoded", "    message.chars().map(|c| {\n\
    \        match c {\n            'a' | 'e' | 'i' | 'o' | 'u' => ((c as u8) + 2)\
    \ as char,\n            _ => c,\n        }\n    }).map(|c| {\n        match c\
    \ {\n            'a' ... 'z' => ((c as u8) - 32) as char,\n            'A' ...\
    \ 'Z' => ((c as u8) + 32) as char,\n            _ => c,\n        }\n    }).collect()",
  "    let alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut new_message = String::new();\n\
    \    for c in message.chars() {\n        match c {\n            'a' ... 'z' =>\
    \ {\n                let new_char = if c.is_uppercase() {\n                  \
    \  alphabet.chars().nth(((alphabet.chars().position(|x| x == c.to_lowercase().nth(0).unwrap()).unwrap()\
    \ + 2) % 26)).unwrap().to_uppercase().collect::<String>()\n                } else\
    \ {\n                    alphabet.chars().nth(((alphabet.chars().position(|x|\
    \ x == c).unwrap() + 2) % 26)).collect::<String>()\n                };\n     \
    \           new_message.push_str(&new_char);\n            },\n            'A'\
    \ ... 'Z' => {\n                let new_char = if c.is_lowercase() {\n       \
    \             alphabet.chars().nth(((alphabet.chars().position(|x| x == c.to_lowercase().nth(0).unwrap()).unwrap()\
    \ + 2) % 26)).unwrap().to_uppercase().collect::<String>()\n                } else\
    \ {\n                    alphabet.chars().nth(((alphabet.chars().position(|x|\
    \ x == c.to_lowercase().nth(0).unwrap()).unwrap() + 2) % 26)).unwrap().to_uppercase().collect::<String>()\n\
    \                };\n                new_message.push_str(&new_char);\n      \
    \      },\n            _ => { new_message.push(c); }\n        }\n    }\n    new_message",
  "    let mut encoded_message = String::new();\n    for c in message.chars() {\n\
    \        let c = if is_vowel(c) {\n            get_next_vowel(c, 2)\n        }\
    \ else {\n            c\n        };\n        encoded_message.push(c.to_ascii_uppercase());\n\
    \    }\n    encoded_message", "    message.chars().map(|c| {\n        match c\
    \ {\n            'a' => 'c',\n            'A' => 'C',\n            'e' => 'g',\n\
    \            'E' => 'G',\n            'i' => 'k',\n            'I' => 'K',\n \
    \           'o' => 'q',\n            'O' => 'Q',\n            'u' => 'y',\n  \
    \          'U' => 'Y',\n            ' ' => ' ',\n            _ => match c.is_uppercase()\
    \ {\n                true => (c as u8 + 2 - 'A' as u8) as char,\n            \
    \    false => (c as u8 + 2 - 'a' as u8) as char,\n            }\n        }\n \
    \   }).collect()", "    let mut encoded = String::from(\"\");\n    for c in message.chars()\
    \ {\n        if c.is_lowercase() {\n            encoded.push(c.to_uppercase().collect::<String>());\n\
    \        } else if c.is_uppercase() {\n            encoded.push(c.to_lowercase().collect::<String>());\n\
    \        } else {\n            encoded.push(c);\n        }\n    }\n    encoded",
  "    // TODO\n    \"\".to_string()", "    let new_message = message.chars().map(|ch|\
    \ {\n        if ch.is_alphabetic() {\n            let key = match ch.is_uppercase()\
    \ {\n                true => (b'A' as u8, b'Z' as u8),\n                false\
    \ => (b'a' as u8, b'z' as u8),\n            };\n            let c = ch as u8;\n\
    \            let tmp = c + 2;\n            let tmp2 = match tmp {\n          \
    \      x if x > key.1 => x - 26,\n                _ => tmp,\n            };\n\
    \            tmp2 as char\n        } else {\n            ch\n        }\n    }).collect::<String>();\n\
    \    new_message", "    let message_chars: Vec<char> = message.chars().collect();\n\
    \    let mut encoded_message = Vec::with_capacity(message_chars.len());\n    for\
    \ c in message_chars {\n        if is_vowel(c) {\n            let encoded_c =\
    \ if c == 'u' {\n                'a'\n            } else {\n                (c\
    \ as u8 + 2) as char\n            };\n            encoded_message.push(encoded_c.to_uppercase().to_string());\n\
    \        } else {\n            encoded_message.push(c.to_lowercase().to_string());\n\
    \        }\n    }\n    encoded_message.join(\"\")", "    let mut final_message\
    \ = String::new();\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    for c in\
    \ message.chars() {\n        if vowels.contains(&c) {\n            let new_vowel\
    \ = match c {\n                'a' => 'c',\n                'e' => 'g',\n    \
    \            'i' => 'k',\n                'o' => 'q',\n                'u' =>\
    \ 'y',\n                _ => c,\n            };\n            final_message.push(new_vowel);\n\
    \        } else {\n            let new_char = match c {\n                'A'...'Z'\
    \ => c.to_ascii_lowercase(),\n                'a'...'z' => c.to_ascii_uppercase(),\n\
    \                _ => c,\n            };\n            final_message.push(new_char);\n\
    \        }\n    }\n    final_message", "    let vowels = vec!['a', 'e', 'i', 'o',\
    \ 'u'];\n    let mut encoded = message.chars().map(|c| {\n        match c {\n\
    \            'A'...'Z' => {\n                (((c as u8) - 65 + 13) % 26 + 65)\
    \ as char\n            },\n            'a'...'z' => {\n                let offset\
    \ = if vowels.contains(&c) { 2 } else { 0 };\n                (((c as u8) - 97\
    \ + 13 + offset) % 26 + 97) as char\n            },\n            _ => c\n    \
    \    }\n    }).collect::<String>();\n    encoded.make_ascii_uppercase();\n   \
    \ encoded", "    let mut encoded_message = String::new();\n    for character in\
    \ message.chars() {\n        encoded_message.push(match character {\n        \
    \    'a' => 'c',\n            'e' => 'g',\n            'i' => 'k',\n         \
    \   'o' => 'q',\n            'u' => 'w',\n            'A' => 'C',\n          \
    \  'E' => 'G',\n            'I' => 'K',\n            'O' => 'Q',\n           \
    \ 'U' => 'W',\n            c => c.to_ascii_uppercase(),\n        });\n    }\n\
    \    encoded_message", "    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut result = String::new();\n    for c in message.chars() {\n        if vowels.contains(&c)\
    \ {\n            let mut temp = (c as u8 + 2) as char;\n            if temp >\
    \ 'z' {\n                temp = (temp as u8 - 26) as char;\n            }\n  \
    \          result.push(temp);\n        } else if c.is_ascii_lowercase() {\n  \
    \          result.push(c.to_ascii_uppercase());\n        } else {\n          \
    \  result.push(c.to_ascii_lowercase());\n        }\n    }\n    result", "    let\
    \ mut result = String::new();\n    for c in message.chars() {\n        if c.is_alphabetic()\
    \ {\n            let code = c as u8;\n            let new_char = if code <= 109\
    \ {\n                code + 2\n            } else {\n                code - 24\n\
    \            };\n            result.push(new_char as char);\n        } else {\n\
    \            result.push(c);\n        }\n    }\n    result", "    message.chars().map(|c|\
    \ {\n        match c {\n            'a' ... 'w' => (c as u8 + 2) as char,\n  \
    \          'x' => 'a',\n            'y' => 'b',\n            'z' => 'c',\n   \
    \         'A' ... 'W' => (c as u8 + 2) as char,\n            'X' => 'A',\n   \
    \         'Y' => 'B',\n            'Z' => 'C',\n            _ => c,\n        }\n\
    \    }).collect()", "    let mut encoded_message = String::new();\n    let vowels\
    \ = ['a', 'e', 'i', 'o', 'u'];\n    for letter in message.chars() {\n        if\
    \ letter.is_lowercase() {\n            encoded_message.push(letter.to_uppercase().next().unwrap());\n\
    \        } else if letter.is_uppercase() {\n            encoded_message.push(letter.to_lowercase().next().unwrap());\n\
    \        } else {\n            encoded_message.push(letter);\n        }\n    }\n\
    \    for vowel in vowels.iter() {\n        encoded_message = encoded_message.replace(*vowel,\
    \ \"\");\n    }\n    for vowel in vowels.iter() {\n        let l = vowel.to_string().to_uppercase().chars().next().unwrap();\n\
    \        let mut next = l;\n        for _ in 0..2 {\n            next = next.to_string().to_uppercase().chars().next().unwrap();\n\
    \        }\n        let l = vowel.to_string().to_lowercase().chars().next().unwrap();\n\
    \        let mut next_low = l;\n        for _ in 0..2 {\n            next_low\
    \ = next_low.to_string().to_lowercase().chars().next().unwrap();\n        }\n\
    \        encoded_message = encoded_message.replace(vowel, &next.to_string());\n\
    \        encoded_message = encoded_message.replace(&l.to_string(), &next_low.to_string());\n\
    \    }\n    encoded_message", "    message.chars().map(|ch| {\n        match ch\
    \ {\n            'a' | 'e' | 'i' | 'o' | 'u' => encode_vowel(ch),\n          \
    \  _ => encode_other(ch),\n        }\n    }).collect()", "    // Split the message\
    \ into an array of characters\n    let chars: Vec<char> = message.chars().collect();\n\
    \    // Iterate through each character in the message and perform operations\n\
    \    let mut encoded_string = \"\".to_string();\n    for ch in chars {\n     \
    \   let mut encoded_char = ch;\n        // If the character is a vowel, increment\
    \ it by 2 places\n        if (ch == 'a') || (ch == 'e') || (ch == 'i') || (ch\
    \ == 'o') || (ch == 'u') {\n            encoded_char = (ch as u8 + 2) as char;\n\
    \        }\n        // If the character is a lowercase letter, convert it to uppercase\n\
    \        if ch.is_ascii_lowercase() {\n            encoded_char = ch.to_ascii_uppercase();\n\
    \        }\n        // If the character is a uppercase letter, convert it to lowercase\n\
    \        if ch.is_ascii_uppercase() {\n            encoded_char = ch.to_ascii_lowercase();\n\
    \        }\n        // Append the encoded character to the output string\n   \
    \     encoded_string.push(encoded_char);\n    }\n    // Return the encoded string\n\
    \    encoded_string", "    let mut encrypted = String::new();\n    for c in message.chars()\
    \ {\n        if c == 'a' {\n            encrypted.push('c');\n        } else if\
    \ c == 'A' {\n            encrypted.push('C');\n        } else if c == 'e' {\n\
    \            encrypted.push('g');\n        } else if c == 'E' {\n            encrypted.push('G');\n\
    \        } else if c == 'i' {\n            encrypted.push('k');\n        } else\
    \ if c == 'I' {\n            encrypted.push('K');\n        } else if c == 'o'\
    \ {\n            encrypted.push('q');\n        } else if c == 'O' {\n        \
    \    encrypted.push('Q');\n        } else if c == 'u' {\n            encrypted.push('y');\n\
    \        } else if c == 'U' {\n            encrypted.push('Y');\n        } else\
    \ if c.is_lowercase() {\n            encrypted.push(c.to_uppercase().next().unwrap());\n\
    \        } else if c.is_uppercase() {\n            encrypted.push(c.to_lowercase().next().unwrap());\n\
    \        } else {\n            encrypted.push(c);\n        }\n    }\n    encrypted",
  "    let mut encoded_message = message.chars().map(|c| encode_character(c));\n \
    \   let result: String = encoded_message.collect();\n    result", "    let mut\
    \ encoded = String::new();\n    for c in message.chars() {\n        if c.is_ascii_lowercase()\
    \ {\n            encoded.push(c.to_ascii_uppercase());\n        } else if c.is_ascii_uppercase()\
    \ {\n            encoded.push(c.to_ascii_lowercase());\n        } else {\n   \
    \         encoded.push(c);\n        }\n    }\n    return encoded;", "    let mut\
    \ output = String::new();\n    for c in message.chars() {\n        if c.is_lowercase()\
    \ {\n            output.push(c.to_uppercase().to_string().chars().nth(0).unwrap());\n\
    \        } else if c.is_uppercase() {\n            output.push(c.to_lowercase().to_string().chars().nth(0).unwrap());\n\
    \        } else {\n            output.push(c);\n        }\n    }\n    return output;",
  "    let mut ret = String::new();\n    for c in message.chars() {\n        if is_vowel(c)\
    \ {\n            let v = shift_two(c);\n            ret.push(v);\n        } else\
    \ {\n            let x = shift_case(c);\n            ret.push(x);\n        }\n\
    \    }\n    ret", "    let mut encoded_message = String::new();\n    for c in\
    \ message.chars() {\n        let x = match c {\n            'a' => 'c',\n    \
    \        'e' => 'g',\n            'i' => 'k',\n            'o' => 'q',\n     \
    \       'u' => 'w',\n            x if x.is_uppercase() => x.to_lowercase().next().unwrap(),\n\
    \            x if x.is_lowercase() => x.to_uppercase().next().unwrap(),\n    \
    \        _ => c,\n        };\n        encoded_message.push(x);\n    }\n    encoded_message",
  "    let alpabet = vec!['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\
    \ 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n   \
    \ let mut result = String::new();\n    for c in message.chars() {\n        if\
    \ c.is_ascii_uppercase() {\n            if c.is_ascii_lowercase() {\n        \
    \        if alpabet.contains(&c) {\n                    result.push(alpabet[(c\
    \ as usize + 2) % 26]);\n                } else {\n                    result.push(c);\n\
    \                }\n            } else {\n                result.push(c.to_ascii_lowercase());\n\
    \            }\n        } else {\n            if c.is_ascii_lowercase() {\n  \
    \              if alpabet.contains(&c) {\n                    result.push(alpabet[(c\
    \ as usize + 2) % 26].to_ascii_uppercase());\n                } else {\n     \
    \               result.push(c);\n                }\n            } else {\n   \
    \             result.push(c.to_ascii_uppercase());\n            }\n        }\n\
    \    }\n    result", "    let mut encoded_message = String::new();\n    let mut\
    \ vowels = HashSet::new();\n    vowels.insert('a');\n    vowels.insert('e');\n\
    \    vowels.insert('i');\n    vowels.insert('o');\n    vowels.insert('u');\n \
    \   vowels.insert('A');\n    vowels.insert('E');\n    vowels.insert('I');\n  \
    \  vowels.insert('O');\n    vowels.insert('U');\n    for c in message.chars()\
    \ {\n        if c.is_lowercase() {\n            encoded_message.push(c.to_uppercase().next().unwrap());\n\
    \        } else if c.is_uppercase() {\n            encoded_message.push(c.to_lowercase().next().unwrap());\n\
    \        } else {\n            encoded_message.push(c);\n        }\n    }\n  \
    \  let mut new_message = String::new();\n    for c in encoded_message.chars()\
    \ {\n        if vowels.contains(&c) {\n            new_message.push(get_next_vowel(c));\n\
    \        } else {\n            new_message.push(c);\n        }\n    }\n    new_message",
  "    let mut encoded_message = String::new();\n    for character in message.chars()\
    \ {\n        if is_vowel(character) {\n            encoded_message.push(get_next_vowel(character));\n\
    \        } else {\n            if is_upper(character) {\n                encoded_message.push(get_lower(character));\n\
    \            } else {\n                encoded_message.push(get_upper(character));\n\
    \            }\n        }\n    }\n    encoded_message", "    // do some cool stuff\
    \ and return a string here\n    let map = |c: char| {\n        let c = c.to_lowercase().next().unwrap();\n\
    \        match c {\n            'a' => 'c',\n            'e' => 'g',\n       \
    \     'i' => 'k',\n            'o' => 'q',\n            'u' => 'y',\n        \
    \    other => other,\n        }\n    };\n    message.chars().map(map).collect()",
  "    let mut msg = message.clone();\n    let mut new_msg = String::new();\n    for\
    \ c in msg.chars() {\n        if c.is_alphabetic() {\n            new_msg.push(match\
    \ c {\n                'a' => 'c',\n                'e' => 'g',\n            \
    \    'i' => 'k',\n                'o' => 'q',\n                'u' => 'y',\n \
    \               _ => c.to_ascii_uppercase(),\n            });\n        } else\
    \ {\n            new_msg.push(c);\n        }\n    }\n    new_msg", "    let mut\
    \ encoded = String::from(\"\");\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n\
    \    for i in message.to_lowercase().chars() {\n        if vowels.contains(&i)\
    \ {\n            encoded.push((i as u8 + 2) as char);\n        } else {\n    \
    \        encoded.push(i);\n        }\n    }\n    encoded", "    message.chars().map(|c|\
    \ {\n        if is_vowel(c) {\n            encode_vowel(c)\n        } else {\n\
    \            encode_other(c)\n        }\n    }).collect()", "    let vowels =\
    \ ['a', 'e', 'i', 'o', 'u'];\n    let mut out = String::new();\n    for c in message.chars()\
    \ {\n        if vowels.contains(&c) {\n            out.push((c as u8 + 2) as char);\n\
    \        } else {\n            out.push(c);\n        }\n    }\n    out", "   \
    \ // TODO: Implement!\n    \"\".to_string()", "    let swap_case = |c: char| {\n\
    \        if c.is_lowercase() {\n            c.to_uppercase().next().unwrap()\n\
    \        } else {\n            c.to_lowercase().next().unwrap()\n        }\n \
    \   };\n\n    let encode_char = |c: char| {\n        if c.is_alphabetic() {\n\
    \            let start = if c.is_lowercase() { b'a' } else { b'A' };\n       \
    \     let encoded = (c as u8) + 2 - start;\n            if encoded > b'z' - start\
    \ {\n                (start + (encoded - (b'z' - start + 1))) as char\n      \
    \      } else {\n                encoded as char\n            }\n        } else\
    \ {\n            c\n        }\n    };\n\n    let mut encoded_message = String::new();\n\
    \    for c in message.chars() {\n        if c.is_alphabetic() {\n            encoded_message.push(swap_case(c));\n\
    \        } else {\n            encoded_message.push(c);\n        }\n    }\n\n\
    \    encoded_message.chars().map(encode_char).collect()", "    let alphabet: Vec<&str>\
    \ = \"abcdefghijklmnopqrstuvwxyz\".split(\"\").collect();\n    let mut new_message\
    \ = String::new();\n    for character in message.chars() {\n        if character.is_alphabetic()\
    \ {\n            let character_index = get_index(character);\n            if character.is_lowercase()\
    \ {\n                let new_index = get_new_index(character_index);\n       \
    \         new_message.push_str(alphabet[new_index]);\n            } else {\n \
    \               let new_index = get_new_index(character_index);\n            \
    \    new_message.push_str(alphabet[new_index].to_uppercase().as_str());\n    \
    \        }\n        } else {\n            new_message.push(character);\n     \
    \   }\n    }\n    new_message", "    let mut s = String::new();\n    for i in\
    \ message.chars() {\n        let res = if is_vowel(i) {\n            match next_vowel(i)\
    \ {\n                Some(v) => v,\n                None => ' ',\n           \
    \ }\n        } else {\n            i\n        };\n        s.push(res);\n    }\n\
    \    s", "    let mut message_encoded = String::new();\n    for c in message.chars()\
    \ {\n        let x: u8 = c as u8;\n        let x_encoded: u8;\n        if x >=\
    \ 97 && x <= 122 {\n            x_encoded = x - 32;\n        } else if x >= 65\
    \ && x <= 90 {\n            x_encoded = x + 32;\n        } else {\n          \
    \  x_encoded = x;\n        }\n        let y: char = x_encoded as char;\n     \
    \   match y {\n            'A' => message_encoded.push('C'),\n            'E'\
    \ => message_encoded.push('G'),\n            'I' => message_encoded.push('K'),\n\
    \            'O' => message_encoded.push('Q'),\n            'U' => message_encoded.push('S'),\n\
    \            'Y' => message_encoded.push('A'),\n            _ => message_encoded.push(y),\n\
    \        }\n    }\n    message_encoded", "    let mut encoded_string = String::new();\n\
    \    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    for ch in message.chars() {\n\
    \        if ch.is_ascii_lowercase() {\n            encoded_string.push(ch.to_ascii_uppercase());\n\
    \        } else if ch.is_ascii_uppercase() {\n            encoded_string.push(ch.to_ascii_lowercase());\n\
    \        } else {\n            encoded_string.push(ch);\n        }\n    }\n  \
    \  encoded_string", '  unimplemented!()', "    let mut output = String::new();\n\
    \    for c in message.chars() {\n        let l = c.to_lowercase().to_string();\n\
    \        if l == \"a\" {\n            output.push('c');\n        } else if l ==\
    \ \"e\" {\n            output.push('g');\n        } else if l == \"i\" {\n   \
    \         output.push('k');\n        } else if l == \"o\" {\n            output.push('q');\n\
    \        } else if l == \"u\" {\n            output.push('s');\n        } else\
    \ if c.is_lowercase() {\n            output.push(((c as u8) + 2) as char);\n \
    \       } else {\n            output.push(((c as u8) - 32 + 2) as char);\n   \
    \     }\n    }\n    output", "    let vowels = \"AEIOUaeiou\";\n    let letters\
    \ = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    let mut result\
    \ = String::new();\n    for c in message.chars() {\n        if vowels.contains(c)\
    \ {\n            result.push_str(&letters[\n                (letters.find(c).unwrap()\
    \ + 2) % letters.len()..\n                (letters.find(c).unwrap() + 3) % letters.len()\n\
    \            ])\n        } else if letters.contains(c) {\n            result.push_str(&letters[\n\
    \                (letters.find(c).unwrap() + letters.len() / 2) % letters.len()..\n\
    \                (letters.find(c).unwrap() + letters.len() / 2 + 1) % letters.len()\n\
    \            ])\n        } else {\n            result.push(c);\n        }\n  \
    \  }\n    result", "    let mut encoded_message = String::new();\n    let vowels\
    \ = ['a', 'e', 'i', 'o', 'u'];\n    for c in message.chars() {\n        if vowels.contains(&c)\
    \ {\n            encoded_message.push(next_vowel(c));\n        } else {\n    \
    \        encoded_message.push(next_char(c));\n        }\n    }\n    encoded_message",
  "    let mut result = String::new();\n    for character in message.chars() {\n \
    \       let replaced = match character {\n            'A' => 'C',\n          \
    \  'a' => 'c',\n            'E' => 'G',\n            'e' => 'g',\n           \
    \ 'I' => 'K',\n            'i' => 'k',\n            'O' => 'Q',\n            'o'\
    \ => 'q',\n            'U' => 'S',\n            'u' => 's',\n            'Y' =>\
    \ 'A',\n            'y' => 'a',\n            _ => character,\n        };\n   \
    \     result.push(replaced);\n    }\n    result", "    message.chars().map(|c|\
    \ {\n        let mut c = if c.is_uppercase() { c.to_lowercase().next().unwrap()\
    \ } else { c };\n        if c == 'a' {\n            c = 'c';\n        } else if\
    \ c == 'e' {\n            c = 'g';\n        } else if c == 'i' {\n           \
    \ c = 'k';\n        } else if c == 'o' {\n            c = 'q';\n        } else\
    \ if c == 'u' {\n            c = 'y';\n        }\n        c\n    }).collect()",
  "    message.chars().map(|l| {\n        let mut new_char = if l.is_ascii_lowercase()\
    \ { l.to_ascii_uppercase() } else { l.to_ascii_lowercase() };\n        match new_char\
    \ {\n            'A' => 'C',\n            'E' => 'G',\n            'I' => 'K',\n\
    \            'O' => 'Q',\n            'U' => 'Y',\n            _ => new_char\n\
    \        }\n    }).collect()", "    const VOWELS: [char; 5] = ['a', 'e', 'i',\
    \ 'o', 'u'];\n    let vowels = &VOWELS;\n    let mut encoded_string = String::new();\n\
    \    for c in message.chars() {\n        let mut char_encoded = c;\n        if\
    \ c.is_alphabetic() {\n            if c.is_uppercase() {\n                char_encoded\
    \ = c.to_lowercase().collect::<Vec<char>>()[0];\n            }\n            if\
    \ vowels.contains(&char_encoded) {\n                char_encoded = c_ahead(char_encoded,\
    \ 2);\n            }\n        }\n        encoded_string.push(char_encoded);\n\
    \    }\n    encoded_string", "    let mut result = String::new();\n    for c in\
    \ message.chars() {\n        if c.is_alphabetic() {\n            result.push(if\
    \ c.is_uppercase() {\n                match c {\n                    'A' => 'C',\n\
    \                    'E' => 'G',\n                    'I' => 'K',\n          \
    \          'O' => 'Q',\n                    'U' => 'Y',\n                    'Z'\
    \ => 'B',\n                    _ => (c as u8 + 2) as char,\n                }\n\
    \            } else {\n                match c {\n                    'a' => 'c',\n\
    \                    'e' => 'g',\n                    'i' => 'k',\n          \
    \          'o' => 'q',\n                    'u' => 'y',\n                    'z'\
    \ => 'b',\n                    _ => (c as u8 + 2) as char,\n                }\n\
    \            });\n        } else {\n            result.push(c);\n        }\n \
    \   }\n    result", "    // Your code here\n    let mut new_message = String::new();\n\
    \    let mut new_char: char;\n    for character in message.chars() {\n       \
    \ if character.is_alphabetic() {\n            if character.is_uppercase() {\n\
    \                if character == 'A' {\n                    new_char = 'C';\n\
    \                } else if character == 'E' {\n                    new_char =\
    \ 'G';\n                } else if character == 'I' {\n                    new_char\
    \ = 'K';\n                } else if character == 'O' {\n                    new_char\
    \ = 'Q';\n                } else if character == 'U' {\n                    new_char\
    \ = 'Y';\n                } else {\n                    new_char = character.to_ascii_lowercase();\n\
    \                }\n            } else {\n                if character == 'a'\
    \ {\n                    new_char = 'c';\n                } else if character\
    \ == 'e' {\n                    new_char = 'g';\n                } else if character\
    \ == 'i' {\n                    new_char = 'k';\n                } else if character\
    \ == 'o' {\n                    new_char = 'q';\n                } else if character\
    \ == 'u' {\n                    new_char = 'y';\n                } else {\n  \
    \                  new_char = character.to_ascii_uppercase();\n              \
    \  }\n            }\n        } else {\n            new_char = character;\n   \
    \     }\n        new_message.push(new_char);\n    }\n    new_message", "    //\
    \ Your code here!\n    unimplemented!();", "    let mut code = String::new();\n\
    \    for c in message.chars() {\n        if c.is_alphabetic() {\n            code.push(match\
    \ c {\n                'a' => 'c',\n                'e' => 'g',\n            \
    \    'i' => 'k',\n                'o' => 'q',\n                'u' => 'y',\n \
    \               _   => c.to_uppercase().next().unwrap()\n            });\n   \
    \     }\n    }\n    code", "    let vowels = \"aeiou\";\n    let alphabet = \"\
    abcdefghijklmnopqrstuvwxyz\";\n    let mut encoded_message = String::new();\n\
    \    for letter in message.chars() {\n        match letter {\n            'a'..='z'\
    \ => {\n                let letter_idx = alphabet.find(letter).unwrap();\n   \
    \             let is_vowel = vowels.find(letter).is_some();\n                if\
    \ is_vowel {\n                    let encoded_idx = (letter_idx + 2) % alphabet.len();\n\
    \                    encoded_message.push(alphabet.chars().nth(encoded_idx).unwrap());\n\
    \                } else {\n                    encoded_message.push(letter);\n\
    \                }\n            },\n            'A'..='Z' => {\n             \
    \   let letter_idx = alphabet.find(letter.to_ascii_lowercase()).unwrap();\n  \
    \              let is_vowel = vowels.find(letter.to_ascii_lowercase()).is_some();\n\
    \                if is_vowel {\n                    let encoded_idx = (letter_idx\
    \ + 2) % alphabet.len();\n                    encoded_message.push(alphabet.chars().nth(encoded_idx).unwrap().to_ascii_uppercase());\n\
    \                } else {\n                    encoded_message.push(letter);\n\
    \                }\n            },\n            _ => encoded_message.push(letter),\n\
    \        }\n    }\n    encoded_message", "    // TODO\n    \"\".to_string()",
  "    let new_message = message.chars().map(|x| {\n        if x.is_alphabetic() {\n\
    \            match x.to_lowercase().next().unwrap() {\n                'a' =>\
    \ 'c',\n                'e' => 'g',\n                'i' => 'k',\n           \
    \     'o' => 'q',\n                'u' => 'w',\n                x => x,\n    \
    \        }\n        } else {\n            x\n        }\n    });\n    let message:\
    \ String = new_message.collect();\n    message.to_uppercase()", "    let lower_vowels\
    \ = ['a', 'e', 'i', 'o', 'u'];\n    let upper_vowels = ['A', 'E', 'I', 'O', 'U'];\n\
    \    let mut encoded_message = String::new();\n    for letter in message.chars()\
    \ {\n        if lower_vowels.contains(&letter) {\n            encoded_message.push(letter.to_ascii_uppercase());\n\
    \        } else if upper_vowels.contains(&letter) {\n            encoded_message.push(letter.to_ascii_lowercase());\n\
    \        } else {\n            encoded_message.push(letter);\n        }\n    }\n\
    \    for (i, letter) in encoded_message.chars().enumerate() {\n        if letter\
    \ == 'A' {\n            encoded_message.replace_range(i..i+1, \"C\");\n      \
    \  } else if letter == 'B' {\n            encoded_message.replace_range(i..i+1,\
    \ \"D\");\n        } else if letter == 'C' {\n            encoded_message.replace_range(i..i+1,\
    \ \"E\");\n        } else if letter == 'D' {\n            encoded_message.replace_range(i..i+1,\
    \ \"F\");\n        } else if letter == 'E' {\n            encoded_message.replace_range(i..i+1,\
    \ \"G\");\n        } else if letter == 'F' {\n            encoded_message.replace_range(i..i+1,\
    \ \"H\");\n        } else if letter == 'G' {\n            encoded_message.replace_range(i..i+1,\
    \ \"I\");\n        } else if letter == 'H' {\n            encoded_message.replace_range(i..i+1,\
    \ \"J\");\n        } else if letter == 'I' {\n            encoded_message.replace_range(i..i+1,\
    \ \"K\");\n        } else if letter == 'J' {\n            encoded_message.replace_range(i..i+1,\
    \ \"L\");\n        } else if letter == 'K' {\n            encoded_message.replace_range(i..i+1,\
    \ \"", "    let mut ret = String::new();\n    for c in message.chars() {\n   \
    \     if !c.is_alphabetic() {\n            ret.push(c);\n            continue;\n\
    \        }\n        let mut e = c;\n        if c.is_uppercase() {\n          \
    \  e = e.to_lowercase().next().unwrap();\n        } else {\n            e = e.to_uppercase().next().unwrap();\n\
    \        }\n        match e {\n            'a' => ret.push('c'),\n           \
    \ 'e' => ret.push('g'),\n            'i' => ret.push('k'),\n            'o' =>\
    \ ret.push('q'),\n            'u' => ret.push('s'),\n            'y' => ret.push('a'),\n\
    \            _ => ret.push(e),\n        }\n    }\n    ret", "    // your code\
    \ goes here\n    let vowels = [ \"a\", \"e\", \"i\", \"o\", \"u\" ];\n    let\
    \ mut encoded_message = String::new();\n    for c in message.chars() {\n     \
    \   if vowels.contains(&c.to_lowercase().to_string().as_str()) {\n           \
    \ if c.is_lowercase() {\n                let mut i = vowels.iter().position(|&r|\
    \ r == c.to_lowercase().to_string().as_str()).unwrap();\n                i = i\
    \ + 2;\n                if i > 4 {\n                    i = i - 5;\n         \
    \       }\n                encoded_message.push_str(vowels[i]);\n            }\
    \ else {\n                let mut i = vowels.iter().position(|&r| r == c.to_lowercase().to_string().as_str()).unwrap();\n\
    \                i = i + 2;\n                if i > 4 {\n                    i\
    \ = i - 5;\n                }\n                encoded_message.push_str(vowels[i].to_uppercase().as_str());\n\
    \            }\n        } else {\n            encoded_message.push(c);\n     \
    \   }\n    }\n    encoded_message", '    unimplemented!();', "    let message\
    \ = message.into_bytes();\n    let mut index = 0;\n    let mut buffer = vec![];\n\
    \    for c in message {\n        index += 1;\n        let c = match c {\n    \
    \        c if c >= 'a' as u8 && c <= 'z' as u8 => c - 0x20,\n            c if\
    \ c >= 'A' as u8 && c <= 'Z' as u8 => c + 0x20,\n            c if c == 'a' as\
    \ u8 || c == 'e' as u8 || c == 'i' as u8 || c == 'o' as u8 || c == 'u' as u8 ||\
    \ c == 'A' as u8 || c == 'E' as u8 || c == 'I' as u8 || c == 'O' as u8 || c ==\
    \ 'U' as u8 => c + 2,\n            c => c,\n        };\n        buffer.push(c);\n\
    \    }\n    String::from_utf8(buffer).unwrap()", "    let mut output = String::new();\n\
    \    for c in message.chars() {\n        if c.is_lowercase() {\n            output.push(c.to_uppercase().next().unwrap());\n\
    \        } else if c.is_uppercase() {\n            output.push(c.to_lowercase().next().unwrap());\n\
    \        } else {\n            output.push(c);\n        }\n    }\n    output",
  "    let mut iter = message.chars();\n    let mut encoded_message = String::new();\n\
    \    while let Some(c) = iter.next() {\n        match c {\n            'a' =>\
    \ encoded_message.push('c'),\n            'e' => encoded_message.push('g'),\n\
    \            'i' => encoded_message.push('k'),\n            'o' => encoded_message.push('q'),\n\
    \            'u' => encoded_message.push('s'),\n            'y' => encoded_message.push('a'),\n\
    \            _ => encoded_message.push(c),\n        }\n    }\n    encoded_message",
  "    message.chars().map(|c| {\n        let lower = c.to_lowercase().collect::<Vec<char>>()[0];\n\
    \        let alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n        let uppercase\
    \ = c.is_uppercase();\n        if alphabet.contains(lower) {\n            let\
    \ index = alphabet.find(lower).unwrap();\n            let (mut next, _) = alphabet.split_at(index);\n\
    \            next = next.chars().rev().take(2).collect::<Vec<char>>();\n     \
    \       next.reverse();\n            let res = next[0];\n            if uppercase\
    \ {\n                res.to_uppercase().collect::<Vec<char>>()[0]\n          \
    \  } else {\n                res\n            }\n        } else {\n          \
    \  c\n        }\n    }).collect()", "    let mut msg = String::new();\n    for\
    \ c in message.chars() {\n        let upper = if c.is_lowercase() {\n        \
    \    c.to_uppercase().next().unwrap()\n        } else {\n            c\n     \
    \   };\n        let lower = if c.is_uppercase() {\n            c.to_lowercase().next().unwrap()\n\
    \        } else {\n            c\n        };\n        match upper {\n        \
    \    'A' => msg.push('C'),\n            'E' => msg.push('G'),\n            'I'\
    \ => msg.push('K'),\n            'O' => msg.push('M'),\n            'U' => msg.push('Q'),\n\
    \            _ => msg.push(lower),\n        }\n    }\n    msg", '    unimplemented!();',
  "    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut output = String::new();\n\
    \    for c in message.chars() {\n        let mut c = c.to_ascii_lowercase();\n\
    \        if c == ' ' {\n            output.push(' ');\n            continue;\n\
    \        }\n        if let Some(index) = vowels.iter().position(|&v| v == c) {\n\
    \            c = vowels[(index + 2) % vowels.len()];\n        }\n        output.push(c);\n\
    \    }\n    output", "    let encoded = message.chars().map(|c| {\n        let\
    \ base = match c.is_lowercase() {\n            true => 'a',\n            false\
    \ => 'A',\n        };\n        let mut new_c = c.to_lowercase().next().unwrap();\n\
    \        let offset = match c {\n            'a' | 'e' | 'i' | 'o' | 'u' => 2,\n\
    \            _ => 0,\n        };\n        if offset != 0 {\n            new_c\
    \ = new_c.wrapping_add(offset);\n        }\n        (new_c as u8 - base as u8\
    \ + base as u8) as char\n    });\n    encoded.collect()", "    let mut encoded\
    \ = String::new();\n    for c in message.chars() {\n        if c.is_alphabetic()\
    \ {\n            let mut next = c.to_ascii_lowercase();\n            match next\
    \ {\n                'a' | 'c' | 'e' | 'g' | 'i' | 'k' | 'm' | 'o' | 'q' | 's'\
    \ | 'u' | 'w' | 'y' => {\n                    next = next.wrapping_add(2);\n \
    \               }\n                'b' | 'd' | 'f' | 'h' | 'j' | 'l' | 'n' | 'p'\
    \ | 'r' | 't' | 'v' | 'x' | 'z' => {\n                    next = next.wrapping_add(1);\n\
    \                }\n                _ => {}\n            }\n            if c.is_lowercase()\
    \ {\n                encoded.push(next);\n            } else {\n             \
    \   encoded.push(next.to_ascii_uppercase());\n            }\n        } else {\n\
    \            encoded.push(c);\n        }\n    }\n    encoded", '  message.chars().map(|c|
    if is_vowel(c) { encode_vowel(c) } else { encode_consonant(c) }).collect()', " \
    \   let chars: Vec<char> = message.chars().collect();\n    let mut result: Vec<char>\
    \ = Vec::new();\n    for char in chars {\n        match char {\n            'A'\
    \ | 'a' => result.push('c'),\n            'E' | 'e' => result.push('g'),\n   \
    \         'I' | 'i' => result.push('k'),\n            'O' | 'o' => result.push('q'),\n\
    \            'U' | 'u' => result.push('s'),\n            _ => result.push(char),\n\
    \        }\n    }\n    result.iter().collect()", "    let mut out = String::new();\n\
    \    let mut l = false;\n    for c in message.chars() {\n        l = !l;\n   \
    \     if l {\n            out.push(c.to_uppercase().next().unwrap());\n      \
    \  } else {\n            out.push(c.to_lowercase().next().unwrap());\n       \
    \ }\n    }\n    out", "    // TODO: Implement me!\n    unimplemented!();", " \
    \   let mut res = String::new();\n    for letter in message.chars() {\n      \
    \  if letter.is_uppercase() {\n            res.push(letter.to_lowercase().to_string().chars().next().unwrap());\n\
    \        } else if letter.is_lowercase() {\n            res.push(letter.to_uppercase().to_string().chars().next().unwrap());\n\
    \        } else {\n            res.push(letter);\n        }\n    }\n    res",
  "    let mut result = String::from(\"\");\n    for char in message.chars() {\n \
    \       result.push(match char {\n            'a' => 'c',\n            'e' =>\
    \ 'g',\n            'i' => 'k',\n            'o' => 'q',\n            'u' => 'w',\n\
    \            'y' => 'a',\n            'A' => 'C',\n            'E' => 'G',\n \
    \           'I' => 'K',\n            'O' => 'Q',\n            'U' => 'W',\n  \
    \          'Y' => 'A',\n            x => x.to_ascii_uppercase(),\n        });\n\
    \    }\n    result", "    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n\
    \    message.chars().map(|c| {\n        if vowels.contains(&c.to_string().as_str())\
    \ {\n            let index = vowels.iter().position(|&r| r == c.to_string().as_str()).unwrap();\n\
    \            let mut new_index = index + 2;\n            if new_index > 4 {\n\
    \                new_index = new_index - 5;\n            }\n            vowels[new_index].chars().next().unwrap()\n\
    \        } else {\n            if c.is_ascii_uppercase() {\n                c.to_ascii_lowercase()\n\
    \            } else {\n                c.to_ascii_uppercase()\n            }\n\
    \        }\n    }).collect()", "    message.chars().map(|c| {\n        let unicode\
    \ = c as u32;\n        if unicode >= 65 && unicode <= 90 {\n            let new_unicode\
    \ = unicode + 2;\n            let new_unicode = if new_unicode > 90 {\n      \
    \          (new_unicode - 90) + 64\n            } else {\n                new_unicode\n\
    \            };\n            return (new_unicode as u8) as char;\n        } else\
    \ if unicode >= 97 && unicode <= 122 {\n            let new_unicode = unicode\
    \ + 2;\n            let new_unicode = if new_unicode > 122 {\n               \
    \ (new_unicode - 122) + 96\n            } else {\n                new_unicode\n\
    \            };\n            return (new_unicode as u8) as char;\n        } else\
    \ {\n            return c;\n        }\n    }).collect()", "    message.into_bytes().iter().map(|b|\
    \ {\n        if b >= &b'a' && b <= &b'z' {\n            b - 1\n        } else\
    \ if b >= &b'A' && b <= &b'Z' {\n            b + 1\n        } else {\n       \
    \     *b\n        }\n    }).map(|b| {\n        if b == b'u' || b == b'U' {\n \
    \           b - 24\n        } else if b == b'v' || b == b'V' {\n            b\
    \ - 22\n        } else if b == b'i' || b == b'I' {\n            b + 2\n      \
    \  } else if b == b'e' || b == b'E' {\n            b + 4\n        } else if b\
    \ == b'o' || b == b'O' {\n            b + 2\n        } else {\n            b\n\
    \        }\n    }).map(|b| b as char).collect()", "    let mut encoded_message\
    \ = String::new();\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    for c\
    \ in message.chars() {\n        if vowels.contains(&c) {\n            encoded_message.push(vowels[((vowels.iter().position(|&x|\
    \ x == c).unwrap() + 2) % 5) as usize]);\n        } else {\n            if c.is_uppercase()\
    \ {\n                encoded_message.push(c.to_lowercase().to_string().chars().next().unwrap());\n\
    \            } else {\n                encoded_message.push(c.to_uppercase().to_string().chars().next().unwrap());\n\
    \            }\n        }\n    }\n    encoded_message", "    let mut swap = message.chars().map(|c|\
    \ match c {\n        'a' => 'c',\n        'e' => 'g',\n        'i' => 'k',\n \
    \       'o' => 'q',\n        'u' => 'w',\n        'A' => 'C',\n        'E' =>\
    \ 'G',\n        'I' => 'K',\n        'O' => 'Q',\n        'U' => 'W',\n      \
    \  _ => c,\n    }).collect::<String>();\n    swap.make_ascii_uppercase();\n  \
    \  swap", "    let mut encoded_message = String::new();\n    let vowels = \"aeiou\"\
    ;\n    for c in message.chars() {\n        if vowels.contains(c) {\n         \
    \   let i = vowels.find(c).unwrap();\n            encoded_message.push(vowels.chars().nth(i\
    \ + 2).unwrap());\n        } else {\n            encoded_message.push(c);\n  \
    \      }\n    }\n    encoded_message", "    const VOWELS: [char; 10] = ['a', 'e',\
    \ 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'];\n    const ENGLISH_ALPHABET: [char;\
    \ 26] = [\n        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\
    \ 'm', 'n', 'o', 'p', 'q', 'r',\n        's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n\
    \    ];\n    let mut c_message = message.chars();\n    let mut encoded_message\
    \ = String::new();\n    loop {\n        match c_message.next() {\n           \
    \ Some(c) => {\n                let mut char_index = ENGLISH_ALPHABET.iter().position(|&r|\
    \ r == c);\n                if char_index.is_some() {\n                    char_index\
    \ = Some(char_index.unwrap() + 2);\n                    let c_index = char_index.unwrap()\
    \ % 26;\n                    let next_char = ENGLISH_ALPHABET[c_index];\n    \
    \                encoded_message.push(next_char);\n                } else {\n\
    \                    encoded_message.push(c);\n                }\n           \
    \ }\n            None => {\n                break;\n            }\n        }\n\
    \    }\n    encoded_message", '    unimplemented!()', "    let letters = message.chars().map(|c|\
    \ {\n        let mut i = c.to_ascii_lowercase() as i8;\n        if i > 109 {\n\
    \            i -= 26;\n        }\n        if i == 97 || i == 101 || i == 105 ||\
    \ i == 111 || i == 117 {\n            i += 2;\n        }\n        (i as u8) as\
    \ char\n    });\n    letters.collect()", "    let mut new_message = String::new();\n\
    \    for ch in message.chars() {\n        let c: char = match ch {\n         \
    \   'a' => 'c',\n            'e' => 'g',\n            'i' => 'k',\n          \
    \  'o' => 'q',\n            'u' => 'w',\n            'A' => 'C',\n           \
    \ 'E' => 'G',\n            'I' => 'K',\n            'O' => 'Q',\n            'U'\
    \ => 'W',\n            _ => ch,\n        };\n        new_message.push(c);\n  \
    \  }\n    new_message", "    let mut encoder = Vec::new();\n    let vowels = ['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut skip_letters = HashSet::new();\n    for (idx,\
    \ ch) in message.to_lowercase().chars().enumerate() {\n        if ch == ' ' {\n\
    \            skip_letters.insert(idx);\n            encoder.push(ch);\n      \
    \  } else if vowels.contains(&ch) {\n            encoder.push(match ch {\n   \
    \             'a' => 'c',\n                'e' => 'g',\n                'i' =>\
    \ 'k',\n                'o' => 'q',\n                'u' => 'y',\n           \
    \     _ => ch,\n            });\n            if idx + 1 < message.len() {\n  \
    \              skip_letters.insert(idx + 1);\n            }\n            if idx\
    \ + 2 < message.len() {\n                skip_letters.insert(idx + 2);\n     \
    \       }\n        } else {\n            encoder.push(ch);\n        }\n    }\n\
    \    let mut encoded = String::new();\n    for (idx, ch) in message.chars().enumerate()\
    \ {\n        if skip_letters.contains(&idx) {\n            encoded.push(ch);\n\
    \        } else {\n            encoded.push(encoder[idx]);\n        }\n    }\n\
    \    encoded", "    let mut enc_message = String::new();\n    let mut idx: i8\
    \ = 0;\n    for c in message.chars() {\n        if c.is_ascii_uppercase() {\n\
    \            idx = c as i8 - 'A' as i8;\n            if c == 'Y' {\n         \
    \       enc_message.push('A');\n            } else if c == 'Z' {\n           \
    \     enc_message.push('B');\n            } else {\n                enc_message.push((idx\
    \ + 2 + 'A' as i8) as u8 as char);\n            }\n        } else if c.is_ascii_lowercase()\
    \ {\n            idx = c as i8 - 'a' as i8;\n            if c == 'y' {\n     \
    \           enc_message.push('a');\n            } else if c == 'z' {\n       \
    \         enc_message.push('b');\n            } else {\n                enc_message.push((idx\
    \ + 2 + 'a' as i8) as u8 as char);\n            }\n        } else {\n        \
    \    enc_message.push(c);\n        }\n    }\n    enc_message", "    let mut encoded\
    \ = String::new();\n    for c in message.chars() {\n        let new_char = match\
    \ c {\n            'A' | 'a' => 'C',\n            'E' | 'e' => 'G',\n        \
    \    'I' | 'i' => 'K',\n            'O' | 'o' => 'Q',\n            'U' | 'u' =>\
    \ 'S',\n            'Y' | 'y' => 'A',\n            'z' => 'b',\n            'x'\
    \ => 'z',\n            'Z' => 'B',\n            'X' => 'Z',\n            ' ' =>\
    \ ' ',\n            c if c.is_ascii_lowercase() => ((c as u8) + 2) as char,\n\
    \            c if c.is_ascii_uppercase() => ((c as u8) + 2) as char,\n       \
    \     _ => c,\n        };\n        encoded.push(new_char);\n    }\n    encoded",
  "    // TODO\n    unimplemented!()", "    let mut result = String::new();\n    for\
    \ ch in message.chars() {\n        if ch.is_lowercase() {\n            result.push(ch.to_uppercase().next().unwrap());\n\
    \        } else if ch.is_uppercase() {\n            result.push(ch.to_lowercase().next().unwrap());\n\
    \        } else {\n            result.push(ch);\n        }\n    }\n    result",
  '    message.chars().map(|c| encode_char(c)).collect()', "    let mut res: String\
    \ = String::new();\n    let base = 'a' as u8;\n    let len = 'z' as u8 - base\
    \ + 1;\n    for c in message.chars() {\n        let lowercase = c.to_lowercase().next().unwrap();\n\
    \        if c.is_ascii_lowercase() {\n            if is_vowel(lowercase) {\n \
    \               let shift = (lowercase as u8 - base + 2) % len;\n            \
    \    res.push((shift + base) as char);\n            } else {\n               \
    \ res.push(lowercase);\n            }\n        } else {\n            if is_vowel(lowercase)\
    \ {\n                let shift = (lowercase as u8 - base + 2) % len;\n       \
    \         res.push((shift + base) as char);\n            } else {\n          \
    \      res.push(lowercase);\n            }\n        }\n    }\n    res"]
stop_tokens:
- "\n}"
