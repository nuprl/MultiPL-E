name: HumanEval_6_parse_nested_parens
language: rust
results:
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // Split string into individual groups and initialize a\
    \ new vector to store results\n    let paren_groups: Vec<&str> = paren_string.split_whitespace().collect();\n\
    \    let mut paren_count = Vec::new();\n\n    // For each group, iterate through\
    \ the string and count open and closed parentheses.\n    // Keep track of the\
    \ max nest count for each group.\n    for group in paren_groups {\n        let\
    \ mut nest_count = 0;\n        let mut max_nest_count = 0;\n        for c in group.chars()\
    \ {\n            if c == '(' {\n                nest_count += 1;\n           \
    \ } else if c == ')' {\n                nest_count -= 1;\n            }\n    \
    \        max_nest_count = std::cmp::max(max_nest_count, nest_count);\n       \
    \ }\n        paren_count.push(max_nest_count);\n    }\n    paren_count\n}\n\n\
    fn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // Parse using a stack\n    let mut stack: Vec<char> =\
    \ Vec::new();\n    let mut level: isize = 0;\n    let mut levels: Vec<isize> =\
    \ Vec::new();\n    for c in paren_string.chars() {\n        if c == '(' {\n  \
    \          level += 1;\n            stack.push(c);\n        } else if c == ')'\
    \ {\n            level -= 1;\n            if stack.pop().unwrap() != '(' {\n \
    \               panic!(\"Input string must have matching parentheses\");\n   \
    \         }\n        } else if c == ' ' {\n            levels.push(level);\n \
    \       }\n    }\n    levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpr4khcnzm.rs:29:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth: isize = 0;\n    let mut depth: isize\
    \ = 0;\n    let mut paren_count: Vec<isize> = Vec::new();\n\n    for char in paren_string.chars()\
    \ {\n        if char == '(' {\n            depth += 1;\n            if depth >\
    \ max_depth {\n                max_depth = depth;\n            }\n        } else\
    \ if char == ')' {\n            depth -= 1;\n        } else if char == ' ' {\n\
    \            paren_count.push(max_depth);\n            max_depth = 0;\n      \
    \      depth = 0;\n        }\n    }\n    paren_count.push(max_depth);\n    paren_count\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // Store the result\n    let mut result = Vec::new();\n\
    \n    // Iterate over the input string\n    let mut stack = Vec::new();\n    for\
    \ paren in paren_string.chars() {\n        match paren {\n            '(' => {\n\
    \                stack.push(paren);\n            }\n            ')' => {\n   \
    \             // A new result is complete\n                if stack.is_empty()\
    \ {\n                    result.push(0);\n                } else {\n         \
    \           // Pop the previous open parenthesis\n                    stack.pop();\n\
    \                    // If the stack is empty, we have encountered a full matched\
    \ level of parens\n                    if stack.is_empty() {\n               \
    \         result.push(1);\n                    }\n                }\n        \
    \    }\n            _ => {}\n        }\n    }\n\n    // If there is anything left\
    \ in the stack, there was a mismatch\n    for _ in stack {\n        result.push(0);\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpjxawtuly.rs:44:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // Split the input string into groups of parentheses.\n\
    \    let paren_groups: Vec<&str> = paren_string.split_whitespace().collect();\n\
    \n    // Keep track of the current depth of nesting while traversing.\n    let\
    \ mut current_depth = 0;\n    let mut max_depth = 0;\n\n    // Parse each group\
    \ of parentheses.\n    let mut depths = Vec::new();\n    for paren_group in paren_groups\
    \ {\n        let mut current_depth = 0;\n        let mut max_depth = 0;\n    \
    \    for c in paren_group.chars() {\n            if c == '(' {\n             \
    \   current_depth += 1;\n                if current_depth > max_depth {\n    \
    \                max_depth = current_depth;\n                }\n            }\
    \ else if c == ')' {\n                current_depth -= 1;\n            }\n   \
    \     }\n        depths.push(max_depth);\n    }\n    depths\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut curr_level\
    \ = 0;\n    let mut max_level = 0;\n    for ch in paren_string.chars() {\n   \
    \     if ch == '(' {\n            curr_level += 1;\n            max_level = std::cmp::max(max_level,\
    \ curr_level);\n        } else if ch == ')' {\n            curr_level -= 1;\n\
    \        } else if ch == ' ' {\n            paren_levels.push(max_level);\n  \
    \          max_level = 0;\n            curr_level = 0;\n        }\n    }\n   \
    \ paren_levels.push(max_level);\n    paren_levels\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .map(|s|\
    \ {\n            let mut count = 0;\n            let mut max_count = 0;\n    \
    \        for c in s.chars() {\n                if c == '(' {\n               \
    \     count += 1;\n                } else if c == ')' {\n                    count\
    \ -= 1;\n                }\n                if count > max_count {\n         \
    \           max_count = count;\n                }\n            }\n           \
    \ max_count\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut current_nesting_level = 0;\n    let mut max_nesting_level\
    \ = 0;\n    let mut max_nesting_vector = Vec::new();\n    for paren in paren_string.chars()\
    \ {\n        if paren == '(' {\n            current_nesting_level += 1;\n    \
    \        if current_nesting_level > max_nesting_level {\n                max_nesting_level\
    \ = current_nesting_level;\n            }\n        } else if paren == ')' {\n\
    \            current_nesting_level -= 1;\n            if current_nesting_level\
    \ == 0 {\n                max_nesting_vector.push(max_nesting_level);\n      \
    \          max_nesting_level = 0;\n            }\n        }\n    }\n    max_nesting_vector\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depth_per_paren = Vec::new();\n    for paren in paren_string.chars() {\n\
    \        match paren {\n            '(' => {\n                depth += 1;\n  \
    \              if depth > max_depth {\n                    max_depth = depth;\n\
    \                }\n            }\n            ')' => {\n                depth\
    \ -= 1;\n            }\n            _ => {}\n        }\n        if paren == '\
    \ ' {\n            depth_per_paren.push(max_depth);\n            max_depth = 0;\n\
    \            depth = 0;\n        }\n    }\n    depth_per_paren.push(max_depth);\n\
    \    depth_per_paren\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let vec: Vec<char> = paren_string.chars().collect();\n\
    \    let mut result = Vec::new();\n    let mut i = 0;\n    let mut max_level =\
    \ 0;\n    let mut level = 0;\n    while i < vec.len() {\n        match vec[i]\
    \ {\n            '(' => {\n                level += 1;\n                if level\
    \ > max_level {\n                    max_level = level;\n                }\n \
    \           }\n            ')' => {\n                level -= 1;\n           \
    \ }\n            ' ' => {\n                result.push(max_level);\n         \
    \       max_level = 0;\n                level = 0;\n            }\n          \
    \  _ => (),\n        }\n        i += 1;\n    }\n    result.push(max_level);\n\
    \    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_groups = paren_string.split(' ');\n    let\
    \ mut max_level: Vec<isize> = Vec::new();\n    let mut max_depth: isize = 0;\n\
    \    for paren_group in paren_groups {\n        let mut depth: isize = 0;\n  \
    \      for char in paren_group.chars() {\n            if char == '(' {\n     \
    \           depth += 1;\n            } else if char == ')' {\n               \
    \ depth -= 1;\n            }\n            if depth > max_depth {\n           \
    \     max_depth = depth;\n            }\n        }\n        max_level.push(max_depth);\n\
    \        max_depth = 0;\n    }\n    max_level\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // parse each group\n    paren_string\n        .split('\
    \ ')\n        .map(|s| {\n            // a stack to keep track of nesting depth\n\
    \            let mut stack = Stack::new();\n            let mut max_depth = 0;\n\
    \            let mut depth = 0;\n            // iterate over characters\n    \
    \        for c in s.chars() {\n                match c {\n                   \
    \ '(' => {\n                        // increment the depth by 1 and push it to\
    \ the stack\n                        depth += 1;\n                        stack.push(depth);\n\
    \                        // update the maximum nesting depth seen so far\n   \
    \                     if depth > max_depth {\n                            max_depth\
    \ = depth;\n                        }\n                    }\n               \
    \     ')' => {\n                        // pop the top value from the stack\n\
    \                        let top = stack.pop();\n                        // sanity\
    \ check\n                        if top.is_none() {\n                        \
    \    panic!(\"unbalanced string!\");\n                        }\n            \
    \            // decrement the depth\n                        depth = top.unwrap()\
    \ - 1;\n                    }\n                    _ => panic!(\"unknown token:\
    \ {}\", c),\n                }\n            }\n            // sanity check\n \
    \           if !stack.is_empty() {\n                panic!(\"unbalanced string!\"\
    );\n            }\n            max_depth\n        })\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  -->\
    \ /tmp/tmpubor1bz5.rs:12:29\n   |\n12 |             let mut stack = Stack::new();\n\
    \   |                             ^^^^^ use of undeclared type `Stack`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut opening_parens = 0;\n    let mut max_nesting =\
    \ 0;\n    let mut max_nesting_history = Vec::new();\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            opening_parens += 1;\n            if opening_parens\
    \ > max_nesting {\n                max_nesting = opening_parens;\n           \
    \ }\n        } else if c == ')' {\n            opening_parens -= 1;\n        }\
    \ else if c == ' ' {\n            max_nesting_history.push(max_nesting);\n   \
    \         max_nesting = 0;\n        }\n    }\n    max_nesting_history.push(max_nesting);\n\
    \    max_nesting_history\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut stack: Vec<usize> = Vec::new();\n    let mut nested_parens_vec:\
    \ Vec<isize> = Vec::new();\n    let mut paren_counter: isize = 0;\n    let mut\
    \ max_nested_parens: isize = 0;\n    for (i, char) in paren_string.chars().enumerate()\
    \ {\n        match char {\n            '(' => {\n                stack.push(i);\n\
    \                paren_counter += 1;\n                if paren_counter > max_nested_parens\
    \ {\n                    max_nested_parens = paren_counter;\n                }\n\
    \            }\n            ')' => {\n                stack.pop();\n         \
    \       paren_counter -= 1;\n            }\n            ' ' => {\n           \
    \     nested_parens_vec.push(max_nested_parens);\n                max_nested_parens\
    \ = 0;\n            }\n            _ => panic!(\"Invalid character in input string\"\
    ),\n        }\n    }\n    if stack.len() != 0 {\n        panic!(\"Unbalanced parentheses\
    \ in input string\");\n    }\n    nested_parens_vec.push(max_nested_parens);\n\
    \    nested_parens_vec\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut groups: Vec<isize> = Vec::new();\n    let mut depth:\
    \ isize = 0;\n    let mut max_depth: isize = 0;\n    for i in paren_string.chars()\
    \ {\n        if i == '(' {\n            depth += 1;\n            if depth > max_depth\
    \ {\n                max_depth = depth;\n            }\n        } else if i ==\
    \ ')' {\n            depth -= 1;\n        } else if i == ' ' {\n            groups.push(max_depth);\n\
    \            max_depth = 0;\n            depth = 0;\n        }\n    }\n    groups.push(max_depth);\n\
    \    groups\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nest_vec = Vec::new();\n    for group in paren_string.split('\
    \ ') {\n        let mut max_nest = 0;\n        let mut current_nest = 0;\n   \
    \     for paren in group.chars() {\n            if paren == '(' {\n          \
    \      current_nest += 1;\n                if current_nest > max_nest {\n    \
    \                max_nest = current_nest;\n                }\n            } else\
    \ if paren == ')' {\n                current_nest -= 1;\n            }\n     \
    \   }\n        max_nest_vec.push(max_nest);\n    }\n    max_nest_vec\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depths = Vec::new();\n    let mut depth = 0;\n\
    \    let mut max_depth = 0;\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                max_depths.push(max_depth);\n     \
    \           max_depth = 0;\n                depth = 0;\n            }\n      \
    \      _ => (),\n        }\n    }\n    max_depths.push(max_depth);\n    max_depths\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut stack = vec![];\n    let mut max_depth = 0;\n \
    \   let mut depths = vec![];\n    for ch in paren_string.chars() {\n        match\
    \ ch {\n            '(' => {\n                stack.push(max_depth);\n       \
    \         max_depth += 1;\n            }\n            ')' => {\n             \
    \   depths.push(max_depth);\n                max_depth = stack.pop().unwrap();\n\
    \            }\n            _ => (),\n        }\n    }\n    return depths;\n}\n\
    \nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 2, 1, 3, 2, 1, 1, 3, 2, 2, 2, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmprsctrmg2.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .map(|g|\
    \ {\n            g.chars()\n                .map(|c| {\n                    if\
    \ c == '(' {\n                        1\n                    } else if c == ')'\
    \ {\n                        -1\n                    } else {\n              \
    \          panic!(\"unexpected character: {}\", c);\n                    }\n \
    \               })\n                .scan(0, |acc, x| {\n                    *acc\
    \ += x;\n                    Some(*acc)\n                })\n                .max()\n\
    \                .unwrap()\n        })\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let paren_string = paren_string.split_whitespace().collect::<Vec<&str>>();\n\
    \    paren_string.iter().map(|s| {\n        let mut max_depth = 0;\n        let\
    \ mut current_depth = 0;\n        for c in s.chars() {\n            if c == '('\
    \ {\n                current_depth += 1;\n                if current_depth > max_depth\
    \ {\n                    max_depth = current_depth;\n                }\n     \
    \       } else if c == ')' {\n                current_depth -= 1;\n          \
    \  }\n        }\n        max_depth\n    }).collect::<Vec<isize>>()\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .map(|s|\
    \ {\n            let mut max_nesting = 0;\n            let mut curr_nesting =\
    \ 0;\n            for c in s.chars() {\n                match c {\n          \
    \          '(' => curr_nesting += 1,\n                    ')' => curr_nesting\
    \ -= 1,\n                    _ => (),\n                }\n                max_nesting\
    \ = max(max_nesting, curr_nesting);\n            }\n            max_nesting\n\
    \        })\n        .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpg2k0ly1t.rs:18:31\n\
    \   |\n18 |                 max_nesting = max(max_nesting, curr_nesting);\n  \
    \ |                               ^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut ret_vec = Vec::new();\n    let mut paren_groups\
    \ = paren_string.split_whitespace();\n    while let Some(group) = paren_groups.next()\
    \ {\n        let mut paren_stack = Vec::new();\n        let mut max_nesting =\
    \ 0;\n        let mut curr_nesting = 0;\n        for paren in group.chars() {\n\
    \            if paren == '(' {\n                paren_stack.push(paren);\n   \
    \             curr_nesting += 1;\n                if curr_nesting > max_nesting\
    \ {\n                    max_nesting = curr_nesting;\n                }\n    \
    \        } else if paren == ')' {\n                if let Some(_) = paren_stack.pop()\
    \ {\n                    curr_nesting -= 1;\n                } else {\n      \
    \              panic!(\"Found closing parenthesis with no matching open parenthesis!\"\
    );\n                }\n            } else {\n                panic!(\"Found character\
    \ other than '(' or ')'\");\n            }\n        }\n        ret_vec.push(max_nesting);\n\
    \    }\n    ret_vec\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut v: Vec<isize> = Vec::new();\n    for paren in paren_string.split_whitespace()\
    \ {\n        v.push(nested_parens(paren));\n    }\n    v\n}\n\nfn main() {\n \
    \   let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `nested_parens` in this scope\n -->\
    \ /tmp/tmplwmy9p5k.rs:9:16\n  |\n9 |         v.push(nested_parens(paren));\n \
    \ |                ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .map(|group|\
    \ {\n            group\n                .chars()\n                .fold(vec![0],\
    \ |mut acc, c| {\n                    match c {\n                        '(' =>\
    \ {\n                            acc.push(acc.last().unwrap() + 1);\n        \
    \                }\n                        ')' => {\n                       \
    \     acc.pop();\n                        }\n                        _ => (),\n\
    \                    }\n                    acc\n                })\n        \
    \        .into_iter()\n                .max()\n                .unwrap()\n   \
    \     })\n        .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpgbo1wilc.rs:33:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut output: Vec<isize> = Vec::new();\n    for paren_group\
    \ in paren_string.split_whitespace() {\n        let mut deepest_level = 0;\n \
    \       let mut current_level = 0;\n        for paren in paren_group.chars() {\n\
    \            if paren == '(' {\n                current_level += 1;\n        \
    \    } else if paren == ')' {\n                current_level -= 1;\n         \
    \   }\n            if current_level > deepest_level {\n                deepest_level\
    \ = current_level;\n            }\n        }\n        output.push(deepest_level);\n\
    \    }\n    output\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth: isize = 0;\n    let mut current_depth:\
    \ isize = 0;\n    let mut results: Vec<isize> = Vec::new();\n\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                current_depth +=\
    \ 1;\n                if current_depth > max_depth {\n                    max_depth\
    \ = current_depth;\n                }\n            }\n            ')' => {\n \
    \               current_depth -= 1;\n            }\n            ' ' => {\n   \
    \             results.push(max_depth);\n                max_depth = 0;\n     \
    \           current_depth = 0;\n            }\n            _ => {\n          \
    \      panic!(\"Unexpected character: {}\", c);\n            }\n        }\n  \
    \  }\n    results.push(max_depth);\n    results\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split(' ')\n        .map(|x| parse_parens(x.to_string()))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `parse_parens` in this scope\n --> /tmp/tmp4gbj5xm2.rs:9:18\n\
    \  |\n9 |         .map(|x| parse_parens(x.to_string()))\n  |                 \
    \ ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut depth_stack: Vec<isize> = Vec::new();\n    let\
    \ mut nested_parens_vec: Vec<isize> = Vec::new();\n    let mut token_vec: Vec<char>\
    \ = paren_string.chars().collect();\n    let mut max_depth: isize = 0;\n    for\
    \ c in token_vec {\n        if c == '(' {\n            depth_stack.push(1);\n\
    \        } else if c == ')' {\n            if depth_stack.len() > 0 {\n      \
    \          depth_stack.pop();\n            }\n        } else if c == ' ' {\n \
    \           nested_parens_vec.push(max_depth);\n            max_depth = 0;\n \
    \       }\n        if max_depth < depth_stack.len() as isize {\n            max_depth\
    \ = depth_stack.len() as isize;\n        }\n    }\n    nested_parens_vec.push(max_depth);\n\
    \    nested_parens_vec\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    for paren_set in paren_string.split_whitespace()\
    \ {\n        let mut depth = 0;\n        let mut max_depth = 0;\n        for c\
    \ in paren_set.chars() {\n            if c == '(' {\n                depth +=\
    \ 1;\n            } else if c == ')' {\n                depth -= 1;\n        \
    \    }\n            if depth > max_depth {\n                max_depth = depth;\n\
    \            }\n        }\n        result.push(max_depth);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut output = Vec::new();\n    for group in paren_string.split_whitespace()\
    \ {\n        let mut nested_level = 0;\n        let mut max_nested_level = 0;\n\
    \        for paren in group.chars() {\n            if paren == '(' {\n       \
    \         nested_level += 1;\n            } else if paren == ')' {\n         \
    \       nested_level -= 1;\n            }\n            if nested_level > max_nested_level\
    \ {\n                max_nested_level = nested_level;\n            }\n       \
    \ }\n        output.push(max_nested_level);\n    }\n    output\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    for paren_group in paren_string.split_whitespace()\
    \ {\n        let mut max_nesting_level = 0;\n        let mut current_nesting_level\
    \ = 0;\n        for paren in paren_group.chars() {\n            if paren == '('\
    \ {\n                current_nesting_level += 1;\n            } else if paren\
    \ == ')' {\n                current_nesting_level -= 1;\n            }\n     \
    \       if current_nesting_level > max_nesting_level {\n                max_nesting_level\
    \ = current_nesting_level;\n            }\n        }\n        result.push(max_nesting_level);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .map(|g|\
    \ {\n            let mut max_nesting_level = 0;\n            let mut current_nesting_level\
    \ = 0;\n            for c in g.chars() {\n                match c {\n        \
    \            '(' => current_nesting_level += 1,\n                    ')' => current_nesting_level\
    \ -= 1,\n                    _ => unreachable!(),\n                }\n       \
    \         max_nesting_level = max_nesting_level.max(current_nesting_level);\n\
    \            }\n            max_nesting_level\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .map(|paren_group|\
    \ get_nested_parens(paren_group.to_string()))\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `get_nested_parens` in this scope\n\
    \ --> /tmp/tmpdvrk1i4d.rs:9:28\n  |\n9 |         .map(|paren_group| get_nested_parens(paren_group.to_string()))\n\
    \  |                            ^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_open_parens = 0;\n    let mut current_open_parens\
    \ = 0;\n    let mut max_nested_parens = vec![];\n\n    for character in paren_string.chars()\
    \ {\n        match character {\n            '(' => {\n                current_open_parens\
    \ += 1;\n                if current_open_parens > max_open_parens {\n        \
    \            max_open_parens = current_open_parens;\n                }\n     \
    \       }\n            ')' => {\n                current_open_parens -= 1;\n \
    \           }\n            ' ' => {\n                max_nested_parens.push(max_open_parens);\n\
    \                max_open_parens = 0;\n                current_open_parens = 0;\n\
    \            }\n            _ => (),\n        }\n    }\n    max_nested_parens.push(max_open_parens);\n\
    \    max_nested_parens\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut v: Vec<isize> = Vec::new();\n    let mut max: isize\
    \ = 0;\n    let mut current: isize = 0;\n    for c in paren_string.chars() {\n\
    \        if c == '(' {\n            current += 1;\n            if current > max\
    \ {\n                max = current;\n            }\n        } else if c == ')'\
    \ {\n            current -= 1;\n        } else if c == ' ' {\n            v.push(max);\n\
    \            max = 0;\n            current = 0;\n        }\n    }\n    v.push(max);\n\
    \    v\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_level: isize = 0;\n    let mut depth: isize\
    \ = 0;\n    let mut result: Vec<isize> = Vec::new();\n\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                depth += 1;\n  \
    \              if depth > max_level {\n                    max_level = depth;\n\
    \                }\n            }\n            ')' => {\n                depth\
    \ -= 1;\n            }\n            ' ' => {\n                result.push(max_level);\n\
    \                max_level = 0;\n                depth = 0;\n            }\n \
    \           _ => continue,\n        }\n    }\n    result.push(max_level);\n  \
    \  result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split(' ')\n        .map(|x| {\n\
    \            let mut count = 0;\n            let mut max_count = 0;\n        \
    \    for i in x.chars() {\n                if i == '(' {\n                   \
    \ count += 1;\n                } else if i == ')' {\n                    count\
    \ -= 1;\n                }\n                if count > max_count {\n         \
    \           max_count = count;\n                }\n            }\n           \
    \ max_count\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut curr_depth = 0;\n \
    \   let mut result = Vec::new();\n    let mut save_depth = false;\n    for ch\
    \ in paren_string.chars() {\n        match ch {\n            '(' => {\n      \
    \          curr_depth += 1;\n                max_depth = curr_depth;\n       \
    \     }\n            ')' => {\n                if curr_depth == max_depth {\n\
    \                    save_depth = true;\n                }\n                curr_depth\
    \ -= 1;\n            }\n            ' ' => {\n                if save_depth {\n\
    \                    result.push(max_depth);\n                    max_depth =\
    \ 0;\n                    curr_depth = 0;\n                    save_depth = false;\n\
    \                }\n            }\n            _ => {}\n        }\n    }\n   \
    \ if curr_depth == max_depth {\n        result.push(max_depth);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp_ftmch4d.rs:42:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_vec: Vec<&str> = paren_string.split_whitespace().collect();\n\
    \    paren_vec.iter().map(|x| calc_paren_depth(x)).collect()\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `calc_paren_depth` in this scope\n -->\
    \ /tmp/tmp4f71_no7.rs:8:30\n  |\n8 |     paren_vec.iter().map(|x| calc_paren_depth(x)).collect()\n\
    \  |                              ^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut count_list: Vec<isize> = Vec::new();\n    let mut\
    \ max_count: isize = 0;\n    let mut count: isize = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            count += 1;\n            if count > max_count\
    \ {\n                max_count = count;\n            }\n        } else if c ==\
    \ ')' {\n            count -= 1;\n        } else if c == ' ' {\n            count_list.push(max_count);\n\
    \            max_count = 0;\n            count = 0;\n        }\n    }\n    count_list.push(max_count);\n\
    \    count_list\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut ret_vec = Vec::new();\n    let mut paren_char_vec:\
    \ Vec<char> = paren_string.chars().collect();\n    for paren_char in paren_char_vec\
    \ {\n        let mut count = 0;\n        let mut level = 0;\n        for ch in\
    \ paren_char {\n            if ch == '(' {\n                count += 1;\n    \
    \            if count > level {\n                    level = count;\n        \
    \        }\n            } else if ch == ')' {\n                count -= 1;\n \
    \           }\n        }\n        ret_vec.push(level);\n    }\n    ret_vec\n}\n\
    \nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: `char` is not an iterator\n  --> /tmp/tmpdz15k2pz.rs:12:19\n\
    \   |\n12 |         for ch in paren_char {\n   |                   ^^^^^^^^^^\
    \ `char` is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `char`\n   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let paren_string = paren_string.split_whitespace().collect::<Vec<&str>>();\n\
    \    paren_string.iter().map(|x| parse_parens(x)).collect::<Vec<isize>>()\n}\n\
    \nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `parse_parens` in this scope\n --> /tmp/tmpoqv5uq1u.rs:8:33\n\
    \  |\n8 |     paren_string.iter().map(|x| parse_parens(x)).collect::<Vec<isize>>()\n\
    \  |                                 ^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_counts = Vec::new();\n    let mut start =\
    \ 0;\n    let mut depth = 0;\n    let mut max_depth = 0;\n    for (i, c) in paren_string.chars().enumerate()\
    \ {\n        if c == '(' {\n            depth += 1;\n            if depth > max_depth\
    \ {\n                max_depth = depth;\n            }\n        } else if c ==\
    \ ')' {\n            depth -= 1;\n        } else if c == ' ' || i == paren_string.len()\
    \ - 1 {\n            if i == paren_string.len() - 1 {\n                paren_counts.push(max_depth);\n\
    \            } else {\n                paren_counts.push(max_depth);\n       \
    \         start = i + 1;\n                max_depth = 0;\n            }\n    \
    \    }\n    }\n    paren_counts\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpbmc4q84x.rs:34:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result: Vec<isize> = Vec::new();\n    let mut paren_stack:\
    \ Vec<char> = Vec::new();\n    let mut max_depth: isize = 0;\n    let mut depth:\
    \ isize = 0;\n    for current_char in paren_string.chars() {\n        match current_char\
    \ {\n            '(' => {\n                paren_stack.push(current_char);\n \
    \               depth += 1;\n                if depth > max_depth {\n        \
    \            max_depth = depth;\n                }\n            }\n          \
    \  ')' => {\n                if !paren_stack.is_empty() {\n                  \
    \  depth -= 1;\n                    paren_stack.pop();\n                }\n  \
    \          }\n            ' ' => {\n                if paren_stack.is_empty()\
    \ {\n                    result.push(max_depth);\n                    max_depth\
    \ = 0;\n                    depth = 0;\n                }\n            }\n   \
    \         _ => panic!(\"Invalid character\"),\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpjyia7o3d.rs:41:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    for group in paren_string.split_whitespace()\
    \ {\n        let mut nesting_level = 0;\n        let mut max_nesting_level = 0;\n\
    \        for paren in group.chars() {\n            if paren == '(' {\n       \
    \         nesting_level += 1;\n            } else if paren == ')' {\n        \
    \        nesting_level -= 1;\n            }\n            if nesting_level > max_nesting_level\
    \ {\n                max_nesting_level = nesting_level;\n            }\n     \
    \   }\n        result.push(max_nesting_level);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result: Vec<isize> = Vec::new();\n    let mut current_level:\
    \ isize = 0;\n    let mut max_level: isize = 0;\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                current_level +=\
    \ 1;\n                if current_level > max_level {\n                    max_level\
    \ = current_level;\n                }\n            }\n            ')' => {\n \
    \               current_level -= 1;\n            }\n            ' ' => {\n   \
    \             result.push(max_level);\n                max_level = 0;\n      \
    \          current_level = 0;\n            }\n            _ => {\n           \
    \     panic!(\"Invalid character encountered!\");\n            }\n        }\n\
    \    }\n    result.push(max_level);\n    result\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split(' ')\n        .map(|group|\
    \ {\n            let mut depth = 0;\n            let mut max_depth = 0;\n    \
    \        for paren in group.chars() {\n                match paren {\n       \
    \             '(' => depth += 1,\n                    ')' => depth -= 1,\n   \
    \                 _ => (),\n                }\n                max_depth = std::cmp::max(max_depth,\
    \ depth);\n            }\n            max_depth\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .map(|grp|\
    \ {\n            let mut level = 0;\n            let mut deep_level = 0;\n   \
    \         for c in grp.chars() {\n                if c == '(' {\n            \
    \        level += 1;\n                    if level > deep_level {\n          \
    \              deep_level = level;\n                    }\n                } else\
    \ if c == ')' {\n                    level -= 1;\n                }\n        \
    \    }\n            deep_level\n        })\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut res: Vec<isize> = Vec::new();\n    let mut paren_stack:\
    \ Vec<char> = Vec::new();\n    let mut max_depth: isize = 0;\n    let mut current_depth:\
    \ isize = 0;\n    for ch in paren_string.chars() {\n        match ch {\n     \
    \       '(' => {\n                paren_stack.push(ch);\n                current_depth\
    \ += 1;\n                if current_depth > max_depth {\n                    max_depth\
    \ = current_depth;\n                }\n            }\n            ')' => {\n \
    \               if paren_stack.is_empty() {\n                    panic!(\"String\
    \ has unpaired parenthesis\");\n                }\n                paren_stack.pop();\n\
    \                current_depth -= 1;\n            }\n            ' ' => {\n  \
    \              if !paren_stack.is_empty() {\n                    panic!(\"String\
    \ has unpaired parenthesis\");\n                }\n                res.push(max_depth);\n\
    \                max_depth = 0;\n                current_depth = 0;\n        \
    \    }\n            _ => {\n                panic!(\"String contains invalid character\"\
    );\n            }\n        }\n    }\n    if !paren_stack.is_empty() {\n      \
    \  panic!(\"String has unpaired parenthesis\");\n    }\n    res.push(max_depth);\n\
    \    res\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_count = 0;\n    let mut curr_count = 0;\n \
    \   let mut max_counts = Vec::new();\n    for c in paren_string.chars() {\n  \
    \      if c == '(' {\n            curr_count += 1;\n            if curr_count\
    \ > max_count {\n                max_count = curr_count;\n            }\n    \
    \    } else if c == ')' {\n            curr_count -= 1;\n        } else if c ==\
    \ ' ' {\n            max_counts.push(max_count);\n            max_count = 0;\n\
    \            curr_count = 0;\n        }\n    }\n    max_counts.push(max_count);\n\
    \    max_counts\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .map(|paren_group|\
    \ {\n            let mut paren_levels = Vec::new();\n            for paren in\
    \ paren_group.chars() {\n                match paren {\n                    '('\
    \ => paren_levels.push(1),\n                    ')' => {\n                   \
    \     let mut paren_cnt = paren_levels.pop().unwrap();\n                     \
    \   if paren_cnt != 0 {\n                            paren_cnt += 1;\n       \
    \                 }\n                        paren_levels.push(paren_cnt);\n \
    \                   }\n                    _ => (),\n                }\n     \
    \       }\n            paren_levels.iter().max().unwrap()\n        })\n      \
    \  .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n  \
    \  assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `&{integer}`\n    --> /tmp/tmp59183agj.rs:26:10\n    \
    \ |\n26   |         .collect()\n     |          ^^^^^^^ value of type `Vec<isize>`\
    \ cannot be built from `std::iter::Iterator<Item=&{integer}>`\n     |\n     =\
    \ help: the trait `FromIterator<&{integer}>` is not implemented for `Vec<isize>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = Vec::new();\n    let mut nesting_level\
    \ = 0;\n    let mut max_level = 0;\n    for char in paren_string.chars() {\n \
    \       if char == '(' {\n            nesting_level += 1;\n            if nesting_level\
    \ > max_level {\n                max_level = nesting_level;\n            }\n \
    \       } else if char == ')' {\n            nesting_level -= 1;\n        } else\
    \ if char == ' ' {\n            max_nesting.push(max_level);\n            max_level\
    \ = 0;\n            nesting_level = 0;\n        }\n    }\n    if nesting_level\
    \ != 0 {\n        max_nesting.push(max_level);\n    }\n    max_nesting\n}\n\n\
    fn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpdqxu5ifm.rs:32:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut depths: Vec<isize> = Vec::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                depth += 1;\n      \
    \          if depth > max_depth {\n                    max_depth = depth;\n  \
    \              }\n            }\n            ')' => {\n                depth -=\
    \ 1;\n            }\n            ' ' => {\n                depths.push(max_depth);\n\
    \                max_depth = 0;\n                depth = 0;\n            }\n \
    \           _ => (),\n        }\n    }\n    depths.push(max_depth);\n    depths\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result: Vec<isize> = Vec::new();\n    let mut max_level:\
    \ isize = 0;\n    let mut level: isize = 0;\n    for paren in paren_string.chars()\
    \ {\n        if paren == '(' {\n            level += 1;\n            if level\
    \ > max_level {\n                max_level = level;\n            }\n        }\
    \ else if paren == ')' {\n            level -= 1;\n        } else if paren ==\
    \ ' ' {\n            result.push(max_level);\n            max_level = 0;\n   \
    \         level = 0;\n        }\n    }\n    result.push(max_level);\n    result\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // vector of all the (non-nested) groups\n    let sub_groups:\
    \ Vec<&str> = paren_string.split(\" \").collect();\n    // output vector of max\
    \ nesting for each sub group\n    let mut max_nesting: Vec<isize> = Vec::new();\n\
    \    for group in sub_groups {\n        // initializing to zero\n        let mut\
    \ curr_nesting = 0;\n        let mut max_nesting_this_group = 0;\n        for\
    \ ch in group.chars() {\n            if ch == '(' {\n                curr_nesting\
    \ += 1;\n            } else if ch == ')' {\n                curr_nesting -= 1;\n\
    \            }\n            max_nesting_this_group = std::cmp::max(max_nesting_this_group,\
    \ curr_nesting);\n        }\n        max_nesting.push(max_nesting_this_group);\n\
    \    }\n    max_nesting\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut output = Vec::new();\n    for string in paren_string.split_whitespace()\
    \ {\n        let mut count = 0;\n        let mut max_count = 0;\n        for char\
    \ in string.chars() {\n            match char {\n                '(' => count\
    \ += 1,\n                ')' => count -= 1,\n                _ => {},\n      \
    \      }\n            if count > max_count {\n                max_count = count;\n\
    \            }\n        }\n        output.push(max_count);\n    }\n    output\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut res: Vec<isize> = Vec::new();\n    for group in\
    \ paren_string.split_whitespace() {\n        let mut max_level = 0;\n        let\
    \ mut level = 0;\n        for ch in group.chars() {\n            match ch {\n\
    \                '(' => level += 1,\n                ')' => level -= 1,\n    \
    \            _ => (),\n            }\n            max_level = std::cmp::max(max_level,\
    \ level);\n        }\n        res.push(max_level);\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_list: Vec<isize> = Vec::new();\n    let mut\
    \ current_level: isize = 0;\n    let mut max_level: isize = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            current_level += 1;\n            if current_level\
    \ > max_level {\n                max_level = current_level;\n            }\n \
    \       } else if c == ')' {\n            current_level -= 1;\n        } else\
    \ if c == ' ' {\n            paren_list.push(max_level);\n            max_level\
    \ = 0;\n            current_level = 0;\n        }\n    }\n    paren_list.push(max_level);\n\
    \    paren_list\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<char> = Vec::new();\n    let mut\
    \ depths: Vec<isize> = Vec::new();\n    let mut depth: isize = 0;\n    let mut\
    \ max_depth: isize = 0;\n    let mut tmp_str: String = String::new();\n    for\
    \ c in paren_string.chars() {\n        if c == ' ' {\n            if paren_stack.len()\
    \ > 0 {\n                depths.push(max_depth);\n                max_depth =\
    \ 0;\n                tmp_str.clear();\n            }\n        } else if c ==\
    \ '(' {\n            paren_stack.push(c);\n            depth += 1;\n         \
    \   max_depth = if depth > max_depth { depth } else { max_depth };\n        }\
    \ else if c == ')' {\n            paren_stack.pop();\n            depth -= 1;\n\
    \        }\n    }\n    if paren_stack.len() > 0 {\n        depths.push(max_depth);\n\
    \    }\n    depths\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpox1ch7zz.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut results = Vec::new();\n    let mut stack = vec![0];\n\
    \n    for c in paren_string.chars() {\n        if c == '(' {\n            stack.push(stack.last().unwrap()\
    \ + 1);\n        } else if c == ')' {\n            stack.pop();\n        } else\
    \ if c == ' ' {\n            results.push(*stack.last().unwrap());\n         \
    \   stack = vec![0];\n        }\n    }\n\n    results\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpmr3zxing.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let result = paren_string\n        .split_whitespace()\n\
    \        .map(|word| {\n            let mut paren_count = 0;\n            let\
    \ mut max_paren = 0;\n            for ch in word.chars() {\n                match\
    \ ch {\n                    '(' => {\n                        paren_count += 1;\n\
    \                        if paren_count > max_paren {\n                      \
    \      max_paren = paren_count;\n                        }\n                 \
    \   }\n                    ')' => {\n                        paren_count -= 1;\n\
    \                    }\n                    _ => {}\n                }\n     \
    \       }\n            max_paren\n        })\n        .collect();\n    result\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // TODO: Implement this function\n    return vec![];\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp9mapqvdw.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut paren_stack =\
    \ Vec::new();\n    let mut counter = 0;\n    let mut is_balanced = true;\n   \
    \ for c in paren_string.chars() {\n        if c == '(' {\n            counter\
    \ += 1;\n            paren_stack.push(c);\n        } else if c == ')' {\n    \
    \        counter -= 1;\n            paren_stack.pop();\n        } else if c ==\
    \ ' ' {\n            result.push(counter);\n            counter = 0;\n       \
    \     is_balanced = paren_stack.is_empty();\n        }\n    }\n    if !is_balanced\
    \ {\n        result.push(-1);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpkv91mp5k.rs:32:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split(' ')\n        .map(|paren_group|\
    \ {\n            paren_group\n                .chars()\n                .fold((0,\
    \ 0), |(nesting_level, max_nesting_level), paren| {\n                    if paren\
    \ == '(' {\n                        (nesting_level + 1, max_nesting_level.max(nesting_level\
    \ + 1))\n                    } else {\n                        (nesting_level\
    \ - 1, max_nesting_level)\n                    }\n                })\n       \
    \         .1\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_level: isize = 0;\n    let mut current_level:\
    \ isize = 0;\n    let mut output: Vec<isize> = Vec::new();\n    for character\
    \ in paren_string.chars() {\n        match character {\n            '(' => {\n\
    \                current_level += 1;\n                if current_level > max_level\
    \ {\n                    max_level = current_level;\n                }\n     \
    \       }\n            ')' => {\n                if current_level > 0 {\n    \
    \                current_level -= 1;\n                }\n            }\n     \
    \       ' ' => {\n                output.push(max_level);\n                max_level\
    \ = 0;\n                current_level = 0;\n            }\n            _ => {\n\
    \                panic!(\"Unrecognized character in the input string!\");\n  \
    \          }\n        }\n    }\n    // Append the deepest level of nesting for\
    \ the last group.\n    output.push(max_level);\n    output\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // I'm using a buffer instead of parsing the string directly\
    \ since indexing char with isize is apparently not\n    // supported in rust.\n\
    \    let paren_vector: Vec<char> = paren_string.chars().collect();\n    let mut\
    \ current_nesting_level = 0;\n    let mut max_nesting_level = 0;\n    let mut\
    \ results = Vec::new();\n    for i in 0..paren_vector.len() {\n        match paren_vector[i]\
    \ {\n            '(' => {\n                current_nesting_level += 1;\n     \
    \           if current_nesting_level > max_nesting_level {\n                 \
    \   max_nesting_level = current_nesting_level;\n                }\n          \
    \  }\n            ')' => {\n                current_nesting_level -= 1;\n    \
    \        }\n            ' ' => {\n                results.push(max_nesting_level);\n\
    \                max_nesting_level = 0;\n                current_nesting_level\
    \ = 0;\n            }\n            _ => panic!(\"Invalid character!\"),\n    \
    \    }\n    }\n    results.push(max_nesting_level);\n    results\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // TODO: Implement this function.\n    vec![]\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp4uui6j8f.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels: Vec<isize> = Vec::new();\n    let max_level\
    \ = paren_string.len() / 2;\n    let mut paren_levels: Vec<isize> = vec![0; max_level];\n\
    \    let mut paren_level_index = 0;\n    let mut paren_level = 0;\n    for ch\
    \ in paren_string.chars() {\n        match ch {\n            '(' => {\n      \
    \          paren_level += 1;\n                paren_levels[paren_level_index]\
    \ = paren_level;\n                paren_level_index += 1;\n            }\n   \
    \         ')' => {\n                paren_level_index -= 1;\n                paren_level\
    \ = paren_levels[paren_level_index];\n            }\n            ' ' => {\n  \
    \              if paren_level_index > 0 {\n                    levels.push(paren_levels[paren_level_index\
    \ - 1]);\n                }\n            }\n            _ => panic!(\"Unexpected\
    \ character\"),\n        }\n    }\n    levels\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpcqgqjoxi.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut nested_levels: Vec<isize> = Vec::new();\n    let\
    \ mut stack = Vec::new();\n    let mut count = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            stack.push(c);\n            count += 1;\n\
    \        } else if c == ')' {\n            stack.pop();\n            count -=\
    \ 1;\n        } else if c == ' ' {\n            nested_levels.push(count);\n \
    \           count = 0;\n        }\n    }\n    nested_levels.push(count);\n   \
    \ return nested_levels;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpnqvzvu3z.rs:28:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_arr: Vec<isize> = vec![];\n    let mut curr_paren_group\
    \ = 0;\n    let mut max_depth = 0;\n    for c in paren_string.chars() {\n    \
    \    if c == '(' {\n            curr_paren_group += 1;\n            if curr_paren_group\
    \ > max_depth {\n                max_depth = curr_paren_group;\n            }\n\
    \        } else if c == ')' {\n            curr_paren_group -= 1;\n        } else\
    \ if c == ' ' {\n            paren_arr.push(max_depth);\n            max_depth\
    \ = 0;\n            curr_paren_group = 0;\n        }\n    }\n    paren_arr.push(max_depth);\n\
    \    paren_arr\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n \
    \   assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let parentheses: Vec<Vec<char>> = paren_string\n      \
    \  .split_whitespace()\n        .map(|s| s.chars().collect())\n        .collect();\n\
    \    let mut levels: Vec<isize> = Vec::new();\n    for parens in parentheses {\n\
    \        let mut level = 0;\n        let mut max_level = 0;\n        for paren\
    \ in parens {\n            if paren == '(' {\n                level += 1;\n  \
    \          } else if paren == ')' {\n                if level > max_level {\n\
    \                    max_level = level;\n                }\n                level\
    \ -= 1;\n            }\n        }\n        levels.push(max_level);\n    }\n  \
    \  levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // Initialize the result vector\n    let mut result = Vec::new();\n\
    \n    // Split the string on spaces\n    let split_vec: Vec<&str> = paren_string.split(\"\
    \ \").collect();\n\n    // Parse the string and generate a vector of isize\n \
    \   for paren_str in split_vec {\n        let mut depth = 0;\n        let mut\
    \ max_depth = 0;\n        for c in paren_str.chars() {\n            if c == '('\
    \ {\n                depth += 1;\n            } else if c == ')' {\n         \
    \       depth -= 1;\n            }\n            if depth > max_depth {\n     \
    \           max_depth = depth;\n            }\n        }\n        result.push(max_depth);\n\
    \    }\n\n    // return the result\n    result\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // TODO\n    paren_string\n        .split(' ')\n      \
    \  .map(|s| {\n            let mut stack = Vec::new();\n            let mut max_depth\
    \ = 0;\n            for c in s.chars() {\n                if c == '(' {\n    \
    \                stack.push(c);\n                    if stack.len() > max_depth\
    \ {\n                        max_depth = stack.len();\n                    }\n\
    \                } else if c == ')' {\n                    stack.pop();\n    \
    \            }\n            }\n            max_depth as isize\n        })\n  \
    \      .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level_stack: Vec<isize> = Vec::new();\n    let\
    \ mut max_level_stack: Vec<isize> = Vec::new();\n    let mut i = 0;\n    for i\
    \ in 0..paren_string.len() {\n        let c = paren_string.as_bytes()[i];\n  \
    \      if c == '(' as u8 {\n            level_stack.push(0);\n        } else if\
    \ c == ')' as u8 {\n            // ')' can't be the first char\n            let\
    \ mut level = level_stack.pop().unwrap();\n            if level_stack.len() ==\
    \ 0 {\n                max_level_stack.push(level);\n            } else {\n  \
    \              level += 1;\n                let max_level = level_stack.pop().unwrap();\n\
    \                level_stack.push(std::cmp::max(level, max_level));\n        \
    \    }\n        } else if c == ' ' as u8 {\n            if level_stack.len() >\
    \ 0 {\n                max_level_stack.push(level_stack.pop().unwrap());\n   \
    \         }\n        }\n    }\n    if level_stack.len() > 0 {\n        max_level_stack.push(level_stack.pop().unwrap());\n\
    \    }\n    max_level_stack\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 0, 2]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpugoa_cxl.rs:38:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let v = paren_string.split(' ').collect::<Vec<&str>>();\n\
    \    let mut max_nesting = 0;\n    let mut output = Vec::<isize>::new();\n   \
    \ for group in v {\n        max_nesting = 0;\n        let mut curr_nesting = 0;\n\
    \        for paren in group.chars() {\n            if paren == '(' {\n       \
    \         curr_nesting += 1;\n                if curr_nesting > max_nesting {\n\
    \                    max_nesting = curr_nesting;\n                }\n        \
    \    } else if paren == ')' {\n                curr_nesting -= 1;\n          \
    \  }\n        }\n        output.push(max_nesting);\n    }\n    output\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split(' ')\n        .map(|group|\
    \ group.chars().fold(0, |acc, c| {\n            if c == '(' {\n              \
    \  acc + 1\n            } else if c == ')' {\n                acc - 1\n      \
    \      } else {\n                panic!(\"Unexpected character '{}' in parentheses\
    \ group: {}\", c, group);\n            }\n        }))\n        .collect()\n}\n\
    \nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpqr5u8dhz.rs:23:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut current_depth = 0;\n\
    \    let mut depths = Vec::new();\n    for c in paren_string.chars() {\n     \
    \   match c {\n            '(' => {\n                current_depth += 1;\n   \
    \             if current_depth > max_depth {\n                    max_depth =\
    \ current_depth;\n                }\n            }\n            ')' => {\n   \
    \             if current_depth > 0 {\n                    current_depth -= 1;\n\
    \                }\n            }\n            ' ' => {\n                if current_depth\
    \ == 0 {\n                    depths.push(max_depth);\n                    max_depth\
    \ = 0;\n                }\n            }\n            _ => {\n               \
    \ panic!(\"unrecognized character\");\n            }\n        }\n    }\n    depths.push(max_depth);\n\
    \    depths\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut res: Vec<isize> = Vec::new();\n    let paren_string\
    \ = paren_string.trim().to_string();\n    let group_strings: Vec<&str> = paren_string.split('\
    \ ').collect();\n    for group_string in group_strings {\n        let mut level\
    \ = 0;\n        let mut max_level = 0;\n        for c in group_string.chars()\
    \ {\n            if c == '(' {\n                level += 1;\n            } else\
    \ if c == ')' {\n                level -= 1;\n            }\n            if level\
    \ > max_level {\n                max_level = level;\n            }\n        }\n\
    \        res.push(max_level);\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut vec = Vec::new();\n    for paren_string in paren_string.split_whitespace()\
    \ {\n        let mut depth = 0;\n        let mut max_depth = 0;\n        for ch\
    \ in paren_string.chars() {\n            if ch == '(' {\n                depth\
    \ += 1;\n            } else if ch == ')' {\n                depth -= 1;\n    \
    \        }\n            if depth > max_depth {\n                max_depth = depth;\n\
    \            }\n        }\n        vec.push(max_depth);\n    }\n    vec\n}\n\n\
    fn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split(' ')\n        .map(|x| {\n\
    \            let mut level = 0;\n            let mut max_level = 0;\n        \
    \    for paren in x.chars() {\n                if paren == '(' {\n           \
    \         level += 1;\n                } else if paren == ')' {\n            \
    \        if level > max_level {\n                        max_level = level;\n\
    \                    }\n                    level -= 1;\n                }\n \
    \           }\n            return max_level;\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut ret_vec = Vec::new();\n    let paren_groups: Vec<&str>\
    \ = paren_string.split_whitespace().collect();\n    for paren_group in paren_groups\
    \ {\n        let mut paren_index_stack = Vec::new();\n        let mut max_depth\
    \ = 0;\n        for (index, val) in paren_group.chars().enumerate() {\n      \
    \      match val {\n                '(' => {\n                    paren_index_stack.push(index);\n\
    \                }\n                ')' => {\n                    let start_index\
    \ = paren_index_stack.pop().unwrap();\n                    let current_depth =\
    \ index - start_index + 1;\n                    if current_depth > max_depth {\n\
    \                        max_depth = current_depth;\n                    }\n \
    \               }\n                _ => {}\n            }\n        }\n       \
    \ ret_vec.push(max_depth as isize);\n    }\n    ret_vec\n}\n\nfn main() {\n  \
    \  let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 6, 2, 10]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpmaw8csge.rs:34:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut groups = paren_string.split_whitespace();\n   \
    \ let mut max_levels = Vec::new();\n    for group in groups {\n        let mut\
    \ levels = 0;\n        let mut max_level = 0;\n        for c in group.chars()\
    \ {\n            if c == '(' {\n                levels += 1;\n            } else\
    \ if c == ')' {\n                levels -= 1;\n            }\n            if levels\
    \ > max_level {\n                max_level = levels;\n            }\n        }\n\
    \        max_levels.push(max_level);\n    }\n    max_levels\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut depths = Vec::new();\n    let mut depth = 0;\n\
    \    let mut max_depth = 0;\n    for i in paren_string.chars() {\n        if i\
    \ == '(' {\n            depth += 1;\n            if depth > max_depth {\n    \
    \            max_depth = depth;\n            }\n        } else if i == ')' {\n\
    \            depth -= 1;\n        } else if i == ' ' {\n            depths.push(max_depth);\n\
    \            max_depth = 0;\n            depth = 0;\n        }\n    }\n    depths.push(max_depth);\n\
    \    depths\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_level = 0;\n    let mut results = Vec::new();\n\
    \    let mut current_level = 0;\n    for c in paren_string.chars() {\n       \
    \ match c {\n            '(' => {\n                current_level += 1;\n     \
    \           if current_level > max_level {\n                    max_level = current_level;\n\
    \                }\n            }\n            ')' => {\n                current_level\
    \ -= 1;\n            }\n            ' ' => {\n                results.push(max_level);\n\
    \                max_level = 0;\n                current_level = 0;\n        \
    \    }\n            _ => panic!(\"Invalid character\"),\n        }\n    }\n  \
    \  results.push(max_level);\n    results\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut count = 0;\n    let mut max_count = 0;\n    let\
    \ mut ret = Vec::new();\n    for char in paren_string.chars() {\n        if char\
    \ == '(' {\n            count += 1;\n            if count > max_count {\n    \
    \            max_count = count;\n            }\n        } else if char == ')'\
    \ {\n            count -= 1;\n        } else if char == ' ' {\n            ret.push(max_count);\n\
    \            max_count = 0;\n            count = 0;\n        }\n    }\n    ret.push(max_count);\n\
    \    ret\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut results = Vec::new();\n    let mut stack = Vec::new();\n\
    \    let mut current_level = 0;\n    let mut group_level = 0;\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                current_level +=\
    \ 1;\n                stack.push(c);\n            }\n            ')' => {\n  \
    \              current_level -= 1;\n                stack.pop();\n           \
    \ }\n            ' ' => {\n                if stack.is_empty() {\n           \
    \         results.push(current_level);\n                    current_level = 0;\n\
    \                }\n            }\n            _ => (),\n        }\n    }\n  \
    \  results\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp87hr6ezf.rs:35:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth: Vec<isize> = Vec::new();\n    let mut\
    \ depth: isize = 0;\n    let mut current_group = Vec::new();\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            depth += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            depth -= 1;\n            current_group.push(c);\n\
    \        } else if c == ' ' {\n            if current_group.len() > 0 {\n    \
    \            max_depth.push(depth);\n                current_group.clear();\n\
    \            }\n        }\n    }\n    if current_group.len() > 0 {\n        max_depth.push(depth);\n\
    \    }\n    max_depth\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp4t8z_vee.rs:32:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // TODO: Implement this function.\n\n    let mut levels:\
    \ Vec<isize> = Vec::new();\n    let mut current_level: isize = 0;\n    let mut\
    \ level_max: isize = 0;\n\n    for ch in paren_string.chars() {\n        match\
    \ ch {\n            '(' => {\n                current_level += 1;\n          \
    \      if current_level > level_max {\n                    level_max = current_level;\n\
    \                }\n            }\n            ')' => {\n                if current_level\
    \ == 0 {\n                    levels.push(0);\n                    level_max =\
    \ 0;\n                } else {\n                    current_level -= 1;\n    \
    \            }\n            }\n            ' ' => {\n                if current_level\
    \ == 0 {\n                    levels.push(level_max);\n                    level_max\
    \ = 0;\n                }\n            }\n            _ => panic!(\"Cannot handle\
    \ this character in paren string\"),\n        }\n    }\n\n    if current_level\
    \ == 0 {\n        levels.push(level_max);\n    }\n\n    levels\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut v = Vec::new();\n    let mut stack: Vec<char> =\
    \ Vec::new();\n    let mut current_level = 0;\n    let mut max_level = 0;\n  \
    \  for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                stack.push(c);\n                current_level += 1;\n       \
    \         if current_level > max_level {\n                    max_level = current_level;\n\
    \                }\n            }\n            ')' => {\n                stack.pop();\n\
    \                current_level -= 1;\n            }\n            ' ' => {\n  \
    \              v.push(max_level);\n                max_level = 0;\n          \
    \      current_level = 0;\n            }\n            _ => {}\n        }\n   \
    \ }\n    v.push(max_level);\n    v\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut counts = Vec::new();\n    let mut max_level = 0;\n\
    \    let mut level = 0;\n    for c in paren_string.chars() {\n        match c\
    \ {\n            '(' => {\n                level += 1;\n                if level\
    \ > max_level {\n                    max_level = level;\n                }\n \
    \           }\n            ')' => {\n                level -= 1;\n           \
    \ }\n            ' ' => {\n                if level == 0 {\n                 \
    \   counts.push(max_level);\n                    max_level = 0;\n            \
    \    }\n            }\n            _ => {}\n        }\n    }\n    counts.push(max_level);\n\
    \    counts\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_count = 0;\n    let mut mut_paren_string =\
    \ paren_string.clone();\n    mut_paren_string.push(' ');\n    let mut num_parens:\
    \ Vec<isize> = Vec::new();\n    let mut current_parens = 0;\n    let mut paren_group\
    \ = String::new();\n    let paren_string_len = mut_paren_string.len();\n    let\
    \ mut start_paren_group = false;\n    for (i, ch) in mut_paren_string.chars().enumerate()\
    \ {\n        match ch {\n            '(' => {\n                if start_paren_group\
    \ {\n                    current_parens += 1;\n                }\n           \
    \     start_paren_group = true;\n            }\n            ')' => {\n       \
    \         if current_parens > max_count {\n                    max_count = current_parens;\n\
    \                }\n                current_parens -= 1;\n            }\n    \
    \        ' ' => {\n                num_parens.push(max_count);\n             \
    \   max_count = 0;\n                current_parens = 0;\n                start_paren_group\
    \ = false;\n            }\n            _ => panic!(\"Unsupported character\"),\n\
    \        }\n        if i == paren_string_len - 1 {\n            break;\n     \
    \   }\n    }\n    num_parens\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 0, 2]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpvqv2s6k4.rs:46:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut v = Vec::new();\n    for x in paren_string.split_whitespace()\
    \ {\n        let mut current_max = 0;\n        let mut counter = 0;\n        for\
    \ c in x.chars() {\n            if c == '(' {\n                counter += 1;\n\
    \                if counter > current_max {\n                    current_max =\
    \ counter;\n                }\n            } else if c == ')' {\n            \
    \    counter -= 1;\n            }\n        }\n        v.push(current_max);\n \
    \   }\n    v\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n   \
    \ assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut stack: Vec<char> = Vec::new();\n    let mut result:\
    \ Vec<isize> = Vec::new();\n    let mut depth: isize = 0;\n    let mut last_depth:\
    \ isize = 0;\n    for c in paren_string.chars() {\n        if c == '(' {\n   \
    \         stack.push(c);\n            depth += 1;\n        } else if c == ')'\
    \ {\n            stack.pop();\n            if stack.is_empty() {\n           \
    \     result.push(depth);\n                last_depth = depth;\n             \
    \   depth = 0;\n            }\n        } else if c == ' ' {\n            result.push(last_depth);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 3, 3, 3, 1, 1, 5]`,\n right: `[2, 3, 1, 3]`', /tmp/tmppsvaw2lu.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut vec: Vec<isize> = Vec::new();\n    for paren_group\
    \ in paren_string.split_whitespace() {\n        let mut level = 0;\n        let\
    \ mut max_level = 0;\n        for paren in paren_group.chars() {\n           \
    \ match paren {\n                '(' => level += 1,\n                ')' => level\
    \ -= 1,\n                _ => panic!(\"Unsupported char\"),\n            }\n \
    \           if level > max_level {\n                max_level = level;\n     \
    \       }\n        }\n        vec.push(max_level);\n    }\n    vec\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut level = 0;\n    let mut max_levels = vec![];\n\
    \    for c in paren_string.chars() {\n        match c {\n            '(' => level\
    \ += 1,\n            ')' => level -= 1,\n            _ => (),\n        }\n   \
    \     if c == ' ' {\n            max_levels.push(level);\n            level =\
    \ 0;\n        }\n    }\n    max_levels\n}\n\nfn main() {\n    let candidate =\
    \ parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp9wp_jwi6.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut depth_level: isize = 0;\n    let mut char_list:\
    \ Vec<char> = Vec::new();\n    let mut group_level: Vec<isize> = Vec::new();\n\
    \    let mut is_group: bool = false;\n\n    // Break the string into characters\n\
    \    for c in paren_string.chars() {\n        char_list.push(c);\n    }\n\n  \
    \  // Iterate through each character in the string\n    for c in char_list {\n\
    \        if c == '(' {\n            // Increment the depth level when we reach\
    \ a '('\n            depth_level += 1;\n            // Check if we are at the\
    \ start of a new group\n            if is_group == false {\n                //\
    \ If we are, then set the is_group to true\n                is_group = true;\n\
    \            }\n        } else if c == ')' {\n            // Decrement the depth\
    \ level when we reach a ')'\n            depth_level -= 1;\n            // Check\
    \ if we are at the end of a group\n            if is_group == true {\n       \
    \         // If we are, then set the is_group to false and push the depth level\n\
    \                // to the group_level\n                is_group = false;\n  \
    \              group_level.push(depth_level);\n            }\n        }\n    }\n\
    \n    return group_level;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 2, 0, 2, 1, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpp2jm9_aw.rs:45:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut res = Vec::new();\n    let mut max_level = 0;\n\
    \    let mut curr_level = 0;\n    for char in paren_string.chars() {\n       \
    \ if char == '(' {\n            curr_level += 1;\n            if curr_level >\
    \ max_level {\n                max_level = curr_level;\n            }\n      \
    \  } else if char == ')' {\n            curr_level -= 1;\n        } else if char\
    \ == ' ' {\n            res.push(max_level);\n            max_level = 0;\n   \
    \         curr_level = 0;\n        }\n    }\n    res.push(max_level);\n    res\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split(' ')\n        .map(|sub_str|\
    \ paren_level(sub_str))\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `paren_level` in this scope\n --> /tmp/tmpz5di9brg.rs:9:24\n\
    \  |\n9 |         .map(|sub_str| paren_level(sub_str))\n  |                  \
    \      ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // Sort this out somehow\n    let mut output = Vec::new();\n\
    \    for paren_group in paren_string.split(\" \") {\n        output.push(parse_paren_group(paren_group));\n\
    \    }\n    output\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `parse_paren_group` in this scope\n\
    \  --> /tmp/tmp0dvpsse8.rs:10:21\n   |\n10 |         output.push(parse_paren_group(paren_group));\n\
    \   |                     ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split(' ')\n        .map(|g| {\n\
    \            g.chars()\n                .fold(0, |acc, c| match (acc, c) {\n \
    \                   (0, '(') => 1,\n                    (acc, '(') => acc + 1,\n\
    \                    (acc, ')') => acc - 1,\n                    _ => acc,\n \
    \               })\n        })\n        .collect()\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpg_77m4g5.rs:23:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut nest_levels = Vec::new();\n    for parens in paren_string.split_whitespace()\
    \ {\n        // Using a stack to keep track of the nesting level at each parenthesis\
    \ group.\n        let mut stack = vec![0];\n        for ch in parens.chars() {\n\
    \            match ch {\n                '(' => {\n                    let top\
    \ = stack.last_mut().unwrap();\n                    *top += 1;\n             \
    \   }\n                ')' => {\n                    stack.push(stack.last().unwrap()\
    \ - 1);\n                }\n                _ => (),\n            }\n        }\n\
    \        // Pop the maximum nesting level of the stack.\n        nest_levels.push(stack.pop().unwrap());\n\
    \    }\n    nest_levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpyuv647bd.rs:31:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .map(|s|\
    \ {\n            // Iterate over each character of the string\n            s.chars()\n\
    \                .fold((0, 0), |mut acc, x| {\n                    // for every\
    \ '(' increment current and max\n                    if x == '(' {\n         \
    \               acc.0 += 1;\n                        acc.1 = acc.0.max(acc.1);\n\
    \                    }\n                    // for every ')' decrement current\n\
    \                    else if x == ')' {\n                        acc.0 -= 1;\n\
    \                    }\n                    acc\n                })\n        \
    \        .1\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split(' ')\n        .map(|s| {\n\
    \            let mut max_nesting = 0;\n            let mut depth = 0;\n      \
    \      for c in s.chars() {\n                if c == '(' {\n                 \
    \   depth += 1;\n                    if depth > max_nesting {\n              \
    \          max_nesting = depth;\n                    }\n                } else\
    \ if c == ')' {\n                    depth -= 1;\n                }\n        \
    \    }\n            max_nesting\n        })\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result: Vec<isize> = Vec::new();\n    let mut stack:\
    \ Vec<usize> = Vec::new();\n    let mut maximum_nesting: isize = 0;\n    let mut\
    \ current_nesting: isize = 0;\n    let mut level: usize = 0;\n    for (i, paren)\
    \ in paren_string.chars().enumerate() {\n        match paren {\n            '('\
    \ => {\n                stack.push(i);\n                level += 1;\n        \
    \        current_nesting += 1;\n                if current_nesting > maximum_nesting\
    \ {\n                    maximum_nesting = current_nesting;\n                }\n\
    \            }\n            ')' => {\n                if stack.len() == 0 {\n\
    \                    panic!(\"Unbalanced brackets\");\n                }\n   \
    \             stack.pop();\n                current_nesting -= 1;\n          \
    \  }\n            ' ' => {\n                if stack.len() == 0 {\n          \
    \          result.push(maximum_nesting);\n                    maximum_nesting\
    \ = 0;\n                    current_nesting = 0;\n                    level =\
    \ 0;\n                }\n            }\n            _ => {\n                println!(\"\
    {}\", paren);\n                panic!(\"Invalid character\");\n            }\n\
    \        }\n    }\n    result.push(maximum_nesting);\n    result\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    for paren_substring in\
    \ paren_string.split_whitespace() {\n        let mut max_nesting = 0;\n      \
    \  let mut current_nesting = 0;\n        for c in paren_substring.chars() {\n\
    \            if c == '(' {\n                current_nesting += 1;\n          \
    \  } else if c == ')' {\n                current_nesting -= 1;\n            }\
    \ else {\n                panic!(\"Invalid character {} in string {}\", c, paren_substring);\n\
    \            }\n            if current_nesting > max_nesting {\n             \
    \   max_nesting = current_nesting;\n            }\n        }\n        if current_nesting\
    \ != 0 {\n            panic!(\"Invalid number of parentheses in string {}\", paren_substring);\n\
    \        }\n        result.push(max_nesting);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut current_depth = 0;\n\
    \    let mut final_depth = Vec::new();\n    let mut add_depth = true;\n    let\
    \ paren_vec: Vec<char> = paren_string.chars().collect();\n    for c in paren_vec\
    \ {\n        if c == '(' {\n            current_depth += 1;\n            if current_depth\
    \ > max_depth {\n                max_depth = current_depth;\n            }\n \
    \       } else if c == ')' {\n            current_depth -= 1;\n        } else\
    \ if c == ' ' {\n            final_depth.push(max_depth);\n            max_depth\
    \ = 0;\n            current_depth = 0;\n            add_depth = false;\n     \
    \   }\n    }\n    if add_depth {\n        final_depth.push(max_depth);\n    }\n\
    \    final_depth\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp4_6xcrf5.rs:35:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_list: Vec<isize> = Vec::new();\n    for group\
    \ in paren_string.split(\" \") {\n        let mut depth = 0;\n        let mut\
    \ max_depth = 0;\n        for paren in group.chars() {\n            match paren\
    \ {\n                '(' => depth += 1,\n                ')' => depth -= 1,\n\
    \                _ => {}\n            }\n            if depth > max_depth {\n\
    \                max_depth = depth;\n            }\n        }\n        paren_list.push(max_depth);\n\
    \    }\n    paren_list\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_groups = paren_string.split_whitespace();\n\
    \    let mut max_levels = Vec::new();\n    while let Some(current_paren_group)\
    \ = paren_groups.next() {\n        let mut current_paren_group_iter = current_paren_group.chars();\n\
    \        let mut current_level = 0;\n        let mut current_max_level = 0;\n\
    \        while let Some(current_char) = current_paren_group_iter.next() {\n  \
    \          match current_char {\n                '(' => {\n                  \
    \  current_level += 1;\n                    if current_level > current_max_level\
    \ {\n                        current_max_level = current_level;\n            \
    \        }\n                }\n                ')' => {\n                    current_level\
    \ -= 1;\n                }\n                _ => panic!(\"There is a non-paren\
    \ in the paren string\"),\n            }\n        }\n        if current_level\
    \ != 0 {\n            panic!(\"Unbalanced parentheses in paren string\");\n  \
    \      }\n        max_levels.push(current_max_level);\n    }\n    max_levels\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut results = Vec::new();\n    let mut current_max\
    \ = 0;\n    let mut open_parens = 0;\n    for c in paren_string.chars() {\n  \
    \      match c {\n            '(' => {\n                open_parens += 1;\n  \
    \              if open_parens > current_max {\n                    current_max\
    \ = open_parens;\n                }\n            }\n            ')' => {\n   \
    \             open_parens -= 1;\n            }\n            ' ' => {\n       \
    \         results.push(current_max);\n                current_max = 0;\n     \
    \           open_parens = 0;\n            }\n            _ => panic!(\"Invalid\
    \ character {} in input string.\", c),\n        }\n    }\n    results.push(current_max);\n\
    \    results\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n   \
    \ assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut group_start =\
    \ 0;\n    let mut counter = 0;\n    let mut max_level = 0;\n    for (i, &c) in\
    \ paren_string.as_bytes().iter().enumerate() {\n        match c {\n          \
    \  b'(' => {\n                counter += 1;\n                if counter > max_level\
    \ {\n                    max_level = counter;\n                }\n           \
    \ }\n            b')' => {\n                counter -= 1;\n            }\n   \
    \         b' ' => {\n                if counter == 0 {\n                    result.push(max_level);\n\
    \                    group_start = i + 1;\n                    max_level = 0;\n\
    \                }\n            }\n            _ => {}\n        }\n    }\n   \
    \ result.push(max_level);\n    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut stack = Vec::new();\n\
    \    let mut current_max = 0;\n    let mut current_level = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            stack.push(c);\n            current_level\
    \ += 1;\n            if current_level > current_max {\n                current_max\
    \ = current_level;\n            }\n        } else if c == ')' {\n            stack.pop();\n\
    \            current_level -= 1;\n        } else if c == ' ' {\n            result.push(current_max);\n\
    \            current_max = 0;\n            current_level = 0;\n        }\n   \
    \ }\n    result.push(current_max);\n    result\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let paren_groups: Vec<&str> = paren_string.split_whitespace().collect();\n\
    \    paren_groups.iter().map(|paren_group| {\n        let mut sum: isize = 0;\n\
    \        let mut max_sum: isize = 0;\n        for c in paren_group.chars() {\n\
    \            if c == '(' {\n                sum += 1;\n            } else if c\
    \ == ')' {\n                sum -= 1;\n            }\n            if sum > max_sum\
    \ {\n                max_sum = sum;\n            }\n        }\n        max_sum\n\
    \    }).collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels: Vec<isize> = Vec::new();\n    for paren_group\
    \ in paren_string.split_whitespace() {\n        let mut level = 0;\n        let\
    \ mut max_level = 0;\n        for paren in paren_group.chars() {\n           \
    \ if paren == '(' {\n                level += 1;\n            } else if paren\
    \ == ')' {\n                level -= 1;\n            }\n            if level >\
    \ max_level {\n                max_level = level;\n            }\n        }\n\
    \        levels.push(max_level);\n    }\n    levels\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut count = 0;\n\
    \    let mut max_depth = 0;\n    for ch in paren_string.chars() {\n        if\
    \ ch == '(' {\n            count += 1;\n            if count > max_depth {\n \
    \               max_depth = count;\n            }\n        } else if ch == ')'\
    \ {\n            count -= 1;\n        } else if ch == ' ' {\n            result.push(max_depth);\n\
    \            max_depth = 0;\n            count = 0;\n        }\n    }\n    result.push(max_depth);\n\
    \    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .map(|paren_group|\
    \ {\n            let mut nesting = 0;\n            let mut max_nesting = 0;\n\
    \            for ch in paren_group.chars() {\n                if ch == '(' {\n\
    \                    nesting += 1;\n                } else if ch == ')' {\n  \
    \                  nesting -= 1;\n                }\n                if nesting\
    \ > max_nesting {\n                    max_nesting = nesting;\n              \
    \  }\n            }\n            max_nesting\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split(' ')\n        .map(|parens|\
    \ {\n            let parens = parens.chars().collect::<Vec<char>>();\n       \
    \     let mut bracket_stack = vec![];\n            for paren in parens {\n   \
    \             if paren == '(' {\n                    bracket_stack.push(paren);\n\
    \                } else {\n                    bracket_stack.pop();\n        \
    \        }\n            }\n            bracket_stack.len() as isize\n        })\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp71un5zkq.rs:26:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = Vec::new();\n    let mut paren_iter\
    \ = paren_string.split_whitespace();\n    for paren_group in paren_iter {\n  \
    \      let mut depth = 0;\n        let mut max_so_far = 0;\n        for paren\
    \ in paren_group.chars() {\n            if paren == '(' {\n                depth\
    \ += 1;\n            } else if paren == ')' {\n                depth -= 1;\n \
    \           }\n            if depth > max_so_far {\n                max_so_far\
    \ = depth;\n            }\n        }\n        max_depth.push(max_so_far);\n  \
    \  }\n    max_depth\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .map(|group|\
    \ {\n            let mut level = 0;\n            let mut max_level = 0;\n    \
    \        for ch in group.chars() {\n                if ch == '(' {\n         \
    \           level += 1;\n                } else if ch == ')' {\n             \
    \       level -= 1;\n                }\n                max_level = cmp::max(max_level,\
    \ level);\n            }\n            max_level\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpchesw_wz.rs:18:29\n   |\n18 |                 max_level = cmp::max(max_level,\
    \ level);\n   |                             ^^^ use of undeclared crate or module\
    \ `cmp`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut deepest_nesting_levels = Vec::new();\n    let mut\
    \ current_nesting_level = 0;\n    let mut max_nesting_level = 0;\n    let paren_string\
    \ = paren_string.replace(\" \", \"\");\n    let mut current_char_iter = paren_string.chars();\n\
    \    let mut current_char = current_char_iter.next();\n    loop {\n        match\
    \ current_char {\n            Some('(') => {\n                current_nesting_level\
    \ += 1;\n                if current_nesting_level > max_nesting_level {\n    \
    \                max_nesting_level = current_nesting_level;\n                }\n\
    \            }\n            Some(')') => {\n                if current_nesting_level\
    \ > 0 {\n                    current_nesting_level -= 1;\n                }\n\
    \            }\n            None => {\n                deepest_nesting_levels.push(max_nesting_level);\n\
    \                current_nesting_level = 0;\n                max_nesting_level\
    \ = 0;\n                current_char = current_char_iter.next();\n           \
    \     if current_char == None {\n                    break;\n                }\n\
    \            }\n            _ => (),\n        }\n        current_char = current_char_iter.next();\n\
    \    }\n    deepest_nesting_levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpwxnb4_o_.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut deepest_nesting_list = Vec::new();\n    let groups:\
    \ Vec<&str> = paren_string.split_whitespace().collect();\n    for group in groups\
    \ {\n        let mut deepest_nesting: isize = 0;\n        let mut curr_nesting:\
    \ isize = 0;\n        for c in group.chars() {\n            if c == '(' {\n  \
    \              curr_nesting += 1;\n            } else if c == ')' {\n        \
    \        curr_nesting -= 1;\n            }\n            if curr_nesting > deepest_nesting\
    \ {\n                deepest_nesting = curr_nesting;\n            }\n        }\n\
    \        deepest_nesting_list.push(deepest_nesting);\n    }\n    deepest_nesting_list\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut stack: Vec<isize> = Vec::new();\n    for ch in\
    \ paren_string.chars() {\n        match ch {\n            '(' => stack.push(0),\n\
    \            ')' => {\n                let top = stack.pop().unwrap();\n     \
    \           if top == 0 {\n                    stack.push(1);\n              \
    \  } else {\n                    stack.push(top + 1);\n                }\n   \
    \         }\n            _ => continue,\n        }\n    }\n    stack\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 0, 0, 3, 1, 0, 0, 2, 1, 2]`,\n right: `[2, 3, 1, 3]`', /tmp/tmplg9c9ggl.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut depth = 0;\n    let\
    \ mut result = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                depth += 1;\n                if depth\
    \ > max_depth {\n                    max_depth = depth;\n                }\n \
    \           }\n            ')' => {\n                depth -= 1;\n           \
    \ }\n            ' ' => {\n                result.push(max_depth);\n         \
    \       max_depth = 0;\n                depth = 0;\n            }\n          \
    \  _ => panic!(\"Unexpected character!\"),\n        }\n    }\n    result.push(max_depth);\n\
    \    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut stack: Vec<isize> = Vec::new();\n    let mut total:\
    \ isize = 0;\n    let mut max: isize = 0;\n    let mut answer: Vec<isize> = Vec::new();\n\
    \n    for c in paren_string.chars() {\n        if c == '(' {\n            total\
    \ += 1;\n            max = total.max(max);\n        } else if c == ')' {\n   \
    \         total -= 1;\n        } else if c == ' ' {\n            answer.push(max);\n\
    \            max = 0;\n            total = 0;\n        }\n    }\n    return answer;\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpa0kpjr3l.rs:29:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut deepest_level: Vec<isize> = Vec::new();\n    let\
    \ groups: Vec<&str> = paren_string.split(\" \").collect();\n    let mut stack:\
    \ Vec<char> = Vec::new();\n    for group in groups {\n        let mut current_level\
    \ = 0;\n        for ch in group.chars() {\n            if ch == '(' {\n      \
    \          stack.push(ch);\n                current_level += 1;\n            }\
    \ else if ch == ')' {\n                stack.pop();\n                current_level\
    \ -= 1;\n            }\n        }\n        deepest_level.push(current_level);\n\
    \    }\n    deepest_level\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpllf8ul04.rs:28:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split(' ')\n        .map(|s| count_nested_parens(s.to_string()))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `count_nested_parens` in this scope\n\
    \ --> /tmp/tmp3lblxp2t.rs:9:18\n  |\n9 |         .map(|s| count_nested_parens(s.to_string()))\n\
    \  |                  ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    //\n    // TODO: Implement\n    //\n    let mut max_nesting_level:\
    \ isize = 0;\n    let mut current_nesting_level: isize = 0;\n    let mut char_array:\
    \ Vec<char> = paren_string.chars().collect();\n    let mut nested_levels: Vec<isize>\
    \ = Vec::new();\n    for c in char_array {\n        if c == '(' {\n          \
    \  current_nesting_level += 1;\n            if current_nesting_level > max_nesting_level\
    \ {\n                max_nesting_level = current_nesting_level;\n            }\n\
    \        } else if c == ')' {\n            current_nesting_level -= 1;\n     \
    \   } else if c == ' ' {\n            nested_levels.push(max_nesting_level);\n\
    \            max_nesting_level = 0;\n            current_nesting_level = 0;\n\
    \        }\n    }\n    nested_levels.push(max_nesting_level);\n    nested_levels\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // The stack is used to keep track of the nesting level\
    \ for each parenthesis.\n    // The paren_type variable is used to indicate the\
    \ type of parenthesis that is being parsed.\n    // '(' will increment the nesting\
    \ level and ')' will decrement the nesting level.\n    let mut paren_stack: Vec<usize>\
    \ = Vec::new();\n    let mut paren_type: u8 = 0;\n\n    let mut paren_nesting_level:\
    \ Vec<isize> = Vec::new();\n    let mut temp_level: usize = 0;\n\n    for c in\
    \ paren_string.chars() {\n        match c {\n            '(' => {\n          \
    \      paren_type = 1;\n                temp_level += 1;\n            }\n    \
    \        ')' => {\n                paren_type = 2;\n                temp_level\
    \ -= 1;\n            }\n            ' ' => {\n                paren_nesting_level.push(temp_level\
    \ as isize);\n                temp_level = 0;\n            }\n            _ =>\
    \ {}\n        }\n    }\n\n    paren_nesting_level\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp3gkc3j26.rs:39:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // Helper function to update the max level for a single\
    \ paren group\n    fn parse_paren_group(paren_group: &str, curr_level: isize,\
    \ max_level: &mut isize) {\n        // Iterate on the chars in the group one by\
    \ one\n        for c in paren_group.chars() {\n            // Open and close parens\
    \ increase and decrease level respectively\n            match c {\n          \
    \      '(' => curr_level += 1,\n                ')' => curr_level -= 1,\n    \
    \            _ => (),\n            }\n            // Take the maximum of the current\
    \ level or the max level\n            *max_level = std::cmp::max(*max_level, curr_level);\n\
    \        }\n    }\n\n    // Split string on space to get list of groups\n    let\
    \ paren_groups: Vec<&str> = paren_string.split(' ').collect();\n    // Initialize\
    \ current and max level of nesting\n    let mut max_levels: Vec<isize> = Vec::new();\n\
    \    // Iterate over groups and update max levels\n    for paren_group in paren_groups\
    \ {\n        let mut curr_level = 0;\n        let mut max_level = 0;\n       \
    \ parse_paren_group(paren_group, curr_level, &mut max_level);\n        max_levels.push(max_level);\n\
    \    }\n    // Return max levels\n    max_levels\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpkntoc_qb.rs:28:13\n\
    \   |\n28 |         let mut curr_level = 0;\n   |             ----^^^^^^^^^^\n\
    \   |             |\n   |             help: remove this `mut`\n   |\n   = note:\
    \ `#[warn(unused_mut)]` on by default\n\nerror[E0384]: cannot assign to immutable\
    \ argument `curr_level`\n  --> /tmp/tmpkntoc_qb.rs:13:24\n   |\n8  |     fn parse_paren_group(paren_group:\
    \ &str, curr_level: isize, max_level: &mut isize) {\n   |                    \
    \                         ---------- help: consider making this binding mutable:\
    \ `mut curr_level`\n...\n13 |                 '(' => curr_level += 1,\n   |  \
    \                      ^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\n\
    error[E0384]: cannot assign to immutable argument `curr_level`\n  --> /tmp/tmpkntoc_qb.rs:14:24\n\
    \   |\n8  |     fn parse_paren_group(paren_group: &str, curr_level: isize, max_level:\
    \ &mut isize) {\n   |                                             ---------- help:\
    \ consider making this binding mutable: `mut curr_level`\n...\n14 |          \
    \       ')' => curr_level -= 1,\n   |                        ^^^^^^^^^^^^^^^ cannot\
    \ assign to immutable argument\n\nerror: aborting due to 2 previous errors; 1\
    \ warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let paren_groups: Vec<&str> = paren_string.split(' ').collect();\n\
    \    let mut list: Vec<isize> = Vec::new();\n    for paren_group in paren_groups\
    \ {\n        let mut deepest_level = 0;\n        let mut current_level = 0;\n\
    \        for char in paren_group.chars() {\n            if char == '(' {\n   \
    \             current_level += 1;\n            } else if char == ')' {\n     \
    \           current_level -= 1;\n            }\n            if current_level >\
    \ deepest_level {\n                deepest_level = current_level;\n          \
    \  }\n        }\n        list.push(deepest_level);\n    }\n    list\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .map(|s|\
    \ {\n            let (_, depth) = s.chars().fold((0, 0), |(count, depth), c| {\n\
    \                if c == '(' {\n                    (count + 1, std::cmp::max(count\
    \ + 1, depth))\n                } else {\n                    (count - 1, depth)\n\
    \                }\n            });\n            depth\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_levels: Vec<isize> = Vec::new();\n    for string\
    \ in paren_string.split_whitespace() {\n        let mut level: isize = 0;\n  \
    \      let mut max_level: isize = 0;\n        for ch in string.chars() {\n   \
    \         if ch == '(' {\n                level += 1;\n            } else if ch\
    \ == ')' {\n                level -= 1;\n            }\n            if level >\
    \ max_level {\n                max_level = level;\n            }\n        }\n\
    \        max_levels.push(max_level);\n    }\n    max_levels\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split(' ')\n        .map(|x| {\n\
    \            let mut nest_count = 0;\n            let mut max_nest_count = 0;\n\
    \            for c in x.chars() {\n                if c == '(' {\n           \
    \         nest_count += 1;\n                } else if c == ')' {\n           \
    \         nest_count -= 1;\n                }\n                if nest_count >\
    \ max_nest_count {\n                    max_nest_count = nest_count;\n       \
    \         }\n            }\n            max_nest_count\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut res = Vec::new();\n    for g in paren_string.split_whitespace()\
    \ {\n        let mut max_depth = 0;\n        let mut curr_depth = 0;\n       \
    \ for c in g.chars() {\n            match c {\n                '(' => {\n    \
    \                curr_depth += 1;\n                    if curr_depth > max_depth\
    \ {\n                        max_depth = curr_depth;\n                    }\n\
    \                }\n                ')' => {\n                    curr_depth -=\
    \ 1;\n                }\n                _ => {\n                    // ignore\
    \ non-paren characters\n                }\n            }\n        }\n        res.push(max_depth);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_level = 0;\n    let mut max_levels = Vec::new();\n\
    \    let mut level = 0;\n    for ch in paren_string.chars() {\n        match ch\
    \ {\n            '(' => {\n                level += 1;\n                if level\
    \ > max_level {\n                    max_level = level;\n                }\n \
    \           }\n            ')' => {\n                if level == max_level {\n\
    \                    max_levels.push(max_level);\n                    max_level\
    \ = 0;\n                }\n                level -= 1;\n            }\n      \
    \      _ => {}\n        }\n    }\n    max_levels\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 2, 3, 1, 3, 2, 2]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpw2c5s54_.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut depth_vec = Vec::new();\n    let mut depth = 0;\n\
    \    for c in paren_string.chars() {\n        match c {\n            '(' => depth\
    \ += 1,\n            ')' => depth -= 1,\n            _ => (),\n        }\n   \
    \     if c == ' ' {\n            depth_vec.push(depth);\n            depth = 0;\n\
    \        }\n    }\n    depth_vec\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpzp16taab.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_levels: Vec<isize> = Vec::new();\n    let groups:\
    \ Vec<&str> = paren_string.split(\" \").collect();\n    for group in groups {\n\
    \        // Set the max level to 0 initially\n        let mut max_level = 0;\n\
    \        // Set the current level to 0 initially\n        let mut curr_level =\
    \ 0;\n        for paren in group.chars() {\n            if paren == '(' {\n  \
    \              curr_level += 1;\n            } else if paren == ')' {\n      \
    \          curr_level -= 1;\n            }\n            if curr_level > max_level\
    \ {\n                max_level = curr_level;\n            }\n        }\n     \
    \   max_levels.push(max_level);\n    }\n    max_levels\n}\n\nfn main() {\n   \
    \ let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut res: Vec<isize> = Vec::new();\n    let mut level:\
    \ isize = 0;\n    let mut nested_level: isize = 0;\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                level += 1;\n  \
    \              if level > nested_level {\n                    nested_level = level;\n\
    \                }\n            }\n            ')' => {\n                level\
    \ -= 1;\n            }\n            ' ' => {\n                if level == 0 {\n\
    \                    res.push(nested_level);\n                    nested_level\
    \ = 0;\n                }\n            }\n            _ => {}\n        }\n   \
    \ }\n    res\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n   \
    \ assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp6lr1jyo1.rs:35:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // Collect the groups separated by spaces into a vector\n\
    \    let paren_groups: Vec<&str> = paren_string.split_whitespace().collect();\n\
    \    let mut depths: Vec<isize> = Vec::new();\n\n    // For each group, track\
    \ the current depth\n    for group in paren_groups {\n        let mut depth =\
    \ 0;\n        let mut max_depth = 0;\n        for c in group.chars() {\n     \
    \       match c {\n                '(' => depth += 1,\n                ')' =>\
    \ depth -= 1,\n                _ => (),\n            }\n            max_depth\
    \ = std::cmp::max(max_depth, depth);\n        }\n        depths.push(max_depth);\n\
    \    }\n    depths\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut current_depth = 0;\n    let mut max_depth = 0;\n\
    \    let mut depth_vector = Vec::new();\n    let mut chars = paren_string.chars();\n\
    \    while let Some(c) = chars.next() {\n        match c {\n            '(' =>\
    \ {\n                current_depth += 1;\n                if current_depth > max_depth\
    \ {\n                    max_depth = current_depth;\n                }\n     \
    \       }\n            ')' => {\n                if current_depth > 0 {\n    \
    \                current_depth -= 1;\n                }\n            }\n     \
    \       ' ' => {\n                depth_vector.push(max_depth);\n            \
    \    max_depth = 0;\n                current_depth = 0;\n            }\n     \
    \       _ => {}\n        }\n    }\n    if current_depth > 0 {\n        depth_vector.push(max_depth);\n\
    \    }\n    depth_vector\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpndxd7exk.rs:40:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut v: Vec<isize> = Vec::new();\n    let mut tokenizer\
    \ = paren_string.split_whitespace();\n    while let Some(t) = tokenizer.next()\
    \ {\n        let mut level = 0;\n        let mut max_level = 0;\n        for c\
    \ in t.chars() {\n            if c == '(' {\n                level += 1;\n   \
    \         } else if c == ')' {\n                level -= 1;\n            }\n \
    \           if level > max_level {\n                max_level = level;\n     \
    \       }\n        }\n        v.push(max_level);\n    }\n    v\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let words = paren_string.split(' ').collect::<Vec<&str>>();\n\
    \    let mut max_levels = vec![];\n    for word in words {\n        let mut curr_level\
    \ = 0;\n        let mut max_level = 0;\n        for c in word.chars() {\n    \
    \        if c == '(' {\n                curr_level += 1;\n            } else if\
    \ c == ')' {\n                curr_level -= 1;\n            }\n            if\
    \ curr_level > max_level {\n                max_level = curr_level;\n        \
    \    }\n        }\n        max_levels.push(max_level);\n    }\n    max_levels\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split(' ')\n        .map(|s| {\n\
    \            s.chars()\n                .fold(0_isize, |acc, c| match c {\n  \
    \                  '(' => acc + 1,\n                    ')' => acc - 1,\n    \
    \                _ => acc,\n                })\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpfhsmiznt.rs:22:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nesting = vec![];\n    let mut count = 0;\n\
    \    let mut max_count = 0;\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                count += 1;\n                if count\
    \ > max_count {\n                    max_count = count;\n                }\n \
    \           }\n            ')' => {\n                count -= 1;\n           \
    \ }\n            ' ' => {\n                max_nesting.push(max_count);\n    \
    \            max_count = 0;\n                count = 0;\n            }\n     \
    \       _ => {}\n        }\n    }\n    max_nesting.push(max_count);\n    max_nesting\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result: Vec<isize> = Vec::new();\n    let mut current_depth:\
    \ isize = 0;\n    let mut max_depth: isize = 0;\n    for curr_char in paren_string.chars()\
    \ {\n        match curr_char {\n            '(' => {\n                current_depth\
    \ += 1;\n                if current_depth > max_depth {\n                    max_depth\
    \ = current_depth;\n                }\n            }\n            ')' => {\n \
    \               current_depth -= 1;\n            }\n            ' ' => {\n   \
    \             result.push(max_depth);\n                max_depth = 0;\n      \
    \          current_depth = 0;\n            }\n            _ => {\n           \
    \     panic!(\"Invalid character: {}\", curr_char);\n            }\n        }\n\
    \    }\n    result.push(max_depth);\n    result\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let paren_groups: Vec<&str> = paren_string.split(' ').collect();\n\
    \    let mut output: Vec<isize> = Vec::new();\n    for paren_group in paren_groups\
    \ {\n        let mut nesting_level: isize = 0;\n        let mut max_nesting_level:\
    \ isize = 0;\n        for char in paren_group.chars() {\n            if char ==\
    \ '(' {\n                nesting_level += 1;\n            } else if char == ')'\
    \ {\n                nesting_level -= 1;\n            }\n            if nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = nesting_level;\n\
    \            }\n        }\n        output.push(max_nesting_level);\n    }\n  \
    \  output\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut counter: isize = 0;\n    let mut max_counter: isize\
    \ = 0;\n    let mut max_vec: Vec<isize> = Vec::new();\n    let mut new_paren_string\
    \ = String::new();\n    let mut index = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == ' ' {\n            if counter > max_counter {\n         \
    \       max_counter = counter;\n            }\n            max_vec.push(max_counter);\n\
    \            max_counter = 0;\n            counter = 0;\n            new_paren_string.push_str(&paren_string[index..]);\n\
    \            break;\n        }\n        if c == '(' {\n            counter +=\
    \ 1;\n        } else if c == ')' {\n            counter -= 1;\n        }\n   \
    \     index += 1;\n    }\n    for c in new_paren_string.chars() {\n        if\
    \ c == '(' {\n            counter += 1;\n        } else if c == ')' {\n      \
    \      counter -= 1;\n        }\n        if counter > max_counter {\n        \
    \    max_counter = counter;\n        }\n    }\n    max_vec.push(max_counter);\n\
    \    max_vec\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n   \
    \ assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 3]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp33xsh8rj.rs:46:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .map(|paren_group|\
    \ calc_nested_paren_group(paren_group))\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `calc_nested_paren_group` in this scope\n\
    \ --> /tmp/tmprbolv2g1.rs:9:28\n  |\n9 |         .map(|paren_group| calc_nested_paren_group(paren_group))\n\
    \  |                            ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .map(|paren_group|\
    \ parse_nested_parens_helper(paren_group))\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `parse_nested_parens_helper` in this\
    \ scope\n --> /tmp/tmpov8glciv.rs:9:28\n  |\n9 |         .map(|paren_group| parse_nested_parens_helper(paren_group))\n\
    \  |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .map(|x|\
    \ {\n            let mut count = 0;\n            let mut depth = 0;\n        \
    \    for c in x.chars() {\n                if c == '(' {\n                   \
    \ count += 1;\n                    depth = depth.max(count);\n               \
    \ } else if c == ')' {\n                    count -= 1;\n                }\n \
    \           }\n            depth\n        })\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    for group in paren_string.split_whitespace()\
    \ {\n        result.push(paren_string_depth(group));\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `paren_string_depth` in this scope\n\
    \ --> /tmp/tmpa1k5d8mg.rs:9:21\n  |\n9 |         result.push(paren_string_depth(group));\n\
    \  |                     ^^^^^^^^^^^^^^^^^^ help: a local variable with a similar\
    \ name exists: `paren_string`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .map(|group|\
    \ {\n            let max_level = group.chars().fold(0, |acc, x| {\n          \
    \      match x {\n                    '(' => acc + 1,\n                    ')'\
    \ => acc - 1,\n                    _ => acc,\n                }\n            });\n\
    \            // If max_level is 0, it means the parentheses are balanced.\n  \
    \          if max_level == 0 {\n                max_level\n            } else\
    \ {\n                // Then we need to divide the max_level by 2.\n         \
    \       max_level / 2\n            }\n        })\n        .collect()\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp7uddxzr_.rs:30:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut curr_depth = 0;\n \
    \   let mut paren_counts = Vec::new();\n    for char in paren_string.chars() {\n\
    \        match char {\n            '(' => {\n                curr_depth += 1;\n\
    \                if curr_depth > max_depth {\n                    max_depth =\
    \ curr_depth;\n                }\n            }\n            ')' => {\n      \
    \          curr_depth -= 1;\n            }\n            ' ' => {\n           \
    \     paren_counts.push(max_depth);\n                max_depth = 0;\n        \
    \        curr_depth = 0;\n            }\n            _ => {}\n        }\n    }\n\
    \    if max_depth > 0 {\n        paren_counts.push(max_depth);\n    }\n    paren_counts\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut current_level\
    \ = 0;\n    let mut current_max = 0;\n    for c in paren_string.chars() {\n  \
    \      match c {\n            '(' => {\n                current_level += 1;\n\
    \                if current_level > current_max {\n                    current_max\
    \ = current_level;\n                }\n            }\n            ')' => {\n \
    \               current_level -= 1;\n            }\n            ' ' => {\n   \
    \             paren_levels.push(current_max);\n                current_max = 0;\n\
    \                current_level = 0;\n            }\n            _ => {}\n    \
    \    }\n    }\n    paren_levels.push(current_max);\n    paren_levels\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut lhs = 0;\n    let mut rhs = 0;\n    let mut max_level\
    \ = 0;\n    let mut result = Vec::new();\n    for c in paren_string.chars() {\n\
    \        if c == '(' {\n            lhs += 1;\n            if lhs > max_level\
    \ {\n                max_level = lhs;\n            }\n        } else if c == ')'\
    \ {\n            rhs += 1;\n        }\n        if lhs == rhs {\n            lhs\
    \ = 0;\n            rhs = 0;\n            result.push(max_level);\n          \
    \  max_level = 0;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 0, 3, 0, 1, 0, 5]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpwvjbq7jo.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut stack = Vec::new();\n\
    \    let mut depth = 0;\n    for c in paren_string.chars() {\n        match c\
    \ {\n            '(' => {\n                depth += 1;\n                stack.push(c);\n\
    \            }\n            ')' => {\n                if stack.len() == 0 {\n\
    \                    result.push(-1);\n                    break;\n          \
    \      } else {\n                    stack.pop();\n                    if stack.len()\
    \ == 0 {\n                        result.push(depth);\n                      \
    \  depth = 0;\n                    }\n                }\n            }\n     \
    \       ' ' => continue,\n            _ => continue,\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 3, 1, 5]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpdk7rqot6.rs:37:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = Vec::new();\n    let\
    \ mut nest_level: isize = 0;\n    let mut max_nest_levels: Vec<isize> = Vec::new();\n\
    \    let mut char_iter = paren_string.chars();\n    while let Some(paren) = char_iter.next()\
    \ {\n        if paren == '(' {\n            nest_level += 1;\n            paren_stack.push(nest_level);\n\
    \        } else if paren == ')' {\n            let temp = paren_stack.pop().unwrap();\n\
    \            nest_level = nest_level - 1;\n            if paren_stack.is_empty()\
    \ {\n                max_nest_levels.push(temp);\n            }\n        } else\
    \ if paren == ' ' {\n            if !paren_stack.is_empty() {\n              \
    \  paren_stack.clear();\n            }\n            nest_level = 0;\n        }\n\
    \    }\n    max_nest_levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpvblg2m8m.rs:33:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut stack = vec![];\n    let mut result = vec![];\n\
    \    for c in paren_string.chars() {\n        match c {\n            '(' => {\n\
    \                stack.push(c);\n            }\n            ')' => {\n       \
    \         let len = stack.len();\n                stack.push(c);\n           \
    \     result.push(len as isize);\n            }\n            _ => {\n        \
    \        stack.clear();\n                continue;\n            }\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4, 5, 3, 4, 5, 1, 3, 4, 6, 8, 9]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpgozyemq3.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_level_max =\
    \ 0;\n    let mut paren_level_list = Vec::new();\n    let mut paren_level_max_list\
    \ = Vec::new();\n    for c in paren_string.chars() {\n        match c {\n    \
    \        '(' => {\n                paren_level += 1;\n                if paren_level\
    \ > paren_level_max {\n                    paren_level_max = paren_level;\n  \
    \              }\n            }\n            ')' => {\n                paren_level\
    \ -= 1;\n            }\n            ' ' => {\n                paren_level_list.push(paren_level);\n\
    \                paren_level_max_list.push(paren_level_max);\n               \
    \ paren_level = 0;\n                paren_level_max = 0;\n            }\n    \
    \        _ => {}\n        }\n    }\n    paren_level_list.push(paren_level);\n\
    \    paren_level_max_list.push(paren_level_max);\n    paren_level_max_list\n}\n\
    \nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // write code here\n    let mut paren_stack: Vec<char>\
    \ = Vec::new();\n    let mut nesting_levels: Vec<isize> = Vec::new();\n    let\
    \ mut current_level: isize = 0;\n    let mut max_level: isize = 0;\n    for i\
    \ in paren_string.chars() {\n        if i == '(' {\n            paren_stack.push(i);\n\
    \            current_level += 1;\n            if current_level > max_level {\n\
    \                max_level = current_level;\n            }\n        } else if\
    \ i == ')' {\n            if paren_stack.pop() == Some('(') {\n              \
    \  if current_level > 0 {\n                    current_level -= 1;\n         \
    \       }\n            }\n        } else if i == ' ' {\n            nesting_levels.push(max_level);\n\
    \            max_level = 0;\n            current_level = 0;\n        }\n    }\n\
    \    nesting_levels.push(max_level);\n    return nesting_levels;\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut count = 0;\n    let mut max_depth = 0;\n    let\
    \ mut paren_levels = Vec::new();\n    for &c in paren_string.chars() {\n     \
    \   match c {\n            '(' => {\n                count += 1;\n           \
    \     max_depth = std::cmp::max(max_depth, count);\n            }\n          \
    \  ')' => {\n                count -= 1;\n            }\n            ' ' => {\n\
    \                paren_levels.push(max_depth);\n                max_depth = 0;\n\
    \                count = 0;\n            }\n            _ => {}\n        }\n \
    \   }\n    paren_levels.push(max_depth);\n    paren_levels\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzqlwjj8o.rs:10:9\n   |\n\
    10 |     for &c in paren_string.chars() {\n   |         ^^    --------------------\
    \ this expression has type `Option<char>`\n   |         |\n   |         expected\
    \ `char`, found reference\n   |         help: you can probably remove the explicit\
    \ borrow: `c`\n   |\n   = note:   expected type `char`\n           found reference\
    \ `&_`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut last_level: isize = 0;\n    let mut max_level:\
    \ isize = 0;\n    let mut level_list: Vec<isize> = Vec::new();\n    let mut index:\
    \ usize = 0;\n    let paren_string_list: Vec<char> = paren_string.chars().collect();\n\
    \    while index < paren_string_list.len() {\n        if paren_string_list[index]\
    \ == '(' {\n            last_level += 1;\n            if last_level > max_level\
    \ {\n                max_level = last_level;\n            }\n        } else if\
    \ paren_string_list[index] == ')' {\n            last_level -= 1;\n        } else\
    \ if paren_string_list[index] == ' ' {\n            level_list.push(max_level);\n\
    \            max_level = 0;\n            last_level = 0;\n        }\n        index\
    \ += 1;\n    }\n    level_list.push(max_level);\n    level_list\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut deepest_nesting = vec![];\n    let mut curr_nesting\
    \ = 0;\n    let mut curr_paren_string = String::new();\n    for paren in paren_string.chars()\
    \ {\n        if paren == ' ' {\n            curr_paren_string.clear();\n     \
    \       curr_nesting = 0;\n            continue;\n        }\n        if paren\
    \ == '(' {\n            curr_nesting += 1;\n        } else if paren == ')' {\n\
    \            curr_nesting -= 1;\n        }\n        curr_paren_string.push(paren);\n\
    \        if curr_paren_string.len() == 2 * curr_nesting {\n            deepest_nesting.push(curr_nesting);\n\
    \        }\n    }\n    deepest_nesting\n}\n\nfn main() {\n    let candidate =\
    \ parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg3_m1a69.rs:26:5\n   |\n\
    6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |      \
    \                                           ---------- expected `Vec<isize>` because\
    \ of return type\n...\n26 |     deepest_nesting\n   |     ^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n    \
    \          found struct `Vec<usize>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut levels: Vec<isize> = Vec::new();\n    let mut curr_level:\
    \ isize = 0;\n    let mut max_level: isize = 0;\n    for ch in paren_string.chars()\
    \ {\n        if ch == '(' {\n            curr_level += 1;\n            if curr_level\
    \ > max_level {\n                max_level = curr_level;\n            }\n    \
    \    } else if ch == ')' {\n            curr_level -= 1;\n        } else if ch\
    \ == ' ' {\n            if curr_level == 0 {\n                levels.push(max_level);\n\
    \                max_level = 0;\n            }\n        }\n    }\n    if curr_level\
    \ == 0 {\n        levels.push(max_level);\n    }\n    levels\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut curr_depth = 0;\n \
    \   let mut answer = Vec::new();\n    let chars: Vec<char> = paren_string.chars().collect();\n\
    \    for c in chars {\n        match c {\n            '(' => {\n             \
    \   curr_depth += 1;\n                if curr_depth > max_depth {\n          \
    \          max_depth = curr_depth;\n                }\n            }\n       \
    \     ')' => {\n                curr_depth -= 1;\n            }\n            '\
    \ ' => {\n                answer.push(max_depth);\n                max_depth =\
    \ 0;\n                curr_depth = 0;\n            }\n            _ => {}\n  \
    \      }\n    }\n    answer.push(max_depth);\n    answer\n}\n\nfn main() {\n \
    \   let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut deepest_parens: Vec<isize> = Vec::new();\n    let\
    \ paren_strs: Vec<&str> = paren_string.split(\" \").collect();\n    for paren_str\
    \ in paren_strs {\n        deepest_parens.push(nested_parens(paren_str));\n  \
    \  }\n    deepest_parens\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `nested_parens` in this scope\n  -->\
    \ /tmp/tmp9gjufadr.rs:10:29\n   |\n10 |         deepest_parens.push(nested_parens(paren_str));\n\
    \   |                             ^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut res: Vec<isize> = Vec::new();\n    let mut depth:\
    \ isize = 0;\n    let mut max_depth: isize = 0;\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                depth += 1;\n  \
    \              max_depth = if depth > max_depth { depth } else { max_depth };\n\
    \            }\n            ')' => {\n                depth -= 1;\n          \
    \  }\n            ' ' => {\n                res.push(max_depth);\n           \
    \     max_depth = 0;\n                depth = 0;\n            }\n            _\
    \ => {}\n        }\n    }\n    if paren_string.ends_with(' ') {\n        res.push(max_depth);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp2y5snvsa.rs:35:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // TODO: Add solution here.\n    vec![]\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpj8xofrkj.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split(' ')\n        .map(|s| {\n\
    \            s.chars()\n                .fold(0, |cnt, c| match c {\n        \
    \            '(' => cnt + 1,\n                    ')' => cnt - 1,\n          \
    \          _ => cnt,\n                })\n        })\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmph2xcv4x0.rs:22:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = 0;\n    let mut current_depth = 0;\n\
    \    let mut max_depths = Vec::new();\n\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                current_depth += 1;\n\
    \                if current_depth > max_depth {\n                    max_depth\
    \ = current_depth;\n                }\n            }\n            ')' => {\n \
    \               if current_depth > 0 {\n                    current_depth -= 1;\n\
    \                }\n            }\n            ' ' => {\n                max_depths.push(max_depth);\n\
    \                max_depth = 0;\n                current_depth = 0;\n        \
    \    }\n            _ => panic!(\"Unrecognized character: {}\", c),\n        }\n\
    \    }\n    max_depths.push(max_depth);\n    max_depths\n}\n\nfn main() {\n  \
    \  let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = Vec::new();\n    let\
    \ mut result: Vec<isize> = Vec::new();\n    let mut curr_par_count: isize = 0;\n\
    \    let mut max_par_count: isize = 0;\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                curr_par_count += 1;\n\
    \                max_par_count = std::cmp::max(max_par_count, curr_par_count);\n\
    \            }\n            ')' => {\n                curr_par_count -= 1;\n \
    \           }\n            ' ' => {\n                if curr_par_count == 0 {\n\
    \                    result.push(max_par_count);\n                    max_par_count\
    \ = 0;\n                }\n            }\n            _ => {}\n        }\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp29teypu_.rs:34:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut curr_max = 0;\n\
    \    let mut curr_level = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            curr_level += 1;\n            if curr_level > curr_max\
    \ {\n                curr_max = curr_level;\n            }\n        } else if\
    \ c == ')' {\n            curr_level -= 1;\n        } else if c == ' ' {\n   \
    \         result.push(curr_max);\n            curr_max = 0;\n            curr_level\
    \ = 0;\n        }\n    }\n    if curr_level != 0 {\n        result.push(curr_max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpdl7fjwxe.rs:32:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut paren_groups = Vec::new();\n    let mut current_group\
    \ = 0;\n    let mut current_layer = 0;\n    let mut max_layer = 0;\n    for paren\
    \ in paren_string.chars() {\n        match paren {\n            '(' => {\n   \
    \             current_layer += 1;\n                if current_layer > max_layer\
    \ {\n                    max_layer = current_layer;\n                }\n     \
    \       }\n            ')' => {\n                current_layer -= 1;\n       \
    \     }\n            ' ' => {\n                paren_groups.push(max_layer);\n\
    \                max_layer = 0;\n                current_layer = 0;\n        \
    \    }\n            _ => {\n                panic!(\"Unexpected character in paren\
    \ string! {}\", paren);\n            }\n        }\n    }\n    paren_groups.push(max_layer);\n\
    \    paren_groups\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let paren_chars: Vec<char> = paren_string.chars().collect();\n\
    \    let mut depths: Vec<isize> = Vec::new();\n    let mut curr_depth: isize =\
    \ 0;\n    let mut parsing_parens: bool = false;\n    for c in paren_chars {\n\
    \        if c == '(' {\n            if parsing_parens {\n                curr_depth\
    \ += 1;\n            } else {\n                parsing_parens = true;\n      \
    \          curr_depth = 1;\n            }\n        } else if c == ')' {\n    \
    \        curr_depth -= 1;\n            if curr_depth == 0 {\n                parsing_parens\
    \ = false;\n                depths.push(curr_depth);\n            }\n        }\
    \ else if c == ' ' {\n            if parsing_parens {\n                depths.push(curr_depth);\n\
    \                parsing_parens = false;\n            }\n        }\n    }\n  \
    \  return depths;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp6oeqg4jg.rs:37:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let paren_strings: Vec<&str> = paren_string.split_whitespace().collect();\n\
    \    paren_strings.iter().map(parse_nested_paren).collect()\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `parse_nested_paren` in this scope\n -->\
    \ /tmp/tmple7ukxgo.rs:8:30\n  |\n8 |     paren_strings.iter().map(parse_nested_paren).collect()\n\
    \  |                              ^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .map(|s|\
    \ parse_parens(s.to_string()))\n        .collect()\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `parse_parens` in this scope\n --> /tmp/tmpwdphrbr9.rs:9:18\n\
    \  |\n9 |         .map(|s| parse_parens(s.to_string()))\n  |                 \
    \ ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // TODO\n    let mut result: Vec<isize> = Vec::new();\n\
    \    let mut max_depth: isize = 0;\n    let mut depth: isize = 0;\n    for character\
    \ in paren_string.chars() {\n        match character {\n            '(' => {\n\
    \                depth += 1;\n                if depth > max_depth {\n       \
    \             max_depth = depth;\n                }\n            }\n         \
    \   ')' => {\n                depth -= 1;\n            }\n            ' ' => {\n\
    \                result.push(max_depth);\n                max_depth = 0;\n   \
    \             depth = 0;\n            }\n            _ => {}\n        }\n    }\n\
    \    result.push(max_depth);\n    result\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // WRITE YOUR CODE HERE\n    return vec![];\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpp_2xfpyn.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // Complete implementation here.\n    //\n    // Hint:\n\
    \    // Use for iterator to iterate through the string.\n    // Use isize to store\
    \ the count of current nesting level.\n    // Use collect() to return a vector\
    \ with maximum nesting level.\n    //\n    // Note:\n    // Keep in mind you should\
    \ check if the character is an opening or closing\n    // parentheses.\n    let\
    \ mut max_nesting = 0;\n    let mut current_nesting = 0;\n    let mut results\
    \ = Vec::new();\n    for ch in paren_string.chars() {\n        if ch == '(' {\n\
    \            current_nesting += 1;\n            if current_nesting > max_nesting\
    \ {\n                max_nesting = current_nesting;\n            }\n        }\
    \ else if ch == ')' {\n            current_nesting -= 1;\n        } else if ch\
    \ == ' ' {\n            results.push(max_nesting);\n            max_nesting =\
    \ 0;\n            current_nesting = 0;\n        }\n    }\n    results.push(max_nesting);\n\
    \    results\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n   \
    \ assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split(' ')\n        .map(|s| {\n\
    \            let mut stack = Vec::<char>::new();\n            let mut depth =\
    \ 0;\n            let mut max_depth = 0;\n            for c in s.chars() {\n \
    \               if c == '(' {\n                    stack.push(c);\n          \
    \          depth += 1;\n                    if depth > max_depth {\n         \
    \               max_depth = depth;\n                    }\n                } else\
    \ if c == ')' {\n                    stack.pop();\n                    depth -=\
    \ 1;\n                }\n            }\n            max_depth\n        })\n  \
    \      .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .map(|s|\
    \ {\n            let mut level = 0;\n            let mut max_level = 0;\n    \
    \        for c in s.chars() {\n                match c {\n                   \
    \ '(' => level += 1,\n                    ')' => level -= 1,\n               \
    \     _ => (),\n                }\n                max_level = std::cmp::max(max_level,\
    \ level);\n            }\n            max_level\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result: Vec<isize> = Vec::new();\n    for mut paren_group\
    \ in paren_string.split_whitespace() {\n        paren_group = &paren_group[1..(paren_group.len()\
    \ - 1)];\n        let mut depth = 0;\n        let mut max_depth = 0;\n       \
    \ for paren in paren_group.chars() {\n            if paren == '(' {\n        \
    \        depth += 1;\n            } else {\n                depth -= 1;\n    \
    \        }\n            if depth > max_depth {\n                max_depth = depth;\n\
    \            }\n        }\n        result.push(max_depth);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 0, 2]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpp43la76x.rs:29:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut group_depth = Vec::new();\n    let mut curr_depth\
    \ = 0;\n    let mut max_depth = 0;\n    for c in paren_string.chars() {\n    \
    \    if c == '(' {\n            curr_depth += 1;\n            max_depth = std::cmp::max(max_depth,\
    \ curr_depth);\n        } else if c == ')' {\n            curr_depth -= 1;\n \
    \       } else if c == ' ' {\n            group_depth.push(max_depth);\n     \
    \       max_depth = 0;\n            curr_depth = 0;\n        }\n    }\n    group_depth.push(max_depth);\n\
    \    group_depth\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result: Vec<isize> = Vec::new();\n    for paren_group\
    \ in paren_string.split(\" \") {\n        let mut nesting_level = 0;\n       \
    \ let mut max_nesting_level = 0;\n        for paren in paren_group.chars() {\n\
    \            if paren == '(' {\n                nesting_level += 1;\n        \
    \    } else if paren == ')' {\n                nesting_level -= 1;\n         \
    \   }\n            if nesting_level > max_nesting_level {\n                max_nesting_level\
    \ = nesting_level;\n            }\n        }\n        result.push(max_nesting_level);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_nest_levels = Vec::new();\n    let mut paren_string_iter\
    \ = paren_string.split_whitespace();\n    let mut paren_groups = Vec::new();\n\
    \    for paren_group in paren_string_iter {\n        paren_groups.push(paren_group);\n\
    \    }\n    for paren_group in paren_groups {\n        let mut paren_iter = paren_group.chars();\n\
    \        let mut level = Vec::new();\n        let mut current_level = 0;\n   \
    \     for paren in paren_iter {\n            if paren == '(' {\n             \
    \   current_level += 1;\n            } else if paren == ')' {\n              \
    \  current_level -= 1;\n            }\n            level.push(current_level);\n\
    \        }\n        max_nest_levels.push(*level.iter().max().unwrap());\n    }\n\
    \    max_nest_levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth = vec![];\n    let mut current_depth\
    \ = 0;\n    let mut current_max = 0;\n    let mut is_open = false;\n    for i\
    \ in paren_string.chars() {\n        match i {\n            '(' => {\n       \
    \         is_open = true;\n                current_depth += 1;\n             \
    \   if current_depth > current_max {\n                    current_max = current_depth;\n\
    \                }\n            }\n            ')' => {\n                is_open\
    \ = false;\n                current_depth -= 1;\n            }\n            '\
    \ ' => {\n                if !is_open {\n                    max_depth.push(current_max);\n\
    \                    current_max = 0;\n                    current_depth = 0;\n\
    \                }\n            }\n            _ => panic!(\"Unknown character\
    \ {} in parentheses\", i),\n        }\n    }\n    // Add the last one\n    max_depth.push(current_max);\n\
    \    max_depth\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n \
    \   assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    // TODO\n    vec![]\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpomidg2mo.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut total_depth: isize = 0;\n    let mut current_max:\
    \ isize = 0;\n    let mut paren_list: Vec<isize> = Vec::new();\n    for paren\
    \ in paren_string.chars() {\n        if paren == '(' {\n            total_depth\
    \ += 1;\n            if total_depth > current_max {\n                current_max\
    \ = total_depth;\n            }\n        } else if paren == ')' {\n          \
    \  total_depth -= 1;\n            if total_depth == 0 {\n                paren_list.push(current_max);\n\
    \                current_max = 0;\n            }\n        }\n    }\n    paren_list\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split(' ')\n        .map(|group|\
    \ {\n            let mut nested_level = 0;\n            let mut highest_level\
    \ = 0;\n            for c in group.chars() {\n                if c == '(' {\n\
    \                    nested_level += 1;\n                } else if c == ')' {\n\
    \                    nested_level -= 1;\n                }\n                if\
    \ nested_level > highest_level {\n                    highest_level = nested_level;\n\
    \                }\n            }\n            highest_level\n        })\n   \
    \     .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut current_depth\
    \ = 0;\n    let mut max_depth = 0;\n    for c in paren_string.chars() {\n    \
    \    if c == '(' {\n            current_depth += 1;\n            if current_depth\
    \ > max_depth {\n                max_depth = current_depth;\n            }\n \
    \       } else if c == ')' {\n            current_depth -= 1;\n        } else\
    \ if c == ' ' {\n            result.push(max_depth);\n            max_depth =\
    \ 0;\n            current_depth = 0;\n        }\n    }\n    result.push(max_depth);\n\
    \    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .map(|s|\
    \ {\n            let mut count = 0;\n            let mut max_count = 0;\n    \
    \        for c in s.chars() {\n                if c == '(' {\n               \
    \     count += 1;\n                } else if c == ')' {\n                    count\
    \ -= 1;\n                }\n                if count > max_count {\n         \
    \           max_count = count;\n                }\n            }\n           \
    \ max_count\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split(' ')\n        .map(|x| {\n\
    \            x.chars()\n                .fold(0_isize, |nested_level, c| match\
    \ c {\n                    '(' => nested_level + 1,\n                    ')' =>\
    \ nested_level - 1,\n                    _ => nested_level,\n                })\n\
    \        })\n        .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpfw3bp3zs.rs:22:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_cnt: isize = 0;\n    let mut cnt: isize = 0;\n\
    \    let mut result: Vec<isize> = Vec::new();\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            cnt += 1;\n            if cnt > max_cnt\
    \ {\n                max_cnt = cnt;\n            }\n        } else if c == ')'\
    \ {\n            cnt -= 1;\n        } else if c == ' ' {\n            result.push(max_cnt);\n\
    \            max_cnt = 0;\n            cnt = 0;\n        }\n    }\n    result.push(max_cnt);\n\
    \    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split(' ')\n        .map(|paren_group|\
    \ {\n            paren_group\n                .chars()\n                .filter(|&c|\
    \ c == '(')\n                .fold(0, |max_level, _| max_level + 1)\n        })\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 3, 1, 5]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp_j7n37jm.rs:20:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .map(|parens|\
    \ {\n            let mut nesting_counter = 0;\n            let mut max_nesting\
    \ = 0;\n            let mut i = 0;\n            while i < parens.len() {\n   \
    \             match parens.chars().nth(i) {\n                    Some('(') =>\
    \ {\n                        nesting_counter += 1;\n                        max_nesting\
    \ = max(max_nesting, nesting_counter);\n                    }\n              \
    \      Some(')') => {\n                        nesting_counter -= 1;\n       \
    \             }\n                    _ => {}\n                }\n            \
    \    i += 1;\n            }\n            max_nesting\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpjqz_i9vu.rs:17:39\n\
    \   |\n17 |                         max_nesting = max(max_nesting, nesting_counter);\n\
    \   |                                       ^^^ not found in this scope\n   |\n\
    help: consider importing this function\n   |\n1  | use std::cmp::max;\n   |\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depths = Vec::new();\n    for group in paren_string.split_whitespace()\
    \ {\n        let mut depth = 0;\n        let mut max_depth = 0;\n        for paren\
    \ in group.chars() {\n            if paren == '(' {\n                depth +=\
    \ 1;\n            } else if paren == ')' {\n                depth -= 1;\n    \
    \        }\n            if depth > max_depth {\n                max_depth = depth;\n\
    \            }\n        }\n        max_depths.push(max_depth);\n    }\n    max_depths\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split(' ')\n        .map(|x| depth_of_parens(x))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `depth_of_parens` in this scope\n -->\
    \ /tmp/tmpjqxyvs0d.rs:9:18\n  |\n9 |         .map(|x| depth_of_parens(x))\n  |\
    \                  ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split(' ')\n        .map(|s| {\n\
    \            let mut counter = 0;\n            let mut max_counter = 0;\n    \
    \        for c in s.chars() {\n                if c == '(' {\n               \
    \     counter += 1;\n                } else if c == ')' {\n                  \
    \  counter -= 1;\n                }\n                if counter > max_counter\
    \ {\n                    max_counter = counter;\n                }\n         \
    \   }\n            max_counter\n        })\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n        .map(|group|\
    \ {\n            let mut max_depth = 0;\n            let mut depth = 0;\n    \
    \        for ch in group.chars() {\n                match ch {\n             \
    \       '(' => {\n                        depth += 1;\n                      \
    \  if depth > max_depth {\n                            max_depth = depth;\n  \
    \                      }\n                    }\n                    ')' => depth\
    \ -= 1,\n                    _ => (),\n                }\n            }\n    \
    \        max_depth\n        })\n        .collect()\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let nested_parens = paren_string.split_whitespace();\n\
    \    let mut result = Vec::new();\n    for parens in nested_parens {\n       \
    \ let mut num_nested = 0;\n        let mut max_nested = 0;\n        for c in parens.chars()\
    \ {\n            if c == '(' {\n                num_nested += 1;\n           \
    \ } else if c == ')' {\n                num_nested -= 1;\n            }\n    \
    \        if num_nested > max_nested {\n                max_nested = num_nested;\n\
    \            }\n        }\n        result.push(max_nested);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n    let mut max_depth: Vec<isize> = Vec::new();\n    let mut\
    \ current_depth: isize = 0;\n    let mut max_level: isize = 0;\n    for char in\
    \ paren_string.chars() {\n        match char {\n            '(' => {\n       \
    \         current_depth += 1;\n                if current_depth > max_level {\n\
    \                    max_level = current_depth;\n                }\n         \
    \   }\n            ')' => {\n                current_depth -= 1;\n           \
    \ }\n            ' ' => {\n                max_depth.push(max_level);\n      \
    \          max_level = 0;\n                current_depth = 0;\n            }\n\
    \            _ => {}\n        }\n    }\n    max_depth.push(max_level);\n    max_depth\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
