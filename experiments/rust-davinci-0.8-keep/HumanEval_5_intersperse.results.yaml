name: HumanEval_5_intersperse
language: rust
results:
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for i in 0..numbers.len()\
    \ {\n        result.push(numbers[i]);\n        if i != numbers.len() - 1 {\n \
    \           result.push(delimeter);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    if numbers.len() == 0 {\n        return numbers;\n\
    \    }\n    let mut result = Vec::new();\n    result.push(numbers[0]);\n    for\
    \ i in numbers.iter().skip(1) {\n        result.push(delimeter);\n        result.push(*i);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    if numbers.len()\
    \ > 0 {\n        result.push(numbers[0]);\n        for num in numbers.iter().skip(1)\
    \ {\n            result.push(delimeter);\n            result.push(*num);\n   \
    \     }\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    if numbers.len() <= 1 {\n        return numbers;\n\
    \    }\n    let mut result = vec![];\n    let mut previous = *numbers.first().unwrap();\n\
    \    result.push(previous);\n    for i in numbers.iter().skip(1) {\n        result.push(delimeter);\n\
    \        result.push(*i);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    // Uncomment the following line when your function\
    \ is done\n    // numbers.into_iter().flat_map(|n| vec![n, delimeter]).collect()\n\
    \    vec![]\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmp_a8vqv3d.rs:15:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for (i, n) in\
    \ numbers.iter().enumerate() {\n        result.push(*n);\n        if i != numbers.len()\
    \ - 1 {\n            result.push(delimeter);\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    if numbers.len() == 0 {\n        return vec![];\n\
    \    }\n    let mut res = vec![numbers[0]];\n    for i in 1..numbers.len() {\n\
    \        res.push(delimeter);\n        res.push(numbers[i]);\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for i in 0..numbers.len()\
    \ {\n        result.push(numbers[i]);\n        if i != numbers.len() - 1 {\n \
    \           result.push(delimeter);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    // TODO: implement this function\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpwqr46amo.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut answer = Vec::new();\n    for (i, num) in\
    \ numbers.iter().enumerate() {\n        answer.push(*num);\n        if i != numbers.len()\
    \ - 1 {\n            answer.push(delimeter);\n        }\n    }\n    answer\n}\n\
    \nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut ret = Vec::new();\n    for (i, x) in numbers.iter().enumerate()\
    \ {\n        ret.push(*x);\n        if i < numbers.len() - 1 {\n            ret.push(delimeter);\n\
    \        }\n    }\n    ret\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for idx in 0..numbers.len()\
    \ {\n        if idx != 0 {\n            result.push(delimeter);\n        }\n \
    \       result.push(numbers[idx]);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut v = Vec::new();\n    for num in numbers\
    \ {\n        v.push(num);\n        v.push(delimeter);\n    }\n    v.pop();\n \
    \   v\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    if numbers.len() < 2 {\n        return numbers;\n\
    \    }\n    let mut answer = Vec::new();\n    for (i, v) in numbers.iter().enumerate()\
    \ {\n        answer.push(*v);\n        if i != numbers.len() - 1 {\n         \
    \   answer.push(delimeter);\n        }\n    }\n    answer\n}\n\nfn main() {\n\
    \    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    if numbers.len() < 2 {\n        return numbers;\n\
    \    }\n    let mut result = Vec::new();\n    let mut iter = numbers.iter();\n\
    \    let first = iter.next().unwrap();\n    let second = iter.next().unwrap();\n\
    \    result.push(*first);\n    result.push(delimeter);\n    result.push(*second);\n\
    \    for n in iter {\n        result.push(delimeter);\n        result.push(*n);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp2uxrec0x.rs:7:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    if numbers.len() <= 1 {\n        return numbers;\n\
    \    }\n\n    let mut result = Vec::new();\n    let mut index = 0;\n    let list_len\
    \ = numbers.len();\n    while index < list_len {\n        result.push(numbers[index]);\n\
    \        if index < list_len - 1 {\n            result.push(delimeter);\n    \
    \    }\n        index += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    if numbers.len() < 2 {\n        return numbers;\n\
    \    }\n    let mut result = Vec::with_capacity(numbers.len() * 2 - 1);\n    for\
    \ i in 0..numbers.len() - 1 {\n        result.push(numbers[i]);\n        result.push(delimeter);\n\
    \    }\n    result.push(numbers[numbers.len() - 1]);\n    result\n}\n\nfn main()\
    \ {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for num in numbers\
    \ {\n        result.push(num);\n        result.push(delimeter);\n    }\n    result.pop();\n\
    \    result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut rv = Vec::new();\n    if numbers.len() ==\
    \ 0 {\n        return rv;\n    }\n    let mut first = true;\n    for n in numbers\
    \ {\n        if first {\n            first = false;\n        } else {\n      \
    \      rv.push(delimeter);\n        }\n        rv.push(n);\n    }\n    rv\n}\n\
    \nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut ret = Vec::new();\n    let mut cur = 0;\n\
    \    while cur < numbers.len() {\n        ret.push(numbers[cur]);\n        if\
    \ cur != numbers.len() - 1 {\n            ret.push(delimeter);\n        }\n  \
    \      cur += 1;\n    }\n    ret\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    numbers.iter().enumerate().flat_map(|(i, x)| {\n\
    \        if i == 0 {\n            vec![*x]\n        } else {\n            vec![delimeter,\
    \ *x]\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut interspersed: Vec<isize> = Vec::new();\n\
    \    if numbers.len() > 0 {\n        for n in numbers.iter() {\n            interspersed.push(*n);\n\
    \            interspersed.push(delimeter);\n        }\n        interspersed.pop();\n\
    \    }\n    interspersed\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut ret = Vec::new();\n    if numbers.len()\
    \ == 0 {\n        return ret;\n    }\n    ret.push(numbers[0]);\n    for i in\
    \ 1..numbers.len() {\n        ret.push(delimeter);\n        ret.push(numbers[i]);\n\
    \    }\n    ret\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut res = Vec::new();\n    for i in 0..numbers.len()\
    \ - 1 {\n        res.push(numbers[i]);\n        res.push(delimeter);\n    }\n\
    \    res.push(numbers[numbers.len() - 1]);\n    res\n}\n\nfn main() {\n    let\
    \ candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmptbcd_6wl.rs:8:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for i in 0..numbers.len()\
    \ - 1 {\n        result.push(numbers[i]);\n        result.push(delimeter);\n \
    \   }\n    result.push(numbers[numbers.len() - 1]);\n    result\n}\n\nfn main()\
    \ {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmprxbjdor7.rs:8:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    if numbers.len() <= 1 {\n        return numbers;\n\
    \    }\n    let mut ret = vec![numbers[0]];\n    for i in 1..numbers.len() {\n\
    \        ret.push(delimeter);\n        ret.push(numbers[i]);\n    }\n    ret\n\
    }\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::<isize>::new();\n    let mut\
    \ number_iter = numbers.iter();\n    if let Some(n) = number_iter.next() {\n \
    \       result.push(*n);\n        for n in number_iter {\n            result.push(delimeter);\n\
    \            result.push(*n);\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for (i, val) in\
    \ numbers.iter().enumerate() {\n        result.push(*val);\n        if i < numbers.len()\
    \ - 1 {\n            result.push(delimeter);\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for number in\
    \ numbers {\n        result.push(number);\n        result.push(delimeter);\n \
    \   }\n    result.pop();\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    if numbers.len()\
    \ == 0 {\n        return result;\n    }\n\n    result.push(numbers[0]);\n    for\
    \ i in 1..numbers.len() {\n        result.push(delimeter);\n        result.push(numbers[i]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    if !numbers.is_empty()\
    \ {\n        let mut it = numbers.iter();\n        result.push(*it.next().unwrap());\n\
    \        for number in it {\n            result.push(delimeter);\n           \
    \ result.push(*number);\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut interspersed = Vec::new();\n    for i in\
    \ 0..numbers.len() {\n        interspersed.push(numbers[i]);\n        if i !=\
    \ numbers.len() - 1 {\n            interspersed.push(delimeter);\n        }\n\
    \    }\n    interspersed\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut res = Vec::new();\n    for i in 0..numbers.len()\
    \ {\n        res.push(numbers[i]);\n        if i != numbers.len() - 1 {\n    \
    \        res.push(delimeter);\n        }\n    }\n    res\n}\n\nfn main() {\n \
    \   let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    if numbers.len() <= 1 {\n        return numbers;\n\
    \    }\n    let mut ret = Vec::new();\n    for num in numbers {\n        ret.push(num);\n\
    \        ret.push(delimeter);\n    }\n    ret.pop();\n    ret\n}\n\nfn main()\
    \ {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    if numbers.len() < 2 {\n        return numbers;\n\
    \    }\n    let mut it = numbers.iter();\n    let mut result = vec![*it.next().unwrap()];\n\
    \    for number in it {\n        result.push(delimeter);\n        result.push(*number);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut res = Vec::new();\n    for i in 0..numbers.len()\
    \ {\n        res.push(numbers[i]);\n        if i < numbers.len() - 1 {\n     \
    \       res.push(delimeter);\n        }\n    }\n    res\n}\n\nfn main() {\n  \
    \  let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    // An empty list has no interspersed numbers\n \
    \   if numbers.len() == 0 {\n        return numbers;\n    }\n\n    // The first\
    \ element is not interspersed with anything, so we put it into the result and\
    \ ignore it in the recursion\n    let mut result = vec![numbers[0]];\n\n    //\
    \ Call recursively over each element pair\n    for i in 1..numbers.len() {\n \
    \       result.extend(intersperse_pair(numbers[i - 1], numbers[i], delimeter));\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2,\
    \ 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `intersperse_pair` in this scope\n \
    \ --> /tmp/tmp_l01et0k.rs:17:23\n   |\n17 |         result.extend(intersperse_pair(numbers[i\
    \ - 1], numbers[i], delimeter));\n   |                       ^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut list = vec![];\n    let mut iter = numbers.iter();\n\
    \    if let Some(element) = iter.next() {\n        list.push(*element);\n    \
    \    for next in iter {\n            list.push(delimeter);\n            list.push(*next);\n\
    \        }\n    }\n    list\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    if !numbers.is_empty()\
    \ {\n        result.push(numbers[0]);\n        for n in numbers.iter().skip(1)\
    \ {\n            result.push(delimeter);\n            result.push(*n);\n     \
    \   }\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for i in 0..numbers.len()\
    \ {\n        if i != 0 {\n            result.push(delimeter);\n        }\n   \
    \     result.push(numbers[i]);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n  match numbers.len() {\n    0 => Vec::new(),\n    1\
    \ => numbers,\n    _ => {\n      let mut ret = Vec::new();\n      for (i, elem)\
    \ in numbers.iter().enumerate() {\n        ret.push(*elem);\n        if i < numbers.len()\
    \ - 1 {\n          ret.push(delimeter);\n        }\n      }\n      ret\n    }\n\
    \  }\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut list = Vec::new();\n    for e in numbers\
    \ {\n        list.push(e);\n        list.push(delimeter);\n    }\n    list.pop();\n\
    \    list\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::<isize>::new();\n    let n\
    \ = numbers.len();\n    for (i, num) in numbers.iter().enumerate() {\n       \
    \ result.push(*num);\n        if i < n - 1 {\n            result.push(delimeter);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut output: Vec<isize> = Vec::new();\n    for\
    \ num in numbers {\n        if output.len() > 0 {\n            output.push(delimeter);\n\
    \        }\n        output.push(num);\n    }\n    output\n}\n\nfn main() {\n \
    \   let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut numbers_iter = numbers.iter();\n    let\
    \ mut result = Vec::new();\n    match numbers_iter.next() {\n        Some(x) =>\
    \ {\n            result.push(*x);\n            for n in numbers_iter {\n     \
    \           result.push(delimeter);\n                result.push(*n);\n      \
    \      }\n        }\n        None => {}\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for (i, &n) in\
    \ numbers.iter().enumerate() {\n        result.push(n);\n        if i != numbers.len()\
    \ - 1 {\n            result.push(delimeter);\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut numbers\
    \ = numbers.into_iter();\n    if let Some(n) = numbers.next() {\n        result.push(n);\n\
    \        for n in numbers {\n            result.push(delimeter);\n           \
    \ result.push(n);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut numbers = numbers;\n    numbers.reverse();\n\
    \    let mut list = vec![];\n    loop {\n        match numbers.pop() {\n     \
    \       Some(n) => {\n                list.push(n);\n                list.push(delimeter);\n\
    \            }\n            None => break,\n        }\n    }\n    list.pop();\n\
    \    list\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    numbers.into_iter().fold(Vec::new(), |mut acc, x|\
    \ {\n        if !acc.is_empty() {\n            acc.push(delimeter);\n        }\n\
    \        acc.push(x);\n        acc\n    })\n}\n\nfn main() {\n    let candidate\
    \ = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for (i, &num)\
    \ in numbers.iter().enumerate() {\n        result.push(num);\n        if i !=\
    \ numbers.len() - 1 {\n            result.push(delimeter);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for i in 0..numbers.len()\
    \ {\n        result.push(numbers[i]);\n        if i < numbers.len() - 1 {\n  \
    \          result.push(delimeter);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    numbers.clone().into_iter().flat_map(|n| vec![n,\
    \ delimeter]).collect()\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 8, 6, 8, 3, 8, 2, 8]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmpc7ky0tcn.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    numbers.iter().map(|x| vec![*x, delimeter]).flatten().collect()\n\
    }\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 8, 6, 8, 3, 8, 2, 8]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmpv4d4ezm_.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut interpersed = Vec::new();\n    let mut i\
    \ = 0;\n    while i < numbers.len() {\n        interpersed.push(numbers[i]);\n\
    \        if i + 1 < numbers.len() {\n            interpersed.push(delimeter);\n\
    \        }\n        i += 1;\n    }\n    interpersed\n}\n\nfn main() {\n    let\
    \ candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    numbers.into_iter().fold(vec![], |mut acc, n| {\n\
    \        acc.push(n);\n        acc.push(delimeter);\n        acc\n    })\n}\n\n\
    fn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 8, 6, 8, 3, 8, 2, 8]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmpbc3ypdew.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut iter =\
    \ numbers.iter();\n    while let Some(number) = iter.next() {\n        result.push(*number);\n\
    \        if let Some(_) = iter.next() {\n            result.push(delimeter);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 8, 3, 8]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmpld20feon.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    if numbers.len() < 2 {\n        return numbers;\n\
    \    }\n    let mut numbers = numbers;\n    let delimeter = vec![delimeter];\n\
    \    numbers.extend(delimeter);\n    numbers.windows(3).flat_map(|window| {\n\
    \        if window[1] == delimeter {\n            vec![window[0], window[2]]\n\
    \        } else {\n            vec![window[0], window[1]]\n        }\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuxzuousl.rs:14:25\n   |\n\
    14 |         if window[1] == delimeter {\n   |                         ^^^^^^^^^\
    \ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n\
    \            found struct `Vec<isize>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for number in\
    \ numbers {\n        result.push(number);\n        result.push(delimeter);\n \
    \   }\n    result.pop();\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    if numbers.len() < 2 {\n        return numbers;\n\
    \    }\n    let mut result = Vec::new();\n    for i in 0..numbers.len() - 1 {\n\
    \        result.push(numbers[i]);\n        result.push(delimeter);\n    }\n  \
    \  result.push(numbers[numbers.len() - 1]);\n    result\n}\n\nfn main() {\n  \
    \  let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    if numbers.len()\
    \ >= 2 {\n        for i in 0..numbers.len() - 1 {\n            result.push(numbers[i]);\n\
    \            result.push(delimeter);\n        }\n        result.push(numbers[numbers.len()\
    \ - 1]);\n    } else if numbers.len() == 1 {\n        result.push(numbers[0]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    match numbers.len() {\n        0 => numbers,\n \
    \       1 => numbers,\n        _ => {\n            let mut result = Vec::with_capacity(numbers.len()\
    \ * 2 - 1);\n            for i in 0..numbers.len() - 1 {\n                result.push(numbers[i]);\n\
    \                result.push(delimeter);\n            }\n            result.push(numbers[numbers.len()\
    \ - 1]);\n            result\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut is_first\
    \ = true;\n    for n in numbers {\n        if is_first {\n            is_first\
    \ = false;\n        } else {\n            result.push(delimeter);\n        }\n\
    \        result.push(n);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for number in\
    \ numbers {\n        result.push(number);\n        result.push(delimeter);\n \
    \   }\n    result.pop();\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let res = numbers.into_iter().flat_map(|x| vec![x,\
    \ delimeter]).collect::<Vec<isize>>();\n    res[..res.len() - 1].to_vec()\n}\n\
    \nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpnk2064mn.rs:8:11\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut was_first\
    \ = true;\n    for num in numbers {\n        if !was_first {\n            result.push(delimeter);\n\
    \        }\n        result.push(num);\n        was_first = false;\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut out = Vec::new();\n    for (i, n) in numbers.iter().enumerate()\
    \ {\n        out.push(*n);\n        if i < numbers.len() - 1 {\n            out.push(delimeter);\n\
    \        }\n    }\n    out\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    // TODO\n    vec![]\n}\n\nfn main() {\n    let candidate\
    \ = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmp0vo__qry.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    if numbers.len() < 2 {\n        return numbers;\n\
    \    }\n    let mut result = Vec::new();\n    for i in 0..numbers.len() - 1 {\n\
    \        result.push(numbers[i]);\n        result.push(delimeter);\n    }\n  \
    \  result.push(numbers[numbers.len() - 1]);\n    result\n}\n\nfn main() {\n  \
    \  let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    // TODO: Implement this function\n    let mut x\
    \ = Vec::new();\n    for i in numbers {\n        x.push(i);\n        x.push(delimeter);\n\
    \    }\n    x.pop();\n    x\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    if numbers.len() <= 1 {\n        return numbers;\n\
    \    }\n    let mut new_list = vec![numbers[0]];\n    for num in numbers.iter().skip(1)\
    \ {\n        new_list.push(delimeter);\n        new_list.push(*num);\n    }\n\
    \    new_list\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    if numbers.len() == 0 {\n        return vec![];\n\
    \    }\n    let mut result = vec![numbers[0]];\n    for i in 1..numbers.len()\
    \ {\n        result.push(delimeter);\n        result.push(numbers[i]);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut acc = Vec::new();\n    for i in numbers\
    \ {\n        acc.push(i);\n        acc.push(delimeter);\n    }\n    acc.pop();\n\
    \    acc\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    // TODO\n    let mut v: Vec<isize> = Vec::new();\n\
    \    if numbers.len() <= 1 {\n        return numbers;\n    } else {\n        for\
    \ n in numbers.iter() {\n            v.push(*n);\n            v.push(delimeter);\n\
    \        }\n        v.pop();\n        return v;\n    }\n}\n\nfn main() {\n   \
    \ let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for i in numbers\
    \ {\n        result.push(i);\n        result.push(delimeter);\n    }\n    result.pop();\n\
    \    result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for i in 0..numbers.len()\
    \ {\n        result.push(numbers[i]);\n        if i != numbers.len() - 1 {\n \
    \           result.push(delimeter);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    if numbers.len() == 0 {\n        return numbers;\n\
    \    }\n    let mut res = vec![];\n    for i in 0..numbers.len() - 1 {\n     \
    \   res.push(numbers[i]);\n        res.push(delimeter);\n    }\n    res.push(numbers[numbers.len()\
    \ - 1]);\n    res\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut first\
    \ = true;\n    for number in numbers {\n        if first {\n            first\
    \ = false;\n        } else {\n            result.push(delimeter);\n        }\n\
    \        result.push(number);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    if numbers.len() < 2 {\n        return numbers;\n\
    \    }\n    let mut ret = vec![];\n    let mut index = 0;\n    while index < numbers.len()\
    \ - 1 {\n        ret.push(numbers[index]);\n        ret.push(delimeter);\n   \
    \     index += 1;\n    }\n    ret.push(numbers[index]);\n    ret\n}\n\nfn main()\
    \ {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut it = numbers.iter();\n\
    \    if let Some(first) = it.next() {\n        result.push(*first);\n        for\
    \ number in it {\n            result.push(delimeter);\n            result.push(*number);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    if numbers.len() == 0 {\n        return vec![];\n\
    \    }\n    let mut result = vec![numbers[0]];\n    for i in 1..numbers.len()\
    \ {\n        result.push(delimeter);\n        result.push(numbers[i]);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for (i, num) in\
    \ numbers.iter().enumerate() {\n        result.push(*num);\n        if i != numbers.len()\
    \ - 1 {\n            result.push(delimeter);\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    numbers.iter().enumerate().flat_map(|(i, &x)| {\n\
    \        if i == 0 {\n            vec![x]\n        } else {\n            vec![delimeter,\
    \ x]\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    numbers.into_iter().flat_map(|n| vec![n, delimeter]).collect()\n\
    }\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 8, 6, 8, 3, 8, 2, 8]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmpr8jtdiir.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut list_iter\
    \ = numbers.iter();\n    if let Some(first) = list_iter.next() {\n        result.push(*first);\n\
    \        for item in list_iter {\n            result.push(delimeter);\n      \
    \      result.push(*item);\n        }\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    if numbers.len() == 0 {\n        return numbers;\n\
    \    }\n    let mut result = vec![numbers[0]];\n    for i in numbers.iter().skip(1)\
    \ {\n        result.push(delimeter);\n        result.push(*i);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    // TODO: Implement intersperse()\n    numbers\n\
    }\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 6, 3, 2]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmp55qlpy_0.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    if numbers.len()\
    \ > 0 {\n        result.push(numbers[0]);\n        for i in 1..numbers.len() {\n\
    \            result.push(delimeter);\n            result.push(numbers[i]);\n \
    \       }\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut res = Vec::new();\n    let mut iter = numbers.iter();\n\
    \    if let Some(n) = iter.next() {\n        res.push(*n);\n        for n in iter\
    \ {\n            res.push(delimeter);\n            res.push(*n);\n        }\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    if numbers.len() <= 1 {\n        return numbers;\n\
    \    }\n    let mut new_list = vec![numbers[0]];\n    for i in 1..numbers.len()\
    \ {\n        new_list.push(delimeter);\n        new_list.push(numbers[i]);\n \
    \   }\n    new_list\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for (i, number)\
    \ in numbers.iter().enumerate() {\n        result.push(*number);\n        if i\
    \ < numbers.len() - 1 {\n            result.push(delimeter);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for (i, elem)\
    \ in numbers.iter().enumerate() {\n        result.push(*elem);\n        if i !=\
    \ numbers.len() - 1 {\n            result.push(delimeter);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut index\
    \ = 0;\n    while index < numbers.len() {\n        result.push(numbers[index]);\n\
    \        if index != numbers.len() - 1 {\n            result.push(delimeter);\n\
    \        }\n        index += 1;\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for (i, n) in\
    \ numbers.iter().enumerate() {\n        result.push(*n);\n        if i < numbers.len()\
    \ - 1 {\n            result.push(delimeter);\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut it = numbers.iter();\n\
    \    match it.next() {\n        Some(n) => {\n            result.push(*n);\n \
    \           for n in it {\n                result.push(delimeter);\n         \
    \       result.push(*n);\n            }\n        }\n        None => (),\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut ret = Vec::new();\n    let mut iter = numbers.iter();\n\
    \    if let Some(elem) = iter.next() {\n        ret.push(*elem);\n        for\
    \ elem in iter {\n            ret.push(delimeter);\n            ret.push(*elem);\n\
    \        }\n    }\n    ret\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut prev =\
    \ numbers[0];\n    result.push(prev);\n    for i in 1..numbers.len() {\n     \
    \   result.push(delimeter);\n        result.push(numbers[i]);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmptq7tkbzk.rs:8:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for i in 0..numbers.len()\
    \ {\n        if i != 0 {\n            result.push(delimeter);\n        }\n   \
    \     result.push(numbers[i]);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut first\
    \ = true;\n    for number in numbers {\n        if first {\n            first\
    \ = false;\n        } else {\n            result.push(delimeter);\n        }\n\
    \        result.push(number);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for (i, n) in\
    \ numbers.iter().enumerate() {\n        result.push(*n);\n        if i != numbers.len()\
    \ - 1 {\n            result.push(delimeter);\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    if numbers.len()\
    \ == 0 {\n        return result;\n    }\n    result.push(numbers[0]);\n    for\
    \ i in 1..numbers.len() {\n        result.push(delimeter);\n        result.push(numbers[i]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    if numbers.len()\
    \ == 0 {\n        return result;\n    }\n    let mut iter = numbers.iter();\n\
    \    result.push(*iter.next().unwrap());\n    while let Some(v) = iter.next()\
    \ {\n        result.push(delimeter);\n        result.push(*v);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for i in 0..numbers.len()\
    \ {\n        result.push(numbers[i]);\n        if i != numbers.len() - 1 {\n \
    \           result.push(delimeter);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    if numbers.len() < 2 {\n        return numbers;\n\
    \    }\n    let mut result = vec![numbers[0]];\n    for i in 1..numbers.len()\
    \ {\n        result.push(delimeter);\n        result.push(numbers[i]);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmplh0cs0vc.rs:7:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    if numbers.len() < 2 {\n        return numbers;\n\
    \    }\n    let mut result = Vec::new();\n    for n in numbers {\n        result.push(n);\n\
    \        result.push(delimeter);\n    }\n    result.pop();\n    result\n}\n\n\
    fn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    match numbers.len() {\n        0 => vec![],\n  \
    \      1 => numbers,\n        _ => {\n            let mut output: Vec<isize> =\
    \ Vec::new();\n            for (i, n) in numbers.iter().enumerate() {\n      \
    \          output.push(*n);\n                if i < numbers.len() - 1 {\n    \
    \                output.push(delimeter);\n                }\n            }\n \
    \           output\n        }\n    }\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n  let mut result = Vec::<isize>::new();\n  for i in\
    \ 0..numbers.len() {\n    if i != 0 {\n      result.push(delimeter);\n    }\n\
    \    result.push(numbers[i]);\n  }\n  result\n}\n\nfn main() {\n    let candidate\
    \ = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut i = 0;\n\
    \    while i < numbers.len() {\n        result.push(numbers[i]);\n        if i\
    \ < numbers.len() - 1 {\n            result.push(delimeter);\n        }\n    \
    \    i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    if numbers.len() == 0 {\n        return numbers;\n\
    \    }\n    let mut ret = vec![numbers[0]];\n    for i in 1..numbers.len() {\n\
    \        ret.push(delimeter);\n        ret.push(numbers[i]);\n    }\n    ret\n\
    }\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    // YOUR CODE HERE\n    Vec::new()\n}\n\nfn main()\
    \ {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmpg74s7_62.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    // Can't use '_' in pattern matching!\n    // https://doc.rust-lang.org/book/error-handling.html#pattern-syntax\n\
    \    match numbers.len() {\n        0 => Vec::new(),\n        1 => numbers,\n\
    \        _ => {\n            let mut new_list = vec![numbers[0]];\n          \
    \  let mut i = 1;\n            while i < numbers.len() {\n                new_list.push(delimeter);\n\
    \                new_list.push(numbers[i]);\n                i += 1;\n       \
    \     }\n            new_list\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for (i, number)\
    \ in numbers.iter().enumerate() {\n        result.push(*number);\n        if i\
    \ != numbers.len() - 1 {\n            result.push(delimeter);\n        }\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::<isize>::new();\n    for number\
    \ in numbers {\n        result.push(number);\n        result.push(delimeter);\n\
    \    }\n    result.pop();\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    if numbers.len() <= 1 {\n        return numbers;\n\
    \    }\n    let mut ret: Vec<isize> = Vec::new();\n    let mut second_pass = false;\n\
    \    for i in numbers {\n        if second_pass {\n            ret.push(delimeter);\n\
    \        }\n        ret.push(i);\n        second_pass = true;\n    }\n    ret\n\
    }\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    numbers.windows(2).flat_map(|[x, y]| vec![x, delimeter]).chain(numbers.last()).collect()\n\
    }\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpiqbr9q0m.rs:7:50\n  |\n7 |\
    \     numbers.windows(2).flat_map(|[x, y]| vec![x, delimeter]).chain(numbers.last()).collect()\n\
    \  |                                                  ^^^^^^^^^ expected `&isize`,\
    \ found `isize`\n\nerror[E0277]: a value of type `Vec<isize>` cannot be built\
    \ from an iterator over elements of type `&isize`\n    --> /tmp/tmpiqbr9q0m.rs:7:84\n\
    \     |\n7    |     numbers.windows(2).flat_map(|[x, y]| vec![x, delimeter]).chain(numbers.last()).collect()\n\
    \     |                                                                      \
    \              ^^^^^^^ value of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=&isize>`\n\
    \     |\n     = help: the trait `FromIterator<&isize>` is not implemented for\
    \ `Vec<isize>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut res = Vec::new();\n    if numbers.len()\
    \ > 0 {\n        for i in 0..numbers.len()-1 {\n            res.push(numbers[i]);\n\
    \            res.push(delimeter);\n        }\n        res.push(numbers[numbers.len()-1]);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut res = Vec::new();\n    for i in 0..numbers.len()\
    \ {\n        res.push(numbers[i]);\n        if i != numbers.len() - 1 {\n    \
    \        res.push(delimeter);\n        }\n    }\n    res\n}\n\nfn main() {\n \
    \   let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for i in 0..numbers.len()\
    \ {\n        result.push(numbers[i]);\n        if i != numbers.len() - 1 {\n \
    \           result.push(delimeter);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for i in numbers\
    \ {\n        if !result.is_empty() {\n            result.push(delimeter);\n  \
    \      }\n        result.push(i);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    if numbers.len() < 2 {\n        return numbers;\n\
    \    }\n\n    let mut result = Vec::with_capacity(numbers.len() * 2 - 1);\n  \
    \  for (i, &number) in numbers.iter().enumerate() {\n        result.push(number);\n\
    \        if i < numbers.len() - 1 {\n            result.push(delimeter);\n   \
    \     }\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    numbers.windows(2).flat_map(|w| vec![w[0], delimeter]).collect()\n\
    }\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 8, 6, 8, 3, 8]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmp3zkhop1d.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut ret = Vec::new();\n    for (i, num) in numbers.iter().enumerate()\
    \ {\n        ret.push(*num);\n        if i < numbers.len() - 1 {\n           \
    \ ret.push(delimeter);\n        }\n    }\n    ret\n}\n\nfn main() {\n    let candidate\
    \ = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut first\
    \ = true;\n    for num in numbers {\n        if first {\n            first = false;\n\
    \        } else {\n            result.push(delimeter);\n        }\n        result.push(num);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut res = Vec::new();\n    for i in 0..numbers.len()\
    \ {\n        res.push(numbers[i]);\n        if i < numbers.len() - 1 {\n     \
    \       res.push(delimeter);\n        }\n    }\n    res\n}\n\nfn main() {\n  \
    \  let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for i in 0..numbers.len()\
    \ {\n        result.push(numbers[i]);\n        if i + 1 < numbers.len() {\n  \
    \          result.push(delimeter);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut ret = vec![];\n    for i in 0..numbers.len()\
    \ {\n        ret.push(numbers[i]);\n        if i != numbers.len() - 1 {\n    \
    \        ret.push(delimeter);\n        }\n    }\n    ret\n}\n\nfn main() {\n \
    \   let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    // TODO\n    vec![]\n}\n\nfn main() {\n    let candidate\
    \ = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmpjcjrydwx.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    if numbers.len() <= 1 {\n        return numbers;\n\
    \    }\n    let mut result = vec![];\n    for i in 0..numbers.len() {\n      \
    \  result.push(numbers[i]);\n        if i < numbers.len() - 1 {\n            result.push(delimeter);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut it = numbers.iter();\n\
    \    loop {\n        match it.next() {\n            Some(x) => {\n           \
    \     result.push(*x);\n                match it.next() {\n                  \
    \  Some(y) => {\n                        result.push(delimeter);\n           \
    \             result.push(*y);\n                    }\n                    None\
    \ => break,\n                }\n            }\n            None => break,\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 8, 6, 3, 8, 2]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmpov7h72ww.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    // `fold_left` will start from left side of the\
    \ list and go to the right,\n    // so we insert the delimeter in the reversed\
    \ order.\n    // And then we need to reverse the result to have a correct order.\n\
    \    numbers.iter().rev().fold(vec![], |mut result, n| {\n        result.push(delimeter);\n\
    \        result.push(*n);\n        result\n    }).iter().rev().map(|&x| x).collect()\n\
    }\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 8, 6, 8, 3, 8, 2, 8]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmp3u0024a1.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    if numbers.len()\
    \ > 0 {\n        result.push(numbers[0]);\n        for i in 1..numbers.len() {\n\
    \            result.push(delimeter);\n            result.push(numbers[i]);\n \
    \       }\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    fn intersperse_worker(result: Vec<isize>, rest:\
    \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n        if rest.is_empty() {\n\
    \            result\n        } else {\n            let mut result = result;\n\
    \            let mut rest = rest;\n            let item = rest.remove(0);\n  \
    \          result.push(item);\n            result.push(delimeter);\n         \
    \   intersperse_worker(result, rest, delimeter)\n        }\n    }\n    let mut\
    \ rest = numbers;\n    rest.remove(0);\n    intersperse_worker(vec![numbers[0]],\
    \ rest, delimeter)\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `numbers`\n  --> /tmp/tmpr4e0bvch.rs:21:29\n\
    \   |\n6  | fn intersperse(numbers: Vec<isize>, delimeter: isize) -> Vec<isize>\
    \ {\n   |                ------- move occurs because `numbers` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trait\n...\n19 |     let mut rest = numbers;\n\
    \   |                    ------- value moved here\n20 |     rest.remove(0);\n\
    21 |     intersperse_worker(vec![numbers[0]], rest, delimeter)\n   |         \
    \                    ^^^^^^^ value borrowed here after move\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    if numbers.len() == 0 {\n        return numbers;\n\
    \    }\n\n    let mut result = vec![numbers[0]];\n    for number in numbers[1..].iter()\
    \ {\n        result.push(delimeter);\n        result.push(*number);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    numbers.into_iter().flat_map(|n| vec![n, delimeter]).collect()\n\
    }\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 8, 6, 8, 3, 8, 2, 8]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmpgkpkxy2u.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    if numbers.len() == 0 {\n        return numbers;\n\
    \    }\n    let mut result = vec![numbers[0]];\n    for i in 1..numbers.len()\
    \ {\n        result.push(delimeter);\n        result.push(numbers[i]);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for n in numbers\
    \ {\n        result.push(n);\n        result.push(delimeter);\n    }\n    result.pop();\n\
    \    result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::<isize>::new();\n    let mut\
    \ first = true;\n    for num in numbers {\n        if first {\n            first\
    \ = false;\n        } else {\n            result.push(delimeter);\n        }\n\
    \        result.push(num);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    // your code goes here\n    Vec::new()\n}\n\nfn\
    \ main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmp1r4x3ex8.rs:14:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    numbers.iter().fold(Vec::new(), |mut v, n| {\n \
    \       v.push(*n);\n        v.push(delimeter);\n        v\n    })\n}\n\nfn main()\
    \ {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 8, 6, 8, 3, 8, 2, 8]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmpnuizfs9o.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for i in numbers\
    \ {\n        if !result.is_empty() {\n            result.push(delimeter);\n  \
    \      }\n        result.push(i);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut first\
    \ = true;\n    for number in numbers {\n        if first {\n            first\
    \ = false;\n        } else {\n            result.push(delimeter);\n        }\n\
    \        result.push(number);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let len = numbers.len();\n    let mut new_list =\
    \ Vec::with_capacity(len * 2);\n    let mut i = 0;\n    while i < len {\n    \
    \    if i != 0 {\n            new_list.push(delimeter);\n        }\n        new_list.push(numbers[i]);\n\
    \        i += 1;\n    }\n    new_list\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for n in numbers\
    \ {\n        if !result.is_empty() {\n            result.push(delimeter);\n  \
    \      }\n        result.push(n);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for (idx, number)\
    \ in numbers.iter().enumerate() {\n        result.push(*number);\n        if idx\
    \ != numbers.len() - 1 {\n            result.push(delimeter);\n        }\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for number in\
    \ numbers {\n        result.push(number);\n        result.push(delimeter);\n \
    \   }\n    result.pop();\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut res = Vec::new();\n    for i in 0..numbers.len()\
    \ {\n        res.push(numbers[i]);\n        if i != numbers.len() - 1 {\n    \
    \        res.push(delimeter);\n        }\n    }\n    res\n}\n\nfn main() {\n \
    \   let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut res = Vec::new();\n    for num in numbers\
    \ {\n        res.push(num);\n        res.push(delimeter);\n    }\n    if res.len()\
    \ > 0 {\n        res.pop();\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for i in 0..numbers.len()\
    \ {\n        result.push(numbers[i]);\n        if i < numbers.len() - 1 {\n  \
    \          result.push(delimeter);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut iter =\
    \ numbers.iter();\n    while let Some(n) = iter.next() {\n        result.push(*n);\n\
    \        if let Some(m) = iter.next() {\n            result.push(delimeter);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 8, 3, 8]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmp4d2zp25e.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    if numbers.len() == 0 {\n        return numbers;\n\
    \    }\n    let mut result = Vec::new();\n    for i in 0..numbers.len() - 1 {\n\
    \        result.push(numbers[i]);\n        result.push(delimeter);\n    }\n  \
    \  result.push(numbers[numbers.len() - 1]);\n    result\n}\n\nfn main() {\n  \
    \  let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut numbers = numbers;\n    numbers.insert(1,\
    \ delimeter);\n    numbers\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'insertion index (is 1) should be <= len (is\
    \ 0)', library/alloc/src/vec/mod.rs:1347:13\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    // acc is an acccumulator which contains the elements\
    \ of the returning list\n    let mut acc = Vec::new();\n    // iterate through\
    \ the input vector and assign each element to `x'\n    for x in numbers {\n  \
    \      // push the element `x' into `acc'\n        acc.push(x);\n        // push\
    \ the delimeter into `acc' if `x' is not the last element of `numbers'\n     \
    \   if numbers.last() != Some(&x) {\n            acc.push(delimeter);\n      \
    \  }\n    }\n    // return the acccumulator\n    acc\n}\n\nfn main() {\n    let\
    \ candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `numbers`\n   --> /tmp/tmpaacacw6u.rs:14:12\n\
    \    |\n6   | fn intersperse(numbers: Vec<isize>, delimeter: isize) -> Vec<isize>\
    \ {\n    |                ------- move occurs because `numbers` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trait\n...\n10  |     for x in numbers {\n\
    \    |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    ...\n14  |         if numbers.last() != Some(&x) {\n    |            ^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `numbers`\n    = note: borrow occurs due to\
    \ deref coercion to `[isize]`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n10  |     for x in &numbers\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for i in 0..numbers.len()\
    \ - 1 {\n        result.push(numbers[i]);\n        result.push(delimeter);\n \
    \   }\n    result.push(numbers[numbers.len() - 1]);\n    result\n}\n\nfn main()\
    \ {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpcvysnk9j.rs:8:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for number in\
    \ numbers {\n        if !result.is_empty() {\n            result.push(delimeter);\n\
    \        }\n        result.push(number);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for i in 0..numbers.len()\
    \ - 1 {\n        result.push(numbers[i]);\n        result.push(delimeter);\n \
    \   }\n    result.push(numbers[numbers.len() - 1]);\n    result\n}\n\nfn main()\
    \ {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpaa3fv7bi.rs:8:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut res = Vec::new();\n    for i in 0..numbers.len()\
    \ - 1 {\n        res.push(numbers[i]);\n        res.push(delimeter);\n    }\n\
    \    res.push(numbers[numbers.len() - 1]);\n    res\n}\n\nfn main() {\n    let\
    \ candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp0poom_b9.rs:8:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    vec![]\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmpkefoibwa.rs:13:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    if numbers.len()\
    \ > 0 {\n        result.push(numbers[0]);\n        for i in 1..numbers.len() {\n\
    \            result.push(delimeter);\n            result.push(numbers[i]);\n \
    \       }\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut interspersed = vec![];\n    for &number\
    \ in numbers.iter() {\n        interspersed.push(number);\n        interspersed.push(delimeter);\n\
    \    }\n    interspersed.pop();\n    interspersed\n}\n\nfn main() {\n    let candidate\
    \ = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    let len = numbers.len();\n\
    \    if len > 0 {\n        result.push(numbers[0]);\n        for i in 1..len {\n\
    \            result.push(delimeter);\n            result.push(numbers[i]);\n \
    \       }\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    if numbers.len() < 2 {\n        return numbers;\n\
    \    }\n    let mut res = vec![numbers[0]];\n    for i in 1..numbers.len() {\n\
    \        res.push(delimeter);\n        res.push(numbers[i]);\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    // TODO\n    let len = numbers.len();\n    if len\
    \ == 0 {\n        vec![]\n    }\n    else if len == 1 {\n        numbers\n   \
    \ }\n    else {\n        let mut result = vec![numbers[0]];\n        for (i, num)\
    \ in numbers.iter().enumerate() {\n            if i != 0 {\n                result.push(delimeter);\n\
    \                result.push(*num);\n            }\n        }\n        result\n\
    \    }\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    Vec::new()\n}\n\nfn main() {\n    let candidate\
    \ = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmpvek4odqc.rs:13:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n  let mut result = vec![];\n  for (i, num) in numbers.iter().enumerate()\
    \ {\n    result.push(*num);\n    if i != numbers.len() - 1 {\n      result.push(delimeter);\n\
    \    }\n  }\n  result\n}\n\nfn main() {\n    let candidate = intersperse;\n  \
    \  assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2,\
    \ 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut new_vec = vec![];\n    for x in numbers\
    \ {\n        new_vec.push(x);\n        new_vec.push(delimeter);\n    }\n    new_vec.pop();\n\
    \    new_vec\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    if numbers.len() <= 1 {\n        return numbers;\n\
    \    }\n\n    let mut result = vec![];\n    for (idx, number) in numbers.iter().enumerate()\
    \ {\n        result.push(*number);\n        if idx < numbers.len() - 1 {\n   \
    \         result.push(delimeter);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    if numbers.len()\
    \ == 0 {\n        return result;\n    }\n    for i in 0..numbers.len() - 1 {\n\
    \        result.push(numbers[i]);\n        result.push(delimeter);\n    }\n  \
    \  result.push(numbers[numbers.len() - 1]);\n    result\n}\n\nfn main() {\n  \
    \  let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    vec![1, 4, 2, 4, 3]\n}\n\nfn main() {\n    let candidate\
    \ = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 2, 4, 3]`,\n right: `[]`', /tmp/tmpsqx9mbje.rs:12:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    if numbers.len()\
    \ == 0 {\n        return result;\n    }\n    let mut iter = numbers.iter();\n\
    \    result.push(*iter.next().unwrap());\n    for i in iter {\n        result.push(delimeter);\n\
    \        result.push(*i);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    if numbers.len()\
    \ == 0 {\n        return result;\n    }\n    result.push(numbers[0]);\n    for\
    \ i in 1..numbers.len() {\n        result.push(delimeter);\n        result.push(numbers[i]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut r = vec![];\n    let mut flag = false;\n\
    \    for &i in numbers.iter() {\n        if flag {\n            r.push(delimeter);\n\
    \        }\n        r.push(i);\n        flag = true;\n    }\n    r\n}\n\nfn main()\
    \ {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n  fn aux(num : isize, delimeter : isize, result : Vec<isize>)\
    \ -> Vec<isize> {\n    if result.len() == 0 {\n      vec![num]\n    } else {\n\
    \      let mut v = result.clone();\n      v.push(delimeter);\n      v.push(num);\n\
    \      v\n    }\n  }\n  numbers.iter().fold(vec![], |result, num| aux(*num, delimeter,\
    \ result))\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut res = Vec::new();\n    let mut iter = numbers.iter();\n\
    \    match iter.next() {\n        Some(n) => {\n            res.push(*n);\n  \
    \          for n in iter {\n                res.push(delimeter);\n           \
    \     res.push(*n);\n            }\n        }\n        None => {}\n    }\n   \
    \ res\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    // TODO\n    let mut res: Vec<isize> = Vec::new();\n\
    \    for i in 0..numbers.len() {\n        if i != numbers.len() - 1 {\n      \
    \      res.push(numbers[i]);\n            res.push(delimeter);\n        } else\
    \ {\n            res.push(numbers[i]);\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    numbers.iter().flat_map(|x| {\n        iter::once(x).chain(iter::once(&delimeter))\n\
    \    }).take(numbers.len() * 2 - 1).collect()\n}\n\nfn main() {\n    let candidate\
    \ = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `iter`\n\
    \ --> /tmp/tmpi3fuhhd_.rs:8:9\n  |\n8 |         iter::once(x).chain(iter::once(&delimeter))\n\
    \  |         ^^^^ use of undeclared crate or module `iter`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared crate or module `iter`\n --> /tmp/tmpi3fuhhd_.rs:8:29\n\
    \  |\n8 |         iter::once(x).chain(iter::once(&delimeter))\n  |           \
    \                  ^^^^ use of undeclared crate or module `iter`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut acc = vec![];\n    for i in numbers {\n\
    \        acc.push(i);\n        acc.push(delimeter);\n    }\n    if acc.len() >\
    \ 0 {\n        acc.pop();\n    }\n    acc\n}\n\nfn main() {\n    let candidate\
    \ = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut iter =\
    \ numbers.iter();\n    while let Some(elem) = iter.next() {\n        result.push(*elem);\n\
    \        if let Some(_) = iter.next() {\n            result.push(delimeter);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 8, 3, 8]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmps6q57dks.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut out: Vec<isize> = Vec::new();\n    let mut\
    \ first = true;\n    for num in numbers {\n        if first {\n            first\
    \ = false;\n        } else {\n            out.push(delimeter);\n        }\n  \
    \      out.push(num);\n    }\n    out\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut ret = Vec::<isize>::new();\n    for (i,\
    \ v) in numbers.iter().enumerate() {\n        ret.push(*v);\n        if i != numbers.len()\
    \ - 1 {\n            ret.push(delimeter);\n        }\n    }\n    ret\n}\n\nfn\
    \ main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut iter =\
    \ numbers.iter();\n    if let Some(x) = iter.next() {\n        result.push(*x);\n\
    \        for x in iter {\n            result.push(delimeter);\n            result.push(*x);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for i in 0..numbers.len()\
    \ {\n        result.push(numbers[i]);\n        if i != numbers.len() - 1 {\n \
    \           result.push(delimeter);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    if numbers.len() < 2 {\n        return numbers;\n\
    \    }\n    let mut result = vec![numbers[0]];\n    for i in 1..numbers.len()\
    \ {\n        result.push(delimeter);\n        result.push(numbers[i]);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut interspersed: Vec<isize> = Vec::new();\n\
    \    for number in numbers {\n        interspersed.push(number);\n        interspersed.push(delimeter);\n\
    \    }\n    interspersed.pop();\n    interspersed\n}\n\nfn main() {\n    let candidate\
    \ = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n\
    \    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    if numbers.len() == 0 {\n        return vec![];\n\
    \    }\n    let mut result = vec![numbers[0]];\n    for i in numbers.iter().skip(1)\
    \ {\n        result.push(delimeter);\n        result.push(*i);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for i in 0..numbers.len()\
    \ {\n        result.push(numbers[i]);\n        if i != numbers.len() - 1 {\n \
    \           result.push(delimeter);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    if numbers.len() < 2 {\n        return numbers;\n\
    \    }\n    let mut result = Vec::new();\n    for (i, n) in numbers.iter().enumerate()\
    \ {\n        result.push(*n);\n        if i < numbers.len() - 1 {\n          \
    \  result.push(delimeter);\n        }\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut iter =\
    \ numbers.iter();\n    if let Some(num) = iter.next() {\n        result.push(*num);\n\
    \        for num in iter {\n            result.push(delimeter);\n            result.push(*num);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for (idx, n) in\
    \ numbers.iter().enumerate() {\n        result.push(*n);\n        if idx < numbers.len()\
    \ - 1 {\n            result.push(delimeter);\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    if numbers.len() <= 1 {\n        return numbers;\n\
    \    }\n    let mut result = vec![];\n    for number in numbers.iter() {\n   \
    \     result.push(*number);\n        result.push(delimeter);\n    }\n    result.pop();\n\
    \    result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for i in numbers\
    \ {\n        result.push(i);\n        result.push(delimeter);\n    }\n    result.pop();\n\
    \    result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for (idx, val)\
    \ in numbers.iter().enumerate() {\n        result.push(*val);\n        if idx\
    \ != numbers.len() - 1 {\n            result.push(delimeter);\n        }\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    if numbers.len() == 0 {\n        return vec![];\n\
    \    }\n    let mut result = vec![numbers[0]];\n    for number in numbers.iter().skip(1)\
    \ {\n        result.push(delimeter);\n        result.push(*number);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut iter =\
    \ numbers.iter();\n    while let Some(x) = iter.next() {\n        result.push(*x);\n\
    \        if let Some(y) = iter.next() {\n            result.push(delimeter);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 8, 3, 8]`,\n right: `[5, 8, 6, 8, 3, 8, 2]`', /tmp/tmp05wvzcqg.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    if numbers.len()\
    \ == 0 {\n        return result;\n    }\n    result.push(numbers[0]);\n    for\
    \ i in 1..numbers.len() {\n        result.push(delimeter);\n        result.push(numbers[i]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for (i, n) in\
    \ numbers.iter().enumerate() {\n        result.push(*n);\n        if i != numbers.len()\
    \ - 1 {\n            result.push(delimeter);\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    if !numbers.is_empty()\
    \ {\n        result.push(numbers[0]);\n        for i in 1..numbers.len() {\n \
    \           result.push(delimeter);\n            result.push(numbers[i]);\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut result = Vec::new();\n    for (i, &n) in\
    \ numbers.iter().enumerate() {\n        result.push(n);\n        if i < numbers.len()\
    \ - 1 {\n            result.push(delimeter);\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut res = Vec::new();\n    if numbers.len()\
    \ > 0 {\n        res.push(numbers[0]);\n        for num in numbers.iter().skip(1)\
    \ {\n            res.push(delimeter);\n            res.push(*num);\n        }\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!(candidate(Vec::<isize>::new(),\
    \ 7), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5,\
    \ 8, 6, 8, 3, 8, 2]);\n    assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2,\
    \ 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Insert a number 'delimeter' between every two consecutive elements\
    \ of input list `numbers'\n/// >>> intersperse([], 4)\n/// []\n/// >>> intersperse([1,\
    \ 2, 3], 4)\n/// [1, 4, 2, 4, 3]\nfn intersperse(numbers: Vec<isize>, delimeter:\
    \ isize) -> Vec<isize> {\n    let mut vec = Vec::new();\n    for (i, n) in numbers.iter().enumerate()\
    \ {\n        vec.push(*n);\n        if i < numbers.len() - 1 {\n            vec.push(delimeter);\n\
    \        }\n    }\n    vec\n}\n\nfn main() {\n    let candidate = intersperse;\n\
    \    assert_eq!(candidate(Vec::<isize>::new(), 7), Vec::<isize>::new());\n   \
    \ assert_eq!(candidate(vec![5, 6, 3, 2], 8), vec![5, 8, 6, 8, 3, 8, 2]);\n   \
    \ assert_eq!(candidate(vec![2, 2, 2], 2), vec![2, 2, 2, 2, 2]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
