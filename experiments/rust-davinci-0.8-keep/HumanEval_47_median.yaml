name: HumanEval_47_median
language: rust
prompt: "/// Return median of elements in the list l.\n/// >>> median([3, 1, 2, 4,\
  \ 5])\n/// 3\n/// >>> median([-10, 4, 6, 1000, 10, 20])\n/// 15.0\nfn median(l:\
  \ Vec<isize>) -> f64 {\n"
tests: "}\n\nfn main() {\n    let candidate = median;\n    assert_eq!(candidate(vec![3,\
  \ 1, 2, 4, 5]), 3.0);\n    assert_eq!(candidate(vec![-10, 4, 6, 1000, 10, 20]),\
  \ 8.0);\n    assert_eq!(candidate(vec![5]), 5.0);\n    assert_eq!(candidate(vec![6,\
  \ 5]), 5.5);\n    assert_eq!(candidate(vec![8, 1, 3, 9, 9, 2, 7]), 7.0);\n}\n"
completions: ["    let mut s = l.clone();\n    s.sort();\n    if s.len() % 2 == 0\
    \ {\n        let a = s[s.len() / 2 - 1];\n        let b = s[s.len() / 2];\n  \
    \      return (a + b) as f64 / 2.0;\n    } else {\n        return s[s.len() /\
    \ 2] as f64;\n    }", "    let mut l = l;\n    let n = l.len();\n    if n % 2\
    \ == 0 {\n        let m = n / 2;\n        (l[m] + l[m - 1]) as f64 / 2.0\n   \
    \ } else {\n        l[n / 2] as f64\n    }", "    if l.len() % 2 == 0 {\n    \
    \    let m = l.len() / 2;\n        (*l.get(m).unwrap() as f64 + *l.get(m - 1).unwrap()\
    \ as f64) / 2.0\n    } else {\n        let m = l.len() / 2;\n        *l.get(m).unwrap()\
    \ as f64\n    }", "    assert!(l.len() != 0);\n    let mut l = l;\n    l.sort();\n\
    \    if l.len() % 2 == 0 {\n        let a = l[l.len() / 2];\n        let b = l[l.len()\
    \ / 2 - 1];\n        (a + b) as f64 / 2.0\n    } else {\n        l[l.len() / 2]\
    \ as f64\n    }", "    if l.len() == 0 {\n        return 0.0;\n    }\n    let\
    \ mut l = l;\n    l.sort();\n    let len = l.len();\n    if len % 2 == 0 {\n \
    \       return ((l[len / 2] + l[len / 2 - 1]) as f64) / 2.0;\n    } else {\n \
    \       return l[len / 2] as f64;\n    }", "    let mut l = l;\n    l.sort();\n\
    \    if l.len() % 2 == 0 {\n        let idx = l.len() / 2;\n        (l[idx - 1]\
    \ + l[idx]) as f64 / 2.0\n    } else {\n        l[l.len() / 2] as f64\n    }",
  "    let mut v = l.clone();\n    v.sort();\n    let mid = v.len() / 2;\n    if v.len()\
    \ % 2 == 0 {\n        let sum = v[mid] + v[mid - 1];\n        sum as f64 / 2f64\n\
    \    } else {\n        v[mid] as f64\n    }", "    let mut l1 = l.clone();\n \
    \   let l_len = l1.len();\n    // Sort the list, then return middle element.\n\
    \    l1.sort();\n    if l_len % 2 == 0 {\n        // When length is even, average\
    \ the middle two elements.\n        (l1[l_len / 2] + l1[l_len / 2 - 1]) as f64\
    \ / 2.0\n    } else {\n        // When length is odd, return middle element.\n\
    \        l1[l_len / 2] as f64\n    }", "    let mut l = l;\n    l.sort();\n  \
    \  if l.len() % 2 == 0 {\n        (l[l.len() / 2] + l[l.len() / 2 - 1]) as f64\
    \ / 2.0\n    } else {\n        l[l.len() / 2] as f64\n    }", "    let mut l =\
    \ l;\n    let mut l1 = Vec::new();\n    let mut l2 = Vec::new();\n    let mut\
    \ l3 = Vec::new();\n    let m = l.len() / 2;\n    for i in 0..l.len() {\n    \
    \    if i <= m {\n            l1.push(l[i]);\n        } else {\n            l2.push(l[i]);\n\
    \        }\n    }\n    l1.sort();\n    l2.sort();\n    l3.append(&mut l1);\n \
    \   l3.append(&mut l2);\n    let l4 = l3.clone();\n    let m = l3.len() / 2;\n\
    \    let m1 = l4.len() / 2;\n    if l3.len() % 2 == 0 {\n        return ((l3[m]\
    \ + l3[m - 1]) as f64) / 2.0;\n    } else {\n        return l4[m1] as f64;\n \
    \   }", "    let mut count = 0;\n    let mut sum = 0;\n    for i in l {\n    \
    \    count += 1;\n        sum += i;\n    }\n    sum as f64 / count as f64", " \
    \   let mut s = l.clone();\n    s.sort();\n    let n = s.len();\n    if n % 2\
    \ == 0 {\n        return ((s[n / 2] + s[n / 2 - 1]) as f64) / 2.0;\n    } else\
    \ {\n        return s[n / 2] as f64;\n    }", "    let mut len = l.len();\n  \
    \  len += 1;\n    return 0.0;", "    if l.len() == 0 {\n        return 0.0;\n\
    \    }\n\n    let mut sorted = l.clone();\n    sorted.sort();\n    let len = sorted.len();\n\
    \    let mid = len / 2;\n    if len % 2 == 0 {\n        (sorted[mid] + sorted[mid\
    \ - 1]) as f64 / 2.0\n    } else {\n        sorted[mid] as f64\n    }", "    let\
    \ mut s = l.clone();\n    s.sort();\n    if s.len() % 2 == 0 {\n        return\
    \ ((s[s.len() / 2] + s[s.len() / 2 - 1]) as f64) / 2.0;\n    } else {\n      \
    \  return s[s.len() / 2] as f64;\n    }", "    let len = l.len();\n    let mut\
    \ sorted = l.clone();\n    sorted.sort();\n    if len % 2 == 0 {\n        ((sorted[len\
    \ / 2 - 1] + sorted[len / 2]) as f64) / 2.0\n    } else {\n        sorted[len\
    \ / 2] as f64\n    }", "    let mut l = l;\n    l.sort();\n    match l.len() %\
    \ 2 {\n        0 => (l[l.len() / 2 - 1] + l[l.len() / 2]) as f64 / 2.0,\n    \
    \    _ => l[l.len() / 2] as f64,\n    }", "    let mut l = l;\n    l.sort();\n\
    \    let mut l = l;\n    let len = l.len();\n    if len % 2 == 0 {\n        let\
    \ a = l.remove(len / 2);\n        let b = l.remove(len / 2 - 1);\n        ((a\
    \ + b) as f64) / 2.0\n    } else {\n        l.remove(len / 2) as f64\n    }",
  "    let mut l_copy = l.clone();\n    l_copy.sort();\n    if l_copy.len() % 2 ==\
    \ 0 {\n        let mid = l_copy.len() / 2;\n        ((l_copy[mid] + l_copy[mid-1])\
    \ as f64)/2.0\n    } else {\n        (l_copy[l_copy.len()/2] as f64)\n    }",
  "    let mut nl = l.clone();\n    nl.sort();\n    if nl.len() % 2 == 0 {\n     \
    \   let m = nl.len() / 2;\n        (nl[m - 1] + nl[m]) as f64 / 2.0\n    } else\
    \ {\n        nl[nl.len() / 2] as f64\n    }", "    let mut sorted = l.clone();\n\
    \    sorted.sort();\n    let len = sorted.len();\n    if len % 2 == 0 {\n    \
    \    let mid_idx = len / 2;\n        (sorted[mid_idx] + sorted[mid_idx - 1]) as\
    \ f64 / 2.0\n    } else {\n        sorted[len / 2] as f64\n    }", "    let sorted_list\
    \ = l.clone();\n    let mut sort_list = sorted_list.to_vec();\n    sort_list.sort();\n\
    \    let length = sort_list.len();\n    if length % 2 == 0 {\n        let idx\
    \ = length / 2;\n        (sort_list[idx] + sort_list[idx - 1]) as f64 / 2.0\n\
    \    } else {\n        let idx = length / 2;\n        sort_list[idx] as f64\n\
    \    }", "    if l.len() == 0 {\n        panic!(\"median of empty list\");\n \
    \   }\n    let mut c = l.clone();\n    c.sort();\n    let ll = c.len();\n    if\
    \ ll % 2 == 1 {\n        return (c[ll / 2] as f64);\n    } else {\n        return\
    \ ((c[ll / 2 - 1] + c[ll / 2]) as f64) / 2.0;\n    }", "    let n = l.len();\n\
    \    if n == 0 {\n        panic!(\"median: empty list\");\n    }\n    let mut\
    \ l = l;\n    l.sort();\n    if n % 2 == 0 {\n        return (l[n / 2 - 1] + l[n\
    \ / 2]) as f64 / 2.0;\n    } else {\n        return l[n / 2] as f64;\n    }",
  "    let mut sorted = l.clone();\n    sorted.sort();\n    let mid = sorted.len()\
    \ / 2;\n    if sorted.len() % 2 == 0 {\n        ((sorted[mid - 1] + sorted[mid])\
    \ as f64) / 2.0\n    } else {\n        sorted[mid] as f64\n    }", "    let mut\
    \ l = l;\n    let mut n = l.len();\n    l.sort();\n    if n % 2 == 0 {\n     \
    \   let m = n / 2;\n        (l[m] + l[m - 1]) as f64 / 2.0\n    } else {\n   \
    \     l[n / 2] as f64\n    }", "    let m = l.len() / 2;\n    if l.len() % 2 ==\
    \ 0 {\n        (l[m - 1] + l[m]) as f64 / 2.0\n    } else {\n        l[m] as f64\n\
    \    }", "    let mut l = l;\n    l.sort();\n    let mid = l.len() / 2;\n    if\
    \ l.len() % 2 == 0 {\n        (l[mid] + l[mid-1]) as f64 / 2.0\n    } else {\n\
    \        l[mid] as f64\n    }", "    let mut l = l;\n    let (mid, _) = l.split_at_mut(l.len()\
    \ / 2);\n    sort(mid);\n    if l.len() % 2 == 0 {\n        median2(l)\n    }\
    \ else {\n        mid[mid.len() / 2] as f64\n    }", "    let len = l.len();\n\
    \    if len == 0 {\n        return 0.0;\n    }\n    let mut v = l.clone();\n \
    \   v.sort();\n    let mid = len / 2;\n    if len % 2 == 0 {\n        (v[mid -\
    \ 1] + v[mid]) as f64 / 2.0\n    } else {\n        v[mid] as f64\n    }", '    l.len()
    as f64', "    if l.len() == 0 {\n        return 0.0;\n    }\n    let m = l.len()\
    \ / 2;\n    if l.len() % 2 == 0 {\n        return (l[m - 1] + l[m]) as f64 / 2.0;\n\
    \    }\n    return l[m] as f64;", "    return match l.len() {\n        0 => 0.0,\n\
    \        1 => l[0] as f64,\n        2 => (l[0] + l[1]) as f64 / 2.0,\n       \
    \ _ => {\n            let mut nl = l.clone();\n            nl.sort();\n      \
    \      if l.len() % 2 == 0 {\n                (nl[l.len() / 2 - 1] + nl[l.len()\
    \ / 2]) as f64 / 2.0\n            } else {\n                nl[l.len() / 2] as\
    \ f64\n            }\n        }\n    };", "    let len = l.len();\n    if len\
    \ == 0 {\n        panic!(\"list should not be empty\")\n    }\n    let mut new_l\
    \ = l.clone();\n    new_l.sort();\n    if len % 2 == 0 {\n        ((new_l[len\
    \ / 2 - 1] + new_l[len / 2]) as f64) / 2.0\n    } else {\n        new_l[len /\
    \ 2] as f64\n    }", "    let mut l = l;\n    l.sort();\n    let len = l.len();\n\
    \    if len % 2 == 0 {\n        (l[len / 2] + l[len / 2 - 1]) as f64 / 2.0\n \
    \   } else {\n        l[len / 2] as f64\n    }", "    let mut l = l;\n    l.sort();\n\
    \    let mid = l.len() / 2;\n    if l.len() % 2 == 0 {\n        (l[mid] + l[mid\
    \ - 1]) as f64 / 2.0\n    } else {\n        l[mid] as f64\n    }", "    let mid\
    \ = (l.len() - 1) / 2;\n    let mut v = l.clone();\n    v.sort();\n    if mid\
    \ % 2 == 0 {\n        return ((v[mid] + v[mid + 1]) as f64) / 2.0;\n    }\n  \
    \  v[mid] as f64", "    let mut l = l;\n    l.sort();\n    if l.len() % 2 == 0\
    \ {\n        return (l[l.len() / 2] + l[l.len() / 2 - 1]) as f64 / 2.0;\n    }\
    \ else {\n        return l[l.len() / 2] as f64;\n    }", "    let mut vec = l.clone();\n\
    \    vec.sort();\n    let mut len = vec.len();\n    if len % 2 == 0 {\n      \
    \  let x = vec[len / 2 - 1];\n        let y = vec[len / 2];\n        return ((x\
    \ + y) as f64) / 2.0;\n    } else {\n        return vec[len / 2] as f64;\n   \
    \ }", "    let l_size = l.len();\n    let mid = l_size / 2;\n    let mut sorted_l\
    \ = l.clone();\n    sorted_l.sort();\n    if l_size % 2 == 0 {\n        (sorted_l[mid\
    \ - 1] + sorted_l[mid]) as f64 / 2.0\n    } else {\n        sorted_l[mid] as f64\n\
    \    }", "    let mut list = l;\n    list.sort();\n    if list.len() % 2 == 0\
    \ {\n        let n = list.len() / 2;\n        (list[n] + list[n - 1]) as f64 /\
    \ 2.0\n    } else {\n        list[list.len() / 2] as f64\n    }", '    unimplemented!();',
  "    if l.len() == 0 {\n        panic!(\"median: empty list\");\n    }\n    let\
    \ mut l2 = l.clone();\n    l2.sort();\n    let n = l2.len();\n    if n % 2 ==\
    \ 0 {\n        (l2[n / 2 - 1] + l2[n / 2]) as f64 / 2.0\n    } else {\n      \
    \  l2[n / 2] as f64\n    }", "    let mut l = l;\n    l.sort();\n    l.len() as\
    \ f64 / 2.0", "    let mut l = l;\n    l.sort();\n    let n = l.len();\n    if\
    \ n % 2 == 0 {\n        let n2 = n / 2;\n        (l[n2 - 1] + l[n2]) as f64 /\
    \ 2.0\n    } else {\n        l[n / 2] as f64\n    }", "    let mut l2 = l.clone();\n\
    \    // Note the type annotation of the below line.\n    l2.sort();\n    let len\
    \ = l2.len();\n    if len % 2 == 0 {\n        // Even number of elements; find\
    \ mean of middle two.\n        let i = len / 2;\n        let j = i - 1;\n    \
    \    (l2[i] + l2[j]) as f64 / 2.0\n    } else {\n        // Odd number of elements;\
    \ find median.\n        let i = len / 2;\n        l2[i] as f64\n    }", "    let\
    \ mut l = l;\n    l.sort();\n    let length = l.len();\n    let is_even = length\
    \ % 2 == 0;\n    if is_even {\n        let first = length / 2 - 1;\n        let\
    \ second = length / 2;\n        let sum = l[first] + l[second];\n        sum as\
    \ f64 / 2.0\n    } else {\n        l[length / 2] as f64\n    }", "    if l.len()\
    \ == 0 {\n        return 0.0;\n    }\n    let mid = l.len() / 2;\n    let l =\
    \ l.clone();\n    if l.len() % 2 == 0 {\n        let a = l[mid - 1];\n       \
    \ let b = l[mid];\n        ((a as f64) + (b as f64)) / 2.0\n    } else {\n   \
    \     l[mid] as f64\n    }", "    // BEGIN_SOLUTION\n    let n = l.len();\n  \
    \  if n == 0 {\n        return 0.0;\n    }\n    let mut l_sorted = l.clone();\n\
    \    l_sorted.sort();\n    if n % 2 == 1 {\n        return l_sorted[n / 2] as\
    \ f64;\n    } else {\n        return (l_sorted[n / 2 - 1] + l_sorted[n / 2]) as\
    \ f64 / 2.0;\n    }\n    // END_SOLUTION", "    let mut sorted = l.clone();\n\
    \    sorted.sort();\n    let mid = (sorted.len() as f64) / 2.0;\n    if mid.fract()\
    \ == 0.0 {\n        ((sorted[mid as usize] + sorted[(mid - 1.0) as usize]) as\
    \ f64) / 2.0\n    } else {\n        sorted[mid.floor() as usize] as f64\n    }",
  "    // Base case\n    if l.len() == 0 {\n        return 0.0;\n    }\n\n    // Sort\
    \ the list\n    let mut sorted_l = l.clone();\n    sorted_l.sort();\n\n    //\
    \ Return median\n    if sorted_l.len() % 2 == 0 {\n        return ((sorted_l[sorted_l.len()\
    \ / 2] + sorted_l[sorted_l.len() / 2 - 1]) as f64) / 2.0;\n    } else {\n    \
    \    return sorted_l[sorted_l.len() / 2] as f64;\n    }", "    if l.len() % 2\
    \ == 0 {\n        return (l[l.len() / 2] + l[l.len() / 2 - 1]) as f64 / 2.0;\n\
    \    } else {\n        return l[l.len() / 2] as f64;\n    }", "    let mut v =\
    \ l.clone();\n    let middle = v.len() / 2;\n    sort(&mut v);\n    if v.len()\
    \ % 2 == 0 {\n        let middle_2 = middle - 1;\n        (v[middle] + v[middle_2])\
    \ as f64 / 2.0\n    } else {\n        v[middle] as f64\n    }", "    let mut l2\
    \ = l.clone();\n    l2.sort();\n    let mid = l2.len() / 2;\n    if l2.len() %\
    \ 2 == 0 {\n        let a = l2[mid] as f64;\n        let b = l2[mid - 1] as f64;\n\
    \        (a + b) / 2.0\n    } else {\n        l2[mid] as f64\n    }", "    let\
    \ mut l = l;\n    // Insert your code here.\n    let half = l.len() / 2;\n   \
    \ // l.sort();\n    for i in 0..l.len() {\n        for j in 0..l.len() {\n   \
    \         if l[i] < l[j] {\n                let temp = l[i];\n               \
    \ l[i] = l[j];\n                l[j] = temp;\n            }\n        }\n    }\n\
    \    println!(\"{:?}\", l);\n    if l.len() % 2 == 0 {\n        ((l[half - 1]\
    \ + l[half]) as f64) / 2.0\n    } else {\n        l[half] as f64\n    }", "  \
    \  match l.len() {\n        0 => 0.0,\n        l => {\n            let n = l as\
    \ f64;\n            let mut v = l;\n            v.sort();\n            if n %\
    \ 2.0 == 0.0 {\n                ((v[(n / 2.0 - 1.0) as usize] + v[(n / 2.0) as\
    \ usize]) as f64) / 2.0\n            } else {\n                v[(n / 2.0) as\
    \ usize] as f64\n            }\n        }\n    }", "    let mut l = l;\n    l.sort();\n\
    \    let mut len = l.len();\n    let mid = len / 2;\n    if len % 2 == 0 {\n \
    \       (l[mid] + l[mid - 1]) as f64 / 2f64\n    } else {\n        l[mid] as f64\n\
    \    }", '    unimplemented!()', "    let mut sl = l.clone();\n    sl.sort();\n\
    \    let n = sl.len();\n    if n % 2 == 0 {\n        ((sl[n / 2] + sl[n / 2 -\
    \ 1]) as f64) / 2.0\n    } else {\n        sl[n / 2] as f64\n    }", "    let\
    \ mut l: Vec<isize> = l;\n    l.sort();\n    let len = l.len();\n    let mid =\
    \ len / 2;\n    let midf = len as f64 / 2.0;\n    if len % 2 == 0 {\n        return\
    \ ((l[mid - 1] + l[mid]) as f64) / 2.0;\n    } else {\n        return l[mid] as\
    \ f64;\n    }", "    let mut l_copy = l.clone();\n    l_copy.sort();\n    if l_copy.len()\
    \ % 2 == 0 {\n        let mid = l_copy.len() / 2;\n        return ((l_copy[mid\
    \ - 1] + l_copy[mid]) as f64) / 2f64;\n    } else {\n        let mid = l_copy.len()\
    \ / 2;\n        return l_copy[mid] as f64;\n    }", "    if l.len() % 2 == 0 {\n\
    \        let l = l.len() / 2;\n        (l as f64 + (l - 1) as f64) / 2.0\n   \
    \ } else {\n        let l = l.len() / 2;\n        l as f64\n    }", "    let mut\
    \ mut_l = l;\n    mut_l.sort();\n    let len = mut_l.len();\n    match len {\n\
    \        0 => panic!(\"median: no elements in list.\"),\n        1 => mut_l[0]\
    \ as f64,\n        _ => {\n            if len % 2 == 0 {\n                (mut_l[len\
    \ / 2] + mut_l[len / 2 - 1]) as f64 / 2.0\n            } else {\n            \
    \    mut_l[len / 2] as f64\n            }\n        }\n    }", "    let len = l.len();\n\
    \    let middle = len / 2;\n    if len % 2 == 0 {\n        (l[middle - 1] + l[middle])\
    \ as f64 / 2.0\n    } else {\n        l[middle] as f64\n    }", "    let mut l\
    \ = l;\n    l.sort();\n    if l.len() % 2 == 0 {\n        let mid_point = l.len()\
    \ / 2;\n        (l[mid_point - 1] + l[mid_point]) as f64 / 2.0\n    } else {\n\
    \        l[l.len() / 2] as f64\n    }", "    let n = l.len();\n    let half =\
    \ n / 2;\n    if n % 2 == 0 {\n        let mut iter = l.iter();\n        let a\
    \ = iter.nth(half - 1).unwrap();\n        let b = iter.nth(half).unwrap();\n \
    \       (*a + *b) as f64 / 2.0\n    } else {\n        *l.iter().nth(half).unwrap()\
    \ as f64\n    }", "    let mut list = l;\n    list.sort();\n    if list.len()\
    \ % 2 == 0 {\n        let even_num = list.len() / 2;\n        let avg = (list[even_num\
    \ - 1] + list[even_num]) as f64 / 2.0;\n        avg\n    } else {\n        let\
    \ odd_num = list.len() / 2;\n        list[odd_num] as f64\n    }", "    let n\
    \ = l.len();\n    if n == 0 {\n        return 0.0;\n    }\n    if n % 2 == 0 {\n\
    \        let a = l[n / 2];\n        let b = l[n / 2 - 1];\n        return ((a\
    \ + b) as f64) / 2.0;\n    }\n    l[n / 2] as f64", "    // YOUR CODE HERE\n \
    \   unimplemented!()", "    let mut mid: f64 = 0.0;\n    if l.len() % 2 == 0 {\n\
    \        let index = l.len() / 2;\n        mid = (l[index] + l[index - 1]) as\
    \ f64 / 2.0;\n    } else {\n        let index = l.len() / 2;\n        mid = l[index]\
    \ as f64;\n    }\n    mid", "    let mut new_l = l.clone();\n    new_l.sort();\n\
    \    let len = new_l.len();\n    if len % 2 == 0 {\n        let m_idx = len /\
    \ 2;\n        (new_l[m_idx] + new_l[m_idx - 1]) as f64 / 2.0\n    } else {\n \
    \       new_l[len / 2] as f64\n    }", "    let mut v = l.clone();\n    v.sort();\n\
    \    let n = v.len();\n    if n % 2 == 0 {\n        (v[n / 2 - 1] + v[n / 2])\
    \ as f64 / 2.0\n    } else {\n        v[n / 2] as f64\n    }", "    let mut l_sorted\
    \ = l.clone();\n    l_sorted.sort();\n    let len = l_sorted.len();\n    if len\
    \ % 2 == 0 {\n        return (l_sorted[len / 2] + l_sorted[len / 2 - 1]) as f64\
    \ / 2.0;\n    } else {\n        return l_sorted[len / 2] as f64;\n    }", "  \
    \  let m = l.len() / 2;\n    let mut sorted = l.clone();\n    sorted.sort();\n\
    \    let middle = sorted[m];\n    let next = sorted[m + 1];\n    (middle + next)\
    \ as f64 / 2.0", "    let mut m = l.clone();\n    m.sort();\n    let mid = m.len()\
    \ / 2;\n    if m.len() % 2 == 0 {\n        (m[mid] + m[mid - 1]) as f64 / 2.0\n\
    \    } else {\n        m[mid] as f64\n    }", "    let mut l_sort = l.clone();\n\
    \    l_sort.sort();\n    if l_sort.len() % 2 == 0 {\n        return (l_sort[l_sort.len()\
    \ / 2] + l_sort[l_sort.len() / 2 - 1]) as f64 / 2.0;\n    } else {\n        return\
    \ l_sort[l_sort.len() / 2] as f64;\n    }", "    let mut l = l;\n    let mut length\
    \ = l.len();\n    if length % 2 == 0 {\n        l.sort();\n        let middle_left\
    \ = length / 2 - 1;\n        let middle_right = length / 2;\n        return ((l[middle_left]\
    \ + l[middle_right]) as f64) / 2.0;\n    } else {\n        l.sort();\n       \
    \ let middle = length / 2;\n        return l[middle] as f64;\n    }", "    let\
    \ mut l = l;\n    l.sort();\n    if l.len() % 2 == 0 {\n        (l[l.len() / 2]\
    \ + l[l.len() / 2 - 1]) as f64 / 2.0\n    } else {\n        l[l.len() / 2] as\
    \ f64\n    }", "    let mut list = l;\n    list.sort();\n    let n = list.len();\n\
    \    if n % 2 == 0 {\n        (list[n / 2] + list[n / 2 - 1]) as f64 / 2.0\n \
    \   } else {\n        list[n / 2] as f64\n    }", "\tif l.len() % 2 == 0 {\n\t\
    \tlet mut sorted_l = l.clone();\n\t\tsorted_l.sort();\n\t\t(sorted_l[(l.len()\
    \ / 2) - 1] + sorted_l[l.len() / 2]) as f64 / 2.0\n\t} else {\n\t\tlet mut sorted_l\
    \ = l.clone();\n\t\tsorted_l.sort();\n\t\tsorted_l[l.len() / 2] as f64\n\t}",
  "    let mut ll = l.clone();\n    ll.sort();\n    if ll.len() % 2 == 0 {\n     \
    \   let x = ll.len() / 2;\n        let sum = ll[x] + ll[x - 1];\n        sum as\
    \ f64 / 2.0\n    } else {\n        ll[ll.len() / 2] as f64\n    }", "    // BEGIN_SOLUTION\n\
    \    let sorted = sorted(l);\n    let len = sorted.len();\n    if len % 2 == 0\
    \ {\n        let upper = sorted[len / 2];\n        let lower = sorted[len / 2\
    \ - 1];\n        (upper + lower) as f64 / 2.0\n    } else {\n        sorted[len\
    \ / 2] as f64\n    }\n    // END_SOLUTION", "    let mut l = l;\n    let mut res:\
    \ f64 = 0.0;\n    l.sort();\n    let len = l.len();\n    if len % 2 == 0 {\n \
    \       res = ((l[len / 2] + l[len / 2 - 1]) as f64) / 2.0;\n    } else {\n  \
    \      res = l[len / 2] as f64;\n    }\n    res", "    let mid = l.len() / 2;\n\
    \    let mut l1 = l.clone();\n    l1.sort();\n    match l.len() % 2 {\n      \
    \  0 => (l1[mid - 1] + l1[mid]) as f64 / 2.0,\n        _ => l1[mid] as f64,\n\
    \    }", "    let mut m = Vec::new();\n    for i in l {\n        m.push(i);\n\
    \    }\n    m.sort();\n    let len = m.len();\n    if len % 2 == 0 {\n       \
    \ (m[len / 2] + m[len / 2 - 1]) as f64 / 2.0\n    } else {\n        m[len / 2]\
    \ as f64\n    }", "    let mut m = l.clone();\n    m.sort();\n    match m.len()\
    \ % 2 {\n        0 => (m[m.len() / 2 - 1] + m[m.len() / 2]) as f64 / 2.0,\n  \
    \      _ => m[m.len() / 2] as f64,\n    }", "    if l.len() == 0 {\n        panic!(\"\
    median() expects a non-empty list.\")\n    }\n    let s: Vec<isize> = sorted(l);\n\
    \    let n = s.len();\n    if n % 2 == 1 {\n        return s[n / 2] as f64;\n\
    \    } else {\n        return (s[n / 2 - 1] + s[n / 2]) as f64 / 2.0;\n    }",
  "    assert!(l.len() > 0);\n    if l.len() % 2 == 0 {\n        let i = l.len() /\
    \ 2;\n        let j = i - 1;\n        (l[i] + l[j]) as f64 / 2.0\n    } else {\n\
    \        l[l.len() / 2] as f64\n    }", "    let mut l2 = l.clone();\n    l2.sort();\n\
    \    let n = l2.len();\n    if n % 2 == 0 {\n        (l2[n / 2 - 1] + l2[n / 2])\
    \ as f64 / 2.0\n    } else {\n        l2[n / 2] as f64\n    }", "    if l.len()\
    \ == 0 {\n        return 0.0;\n    }\n    let mut vec = l.clone();\n    vec.sort();\n\
    \    let midpoint = vec.len() / 2;\n    if vec.len() % 2 == 0 {\n        let left\
    \ = vec[midpoint - 1];\n        let right = vec[midpoint];\n        (left + right)\
    \ as f64 / 2.0\n    } else {\n        vec[midpoint] as f64\n    }", "    let mut\
    \ vec = l.clone();\n    vec.sort();\n    return match vec.len() % 2 {\n      \
    \  0 => (vec[vec.len() / 2] + vec[vec.len() / 2 - 1]) as f64 / 2.0,\n        _\
    \ => vec[vec.len() / 2] as f64,\n    };", "    let mut sorted = l.clone();\n \
    \   sorted.sort();\n    let mid = sorted.len() / 2;\n    if sorted.len() % 2 ==\
    \ 0 {\n        (sorted[mid] + sorted[mid - 1]) as f64 / 2.0\n    } else {\n  \
    \      sorted[mid] as f64\n    }", "    let n = l.len();\n    let mut sorted =\
    \ l.clone();\n    sorted.sort();\n    let sum_two = sorted[n / 2] + sorted[(n\
    \ / 2) - 1];\n    return sum_two as f64 / 2.0;", "    let mut mid = 0;\n    let\
    \ mut l = l;\n    // sort the list, then return the middle element\n    l.sort();\n\
    \    if l.len() % 2 == 0 {\n        mid = l.len() / 2;\n        (l[mid] + l[mid\
    \ - 1]) as f64 / 2.0\n    } else {\n        mid = l.len() / 2;\n        l[mid]\
    \ as f64\n    }", "    let mut l = l;\n    l.sort();\n    let n = l.len();\n \
    \   if n % 2 == 0 {\n        (l[n / 2 - 1] + l[n / 2]) as f64 / 2.0\n    } else\
    \ {\n        l[n / 2] as f64\n    }", "    fn median_helper(l: Vec<isize>, i:\
    \ usize, n: usize) -> f64 {\n        if n == 0 {\n            0 as f64\n     \
    \   } else if n % 2 == 0 {\n            (l[i + n / 2 - 1] + l[i + n / 2]) as f64\
    \ / 2.0\n        } else {\n            l[i + n / 2] as f64\n        }\n    }\n\
    \n    let mut l = l;\n    l.sort();\n    median_helper(l, 0, l.len())", "    let\
    \ mut l = l;\n    l.sort();\n    let mid = l.len() / 2;\n    if l.len() % 2 ==\
    \ 0 {\n        let v = l[mid - 1] + l[mid];\n        (v as f64) / 2.0\n    } else\
    \ {\n        (l[mid] as f64)\n    }", "    let mut length = l.len();\n    if length\
    \ % 2 == 0 {\n        length = length / 2;\n        let mut sorted = l.clone();\n\
    \        sorted.sort();\n        let m = sorted[length - 1];\n        let m1 =\
    \ sorted[length];\n        let res = (m + m1) as f64 / 2.0;\n        res\n   \
    \ } else {\n        length = length / 2;\n        let mut sorted = l.clone();\n\
    \        sorted.sort();\n        let res = sorted[length] as f64;\n        res\n\
    \    }", "    let n = l.len();\n    if n == 0 {\n        panic!(\"median(vec![])\"\
    );\n    }\n    let mut m = l.clone();\n    m.sort();\n    if n % 2 == 0 {\n  \
    \      (m[n / 2 - 1] + m[n / 2]) as f64 / 2.0\n    } else {\n        m[n / 2]\
    \ as f64\n    }", "    let mut sorted = l.clone();\n    sorted.sort();\n    let\
    \ n = sorted.len();\n    if n % 2 == 0 {\n        (sorted[n / 2] + sorted[n /\
    \ 2 - 1]) as f64 / 2.0\n    } else {\n        sorted[n / 2] as f64\n    }", " \
    \   // YOUR CODE HERE\n    0.0", "    let len = l.len();\n    if len == 0 {\n\
    \        panic!(\"Empty list\");\n    }\n    let mut mut_l = l;\n    mut_l.sort();\n\
    \    let mid = len / 2;\n    if len % 2 == 0 {\n        (mut_l[mid - 1] + mut_l[mid])\
    \ as f64 / 2.0\n    } else {\n        mut_l[mid] as f64\n    }", "    let mut\
    \ list = l;\n    list.sort();\n    let mid = list.len() / 2;\n    if list.len()\
    \ % 2 == 0 {\n        (list[mid] + list[mid - 1]) as f64 / 2.0\n    } else {\n\
    \        list[mid] as f64\n    }", "    let len = l.len();\n    let mid = len\
    \ / 2;\n    if len % 2 == 0 {\n        (l[mid - 1] + l[mid]) as f64 / 2.0\n  \
    \  } else {\n        l[mid] as f64\n    }", "    let sorted = l.clone();\n   \
    \ let mut sorted_clone = sorted.clone();\n    sorted_clone.sort();\n    let n\
    \ = sorted_clone.len();\n    let left = (n - 1) / 2;\n    let right = n / 2;\n\
    \    (((sorted_clone[left] + sorted_clone[right]) as f64) / 2 as f64)", "    if\
    \ l.len() % 2 == 0 {\n        let middle_number = (l.len() / 2) as usize;\n  \
    \      ((l[middle_number - 1] + l[middle_number]) as f64) / 2.0\n    } else {\n\
    \        let middle_number = ((l.len() - 1) / 2) as usize;\n        l[middle_number]\
    \ as f64\n    }", "    let size = l.len();\n    let mut m = l.clone();\n    m.sort();\n\
    \    if size % 2 == 0 {\n        (m[size / 2 - 1] + m[size / 2]) as f64 / 2.0\n\
    \    } else {\n        m[size / 2] as f64\n    }", "    let median = 0.0;\n  \
    \  // YOUR CODE HERE\n    let mut l = l;\n    l.sort();\n    let l_len = l.len();\n\
    \    if l_len % 2 == 0 {\n        (l[l_len / 2] + l[l_len / 2 - 1]) as f64 / 2.0\n\
    \    } else {\n        l[l_len / 2] as f64\n    }", "    let mut clone = l.clone();\n\
    \    clone.sort();\n    let mut iter = clone.iter();\n    if clone.len() % 2 ==\
    \ 0 {\n        let n = clone.len() as f64;\n        let a = *iter.nth(n as usize\
    \ / 2 - 1).unwrap() as f64;\n        let b = *iter.nth(n as usize / 2).unwrap()\
    \ as f64;\n        (a + b) / 2.0\n    } else {\n        let n = clone.len() as\
    \ f64;\n        *iter.nth(n as usize / 2).unwrap() as f64\n    }", "    let mut\
    \ sorted = l.clone();\n    sorted.sort();\n    let len = sorted.len();\n    let\
    \ mid = len / 2;\n    if len % 2 == 0 {\n        let mid_idx = mid as isize;\n\
    \        let prev_idx = mid_idx - 1;\n        let first = sorted[prev_idx as usize];\n\
    \        let second = sorted[mid_idx as usize];\n        (first + second) as f64\
    \ / 2.0\n    } else {\n        sorted[mid] as f64\n    }", "    // YOUR CODE HERE\n\
    \    let mut l = l;\n    l.sort();\n    let len = l.len();\n    if len % 2 ==\
    \ 0 {\n        let middle = len / 2;\n        (l[middle] + l[middle - 1]) as f64\
    \ / 2.0\n    } else {\n        l[len / 2] as f64\n    }", "    let mut l = l;\n\
    \    l.sort();\n    let len = l.len();\n    let mid = len / 2;\n    if len % 2\
    \ == 0 {\n        (l[mid] + l[mid - 1]) as f64 / 2.0\n    } else {\n        l[mid]\
    \ as f64\n    }", "    let mut l = l;\n    l.sort();\n    if l.len() % 2 == 0\
    \ {\n        (l[l.len() / 2] + l[l.len() / 2 - 1]) as f64 / 2.0\n    } else {\n\
    \        l[l.len() / 2] as f64\n    }", "    match l.len() {\n        0 => panic!(\"\
    empty list\"),\n        1 => l[0] as f64,\n        2 => (l[0] + l[1]) as f64 /\
    \ 2.0,\n        _ => {\n            let mid = l.len() / 2;\n            let slice\
    \ = &l[0..mid];\n            let left = median(slice.to_vec());\n            let\
    \ slice = &l[mid..l.len()];\n            let right = median(slice.to_vec());\n\
    \            (left + right) / 2.0\n        }\n    }", "    let mut tmp = l.clone();\n\
    \    tmp.sort();\n    let len = tmp.len();\n    if len % 2 == 0 {\n        return\
    \ (tmp[len / 2] + tmp[len / 2 - 1]) as f64 / 2.0;\n    } else {\n        return\
    \ tmp[len / 2] as f64;\n    }", "    // BEGIN SOLUTION\n    use std::f64;\n  \
    \  l.into_iter().fold(0.0, |m, x| m + x as f64) / (l.len() as f64)\n    // END\
    \ SOLUTION", "    let mut l = l;\n    l.sort();\n    let len = l.len();\n    if\
    \ len % 2 == 0 {\n        return ((l[len / 2] + l[len / 2 - 1]) as f64) / 2.0;\n\
    \    } else {\n        return l[len / 2] as f64;\n    }", "    let mut l_sorted\
    \ = l.clone();\n    l_sorted.sort();\n    if l_sorted.len() % 2 == 0 {\n     \
    \   (l_sorted[l_sorted.len() / 2 - 1] + l_sorted[l_sorted.len() / 2]) as f64 /\
    \ 2.0\n    } else {\n        l_sorted[l_sorted.len() / 2] as f64\n    }", "  \
    \  let mut l = l;\n    l.sort();\n    let n = l.len();\n    let mid = n / 2;\n\
    \    if n % 2 == 0 {\n        (l[mid - 1] + l[mid]) as f64 / 2.0\n    } else {\n\
    \        l[mid] as f64\n    }", "    // return 0;\n    let len = l.len();\n  \
    \  if len == 0 {\n        return 0.0;\n    } else if len % 2 == 0 {\n        return\
    \ ((l[len / 2 - 1] + l[len / 2]) as f64) / 2.0;\n    } else {\n        return\
    \ l[len / 2] as f64;\n    }", "    let len = l.len();\n    if len == 0 {\n   \
    \     return 0.0;\n    }\n    let l = sort(l);\n    if len % 2 == 0 {\n      \
    \  return (l[len / 2 - 1] + l[len / 2]) as f64 / 2.0;\n    } else {\n        return\
    \ l[len / 2] as f64;\n    }", "    if l.len() % 2 == 0 {\n        let x: usize\
    \ = l.len() / 2;\n        (l[x] + l[x-1]) as f64 / 2.0\n    } else {\n       \
    \ let x: usize = l.len() / 2;\n        l[x] as f64\n    }", "    let mut l = l;\n\
    \    l.sort();\n    let half = l.len() / 2;\n    match l.len() % 2 {\n       \
    \ 0 => (l[half - 1] + l[half]) as f64 / 2.0,\n        _ => l[half] as f64,\n \
    \   }", "    let mut i = l.clone();\n    i.sort();\n    let mut n = i.len();\n\
    \    n = n - 1;\n    (i[n / 2] + i[(n + 1) / 2]) as f64 / 2 as f64", "    let\
    \ mut new_list = l.clone();\n    new_list.sort();\n    let length = new_list.len();\n\
    \    if length % 2 == 0 {\n        return (new_list[length / 2] + new_list[length\
    \ / 2 - 1]) as f64 / 2.0;\n    } else {\n        return new_list[length / 2] as\
    \ f64;\n    }", "    let length = l.len();\n    let index = length / 2;\n    let\
    \ mut mid_num: isize;\n    if length % 2 == 0 {\n        mid_num = (l[index -\
    \ 1] + l[index]) / 2;\n    } else {\n        mid_num = l[index];\n    }\n    mid_num\
    \ as f64", "    let mut temp = l.clone();\n    temp.sort();\n    let mid_index\
    \ = temp.len() / 2;\n    if temp.len() % 2 == 0 {\n        let mid = temp[mid_index\
    \ - 1] + temp[mid_index];\n        (mid as f64) / 2.0\n    } else {\n        temp[mid_index]\
    \ as f64\n    }", '    unimplemented!()', "    let mut v = l.clone();\n    v.sort();\n\
    \    let len = v.len();\n    if len % 2 == 0 {\n        (v[len / 2] + v[len /\
    \ 2 - 1]) as f64 / 2.0\n    } else {\n        v[len / 2] as f64\n    }", "   \
    \ match (l.len() % 2, l.len()) {\n        (0, 0) => 0.0,\n        (0, 2) => (l[0]\
    \ + l[1]) as f64 / 2.0,\n        (0, _) => l[l.len() / 2] as f64,\n        (1,\
    \ _) => l[l.len() / 2] as f64,\n        _ => panic!(\"Something went wrong with\
    \ median function.\"),\n    }", "    let mut l_copy = l.clone();\n    l_copy.sort();\n\
    \    let mid = l_copy.len() / 2;\n    if l_copy.len() % 2 == 0 {\n        (l_copy[mid]\
    \ + l_copy[mid - 1]) as f64 / 2.0\n    } else {\n        l_copy[mid] as f64\n\
    \    }", "    let mut sl = l.clone();\n    sl.sort();\n    let len = sl.len();\n\
    \    if len % 2 == 0 {\n        return sl[len / 2 - 1] as f64 + sl[len / 2] as\
    \ f64 / 2.0;\n    } else {\n        return sl[len / 2] as f64;\n    }", '    return
    0.0;', "    let mut sorted = l.clone();\n    sorted.sort();\n    let n = sorted.len();\n\
    \    if n % 2 == 0 {\n        (sorted[n / 2] + sorted[n / 2 - 1]) as f64 / 2.0\n\
    \    } else {\n        sorted[n / 2] as f64\n    }", '    0.0', "    let mut list\
    \ = l;\n    list.sort();\n    list.iter().fold(0, |acc, &x| acc + x) as f64 /\
    \ list.len() as f64", "    let mut sorted = l.clone();\n    sorted.sort();\n \
    \   let mid = sorted.len() / 2;\n    if sorted.len() % 2 == 0 {\n        (sorted[mid]\
    \ + sorted[mid - 1]) as f64 / 2.0\n    } else {\n        sorted[mid] as f64\n\
    \    }", "    match l.len() {\n        0 => 0.0,\n        1 => l[0] as f64,\n\
    \        _ => {\n            let mid = l.len() / 2;\n            let mut sorted\
    \ = l.clone();\n            sorted.sort();\n            if sorted.len() % 2 ==\
    \ 0 {\n                (sorted[mid - 1] + sorted[mid]) as f64 / 2.0\n        \
    \    } else {\n                sorted[mid] as f64\n            }\n        }\n\
    \    }", "    let len = l.len();\n    if len % 2 == 0 {\n        return (l[len\
    \ / 2 - 1] + l[len / 2]) as f64 / 2.0;\n    }\n    return l[len / 2] as f64;",
  "    match l.len() {\n        0 => 0.0,\n        1 => l[0] as f64,\n        _ =>\
    \ {\n            // l is sorted in ascending order\n            let mut sorted_l\
    \ = l.clone();\n            sorted_l.sort();\n            match sorted_l.len()\
    \ % 2 {\n                0 => (sorted_l[sorted_l.len() / 2 - 1] + sorted_l[sorted_l.len()\
    \ / 2]) as f64 / 2.0,\n                _ => sorted_l[sorted_l.len() / 2] as f64,\n\
    \            }\n        }\n    }", '    l.iter().sum::<isize>() as f64 / l.len()
    as f64', "    let mut new_list = l.clone();\n    let length = new_list.len();\n\
    \    if length % 2 == 0 {\n        let mut merged_list = merge_sort(new_list);\n\
    \        let middle = length / 2;\n        let elem1 = merged_list.get(middle).unwrap();\n\
    \        let elem2 = merged_list.get(middle - 1).unwrap();\n        let median\
    \ = ((*elem1 + *elem2) as f64) / 2.0;\n        median\n    } else {\n        let\
    \ mut merged_list = merge_sort(new_list);\n        let middle = length / 2;\n\
    \        let elem = merged_list.get(middle).unwrap();\n        *elem as f64\n\
    \    }", "    let mut l2 = l.clone();\n    l2.sort();\n    let n = l2.len();\n\
    \    if n % 2 == 0 {\n        (l2[n / 2 - 1] + l2[n / 2]) as f64 / 2.0\n    }\
    \ else {\n        l2[n / 2] as f64\n    }", '    unimplemented!()', "    let n\
    \ = l.len();\n    let mid = n / 2;\n    if n % 2 == 0 {\n        let s = l[mid\
    \ - 1] + l[mid];\n        s as f64 / 2f64\n    } else {\n        let s = l[mid];\n\
    \        s as f64\n    }", "    let mut l_sorted = l.clone();\n    l_sorted.sort();\n\
    \    let len = l_sorted.len();\n    if len % 2 == 0 {\n        let t = l_sorted[len\
    \ / 2] + l_sorted[len / 2 - 1];\n        return t as f64 / 2.0;\n    } else {\n\
    \        return l_sorted[len / 2] as f64;\n    }", '    return calc_median(l);',
  "    let mut ll = l.clone();\n    ll.sort();\n    let mid = (ll.len() as f64 / 2.0).ceil()\
    \ as usize;\n    if ll.len() % 2 == 0 {\n        ((ll[mid] + ll[mid - 1]) as f64)\
    \ / 2.0\n    } else {\n        ll[mid] as f64\n    }", "    let mut l = l;\n \
    \   l.sort();\n    let len = l.len();\n    if len % 2 == 0 {\n        (l[len /\
    \ 2] + l[len / 2 - 1]) as f64 / 2.0\n    } else {\n        l[len / 2] as f64\n\
    \    }", "    let mid = l.len() / 2;\n    if l.len() % 2 == 0 {\n        (l[mid\
    \ - 1] + l[mid]) as f64 / 2.0\n    } else {\n        l[mid] as f64\n    }", " \
    \   // Sort the list.\n    let mut l = l;\n    l.sort();\n\n    // Get the length\
    \ of the list.\n    let len = l.len();\n\n    // Get the middle index.\n    let\
    \ middle = len / 2;\n\n    // If the list has an even number of elements, return\
    \ the average of the\n    // two middle elements.\n    if len % 2 == 0 {\n   \
    \     let mid1 = l[middle - 1];\n        let mid2 = l[middle];\n        return\
    \ (mid1 + mid2) as f64 / 2.0;\n    }\n\n    // Otherwise, return the middle element.\n\
    \    l[middle] as f64", "    let mut l: Vec<isize> = l;\n    l.sort();\n    let\
    \ mid = l.len() / 2;\n    if l.len() % 2 == 0 {\n        (l[mid] + l[mid - 1])\
    \ as f64 / 2.0\n    } else {\n        l[mid] as f64\n    }", "    // This solution\
    \ uses mergesort to sort the list, then finds the median.\n    // This is slow;\
    \ if you want to improve it, you may use other sorting\n    // algorithms such\
    \ as quicksort.\n    let mut sorted = merge_sort(l);\n    let len = sorted.len();\n\
    \    if len % 2 == 0 {\n        (sorted[len / 2 - 1] + sorted[len / 2]) as f64\
    \ / 2.0\n    } else {\n        sorted[len / 2] as f64\n    }", "    let len =\
    \ l.len();\n    let mut s = l.clone();\n    s.sort();\n    if len % 2 == 0 {\n\
    \        let m = len / 2;\n        (s[m] + s[m-1]) as f64 / 2.0\n    } else {\n\
    \        let m = len / 2;\n        s[m] as f64\n    }", "    if l.len() % 2 ==\
    \ 0 {\n        let half_len = l.len() / 2;\n        let half_len_plus_one = half_len\
    \ + 1;\n        let mut l_clone = l.clone();\n        l_clone.sort();\n      \
    \  let median_left = l_clone[half_len - 1];\n        let median_right = l_clone[half_len_plus_one\
    \ - 1];\n        (median_left + median_right) as f64 / 2.0\n    } else {\n   \
    \     let half_len = l.len() / 2;\n        let mut l_clone = l.clone();\n    \
    \    l_clone.sort();\n        l_clone[half_len] as f64\n    }", "    let mut vec\
    \ = l.clone();\n    vec.sort();\n    if vec.len() % 2 == 0 {\n        (vec[vec.len()\
    \ / 2] + vec[vec.len() / 2 - 1]) as f64 / 2.0\n    } else {\n        vec[vec.len()\
    \ / 2] as f64\n    }", "    let mut l: Vec<isize> = l;\n    l.sort();\n    let\
    \ n = l.len();\n    if n == 0 {\n        panic!(\"cannot compute median of empty\
    \ list\");\n    }\n    if n % 2 == 1 {\n        return (l[n / 2] as f64);\n  \
    \  } else {\n        return ((l[n / 2 - 1] + l[n / 2]) as f64) / 2.0;\n    }",
  "    let mut l = l;\n    l.sort();\n    if l.len() % 2 == 0 {\n        return (l[l.len()\
    \ / 2] + l[l.len() / 2 - 1]) as f64 / 2.0;\n    } else {\n        return l[l.len()\
    \ / 2] as f64;\n    }", "    if l.len() % 2 == 0 {\n        (l[l.len() / 2] +\
    \ l[l.len() / 2 - 1]) as f64 / 2.0\n    } else {\n        l[l.len() / 2] as f64\n\
    \    }", "    if l.len() % 2 == 0 {\n        return (l[l.len() / 2] + l[l.len()\
    \ / 2 - 1]) as f64 / 2.0;\n    }\n    l[l.len() / 2] as f64", "    let len = l.len();\n\
    \    if len == 0 {\n        return 0.0;\n    }\n    let mut sorted = l.clone();\n\
    \    sorted.sort();\n    let mid = len / 2;\n    if len % 2 == 0 {\n        (sorted[mid\
    \ - 1] + sorted[mid]) as f64 / 2.0\n    } else {\n        sorted[mid] as f64\n\
    \    }", "    let mid = l.len()/2;\n    if l.len() % 2 == 0 {\n        let sum:\
    \ f64 = (l[mid - 1] + l[mid]) as f64;\n        sum / 2.0\n    } else {\n     \
    \   (l[mid] as f64)\n    }", "    let n = l.len();\n    let s = l.into_iter().fold(0,\
    \ |a, b| a + b);\n    s as f64 / n as f64", "    // BEGIN_SOLUTION\n    let len\
    \ = l.len();\n    if len == 0 {\n        panic!(\"empty list\")\n    }\n    let\
    \ mut vec = l;\n    vec.sort();\n    if len % 2 == 0 {\n        (vec[len / 2 -\
    \ 1] + vec[len / 2]) as f64 / 2.0\n    } else {\n        vec[len / 2] as f64\n\
    \    }\n    // END_SOLUTION", "    let n = l.len();\n    let mut m = l.clone();\n\
    \    m.sort();\n    if n % 2 == 0 {\n        return (m[n / 2 - 1] + m[n / 2])\
    \ as f64 / 2.0;\n    } else {\n        return m[n / 2] as f64;\n    }", "    let\
    \ mut sorted = l.clone();\n    sorted.sort();\n    let len = sorted.len();\n \
    \   if len % 2 == 0 {\n        let mid_up = len / 2;\n        let mid_down = mid_up\
    \ - 1;\n        return ((sorted[mid_up] + sorted[mid_down]) as f64) / 2.0;\n \
    \   } else {\n        let mid = len / 2;\n        return sorted[mid] as f64;\n\
    \    }", "    if l.len() == 0 {\n        panic!(\"Empty list\");\n    }\n    let\
    \ mut sorted = l.clone();\n    sorted.sort();\n    if sorted.len() % 2 == 0 {\n\
    \        (sorted[sorted.len() / 2] + sorted[sorted.len() / 2 - 1]) as f64 / 2f64\n\
    \    } else {\n        sorted[sorted.len() / 2] as f64\n    }", "    // YOUR CODE\
    \ HERE\n    let mut m = l.clone();\n    m.sort();\n    let len = m.len();\n  \
    \  if len % 2 == 0 {\n        return (m[len / 2] + m[len / 2 - 1]) as f64 / 2.0;\n\
    \    } else {\n        return m[len / 2] as f64;\n    }", "    let mid = l.len()\
    \ / 2;\n    if l.len() % 2 == 0 {\n        let avg = (l[mid] + l[mid - 1]) as\
    \ f64 / 2.0;\n        avg\n    } else {\n        l[mid] as f64\n    }", "    let\
    \ mut l = l;\n    l.sort();\n    let n = l.len();\n    if n % 2 == 0 {\n     \
    \   let m = n / 2;\n        let avg = (l[m] + l[m-1]) as f64 / 2.0;\n        avg\n\
    \    } else {\n        l[n/2] as f64\n    }", "    let mut l = l;\n    l.sort();\n\
    \    let m = l.len() / 2;\n    if l.len() % 2 == 0 {\n        (l[m - 1] + l[m])\
    \ as f64 / 2.0\n    } else {\n        l[m] as f64\n    }", "    let mut sorted\
    \ = l.clone();\n    sorted.sort();\n    let middle = sorted.len() / 2;\n    if\
    \ sorted.len() % 2 == 0 {\n        (sorted[middle] + sorted[middle - 1]) as f64\
    \ / 2.0\n    } else {\n        sorted[middle] as f64\n    }", "    let mut l =\
    \ l;\n    l.sort();\n    let len = l.len();\n    match len {\n        0 => 0.0,\n\
    \        1 => l[0] as f64,\n        _ => {\n            let mid = len / 2;\n \
    \           if len % 2 == 0 {\n                (l[mid] + l[mid - 1]) as f64 /\
    \ 2.0\n            } else {\n                l[mid] as f64\n            }\n  \
    \      }\n    }", "    assert!(l.len() > 0);\n    let mut l = l;\n    l.sort();\n\
    \    if l.len() % 2 == 0 {\n        (l[l.len() / 2 - 1] + l[l.len() / 2]) as f64\
    \ / 2.0\n    } else {\n        l[l.len() / 2] as f64\n    }", "    let m = list_sum(l.clone())\
    \ / (l.len() as f64);\n    if l.len() % 2 == 0 {\n        (m + (list_sum(l.clone())\
    \ / (l.len() as f64))) / 2.0\n    } else {\n        m\n    }", '    unimplemented!();',
  "    if l.len() == 0 {\n        return 0.0;\n    }\n\n    // let mut l = l;\n  \
    \  // l.sort();\n    let mut l: Vec<isize> = l.iter().cloned().collect();\n  \
    \  l.sort();\n\n    let len = l.len();\n    if len % 2 == 0 {\n        return\
    \ (l[len / 2 - 1] + l[len / 2]) as f64 / 2.0;\n    } else {\n        return l[len\
    \ / 2] as f64;\n    }", "    let mut l_sort = l.clone();\n    l_sort.sort();\n\
    \    let len = l_sort.len();\n    if len % 2 == 0 {\n        (l_sort[len / 2]\
    \ + l_sort[len / 2 - 1]) as f64 / 2.0\n    } else {\n        l_sort[len / 2] as\
    \ f64\n    }", "    let m = l.len() / 2;\n    if l.len() % 2 == 0 {\n        (l[m]\
    \ + l[m - 1]) as f64 / 2.0\n    } else {\n        l[m] as f64\n    }", "    let\
    \ len = l.len();\n    let mut sorted_list = l.clone();\n    sorted_list.sort();\n\
    \    if len % 2 == 0 {\n        let mut median = (sorted_list[len / 2] + sorted_list[len\
    \ / 2 - 1]) as f64;\n        median /= 2.0;\n        median\n    } else {\n  \
    \      sorted_list[len / 2] as f64\n    }", "    // BEGIN_SOLUTION\n    let mid\
    \ = l.len() / 2;\n    if l.len() % 2 == 0 {\n        ((l[mid] + l[mid - 1]) as\
    \ f64) / 2.0\n    } else {\n        l[mid] as f64\n    }\n    // END_SOLUTION",
  "    let mut l1 = l.clone();\n    let mut l2 = l.clone();\n    l1.sort();\n    l2.sort_by(|x,\
    \ y| y.cmp(x));\n    if l1.len() % 2 == 0 {\n        let x = (l1[l1.len() / 2\
    \ - 1] + l1[l1.len() / 2]) as f64;\n        return x / 2.0;\n    } else {\n  \
    \      return l1[l1.len() / 2] as f64;\n    }", "    let mut b: Vec<isize> = l.clone();\n\
    \    b.sort();\n    let n = b.len();\n    if n % 2 == 0 {\n        let a = n /\
    \ 2;\n        (b[a] + b[a - 1]) as f64 / 2.0\n    } else {\n        b[n / 2] as\
    \ f64\n    }", "    let mut l2 = l.clone();\n    l2.sort();\n    let s = l2.len();\n\
    \    if s % 2 == 0 {\n        let i = s / 2;\n        (l2[i] + l2[i-1]) as f64\
    \ / 2.0\n    } else {\n        l2[s/2] as f64\n    }", "    let mut l = l;\n \
    \   l.sort();\n    let mid = l.len() / 2;\n    if l.len() % 2 == 0 {\n       \
    \ (l[mid - 1] + l[mid]) as f64 / 2.0\n    } else {\n        l[mid] as f64\n  \
    \  }", "    let mut m = l.clone();\n    m.sort();\n    let len = m.len();\n  \
    \  if len % 2 == 0 {\n        (m[len / 2] + m[len / 2 - 1]) as f64 / 2.0\n   \
    \ } else {\n        m[len / 2] as f64\n    }", "    let len = l.len();\n    if\
    \ len % 2 == 0 {\n        ((l[len / 2 - 1] + l[len / 2]) as f64) / 2.0\n    }\
    \ else {\n        l[len / 2] as f64\n    }", "    let l = l.clone();\n    let\
    \ mut l: Vec<isize> = l.into_iter().collect();\n    l.sort();\n    let n = l.len();\n\
    \    if n % 2 == 0 {\n        (l[n / 2 - 1] + l[n / 2]) as f64 / 2.0\n    } else\
    \ {\n        l[n / 2] as f64\n    }", "    let mut m = l.clone();\n    m.sort();\n\
    \    let len = m.len();\n    if len % 2 == 0 {\n        let i = len / 2;\n   \
    \     (m[i] + m[i-1]) as f64 / 2.0\n    } else {\n        m[len / 2] as f64\n\
    \    }", "    let mut new_l = l.clone();\n    new_l.sort();\n    let length =\
    \ new_l.len();\n    if length % 2 == 0 {\n        let n = new_l[length / 2];\n\
    \        let m = new_l[length / 2 - 1];\n        (n + m) as f64 / 2.0\n    } else\
    \ {\n        new_l[length / 2] as f64\n    }", "    if l.len() % 2 == 0 {\n  \
    \      let n = l.len() / 2;\n        (l[n] + l[n - 1]) as f64 / 2.0\n    } else\
    \ {\n        let n = l.len() / 2;\n        l[n] as f64\n    }", "    let mut list:\
    \ Vec<isize> = l;\n    list.sort();\n    let n = list.len();\n    if n % 2 ==\
    \ 0 {\n        (list[n / 2 - 1] + list[n / 2]) as f64 / 2.0\n    } else {\n  \
    \      list[n / 2] as f64\n    }", "    let n = l.len();\n    let median_index\
    \ = (n / 2) as usize;\n    let mut sorted_l = l.clone();\n    sorted_l.sort();\n\
    \    if n % 2 == 0 {\n        return ((sorted_l[median_index] + sorted_l[median_index\
    \ - 1]) as f64) / 2.0;\n    } else {\n        return sorted_l[median_index] as\
    \ f64;\n    }", "    let mut l = l;\n    l.sort();\n    let len = l.len();\n \
    \   let mid = len / 2;\n    match len % 2 {\n        0 => ((l[mid - 1] + l[mid])\
    \ as f64) / 2.0,\n        _ => l[mid] as f64,\n    }", "\t//let mut lcopy = l.clone();\n\
    \tlet mut lcopy = l.clone();\n\tlcopy.sort();\n\tlet len = lcopy.len();\n\tif\
    \ len % 2 == 0 {\n\t\t(lcopy[len/2 - 1] + lcopy[len/2]) as f64 / 2.0\n\t} else\
    \ {\n\t\tlcopy[len/2] as f64\n\t}", "    let l_sort = l.clone();\n    let mut\
    \ l_sort_desc: Vec<isize> = l_sort.iter().cloned().collect();\n    l_sort_desc.sort();\n\
    \    let mut l_sort_asc: Vec<isize> = l_sort.iter().cloned().collect();\n    l_sort_asc.sort_by(|a,\
    \ b| b.cmp(a));\n    if l_sort_asc.len() % 2 == 0 {\n        let mid = l_sort_asc.len()\
    \ / 2;\n        (l_sort_asc[mid] + l_sort_asc[mid - 1]) as f64 / 2.0\n    } else\
    \ {\n        l_sort_asc[l_sort_asc.len() / 2] as f64\n    }", "    let len = l.len();\n\
    \    let mut out = 0.0;\n    let mut li = l.clone();\n    li.sort();\n    if len\
    \ % 2 == 0 {\n        let index = len / 2;\n        out = (li[index - 1] + li[index])\
    \ as f64 / 2.0;\n    } else {\n        let index = len / 2;\n        out = li[index]\
    \ as f64;\n    }\n    out", "    let mut m = l.clone();\n    m.sort();\n    let\
    \ len = m.len();\n    if len % 2 == 0 {\n        (m[len / 2] + m[len / 2 - 1])\
    \ as f64 / 2.0\n    } else {\n        m[len / 2] as f64\n    }", "    if l.len()\
    \ == 0 {\n        return 0.0;\n    }\n    let mut l_copy = l.clone();\n    l_copy.sort();\n\
    \    let n = l_copy.len();\n    return (l_copy[n / 2] + l_copy[(n - 1) / 2]) as\
    \ f64 / 2.0;", "    let mut l = l;\n    let n = l.len();\n    l.sort();\n    if\
    \ n % 2 == 0 {\n        (l[n / 2 - 1] + l[n / 2]) as f64 / 2.0\n    } else {\n\
    \        l[n / 2] as f64\n    }"]
stop_tokens:
- "\n}"
