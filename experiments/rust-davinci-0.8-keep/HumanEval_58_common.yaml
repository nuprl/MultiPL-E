name: HumanEval_58_common
language: rust
prompt: "/// Return sorted unique common elements for two lists.\n/// >>> common([1,\
  \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n/// [1, 5, 653]\n/// >>> common([5,\
  \ 3, 2, 8], [3, 2])\n/// [2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize>\
  \ {\n"
tests: "}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
  \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
  \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
  \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
  \ Vec::<isize>::new());\n}\n"
completions: ['    l1.into_iter().filter(|&x| l2.contains(&x)).collect()', "    let\
    \ mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    let\
    \ mut i = 0;\n    let mut j = 0;\n    let mut result = Vec::new();\n    while\
    \ i < l1.len() && j < l2.len() {\n        if l1[i] == l2[j] {\n            result.push(l1[i]);\n\
    \            i += 1;\n            j += 1;\n        } else if l1[i] < l2[j] {\n\
    \            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    result", "    let mut res = Vec::new();\n    if l1.len() == 0 || l2.len()\
    \ == 0 {\n        return res;\n    }\n    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    let mut i = 0;\n    let mut j = 0;\n    while\
    \ i < l1.len() && j < l2.len() {\n        if l1[i] == l2[j] {\n            res.push(l1[i]);\n\
    \            i += 1;\n            j += 1;\n        } else if l1[i] < l2[j] {\n\
    \            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    res", "    let mut all = l1.iter().chain(l2.iter()).collect::<Vec<_>>();\n\
    \    all.sort();\n    all.dedup();\n    all", "    let mut common = Vec::new();\n\
    \    for x in l1 {\n        if l2.contains(&x) {\n            common.push(x);\n\
    \        }\n    }\n    common.sort();\n    common.dedup();\n    common", '    l1.iter().filter(|x|
    l2.contains(x)).cloned().collect::<Vec<isize>>()', "    // ...\n    // ... your\
    \ code here\n    // ...\n    let mut li1: Vec<isize> = l1.iter().cloned().collect();\n\
    \    let mut li2: Vec<isize> = l2.iter().cloned().collect();\n    li1.sort();\n\
    \    li2.sort();\n    let mut i = 0;\n    let mut j = 0;\n    let mut res: Vec<isize>\
    \ = Vec::new();\n    while i < li1.len() && j < li2.len() {\n        if li1[i]\
    \ == li2[j] {\n            res.push(li1[i]);\n            i += 1;\n          \
    \  j += 1;\n        } else if li1[i] < li2[j] {\n            i += 1;\n       \
    \ } else {\n            j += 1;\n        }\n    }\n    res", "    let mut res\
    \ = Vec::new();\n    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n\
    \    l2.sort();\n    let (mut a, mut b) = (0, 0);\n    while a < l1.len() && b\
    \ < l2.len() {\n        if l1[a] == l2[b] {\n            if !res.contains(&l1[a])\
    \ {\n                res.push(l1[a]);\n            }\n            a += 1;\n  \
    \          b += 1;\n        } else if l1[a] < l2[b] {\n            a += 1;\n \
    \       } else {\n            b += 1;\n        }\n    }\n    res", "    let mut\
    \ result = Vec::new();\n    for el in l1 {\n        if l2.contains(&el) && !result.contains(&el)\
    \ {\n            result.push(el);\n        }\n    }\n    result.sort();\n    result",
  "    let mut v1 = l1.clone();\n    let mut v2 = l2.clone();\n    v1.sort();\n  \
    \  v2.sort();\n    let mut v3 = Vec::new();\n    let mut v4 = Vec::new();\n  \
    \  let mut v = Vec::new();\n    if v1.len() < v2.len() {\n        for i in 0..v1.len()\
    \ {\n            if v1[i] == v2[i] {\n                v3.push(v1[i]);\n      \
    \      }\n        }\n    } else {\n        for i in 0..v2.len() {\n          \
    \  if v1[i] == v2[i] {\n                v4.push(v2[i]);\n            }\n     \
    \   }\n    }\n    for i in 0..v3.len() {\n        if !v.contains(&v3[i]) {\n \
    \           v.push(v3[i]);\n        }\n    }\n    for i in 0..v4.len() {\n   \
    \     if !v.contains(&v4[i]) {\n            v.push(v4[i]);\n        }\n    }\n\
    \    v", "    let mut res = l1.into_iter().collect::<Vec<isize>>();\n    res.extend(l2.into_iter());\n\
    \    res.sort();\n    res.dedup();\n    res", "    let mut l1 = l1;\n    let mut\
    \ l2 = l2;\n    l1.sort();\n    l2.sort();\n    let mut l1_iter = l1.iter();\n\
    \    let mut l2_iter = l2.iter();\n    let mut l1_val = *l1_iter.next().unwrap();\n\
    \    let mut l2_val = *l2_iter.next().unwrap();\n    let mut result = Vec::new();\n\
    \    loop {\n        if l1_val == l2_val {\n            result.push(l1_val);\n\
    \            l1_val = *l1_iter.next().unwrap_or(&isize::min_value());\n      \
    \      l2_val = *l2_iter.next().unwrap_or(&isize::min_value());\n        } else\
    \ if l1_val < l2_val {\n            l1_val = *l1_iter.next().unwrap_or(&isize::min_value());\n\
    \        } else {\n            l2_val = *l2_iter.next().unwrap_or(&isize::min_value());\n\
    \        }\n        if l1_val == isize::min_value() && l2_val == isize::min_value()\
    \ {\n            break;\n        }\n    }\n    result", "    let mut result =\
    \ vec![];\n    for item in l1 {\n        if l2.contains(&item) && !result.contains(&item)\
    \ {\n            result.push(item);\n        }\n    }\n    result.sort();\n  \
    \  result", "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n\
    \    l1.retain(|x| l2.contains(x));\n    l1.dedup();\n    l1", "  let mut result\
    \ = vec![];\n  for item in l1 {\n    if l2.contains(&item) && !result.contains(&item)\
    \ {\n      result.push(item);\n    }\n  }\n  result.sort();\n  result", '    l1.iter().filter(|&x|
    l2.contains(x)).copied().collect()', "  let mut inter: Vec<isize> = Vec::new();\n\
    \  let mut min_len: usize = l1.len();\n  let l: &Vec<isize> = if l2.len() < min_len\
    \ {\n    min_len = l2.len();\n    &l2\n  } else {\n    &l1\n  };\n  for x in l\
    \ {\n    if l1.contains(x) && l2.contains(x) {\n      inter.push(*x);\n    }\n\
    \  }\n  inter.sort();\n  inter.dedup();\n  inter", "    let mut l: Vec<isize>\
    \ = Vec::new();\n    let mut a = l1.iter().collect::<Vec<&isize>>();\n    let\
    \ mut b = l2.iter().collect::<Vec<&isize>>();\n    a.sort();\n    b.sort();\n\
    \    let mut i = 0;\n    let mut j = 0;\n    while i < a.len() && j < b.len()\
    \ {\n        if a[i] == b[j] {\n            l.push(*a[i]);\n            i += 1;\n\
    \            j += 1;\n        } else if a[i] < b[j] {\n            i += 1;\n \
    \       } else {\n            j += 1;\n        }\n    }\n    l", "    let mut\
    \ l1: Vec<isize> = l1;\n    let mut l2: Vec<isize> = l2;\n    l1.sort();\n   \
    \ l2.sort();\n    let l3: Vec<isize> = l1.iter().filter(|&x| l2.contains(x)).cloned().collect();\n\
    \    l3.iter().unique().cloned().collect()", '    unimplemented!()', "    let\
    \ set1: BTreeSet<isize> = l1.into_iter().collect();\n    let set2: BTreeSet<isize>\
    \ = l2.into_iter().collect();\n    let mut v: Vec<isize> = set1.intersection(&set2).cloned().collect();\n\
    \    v.sort();\n    v", "    // TODO: write code here\n    vec![]", "    let mut\
    \ result = Vec::new();\n    let mut l2 = l2;\n    l2.sort();\n    for i in l1\
    \ {\n        if !result.contains(&i) && l2.binary_search(&i).is_ok() {\n     \
    \       result.push(i);\n        }\n    }\n    result.sort();\n    result", " \
    \   let mut s1 = l1.into_iter().collect::<HashSet<_>>();\n    let mut s2 = l2.into_iter().collect::<HashSet<_>>();\n\
    \    s1.retain(|x| s2.contains(x));\n    s1.into_iter().collect::<Vec<_>>()",
  "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n  \
    \  let mut result = Vec::new();\n    let mut i = 0;\n    let mut j = 0;\n    while\
    \ i < l1.len() && j < l2.len() {\n        if l1[i] == l2[j] {\n            result.push(l1[i]);\n\
    \            i += 1;\n            j += 1;\n        } else if l1[i] < l2[j] {\n\
    \            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    result", '    unimplemented!()', "    let mut l1 = l1;\n    let mut l2 =\
    \ l2;\n    l1.sort();\n    l2.sort();\n    l1.iter().cloned().filter(|n| l2.contains(n)).collect()",
  "    let mut i = 0;\n    let mut j = 0;\n    let mut res = Vec::new();\n    while\
    \ i < l1.len() && j < l2.len() {\n        if l1[i] < l2[j] {\n            i +=\
    \ 1;\n        } else if l1[i] > l2[j] {\n            j += 1;\n        } else {\n\
    \            if i == 0 || l1[i] != l1[i - 1] {\n                res.push(l1[i]);\n\
    \            }\n            i += 1;\n            j += 1;\n        }\n    }\n \
    \   res", "    let mut l1_s = l1.clone();\n    let mut l2_s = l2.clone();\n  \
    \  l1_s.sort();\n    l2_s.sort();\n    l1_s.into_iter().filter(|x| l2_s.contains(x)).collect()",
  "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n  \
    \  let mut result = Vec::new();\n    let mut i = 0;\n    let mut j = 0;\n    while\
    \ i < l1.len() && j < l2.len() {\n        if l1[i] == l2[j] {\n            result.push(l1[i]);\n\
    \            i += 1;\n            j += 1;\n        } else if l1[i] < l2[j] {\n\
    \            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    result", "    let mut out = Vec::new();\n    for i in l1 {\n        if l2.contains(&i)\
    \ && !out.contains(&i) {\n            out.push(i);\n        }\n    }\n    out.sort();\n\
    \    out", '    unimplemented!()', "    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    l1.dedup();\n    l2.dedup();\n    l1.into_iter().filter(|x|\
    \ l2.contains(x)).collect()", "    let mut res = Vec::new();\n    let mut l1 =\
    \ l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    l1.dedup();\n\
    \    l2.dedup();\n    l1.retain(|&x| l2.contains(&x));\n    l1", "    let mut\
    \ result = Vec::new();\n    for i in l1 {\n        if l2.contains(&i) && !result.contains(&i)\
    \ {\n            result.push(i);\n        }\n    }\n    result.sort();\n    result",
  "    let mut unique_l1 = l1.into_iter().collect::<HashSet<isize>>();\n    let mut\
    \ unique_l2 = l2.into_iter().collect::<HashSet<isize>>();\n    unique_l1.retain(|x|\
    \ unique_l2.contains(x));\n    let mut common = unique_l1.into_iter().collect::<Vec<isize>>();\n\
    \    common.sort();\n    common", "    let set1: HashSet<_> = l1.into_iter().collect();\n\
    \    let set2: HashSet<_> = l2.into_iter().collect();\n    set1.intersection(&set2).map(|&x|\
    \ x).collect()", "    let mut s1 = l1.iter().cloned().collect::<BTreeSet<isize>>();\n\
    \    let mut s2 = l2.iter().cloned().collect::<BTreeSet<isize>>();\n    s1.intersection(&s2).cloned().collect()",
  '    l1.into_iter().filter(|&x| l2.contains(&x)).collect()', "    let mut result\
    \ = Vec::new();\n    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n\
    \    l2.sort();\n    l1.dedup();\n    l2.dedup();\n    for i in 0..l1.len() {\n\
    \        for j in 0..l2.len() {\n            if l1[i] == l2[j] {\n           \
    \     result.push(l1[i]);\n            }\n        }\n    }\n    result", "   \
    \ // TODO: implement this function\n    unimplemented!()", "    let res: Vec<isize>\
    \ = l1.iter().filter(|&x| l2.contains(x)).copied().collect();\n    res", '    l1.iter().filter(|el|
    l2.contains(el)).cloned().collect::<Vec<isize>>()', '    unimplemented!()', '    unimplemented!();',
  "    // TODO: https://www.reddit.com/r/rust/comments/38m0ab/common_is_not_in_scope/\n\
    \    let mut res = vec![];\n    for x in l1 {\n        if l2.contains(&x) && !res.contains(&x)\
    \ {\n            res.push(x);\n        }\n    }\n    res.sort();\n    res", " \
    \   let mut res = Vec::new();\n    let mut sorted1 = l1.clone();\n    let mut\
    \ sorted2 = l2.clone();\n    sorted1.sort();\n    sorted2.sort();\n    let mut\
    \ i = 0;\n    let mut j = 0;\n    while i < sorted1.len() && j < sorted2.len()\
    \ {\n        if sorted1[i] == sorted2[j] {\n            res.push(sorted1[i]);\n\
    \            i += 1;\n            j += 1;\n        } else if sorted1[i] < sorted2[j]\
    \ {\n            i += 1;\n        } else {\n            j += 1;\n        }\n \
    \   }\n    res", "    let mut uniq_l1 = l1.clone();\n    uniq_l1.sort();\n   \
    \ uniq_l1.dedup();\n    let mut uniq_l2 = l2.clone();\n    uniq_l2.sort();\n \
    \   uniq_l2.dedup();\n    uniq_l1.iter().filter(|&x| uniq_l2.contains(x)).cloned().collect()",
  '    unimplemented!()', "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n\
    \    l2.sort();\n    let l1 = l1.dedup();\n    let l2 = l2.dedup();\n    let mut\
    \ res = Vec::new();\n    for i in l1 {\n        if l2.contains(&i) {\n       \
    \     res.push(i);\n        }\n    }\n    res", "    let mut l1: Vec<isize> =\
    \ l1;\n    let mut l2: Vec<isize> = l2;\n    l1.sort();\n    l2.sort();\n    let\
    \ l3: Vec<isize> = l1.into_iter().filter(|a| l2.contains(a)).collect();\n    return\
    \ l3;", '    unimplemented!()', "    let mut res = vec![];\n    for (idx, val)\
    \ in l1.iter().enumerate() {\n        if l2.contains(val) {\n            res.push(*val);\n\
    \        }\n    }\n    let mut res = res.to_vec();\n    res.sort();\n    res.dedup();\n\
    \    res", '    l1.iter().cloned().filter(|&x| l2.contains(&x)).collect()', " \
    \   let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n \
    \   let mut res = Vec::new();\n    let mut ix1 = 0;\n    let mut ix2 = 0;\n  \
    \  while ix1 < l1.len() && ix2 < l2.len() {\n        if l1[ix1] == l2[ix2] {\n\
    \            res.push(l1[ix1]);\n            ix1 += 1;\n            ix2 += 1;\n\
    \        } else if l1[ix1] < l2[ix2] {\n            ix1 += 1;\n        } else\
    \ {\n            ix2 += 1;\n        }\n    }\n    res", "    let mut v = l1.iter().map(|&x|\
    \ x).collect::<Vec<isize>>();\n    v.extend(l2.iter().map(|&x| x));\n    v.sort();\n\
    \    v.dedup();\n    v", "    let mut result = vec![];\n    for i in l1 {\n  \
    \      if l2.contains(&i) && !result.contains(&i) {\n            result.push(i);\n\
    \        }\n    }\n    result.sort();\n    result", "    // TODO write your code\
    \ here\n    l1.iter().filter(|&x| l2.contains(x)).map(|&x| x).collect()", '    return
    Vec::new();', "    let mut sorted1 = l1.clone();\n    sorted1.sort();\n    let\
    \ mut sorted2 = l2.clone();\n    sorted2.sort();\n    let mut common: Vec<isize>\
    \ = Vec::new();\n    let mut i = 0;\n    let mut j = 0;\n    while i < sorted1.len()\
    \ && j < sorted2.len() {\n        if sorted1[i] == sorted2[j] {\n            common.push(sorted1[i]);\n\
    \            i += 1;\n            j += 1;\n        } else if sorted1[i] < sorted2[j]\
    \ {\n            i += 1;\n        } else {\n            j += 1;\n        }\n \
    \   }\n    let mut result: Vec<isize> = Vec::new();\n    for k in 0..common.len()\
    \ {\n        if k == 0 || common[k] != common[k - 1] {\n            result.push(common[k]);\n\
    \        }\n    }\n    result", "    let mut v: Vec<isize> = Vec::new();\n   \
    \ for item in l1 {\n        if l2.contains(&item) {\n            v.push(item);\n\
    \        }\n    }\n    v.sort();\n    v.dedup();\n    v", "    let mut m1 = hashmap!{};\n\
    \    let mut m2 = hashmap!{};\n    let mut ret = vec![];\n    for i in l1 {\n\
    \        m1.insert(i, 1);\n    }\n    for i in l2 {\n        m2.insert(i, 1);\n\
    \    }\n    for (k, _) in m1 {\n        if m2.contains_key(&k) {\n           \
    \ ret.push(k);\n        }\n    }\n    ret.sort();\n    ret", '  vec![]', "   \
    \ let mut new_list = Vec::new();\n    for i in l1 {\n        if l2.contains(&i)\
    \ {\n            new_list.push(i);\n        }\n    }\n    new_list.sort();\n \
    \   new_list.dedup();\n    new_list", '    l1.iter().filter(|&x| l2.contains(x)).map(|&x|
    x).collect()', "    let mut v = Vec::new();\n    let mut count = 0;\n    for i\
    \ in l1 {\n        for j in l2 {\n            if i == j {\n                v.push(i);\n\
    \                count += 1;\n            }\n        }\n    }\n    v.sort();\n\
    \    v.dedup();\n    v", "    let mut v: Vec<isize> = l1.into_iter().filter(|x|\
    \ l2.contains(x)).collect();\n    v.sort();\n    v.dedup();\n    v", "    let\
    \ mut result = Vec::new();\n    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n\
    \    l2.sort();\n    l1.dedup();\n    l2.dedup();\n    let mut l1 = l1.into_iter();\n\
    \    let mut l2 = l2.into_iter();\n    while let (Some(n1), Some(n2)) = (l1.next(),\
    \ l2.next()) {\n        if n1 == n2 {\n            result.push(n1);\n        }\
    \ else if n1 < n2 {\n            l2 = l2.skip_while(|n| *n < n1);\n        } else\
    \ {\n            l1 = l1.skip_while(|n| *n < n2);\n        }\n    }\n    result",
  '    unimplemented!();', "    let mut elements: Vec<isize> = Vec::new();\n    let\
    \ mut both_lists: Vec<isize> = Vec::new();\n    both_lists.extend(l1);\n    both_lists.extend(l2);\n\
    \    both_lists.sort();\n    both_lists.dedup();\n    for el in both_lists {\n\
    \        if l1.contains(&el) && l2.contains(&el) {\n            elements.push(el);\n\
    \        }\n    }\n    elements", "    let mut hm: HashMap<isize, isize> = HashMap::new();\n\
    \    let mut result: Vec<isize> = Vec::new();\n    for v in l1 {\n        *hm.entry(v).or_insert(0)\
    \ += 1;\n    }\n    for v in l2 {\n        if hm.contains_key(&v) {\n        \
    \    *hm.entry(v).or_insert(0) += 1;\n        }\n    }\n    for (k, v) in hm {\n\
    \        if v > 1 {\n            result.push(k);\n        }\n    }\n    result.sort();\n\
    \    result", "    let mut v1 = l1.clone();\n    let mut v2 = l2.clone();\n  \
    \  v1.sort();\n    v2.sort();\n    let mut v3 = Vec::new();\n    let mut i = 0;\n\
    \    let mut j = 0;\n    while i < v1.len() && j < v2.len() {\n        if v1[i]\
    \ < v2[j] {\n            i += 1;\n        } else if v1[i] > v2[j] {\n        \
    \    j += 1;\n        } else {\n            v3.push(v1[i]);\n            i +=\
    \ 1;\n            j += 1;\n        }\n    }\n    v3", "    let mut l1 = l1;\n\
    \    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    l1.dedup();\n    l2.dedup();\n\
    \    l1.retain(|x| l2.contains(x));\n    l1", '    unimplemented!()', '    l1.intersect(&l2).cloned().collect()',
  "    let mut result = Vec::new();\n    let mut set_2 = HashSet::new();\n    for\
    \ n in l2 {\n        set_2.insert(n);\n    }\n    for n in l1 {\n        if set_2.contains(&n)\
    \ {\n            result.push(n);\n        }\n    }\n    result.sort();\n    result.dedup();\n\
    \    result", '    unimplemented!();', "    let mut v1 = l1.clone();\n    let\
    \ mut v2 = l2.clone();\n    v1.sort();\n    v2.sort();\n    let mut v3 = vec![];\n\
    \    let mut c = 0;\n    let mut c1 = 0;\n    let mut c2 = 0;\n    while c1 <\
    \ v1.len() && c2 < v2.len() {\n        if v1[c1] == v2[c2] {\n            if c\
    \ == 0 {\n                v3.push(v1[c1]);\n                c += 1;\n        \
    \    } else if v3[c - 1] != v1[c1] {\n                v3.push(v1[c1]);\n     \
    \           c += 1;\n            }\n            c1 += 1;\n            c2 += 1;\n\
    \        } else if v1[c1] < v2[c2] {\n            c1 += 1;\n        } else {\n\
    \            c2 += 1;\n        }\n    }\n    v3", "  let mut res = Vec::new();\n\
    \  for e in l1 {\n    if l2.contains(&e) && !res.contains(&e) {\n      res.push(e);\n\
    \    }\n  }\n  res.sort();\n  res", "    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    l1.dedup();\n    l2.dedup();\n    l1.retain(|&x|\
    \ l2.contains(&x));\n    l1", "    if l1.len() < l2.len() {\n        common(l2,\
    \ l1)\n    } else {\n        l1.iter().cloned().filter(|x| l2.contains(x)).collect()\n\
    \    }", "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n\
    \    return l1.iter().filter(|x| l2.contains(x)).map(|x| *x).collect();", "  \
    \  fn _common(l1: &[isize], l2: &[isize], acc: &mut Vec<isize>) {\n        if\
    \ l1.is_empty() || l2.is_empty() {\n            return;\n        }\n        if\
    \ l1[0] < l2[0] {\n            _common(&l1[1..], l2, acc);\n        } else if\
    \ l1[0] > l2[0] {\n            _common(l1, &l2[1..], acc);\n        } else {\n\
    \            acc.push(l1[0]);\n            _common(&l1[1..], &l2[1..], acc);\n\
    \        }\n    }\n    let mut res = Vec::new();\n    _common(&l1, &l2, &mut res);\n\
    \    res", "    let mut list1 = l1.clone();\n    let mut list2 = l2.clone();\n\
    \    list1.sort();\n    list2.sort();\n    let mut v: Vec<isize> = Vec::new();\n\
    \    let mut i1 = 0;\n    let mut i2 = 0;\n    while i1 < list1.len() && i2 <\
    \ list2.len() {\n        if list1[i1] < list2[i2] {\n            i1 += 1;\n  \
    \      } else if list1[i1] > list2[i2] {\n            i2 += 1;\n        } else\
    \ {\n            v.push(list1[i1]);\n            i1 += 1;\n            i2 += 1;\n\
    \        }\n    }\n    v", "    use std::collections::HashSet;\n    let hs: HashSet<isize>\
    \ = l1.into_iter().collect();\n    let hs2: HashSet<isize> = l2.into_iter().collect();\n\
    \    let mut l: Vec<isize> = Vec::new();\n    for x in hs2 {\n        if hs.contains(&x)\
    \ {\n            l.push(x);\n        }\n    }\n    l.sort();\n    l.dedup();\n\
    \    l", "    let mut set1: BTreeSet<isize> = BTreeSet::new();\n    let mut set2:\
    \ BTreeSet<isize> = BTreeSet::new();\n    for n in l1 {\n        set1.insert(n);\n\
    \    }\n    for n in l2 {\n        set2.insert(n);\n    }\n    set1.intersection(&set2).cloned().collect()",
  "    let mut res = Vec::new();\n    let mut i = 0;\n    let mut j = 0;\n    l1.sort();\n\
    \    l2.sort();\n    while i < l1.len() && j < l2.len() {\n        if l1[i] ==\
    \ l2[j] {\n            if res.len() == 0 || res[res.len() - 1] != l1[i] {\n  \
    \              res.push(l1[i]);\n            }\n            i += 1;\n        \
    \    j += 1;\n        } else if l1[i] < l2[j] {\n            i += 1;\n       \
    \ } else {\n            j += 1;\n        }\n    }\n    res", "    let mut res\
    \ = vec![];\n    for x in l1 {\n        if l2.contains(&x) && !res.contains(&x)\
    \ {\n            res.push(x);\n        }\n    }\n    res.sort();\n    res", " \
    \   // TODO: Implement\n    vec![]", "    let mut set1: HashSet<isize> = HashSet::new();\n\
    \    let mut set2: HashSet<isize> = HashSet::new();\n    let mut common: HashSet<isize>\
    \ = HashSet::new();\n\n    // Add numbers to sets\n    for x in l1 {\n       \
    \ set1.insert(x);\n    }\n    for x in l2 {\n        set2.insert(x);\n    }\n\n\
    \    // Check for any common numbers\n    for x in set1 {\n        if set2.contains(&x)\
    \ {\n            common.insert(x);\n        }\n    }\n\n    // Sort the common\
    \ numbers\n    let mut common_vec: Vec<isize> = Vec::new();\n    for x in common\
    \ {\n        common_vec.push(x);\n    }\n    common_vec.sort();\n\n    common_vec",
  "    let mut uniq_l1 = l1.clone();\n    uniq_l1.sort();\n    uniq_l1.dedup();\n\
    \    let mut uniq_l2 = l2.clone();\n    uniq_l2.sort();\n    uniq_l2.dedup();\n\
    \    let mut ret: Vec<isize> = vec![];\n    for i in uniq_l1 {\n        if uniq_l2.contains(&i)\
    \ {\n            ret.push(i);\n        }\n    }\n    ret", "    let mut res =\
    \ Vec::new();\n    let mut l1_clone = l1.clone();\n    let mut l2_clone = l2.clone();\n\
    \    l1_clone.sort();\n    l2_clone.sort();\n    let mut i = 0;\n    let mut j\
    \ = 0;\n    while i < l1_clone.len() && j < l2_clone.len() {\n        if l1_clone[i]\
    \ == l2_clone[j] {\n            res.push(l1_clone[i]);\n            i += 1;\n\
    \            j += 1;\n        } else if l1_clone[i] < l2_clone[j] {\n        \
    \    i += 1;\n        } else {\n            j += 1;\n        }\n    }\n    res",
  "    let mut r1 = l1.clone();\n    let mut r2 = l2.clone();\n    r1.sort();\n  \
    \  r2.sort();\n    r1.retain(|&x| r2.contains(&x));\n    r1.sort();\n    r1.dedup();\n\
    \    r1", "    let mut ret: Vec<isize> = vec![];\n    let mut set1: HashSet<isize>\
    \ = HashSet::new();\n    let mut set2: HashSet<isize> = HashSet::new();\n    for\
    \ i in l1 {\n        set1.insert(i);\n    }\n    for i in l2 {\n        set2.insert(i);\n\
    \    }\n    for i in set1.intersection(&set2) {\n        ret.push(*i);\n    }\n\
    \    ret.sort();\n    ret", '    unimplemented!();', "    let mut l1 = l1;\n \
    \   let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    l1.retain(|&v| l2.contains(&v));\n\
    \    l1.dedup();\n    l1", "  let l1 = l1.into_iter().collect::<HashSet<_>>();\n\
    \  let l2 = l2.into_iter().collect::<HashSet<_>>();\n  l1.intersection(&l2).cloned().collect::<Vec<_>>()",
  "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n  \
    \  let mut l1 = l1.iter();\n    let mut l2 = l2.iter();\n    let mut l1i = l1.next();\n\
    \    let mut l2i = l2.next();\n    let mut result = Vec::new();\n    while l1i.is_some()\
    \ && l2i.is_some() {\n        if l1i.unwrap() == l2i.unwrap() {\n            result.push(*l1i.unwrap());\n\
    \            l1i = l1.next();\n            l2i = l2.next();\n        } else if\
    \ l1i.unwrap() < l2i.unwrap() {\n            l1i = l1.next();\n        } else\
    \ {\n            l2i = l2.next();\n        }\n    }\n    result", "  //remove\
    \ duplicates\n  let set1: HashSet<isize> = l1.into_iter().collect();\n  let set2:\
    \ HashSet<isize> = l2.into_iter().collect();\n  //find common values\n  let mut\
    \ common: Vec<isize> = set1.intersection(&set2).cloned().collect();\n  //sort\n\
    \  common.sort();\n  common", "    let mut result = Vec::new();\n    for e in\
    \ l1 {\n        if l2.contains(&e) && !result.contains(&e) {\n            result.push(e);\n\
    \        }\n    }\n    result.sort();\n    result", "    if l1.len() == 0 || l2.len()\
    \ == 0 {\n        return vec![];\n    }\n    let mut res = vec![];\n    for (k,\
    \ v) in l1.iter().enumerate() {\n        if k == 0 {\n            res.push(*v);\n\
    \        } else {\n            let mut left = 0;\n            let mut right =\
    \ res.len() - 1;\n            while left <= right {\n                let mid =\
    \ (left + right) / 2;\n                if res[mid] == *v {\n                 \
    \   break;\n                } else if res[mid] < *v {\n                    left\
    \ = mid + 1;\n                } else {\n                    right = mid - 1;\n\
    \                }\n            }\n            if left > right {\n           \
    \     res.insert(left, *v);\n            }\n        }\n    }\n    let mut tmp\
    \ = vec![];\n    for (k, v) in l2.iter().enumerate() {\n        if k == 0 {\n\
    \            tmp.push(*v);\n        } else {\n            let mut left = 0;\n\
    \            let mut right = tmp.len() - 1;\n            while left <= right {\n\
    \                let mid = (left + right) / 2;\n                if tmp[mid] ==\
    \ *v {\n                    break;\n                } else if tmp[mid] < *v {\n\
    \                    left = mid + 1;\n                } else {\n             \
    \       right = mid - 1;\n                }\n            }\n            if left\
    \ > right {\n                tmp.insert(left, *v);\n            }\n        }\n\
    \    }\n    let mut res2 = vec![];\n    let mut index1 = 0;\n    let mut index2\
    \ = 0;\n    while index1 < res.len() && index2 < tmp.len() {\n        if res[index1]\
    \ == tmp[index2] {\n            res2.push(res[index1]);\n            index1 +=\
    \ 1;\n            index2 += 1;\n        } else if res[index1] < tmp[index2] {\n\
    \            index1 += 1;\n        } else {\n            index2 += 1;\n      \
    \  }\n    }\n    res2", '    unimplemented!()', "    let mut s1 = l1.into_iter().collect::<BTreeSet<_>>();\n\
    \    let mut s2 = l2.into_iter().collect::<BTreeSet<_>>();\n    s1.retain(|&x|\
    \ s2.contains(&x));\n    s1.into_iter().collect()", "    fn _common(l1: &[isize],\
    \ l2: &[isize], acc: &mut Vec<isize>) {\n        if l1.is_empty() || l2.is_empty()\
    \ {\n            return;\n        }\n\n        let (h1, t1) = l1.split_first().unwrap();\n\
    \        let (h2, t2) = l2.split_first().unwrap();\n\n        match h1.cmp(h2)\
    \ {\n            Ordering::Less => _common(t1, l2, acc),\n            Ordering::Greater\
    \ => _common(l1, t2, acc),\n            Ordering::Equal => {\n               \
    \ acc.push(*h1);\n                _common(t1, t2, acc);\n            }\n     \
    \   }\n    }\n\n    let mut result = Vec::new();\n    _common(&l1, &l2, &mut result);\n\
    \    result", "    let mut ret: Vec<isize> = vec![];\n    let mut l1 = l1;\n \
    \   let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    let mut iter1 = l1.iter();\n\
    \    let mut iter2 = l2.iter();\n    let mut val1 = iter1.next();\n    let mut\
    \ val2 = iter2.next();\n    while val1.is_some() && val2.is_some() {\n       \
    \ let v1 = val1.unwrap();\n        let v2 = val2.unwrap();\n        if v1 < v2\
    \ {\n            val1 = iter1.next();\n        } else if v1 > v2 {\n         \
    \   val2 = iter2.next();\n        } else {\n            ret.push(*v1);\n     \
    \       val1 = iter1.next();\n            val2 = iter2.next();\n        }\n  \
    \  }\n    ret", '    l1.intersect(&l2).cloned().collect()', "    let mut l1 =\
    \ l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    l1.dedup();\n\
    \    l2.dedup();\n    l1.iter().filter(|&x| l2.contains(x)).cloned().collect()",
  '    l1.iter().filter(|&x| l2.contains(x)).cloned().collect::<Vec<isize>>()', " \
    \   let mut l1: Vec<isize> = l1;\n    let mut l2: Vec<isize> = l2;\n    l1.sort();\n\
    \    l2.sort();\n    let mut result: Vec<isize> = Vec::new();\n    let mut list1:\
    \ Vec<isize> = Vec::new();\n    let mut list2: Vec<isize> = Vec::new();\n    let\
    \ mut result: Vec<isize> = Vec::new();\n    let mut prev: isize = -1;\n    for\
    \ e in l1.iter() {\n        list1.push(*e);\n    }\n    for e in l2.iter() {\n\
    \        list2.push(*e);\n    }\n    while !list1.is_empty() && !list2.is_empty()\
    \ {\n        let (value1, value2) = (list1[0], list2[0]);\n        if value1 ==\
    \ value2 {\n            if value1 != prev {\n                result.push(value1);\n\
    \                prev = value1;\n            }\n            list1.remove(0);\n\
    \            list2.remove(0);\n        } else if value1 < value2 {\n         \
    \   list1.remove(0);\n        } else {\n            list2.remove(0);\n       \
    \ }\n    }\n    result", "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n\
    \    l2.sort();\n    let mut i = 0;\n    let mut j = 0;\n    let mut res = Vec::new();\n\
    \    while i < l1.len() && j < l2.len() {\n        if l1[i] < l2[j] {\n      \
    \      i += 1;\n        } else if l1[i] > l2[j] {\n            j += 1;\n     \
    \   } else {\n            res.push(l1[i]);\n            i += 1;\n            j\
    \ += 1;\n        }\n    }\n    res", "    let mut res = l1.clone();\n    let mut\
    \ l1 = l1;\n    l1.sort();\n    let mut l2 = l2;\n    l2.sort();\n    let mut\
    \ n1 = 0;\n    let mut n2 = 0;\n    loop {\n        if n1 == l1.len() || n2 ==\
    \ l2.len() {\n            break;\n        }\n        if l1[n1] == l2[n2] {\n \
    \           res.push(l1[n1]);\n            n1 += 1;\n            n2 += 1;\n  \
    \      } else if l1[n1] < l2[n2] {\n            n1 += 1;\n        } else {\n \
    \           n2 += 1;\n        }\n    }\n    res.sort();\n    res.dedup();\n  \
    \  res", '    unimplemented!()', "    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    l1.dedup();\n    l2.dedup();\n    l1.retain(|x|\
    \ l2.contains(x));\n    l1", '    unimplemented!()', "    let mut res = Vec::new();\n\
    \    let mut l1_set = l1.clone().into_iter().collect::<HashSet<isize>>();\n  \
    \  let mut l2_set = l2.clone().into_iter().collect::<HashSet<isize>>();\n    for\
    \ item in l1_set.intersection(&l2_set) {\n        res.push(*item);\n    }\n  \
    \  res.sort();\n    res", "    let mut m1 = HashMap::new();\n    let mut m2 =\
    \ HashMap::new();\n    for i in l1 {\n        if m1.contains_key(&i) {\n     \
    \       m1.insert(i, *m1.get(&i).unwrap() + 1);\n        } else {\n          \
    \  m1.insert(i, 1);\n        }\n    }\n    for i in l2 {\n        if m2.contains_key(&i)\
    \ {\n            m2.insert(i, *m2.get(&i).unwrap() + 1);\n        } else {\n \
    \           m2.insert(i, 1);\n        }\n    }\n    let mut res = Vec::new();\n\
    \    for (k, v) in m1 {\n        if m2.contains_key(&k) {\n            let v2\
    \ = *m2.get(&k).unwrap();\n            let v1 = v;\n            let c = std::cmp::min(v1,\
    \ v2);\n            for _ in 0..c {\n                res.push(k);\n          \
    \  }\n        }\n    }\n    res.sort();\n    res", "    let s1: HashSet<isize>\
    \ = l1.into_iter().collect();\n    let s2: HashSet<isize> = l2.into_iter().collect();\n\
    \    let output: Vec<isize> = s1.intersection(&s2).cloned().collect();\n    output.sort();\n\
    \    output", "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n  \
    \  l2.sort();\n    l1.iter().filter(|&x| l2.contains(x)).cloned().collect()",
  "    let mut s1 = l1.clone();\n    let mut s2 = l2.clone();\n    s1.sort();\n  \
    \  s2.sort();\n    return s1.into_iter().filter(|x| s2.contains(x)).collect();",
  "    let mut result = Vec::new();\n    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    let mut i = 0;\n    let mut j = 0;\n    let\
    \ len1 = l1.len();\n    let len2 = l2.len();\n    while i < len1 && j < len2 {\n\
    \        if l1[i] == l2[j] {\n            result.push(l1[i]);\n            i +=\
    \ 1;\n            j += 1;\n        } else if l1[i] < l2[j] {\n            i +=\
    \ 1;\n        } else {\n            j += 1;\n        }\n    }\n    result", '    l1.into_iter().filter(|&x|
    l2.contains(&x)).collect()', "    let a: HashSet<_> = l1.into_iter().collect();\n\
    \    let b: HashSet<_> = l2.into_iter().collect();\n    let c: HashSet<_> = a.intersection(&b).cloned().collect();\n\
    \    let mut v: Vec<isize> = c.into_iter().collect();\n    v.sort();\n    v",
  "  if l1.len() == 0 || l2.len() == 0 {\n    return Vec::new();\n  }\n  l1.into_iter().filter(|x|\
    \ l2.contains(x)).collect()", "    let mut l1 = l1;\n    let mut l2 = l2;\n  \
    \  l1.sort();\n    l2.sort();\n    l1.dedup();\n    l2.dedup();\n    l1.retain(|x|\
    \ l2.contains(x));\n    l1", "  let l1_set: HashSet<_> = l1.into_iter().collect();\n\
    \  let l2_set: HashSet<_> = l2.into_iter().collect();\n  let common_elements:\
    \ HashSet<_> = l1_set.intersection(&l2_set).collect();\n  let mut common_vec:\
    \ Vec<isize> = common_elements.into_iter().collect();\n  common_vec.sort();\n\
    \  common_vec", "    let mut set: HashSet<isize> = HashSet::new();\n    for n\
    \ in l1 {\n        set.insert(n);\n    }\n    let mut v2: Vec<isize> = Vec::new();\n\
    \    for n in l2 {\n        if set.contains(&n) {\n            v2.push(n);\n \
    \       }\n    }\n    v2.sort();\n    v2.dedup();\n    v2", "    let mut res =\
    \ Vec::new();\n    let mut i1 = 0;\n    let mut i2 = 0;\n    let mut last_val:\
    \ isize = 0;\n    let mut sorted_l1 = l1.clone();\n    let mut sorted_l2 = l2.clone();\n\
    \    sorted_l1.sort();\n    sorted_l2.sort();\n    while i1 < sorted_l1.len()\
    \ && i2 < sorted_l2.len() {\n        if sorted_l1[i1] == sorted_l2[i2] {\n   \
    \         if sorted_l1[i1] != last_val {\n                res.push(sorted_l1[i1]);\n\
    \                last_val = sorted_l1[i1];\n            }\n            i1 += 1;\n\
    \            i2 += 1;\n        } else if sorted_l1[i1] < sorted_l2[i2] {\n   \
    \         i1 += 1;\n        } else {\n            i2 += 1;\n        }\n    }\n\
    \    res", "    let uniq1 = l1.into_iter().collect::<HashSet<_>>();\n    let uniq2\
    \ = l2.into_iter().collect::<HashSet<_>>();\n    uniq1.intersection(&uniq2).cloned().collect::<Vec<_>>()",
  "    let mut result = vec![];\n    for x in l1 {\n        if l2.contains(&x) &&\
    \ !result.contains(&x) {\n            result.push(x);\n        }\n    }\n    result.sort();\n\
    \    result", "    let mut common_list: Vec<isize> = Vec::new();\n    for i in\
    \ 0..l1.len() {\n        if let Some(idx) = l2.iter().position(|&x| x == l1[i])\
    \ {\n            common_list.push(l1[i]);\n            common_list.push(l2[idx]);\n\
    \        }\n    }\n    let mut unique_list: Vec<isize> = Vec::new();\n    for\
    \ i in 0..common_list.len() {\n        if let Some(idx) = unique_list.iter().position(|&x|\
    \ x == common_list[i]) {\n            unique_list.remove(idx);\n        } else\
    \ {\n            unique_list.push(common_list[i]);\n        }\n    }\n    unique_list.sort();\n\
    \    unique_list", "    let mut result = Vec::new();\n    for i in l1 {\n    \
    \    if l2.contains(&i) && !result.contains(&i) {\n            result.push(i);\n\
    \        }\n    }\n    result.sort();\n    result", "    let mut result = Vec::new();\n\
    \    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n\
    \    for i in 0..l1.len() {\n        for j in 0..l2.len() {\n            if l1[i]\
    \ == l2[j] {\n                result.push(l1[i]);\n                l2.remove(j);\n\
    \                break;\n            }\n        }\n    }\n    result", "    let\
    \ mut set1: HashSet<isize> = HashSet::new();\n    let mut set2: HashSet<isize>\
    \ = HashSet::new();\n    let mut result: Vec<isize> = Vec::new();\n\n    for i\
    \ in l1 {\n        set1.insert(i);\n    }\n    for i in l2 {\n        set2.insert(i);\n\
    \    }\n\n    for i in set1.intersection(&set2) {\n        result.push(*i);\n\
    \    }\n\n    result.sort();\n    result", "    let mut l1 = l1;\n    let mut\
    \ l2 = l2;\n    l1.sort();\n    l2.sort();\n    l1.iter().filter(|e| l2.contains(e)).cloned().collect()",
  "    let mut v1 = l1.clone();\n    let mut v2 = l2.clone();\n    v1.sort();\n  \
    \  v2.sort();\n    let mut v1_index = 0;\n    let mut v2_index = 0;\n    let mut\
    \ result = Vec::new();\n    while v1_index < v1.len() && v2_index < v2.len() {\n\
    \        if v1[v1_index] < v2[v2_index] {\n            v1_index += 1;\n      \
    \  } else if v1[v1_index] > v2[v2_index] {\n            v2_index += 1;\n     \
    \   } else {\n            result.push(v1[v1_index]);\n            v1_index +=\
    \ 1;\n            v2_index += 1;\n        }\n    }\n    result", "    let mut\
    \ l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    let mut\
    \ sorted_common = Vec::new();\n    let mut i = 0;\n    let mut j = 0;\n    while\
    \ i < l1.len() && j < l2.len() {\n        if l1[i] < l2[j] {\n            i +=\
    \ 1;\n        } else if l1[i] > l2[j] {\n            j += 1;\n        } else {\n\
    \            sorted_common.push(l1[i]);\n            i += 1;\n            j +=\
    \ 1;\n        }\n    }\n    sorted_common", "    let l1 = l1.into_iter().collect::<HashSet<_>>();\n\
    \    let l2 = l2.into_iter().collect::<HashSet<_>>();\n    l1.intersection(&l2).cloned().collect()",
  "    let mut v = l1.iter().collect::<Vec<&isize>>();\n    v.sort();\n    v.dedup();\n\
    \    let mut v2 = l2.iter().collect::<Vec<&isize>>();\n    v2.sort();\n    v2.dedup();\n\
    \    let mut v3 = Vec::new();\n    for i in v {\n        if v2.contains(i) {\n\
    \            v3.push(*i);\n        }\n    }\n    v3", "    let set1: HashSet<isize>\
    \ = l1.into_iter().collect();\n    let set2: HashSet<isize> = l2.into_iter().collect();\n\
    \    let intersection: HashSet<isize> = set1.intersection(&set2).map(|&x| x).collect();\n\
    \    let mut result: Vec<isize> = intersection.into_iter().collect();\n    result.sort();\n\
    \    result", "    let l1: HashSet<isize> = l1.into_iter().collect();\n    let\
    \ l2: HashSet<isize> = l2.into_iter().collect();\n    let l3: HashSet<isize> =\
    \ l1.intersection(&l2).map(|v| *v).collect();\n    l3.into_iter().collect()",
  "    let mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n  \
    \  l1.dedup();\n    l2.dedup();\n    l1.retain(|v| l2.contains(v));\n    l1",
  "    let mut l1_unique: Vec<isize> = l1.into_iter().unique().collect();\n    let\
    \ mut l2_unique: Vec<isize> = l2.into_iter().unique().collect();\n    l1_unique.sort();\n\
    \    l2_unique.sort();\n    let mut res: Vec<isize> = Vec::new();\n    let mut\
    \ l1_iter = l1_unique.iter();\n    let mut l2_iter = l2_unique.iter();\n    let\
    \ mut l1_next: isize = match l1_iter.next() {\n        Some(x) => *x,\n      \
    \  None => return res,\n    };\n    let mut l2_next: isize = match l2_iter.next()\
    \ {\n        Some(x) => *x,\n        None => return res,\n    };\n    loop {\n\
    \        match l1_next.cmp(&l2_next) {\n            Ordering::Equal => {\n   \
    \             res.push(l1_next);\n                l1_next = match l1_iter.next()\
    \ {\n                    Some(x) => *x,\n                    None => break,\n\
    \                };\n                l2_next = match l2_iter.next() {\n      \
    \              Some(x) => *x,\n                    None => break,\n          \
    \      };\n            }\n            Ordering::Less => {\n                l1_next\
    \ = match l1_iter.next() {\n                    Some(x) => *x,\n             \
    \       None => break,\n                };\n            }\n            Ordering::Greater\
    \ => {\n                l2_next = match l2_iter.next() {\n                   \
    \ Some(x) => *x,\n                    None => break,\n                };\n   \
    \         }\n        }\n    }\n    res", "    let mut res = Vec::new();\n    let\
    \ mut l1_iter = l1.iter();\n    let mut l2_iter = l2.iter();\n    let mut l1_next\
    \ = l1_iter.next();\n    let mut l2_next = l2_iter.next();\n    while l1_next.is_some()\
    \ && l2_next.is_some() {\n        let mut x = *l1_next.unwrap();\n        let\
    \ mut y = *l2_next.unwrap();\n        match x.cmp(&y) {\n            Ordering::Equal\
    \ => {\n                res.push(x);\n                l1_next = l1_iter.next();\n\
    \                l2_next = l2_iter.next();\n            }\n            Ordering::Less\
    \ => {\n                l1_next = l1_iter.next();\n            }\n           \
    \ Ordering::Greater => {\n                l2_next = l2_iter.next();\n        \
    \    }\n        }\n    }\n    res", "    let mut result = Vec::new();\n    let\
    \ mut d1 = l1.iter().map(|x| (*x, 1)).collect::<HashMap<isize, isize>>();\n  \
    \  let mut d2 = l2.iter().map(|x| (*x, 1)).collect::<HashMap<isize, isize>>();\n\
    \    for k in d1.keys() {\n        if d2.contains_key(k) {\n            result.push(*k);\n\
    \        }\n    }\n    result.sort();\n    result", "    let s1: HashSet<_> =\
    \ l1.into_iter().collect();\n    let s2: HashSet<_> = l2.into_iter().collect();\n\
    \    let intersect: HashSet<_> = s1.intersection(&s2).cloned().collect();\n  \
    \  let mut v: Vec<isize> = intersect.into_iter().collect();\n    v.sort();\n \
    \   v", "    let mut res = Vec::new();\n    let mut tmp = [l1, l2];\n    tmp[0].sort();\n\
    \    tmp[1].sort();\n    for i in 0..tmp[0].len() {\n        if tmp[0][i] == tmp[1][i]\
    \ {\n            res.push(tmp[0][i]);\n        }\n    }\n    res", "    let mut\
    \ res = Vec::new();\n    let mut i = 0;\n    let mut j = 0;\n    while i < l1.len()\
    \ && j < l2.len() {\n        if l1[i] < l2[j] {\n            i += 1;\n       \
    \ } else if l1[i] > l2[j] {\n            j += 1;\n        } else {\n         \
    \   if res.len() == 0 || res[res.len() - 1] != l1[i] {\n                res.push(l1[i]);\n\
    \            }\n            i += 1;\n            j += 1;\n        }\n    }\n \
    \   res", "    let mut res = Vec::new();\n    for v in l1 {\n        if l2.contains(&v)\
    \ && !res.contains(&v) {\n            res.push(v);\n        }\n    }\n    res.sort();\n\
    \    res", "    let mut l1: Vec<isize> = l1;\n    let mut l2: Vec<isize> = l2;\n\
    \    l1.sort();\n    l2.sort();\n    l1.retain(|&x| l2.contains(&x));\n    l1.dedup();\n\
    \    l1", "    let mut set1: HashSet<isize> = HashSet::new();\n    let mut set2:\
    \ HashSet<isize> = HashSet::new();\n    let mut common_vec: Vec<isize> = Vec::new();\n\
    \n    for item in l1 {\n        set1.insert(item);\n    }\n\n    for item in l2\
    \ {\n        set2.insert(item);\n    }\n\n    for item in set1.intersection(&set2)\
    \ {\n        common_vec.push(*item);\n    }\n\n    common_vec.sort();\n    common_vec",
  "    let mut l3 = l1.clone();\n    l3.extend(l2.clone());\n    l3.sort();\n    l3.dedup();\n\
    \    l3.into_iter().filter(|x| l1.contains(x) && l2.contains(x)).collect()", " \
    \   let mut v1 = l1.clone();\n    let mut v2 = l2.clone();\n    v1.sort();\n \
    \   v2.sort();\n    let mut l = Vec::new();\n    let mut i = 0;\n    let mut j\
    \ = 0;\n    while i < v1.len() && j < v2.len() {\n        if v1[i] == v2[j] {\n\
    \            l.push(v1[i]);\n            i += 1;\n            j += 1;\n      \
    \  } else if v1[i] < v2[j] {\n            i += 1;\n        } else {\n        \
    \    j += 1;\n        }\n    }\n    l", "    let u1 = unique(l1);\n    let u2\
    \ = unique(l2);\n    let mut result = Vec::new();\n    for u in u1 {\n       \
    \ if u2.contains(&u) {\n            result.push(u);\n        }\n    }\n    result.sort();\n\
    \    result", '    unimplemented!()', "    let mut l1: Vec<isize> = l1;\n    let\
    \ mut l2: Vec<isize> = l2;\n    l1.sort();\n    l2.sort();\n    let mut l1_i =\
    \ 0;\n    let mut l2_i = 0;\n    let mut res = Vec::new();\n    loop {\n     \
    \   if l1_i >= l1.len() || l2_i >= l2.len() {\n            break;\n        }\n\
    \        if l1[l1_i] < l2[l2_i] {\n            l1_i += 1;\n        } else if l1[l1_i]\
    \ > l2[l2_i] {\n            l2_i += 1;\n        } else {\n            res.push(l1[l1_i]);\n\
    \            l1_i += 1;\n            l2_i += 1;\n        }\n    }\n    res", " \
    \   let mut list1 = l1.clone();\n    let mut list2 = l2.clone();\n    list1.sort();\n\
    \    list2.sort();\n    let mut i = 0;\n    let mut j = 0;\n    let mut output\
    \ = Vec::new();\n    while i < list1.len() && j < list2.len() {\n        if list1[i]\
    \ == list2[j] {\n            output.push(list1[i]);\n            i += 1;\n   \
    \         j += 1;\n        } else if list1[i] < list2[j] {\n            i += 1;\n\
    \        } else {\n            j += 1;\n        }\n    }\n    output", "    let\
    \ mut result = vec![];\n    // iterate over the first list\n    for i in l1 {\n\
    \        // check if list contains i\n        if l2.contains(&i) {\n         \
    \   result.push(i);\n        }\n    }\n    result.sort();\n    result.dedup();\n\
    \    result", "    let mut x: Vec<isize> = Vec::new();\n    let mut y: Vec<isize>\
    \ = Vec::new();\n    x.extend(l1);\n    y.extend(l2);\n    let mut v1: Vec<_>\
    \ = x.clone().into_iter().collect();\n    let mut v2: Vec<_> = y.clone().into_iter().collect();\n\
    \    v1.sort();\n    v2.sort();\n    let mut m1: Vec<isize> = Vec::new();\n  \
    \  let mut m2: Vec<isize> = Vec::new();\n    for i in v1.iter() {\n        if\
    \ m1.contains(i) {\n            continue;\n        }\n        m1.push(*i);\n \
    \   }\n    for i in v2.iter() {\n        if m2.contains(i) {\n            continue;\n\
    \        }\n        m2.push(*i);\n    }\n    let mut v3: Vec<isize> = Vec::new();\n\
    \    for i in m1.iter() {\n        if m2.contains(i) {\n            v3.push(*i);\n\
    \        }\n    }\n    v3", "    if l1.len() == 0 || l2.len() == 0 {\n       \
    \ return Vec::new();\n    }\n    let mut result = Vec::new();\n    for i in 0..l1.len()\
    \ {\n        for j in 0..l2.len() {\n            if l1[i] == l2[j] {\n       \
    \         result.push(l1[i]);\n            }\n        }\n    }\n    result.sort();\n\
    \    result.dedup();\n    result", "    let mut l1 = l1;\n    let mut l2 = l2;\n\
    \    l1.sort();\n    l2.sort();\n    let mut result = Vec::new();\n    let mut\
    \ i = 0;\n    let mut j = 0;\n    while i < l1.len() && j < l2.len() {\n     \
    \   if l1[i] == l2[j] {\n            result.push(l1[i]);\n            i += 1;\n\
    \            j += 1;\n        } else if l1[i] < l2[j] {\n            i += 1;\n\
    \        } else {\n            j += 1;\n        }\n    }\n    result", "    let\
    \ mut l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    let\
    \ mut set1 = HashSet::new();\n    for i in l1 {\n        set1.insert(i);\n   \
    \ }\n    let mut set2 = HashSet::new();\n    for i in l2 {\n        set2.insert(i);\n\
    \    }\n    let mut intersect: Vec<isize> = vec![];\n    for i in set1 {\n   \
    \     if set2.contains(&i) {\n            intersect.push(i);\n        }\n    }\n\
    \    intersect", "    let mut common_elements: Vec<isize> = vec![];\n    for i\
    \ in 0..l1.len() {\n        for j in 0..l2.len() {\n            if l1[i] == l2[j]\
    \ {\n                common_elements.push(l1[i]);\n            }\n        }\n\
    \    }\n    common_elements.sort();\n    common_elements.dedup();\n    common_elements",
  '    l1.into_iter().filter(|n| l2.contains(n)).collect()', "    let m1 = set(l1);\n\
    \    let m2 = set(l2);\n    let mut res = Vec::new();\n    for key in m1.keys()\
    \ {\n        if m2.contains_key(key) {\n            res.push(*key);\n        }\n\
    \    }\n    res.sort();\n    res", "    let mut uniques = Vec::new();\n    for\
    \ i in l1 {\n        for j in l2.iter() {\n            if i == *j {\n        \
    \        uniques.push(i);\n            }\n        }\n    }\n    uniques.sort();\n\
    \    uniques.dedup();\n    uniques", "    // TODO\n    vec![]", "    let mut l1\
    \ = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    let (mut l1,\
    \ mut l2) = (l1.into_iter(), l2.into_iter());\n    let mut common = Vec::new();\n\
    \    let (mut a, mut b) = (l1.next(), l2.next());\n    while let (Some(a_num),\
    \ Some(b_num)) = (a, b) {\n        if a_num == b_num {\n            common.push(a_num);\n\
    \            a = l1.next();\n            b = l2.next();\n        } else if a_num\
    \ < b_num {\n            a = l1.next();\n        } else {\n            b = l2.next();\n\
    \        }\n    }\n    common", '    return intersection(l1, l2);', "    let mut\
    \ o: Vec<isize> = Vec::new();\n    for &x in l1.iter() {\n        for &y in l2.iter()\
    \ {\n            if x == y {\n                o.push(x);\n            }\n    \
    \    }\n    }\n    o.sort();\n    o.dedup();\n    o", '    unimplemented!()',
  "    // let set1: HashSet<isize> = l1.into_iter().collect();\n    // let set2: HashSet<isize>\
    \ = l2.into_iter().collect();\n    // let intersect = set1.intersection(&set2);\n\
    \    // let mut ret = intersect.into_iter().collect::<Vec<&isize>>();\n    //\
    \ ret.sort();\n    // ret\n    vec![]", "    let mut l1 = l1;\n    let mut l2\
    \ = l2;\n    l1.sort();\n    l2.sort();\n    let l1 = l1.into_iter().unique();\n\
    \    let l2 = l2.into_iter().unique();\n    let mut result = vec![];\n    for\
    \ i in l1 {\n        if l2.contains(&i) {\n            result.push(i);\n     \
    \   }\n    }\n    result", "    let mut common_elements: Vec<isize> = Vec::new();\n\
    \    let mut l1_iter = l1.iter();\n    let mut l2_iter = l2.iter();\n    let mut\
    \ prev_elt = None;\n    while let (Some(a), Some(b)) = (l1_iter.next(), l2_iter.next())\
    \ {\n        if a == b {\n            common_elements.push(*a);\n            prev_elt\
    \ = Some(*a);\n        } else if a > b {\n            l1_iter = l1.iter().skip_while(|&x|\
    \ x <= b || Some(x) == prev_elt);\n        } else {\n            l2_iter = l2.iter().skip_while(|&x|\
    \ x <= a || Some(x) == prev_elt);\n        }\n    }\n    common_elements", " \
    \   let l1 = l1.into_iter().collect::<BTreeSet<_>>();\n    let l2 = l2.into_iter().collect::<BTreeSet<_>>();\n\
    \    l1.intersection(&l2).map(|&x| x).collect()", "    let mut seen = HashSet::new();\n\
    \    let mut res = Vec::new();\n    let mut l1 = l1;\n    let mut l2 = l2;\n \
    \   l1.sort();\n    l2.sort();\n    for n in l1.iter() {\n        if seen.contains(n)\
    \ {\n            continue;\n        }\n        seen.insert(*n);\n        for m\
    \ in l2.iter() {\n            if n == m {\n                res.push(*n);\n   \
    \             break;\n            }\n        }\n    }\n    res", "    let mut\
    \ out = vec![];\n    let mut l1_set = l1.iter().map(|x| *x).collect::<HashSet<isize>>();\n\
    \    let mut l2_set = l2.iter().map(|x| *x).collect::<HashSet<isize>>();\n   \
    \ for n in l1_set.iter() {\n        if l2_set.contains(n) {\n            out.push(*n);\n\
    \        }\n    }\n    return out;", "    let s1: BTreeSet<isize> = l1.into_iter().collect();\n\
    \    let s2: BTreeSet<isize> = l2.into_iter().collect();\n    s1.intersection(&s2).map(|i|\
    \ *i).collect()", "    // TODO: implement this function using map-reduce\n   \
    \ let m = l1.iter().map(|&x| x).collect::<HashSet<isize>>();\n    let n = l2.iter().map(|&x|\
    \ x).collect::<HashSet<isize>>();\n    let mut r = m.intersection(&n).map(|&x|\
    \ x).collect::<Vec<isize>>();\n    r.sort();\n    r", "    // remove duplicates\n\
    \    let l1 = uniq(l1);\n    let l2 = uniq(l2);\n\n    let mut a = l1.clone();\n\
    \    let mut b = l2.clone();\n\n    // sort\n    a.sort();\n    b.sort();\n\n\
    \    // merge\n    let mut common = Vec::new();\n    let mut j = 0;\n    for i\
    \ in 0..a.len() {\n        loop {\n            if j >= b.len() {\n           \
    \     break;\n            }\n            if a[i] == b[j] {\n                common.push(a[i]);\n\
    \                j += 1;\n                break;\n            } else if a[i] <\
    \ b[j] {\n                break;\n            } else {\n                j += 1;\n\
    \            }\n        }\n    }\n\n    common", "    let mut v1 = l1.clone();\n\
    \    let mut v2 = l2.clone();\n    v1.sort();\n    v2.sort();\n    let mut v:\
    \ Vec<isize> = Vec::new();\n    let mut i1 = 0;\n    let mut i2 = 0;\n    while\
    \ i1 < v1.len() && i2 < v2.len() {\n        if v1[i1] == v2[i2] {\n          \
    \  v.push(v1[i1]);\n            i1 += 1;\n            i2 += 1;\n        } else\
    \ if v1[i1] < v2[i2] {\n            i1 += 1;\n        } else {\n            i2\
    \ += 1;\n        }\n    }\n    v", '    l1.iter().filter(|&x| l2.contains(x)).cloned().collect::<Vec<isize>>()',
  "    let mut result = l1\n        .into_iter()\n        .filter(|x| l2.contains(x))\n\
    \        .collect::<Vec<isize>>();\n    result.sort();\n    result.dedup();\n\
    \    result", "    // TODO\n    let mut l3: Vec<isize> = Vec::new();\n    if l1.len()\
    \ >= l2.len() {\n        for i in 0..l1.len() {\n            for j in 0..l2.len()\
    \ {\n                if l1[i] == l2[j] {\n                    l3.push(l1[i]);\n\
    \                }\n            }\n        }\n    } else {\n        for i in 0..l2.len()\
    \ {\n            for j in 0..l1.len() {\n                if l2[i] == l1[j] {\n\
    \                    l3.push(l2[i]);\n                }\n            }\n     \
    \   }\n    }\n    l3.sort();\n    l3.dedup();\n    l3", '    unimplemented!()',
  "    let mut union = l1.clone();\n    union.extend(l2.clone());\n    union.sort();\n\
    \    let mut a = true;\n    let mut uniq = Vec::new();\n    for n in union {\n\
    \        if a && n == uniq.last().unwrap_or(&0) {\n            a = false;\n  \
    \      } else {\n            uniq.push(n);\n            a = true;\n        }\n\
    \    }\n    uniq", '    unimplemented!()', "    let mut l1 = l1;\n    let mut\
    \ l2 = l2;\n    l1.sort();\n    l2.sort();\n    let mut li = Vec::new();\n   \
    \ let mut i = 0;\n    let mut j = 0;\n    while i < l1.len() && j < l2.len() {\n\
    \        let v1 = l1[i];\n        let v2 = l2[j];\n        if v1 == v2 {\n   \
    \         li.push(v1);\n            i += 1;\n            j += 1;\n        } else\
    \ if v1 < v2 {\n            i += 1;\n        } else {\n            j += 1;\n \
    \       }\n    }\n    li", "    // TODO: implement\n    vec![]", "    let mut\
    \ l1 = l1;\n    let mut l2 = l2;\n    l1.sort();\n    l2.sort();\n    let mut\
    \ out = Vec::new();\n    let mut l1i = 0;\n    let mut l2i = 0;\n    loop {\n\
    \        if l1i == l1.len() || l2i == l2.len() {\n            break;\n       \
    \ }\n        if l1[l1i] < l2[l2i] {\n            l1i += 1;\n        } else if\
    \ l1[l1i] > l2[l2i] {\n            l2i += 1;\n        } else {\n            out.push(l1[l1i]);\n\
    \            l1i += 1;\n            l2i += 1;\n        }\n    }\n    out", '    unimplemented!();',
  '    unimplemented!();', "    let mut r: Vec<isize> = Vec::new();\n    let mut m1:\
    \ HashMap<isize, bool> = HashMap::new();\n    let mut m2: HashMap<isize, bool>\
    \ = HashMap::new();\n    for i in l1 {\n        m1.insert(i, true);\n    }\n \
    \   for i in l2 {\n        m2.insert(i, true);\n    }\n    for i in l1 {\n   \
    \     if m2.contains_key(&i) {\n            r.push(i);\n        }\n    }\n   \
    \ r.sort();\n    r.dedup();\n    r", '    unimplemented!();', "    let mut l:\
    \ Vec<isize> = l1\n        .iter()\n        .filter(|&e| l2.contains(e))\n   \
    \     .map(|&e| e)\n        .collect();\n    l.sort();\n    l.dedup();\n    l",
  "    let mut result = vec![];\n    for i in l1 {\n        if l2.contains(&i) &&\
    \ !result.contains(&i) {\n            result.push(i);\n        }\n    }\n    result.sort();\n\
    \    result", "    let mut result = Vec::new();\n    for i in l1 {\n        if\
    \ l2.contains(&i) && !result.contains(&i) {\n            result.push(i);\n   \
    \     }\n    }\n    result.sort();\n    result", "    fn uniq<T: Eq + Copy>(l:\
    \ Vec<T>) -> Vec<T> {\n        let mut out = Vec::new();\n        for i in l {\n\
    \            if !out.contains(&i) {\n                out.push(i);\n          \
    \  }\n        }\n        out\n    }\n\n    fn sort<T: Ord + Copy>(l: Vec<T>) ->\
    \ Vec<T> {\n        let mut out = l.clone();\n        out.sort();\n        out\n\
    \    }\n\n    sort(uniq(l1.iter().filter(|&x| l2.contains(x)).map(|&x| x).collect()))",
  "    let mut ret = Vec::new();\n    for elem in l1 {\n        if l2.contains(&elem)\
    \ && !ret.contains(&elem) {\n            ret.push(elem);\n        }\n    }\n \
    \   ret.sort();\n    ret", "    // TODO: Write code here\n    return Vec::new();",
  "    let mut l1: Vec<isize> = l1;\n    let mut l2: Vec<isize> = l2;\n    l1.sort();\n\
    \    l2.sort();\n    let mut i1 = 0;\n    let mut i2 = 0;\n    let mut ret = Vec::new();\n\
    \    loop {\n        if i1 == l1.len() || i2 == l2.len() {\n            break;\n\
    \        }\n        if l1[i1] < l2[i2] {\n            i1 += 1;\n        } else\
    \ if l1[i1] > l2[i2] {\n            i2 += 1;\n        } else {\n            ret.push(l1[i1]);\n\
    \            i1 += 1;\n            i2 += 1;\n        }\n    }\n    ret"]
stop_tokens:
- "\n}"
