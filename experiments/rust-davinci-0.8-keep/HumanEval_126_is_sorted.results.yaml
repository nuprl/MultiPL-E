name: HumanEval_126_is_sorted
language: rust
results:
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut max = isize::min_value();\n    let mut count = 0;\n \
    \   for x in lst {\n        if x >= max {\n            max = x;\n            count\
    \ += 1;\n        }\n    }\n    count == lst.len()\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `lst`\n   --> /tmp/tmpfs8g4s3o.rs:22:14\n\
    \    |\n13  | fn is_sorted(lst: Vec<isize>) -> bool {\n    |              ---\
    \ move occurs because `lst` has type `Vec<isize>`, which does not implement the\
    \ `Copy` trait\n...\n16  |     for x in lst {\n    |              --- `lst` moved\
    \ due to this implicit call to `.into_iter()`\n...\n22  |     count == lst.len()\n\
    \    |              ^^^^^^^^^ value borrowed here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n    |\n16  |     for x in &lst {\n    |              +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut last = std::isize::MIN;\n    let mut counter = 0;\n \
    \   for i in lst {\n        if i > last {\n            last = i;\n           \
    \ counter = 0;\n        } else if i == last {\n            counter += 1;\n   \
    \     } else {\n            return false;\n        }\n        if counter > 1 {\n\
    \            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n   \
    \ let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst = lst;\n    lst.sort();\n    lst.dedup();\n    lst\
    \ == lst.iter().rev().collect::<Vec<&isize>>()\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp8fpq0rel.rs:17:9\n\
    \   |\n17 |     lst == lst.iter().rev().collect::<Vec<&isize>>()\n   |       \
    \  ^^ no implementation for `isize == &isize`\n   |\n   = help: the trait `PartialEq<&isize>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n   = note: required because of the requirements\
    \ on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let sorted = lst.iter().copied().collect::<Vec<isize>>();\n \
    \   sorted == lst\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpxee5y7gz.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    // TODO\n    false\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpjpu6juy7.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst = lst;\n    lst.sort();\n    lst.dedup();\n    lst\
    \ == lst.clone().sort()\n}\n\nfn main() {\n    let candidate = is_sorted;\n  \
    \  assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `Vec<isize>` with `()`\n  --> /tmp/tmp3i7ubox6.rs:17:9\n\
    \   |\n17 |     lst == lst.clone().sort()\n   |         ^^ no implementation for\
    \ `Vec<isize> == ()`\n   |\n   = help: the trait `PartialEq<()>` is not implemented\
    \ for `Vec<isize>`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n             <Vec<T, A> as\
    \ PartialEq<&[U; N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n         \
    \    <Vec<T, A> as PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<[U]>>\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpgz01nten.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut temp = lst[0];\n    for x in &lst {\n        if *x <\
    \ temp {\n            return false;\n        }\n        temp = *x;\n    }\n  \
    \  true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpytib2ae3.rs:14:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut visited = vec![];\n    let mut sorted = true;\n    for\
    \ i in lst {\n        if visited.contains(&i) {\n            sorted = false;\n\
    \            break;\n        }\n        visited.push(i);\n    }\n    sorted\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqi6i4ce8.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    for i in 0..lst.len() - 1 {\n        if lst[i] >= lst[i + 1]\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmplu3x_g9d.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    for i in 0..lst.len() - 1 {\n   \
    \     if lst[i] > lst[i + 1] {\n            sorted = false;\n            break;\n\
    \        }\n    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpqmp4ie5j.rs:15:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut result = true;\n    let mut unique = lst.to_vec();\n\
    \    unique.sort();\n    unique.dedup();\n    for (i, item) in lst.iter().enumerate()\
    \ {\n        if item != &unique[i] {\n            result = false;\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 4 but the index\
    \ is 4', /tmp/tmp8iygw_9o.rs:19:21\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut tmp = lst[0];\n    let mut counter = 0;\n    for i in\
    \ lst {\n        if i < tmp {\n            return false;\n        }\n        if\
    \ i == tmp {\n            counter += 1;\n        }\n        tmp = i;\n    }\n\
    \    if counter >= 2 {\n        return false;\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp4d8_g_sp.rs:14:19\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst = lst;\n    lst.sort();\n    lst.dedup();\n    lst\
    \ == lst.clone().sort()\n}\n\nfn main() {\n    let candidate = is_sorted;\n  \
    \  assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `Vec<isize>` with `()`\n  --> /tmp/tmpqvc6162c.rs:17:9\n\
    \   |\n17 |     lst == lst.clone().sort()\n   |         ^^ no implementation for\
    \ `Vec<isize> == ()`\n   |\n   = help: the trait `PartialEq<()>` is not implemented\
    \ for `Vec<isize>`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n             <Vec<T, A> as\
    \ PartialEq<&[U; N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n         \
    \    <Vec<T, A> as PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<[U]>>\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut prev = std::isize::MIN;\n    for num in lst {\n     \
    \   if num <= prev {\n            return false;\n        }\n        prev = num;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpuqo2474k.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    lst.windows(2).any(|x| x[0] > x[1]) == false\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpx_klzlyf.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    for i in 0..lst.len() - 1 {\n        if lst[i] >= lst[i + 1]\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpwk5kjqvc.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    if lst.len() == 1 {\n        return true;\n    }\n    let mut\
    \ counter = lst[0];\n    for index in 1..lst.len() {\n        if counter != lst[index]\
    \ {\n            if counter > lst[index] {\n                return false;\n  \
    \          }\n            counter = lst[index];\n        } else {\n          \
    \  return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp1ddpzy_6.rs:17:23\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    // This will be true if the list is sorted, false otherwise\n\
    \    let mut sorted = true;\n    // This will contain the previous number encountered\n\
    \    let mut last_number = 0;\n    // This will contain the number of occurances\
    \ of the previous number encountered\n    let mut number_of_times_last_number_occured\
    \ = 0;\n    // This will contain the number of occurances of the current number\
    \ being processed\n    let mut number_of_times_this_number_occured = 0;\n    //\
    \ This will be true if the previous number encountered is the same as the current\
    \ number being processed\n    let mut is_same_number = false;\n    // This will\
    \ be true if the previous number encountered is smaller than the current number\
    \ being processed\n    let mut is_greater_number = false;\n    // This will be\
    \ true if the previous number encountered is bigger than the current number being\
    \ processed\n    let mut is_smaller_number = false;\n    // This will be true\
    \ if any number was encountered that is the same or bigger than the previous number\n\
    \    let mut seen_bigger_or_same_number = false;\n    // This will be true if\
    \ any number was encountered that is the same or smaller than the previous number\n\
    \    let mut seen_smaller_or_same_number = false;\n    // This will be true if\
    \ the list is of length 1\n    let is_length_one = lst.len() == 1;\n    // This\
    \ will be true if the list is of length 0\n    let is_length_zero = lst.len()\
    \ == 0;\n    // This will be true if the list is of length greater than 1\n  \
    \  let is_length_greater_than_one = lst.len() > 1;\n    // If list is of length\
    \ 0 or 1, return true\n    if is_length_zero || is_length_one {\n        return\
    \ true;\n    }\n    // Iterate through the list\n    for i in 0..lst.len() {\n\
    \        // If this is the first iteration, set the last number encountered to\
    \ the current number\n        if i == 0 {\n            last_number = lst[i];\n\
    \            continue;\n        }\n        // Store the previous number encountered\n\
    \        let previous_number = last_number;\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmppz8r6nle.rs:68:3\n\
    \   |\n13 | fn is_sorted(lst: Vec<isize>) -> bool {\n   |                    \
    \                   - unclosed delimiter\n...\n43 |     for i in 0..lst.len()\
    \ {\n   |                           - this delimiter might not be properly closed...\n\
    ...\n51 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    68 | }\n   |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppz8r6nle.rs:13:34\n\
    \   |\n13 | fn is_sorted(lst: Vec<isize>) -> bool {\n   |    ---------       \
    \              ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    for i in 0..lst.len() - 1 {\n        if lst[i] >= lst[i + 1]\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpw16a74ye.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    lst.windows(2).all(|x| x[0] <= x[1])\n}\n\nfn main() {\n    let\
    \ candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwktrx63h.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    // Convert list to Vec<char>\n    let lst_str: Vec<char> = lst.iter().map(|n|\
    \ n.to_string().chars().next().unwrap()).collect();\n    let lst_str: String =\
    \ lst_str.iter().collect();\n    let sorted_str: String = lst_str.chars().sorted().collect();\n\
    \    lst_str == sorted_str\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sorted` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpufhambeq.rs:17:46\n   |\n17 |     let sorted_str:\
    \ String = lst_str.chars().sorted().collect();\n   |                         \
    \                     ^^^^^^ method not found in `Chars<'_>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut set = std::collections::HashSet::new();\n    let mut\
    \ last = None;\n    for i in lst {\n        if let Some(last) = last {\n     \
    \       if i < last {\n                return false;\n            }\n        }\n\
    \        last = Some(i);\n        set.insert(i);\n    }\n    set.len() == lst.len()\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `lst`\n   --> /tmp/tmpjay0e6h7.rs:25:18\n\
    \    |\n13  | fn is_sorted(lst: Vec<isize>) -> bool {\n    |              ---\
    \ move occurs because `lst` has type `Vec<isize>`, which does not implement the\
    \ `Copy` trait\n...\n16  |     for i in lst {\n    |              --- `lst` moved\
    \ due to this implicit call to `.into_iter()`\n...\n25  |     set.len() == lst.len()\n\
    \    |                  ^^^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `lst`\nhelp:\
    \ consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n16  |     for i in &lst {\n    |              +\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    lst.len() < 2 || lst.windows(2).all(|x| x[0] < x[1])\n}\n\nfn\
    \ main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5ln8cpt8.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst1 = lst.clone();\n    lst1.sort();\n    lst == lst1\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpa3g_kwrg.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted_lst = lst.clone();\n    sorted_lst.sort();\n \
    \   sorted_lst == lst\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvdh6zy69.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut cnt = 0;\n    for i in 0..lst.len() {\n        if i +\
    \ 1 < lst.len() && lst[i] < lst[i + 1] {\n            cnt += 1;\n        }\n \
    \   }\n    cnt == lst.len() - 1\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp4eqjhitf.rs:20:12\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted_lst = lst.clone();\n    sorted_lst.sort();\n \
    \   sorted_lst == lst\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpklwg_93p.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut ans = true;\n    for i in 0..lst.len() - 1 {\n      \
    \  if lst[i] > lst[i + 1] {\n            ans = false;\n            break;\n  \
    \      }\n    }\n    ans\n}\n\nfn main() {\n    let candidate = is_sorted;\n \
    \   assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp067xa0a9.rs:15:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut count = 0;\n    for i in 0..lst.len() {\n        if i\
    \ > 0 && lst[i] <= lst[i - 1] {\n            count += 1;\n        }\n    }\n \
    \   if count > 0 {\n        return false;\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmphw3qc7vi.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    if lst.len() == 1 {\n        return true;\n    }\n\n    let mut\
    \ cache = [0 as isize; 10];\n    let mut prev = lst[0];\n    for i in 1..lst.len()\
    \ {\n        if lst[i] < prev {\n            return false;\n        }\n      \
    \  cache[lst[i] as usize] += 1;\n        if cache[lst[i] as usize] > 1 {\n   \
    \         return false;\n        }\n        prev = lst[i];\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp04x24nun.rs:19:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = lst.clone();\n    sorted.sort();\n    lst ==\
    \ sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpega60zcx.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut last = None;\n    for item in lst {\n        if let Some(prev)\
    \ = last {\n            if prev >= item {\n                return false;\n   \
    \         }\n        }\n        last = Some(item);\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmplczv9_ec.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpt3anonph.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut is_sorted = true;\n    let mut prev = None;\n    for\
    \ num in lst {\n        match prev {\n            Some(p) => {\n             \
    \   if num < p {\n                    is_sorted = false;\n                   \
    \ break;\n                }\n            }\n            None => {}\n        }\n\
    \        prev = Some(num);\n    }\n    is_sorted\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpndq5wu6m.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = lst.clone();\n    sorted.sort();\n    sorted.dedup();\n\
    \    lst == sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2cwrwe62.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    if lst.len() == 1 {\n        return true;\n    }\n\n    for i\
    \ in 0..lst.len() - 1 {\n        if lst[i] < lst[i + 1] {\n            continue;\n\
    \        } else {\n            return false;\n        }\n    }\n\n    true\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpok33hw0d.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut it = lst.iter();\n    let mut curr = it.next();\n   \
    \ for i in it {\n        if curr.unwrap() > i {\n            return false;\n \
    \       }\n        curr = Some(i);\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpi5ifch3f.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut it = lst.iter();\n    let mut prev = it.next();\n   \
    \ for el in it {\n        if prev.unwrap() >= el {\n            return false;\n\
    \        }\n        prev = Some(el);\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpjh2g0t03.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    if lst.len() == 1 {\n        return true;\n    }\n    let mut\
    \ vec = lst.clone();\n    vec.sort();\n    vec.dedup();\n    vec == lst\n}\n\n\
    fn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmps_47ofuc.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut result = true;\n    let mut index = 0;\n    for item\
    \ in lst.clone() {\n        if index < lst.len() - 1 {\n            result = result\
    \ && (item <= lst[index + 1]);\n        }\n        index += 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpevtdiovj.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    if lst.len() <= 1 {\n        return true;\n    }\n    let mut\
    \ prev = lst[0];\n    for i in 1..lst.len() {\n        if lst[i] < prev {\n  \
    \          return false;\n        }\n        prev = lst[i];\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpx9vdeoha.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    if lst.len() == 1 {\n        return true;\n    }\n    let mut\
    \ prev = lst[0];\n    for i in 1..lst.len() {\n        if lst[i] < prev {\n  \
    \          return false;\n        }\n        prev = lst[i];\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpjr24z2mb.rs:17:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    // TODO!()\n    let mut v1: Vec<isize> = Vec::new();\n    for\
    \ i in 0..lst.len() {\n        v1.push(lst[i]);\n    }\n    v1.sort();\n    let\
    \ mut sort = 0;\n    let mut flag = false;\n    let mut n = 1;\n    while n <\
    \ lst.len() {\n        if lst[n] < lst[n - 1] {\n            flag = true;\n  \
    \          break;\n        }\n        n += 1;\n    }\n    if !flag {\n       \
    \ for i in 0..lst.len() {\n            if lst[i] == v1[i] {\n                sort\
    \ += 1;\n            }\n        }\n    }\n    sort == lst.len()\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4kof0gh6.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst = lst;\n    lst.sort();\n    for (i, v) in lst.iter().enumerate()\
    \ {\n        if i > 0 && *v == lst[i - 1] {\n            return false;\n     \
    \   }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n   \
    \ assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n   \
    \ assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpkkee7krw.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    lst.is_sorted()\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "error[E0658]: use of unstable library feature 'is_sorted': new API\n  -->\
    \ /tmp/tmpf6dnlsjt.rs:14:9\n   |\n14 |     lst.is_sorted()\n   |         ^^^^^^^^^\n\
    \   |\n   = note: see issue #53485 <https://github.com/rust-lang/rust/issues/53485>\
    \ for more information\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0658`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    for i in 0..lst.len() - 1 {\n        if lst[i] >= lst[i + 1]\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp1hv91dbf.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut previous = 0;\n    for i\
    \ in lst {\n        if i < previous {\n            sorted = false;\n        }\n\
    \        previous = i;\n    }\n    sorted\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpu_xa1w_q.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    lst.windows(2).all(|x| x[0] <= x[1])\n}\n\nfn main() {\n    let\
    \ candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmptk6j9yde.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    if lst.len() <= 1 {\n        return true;\n    }\n    let mut\
    \ last = lst[0];\n    for item in lst.iter().skip(1) {\n        if last >= *item\
    \ {\n            return false;\n        }\n        last = *item;\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprcgu4xf1.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut temp = lst.clone();\n    temp.sort();\n    temp.dedup();\n\
    \    lst == temp\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpsg2whoqh.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut new_lst = lst.clone();\n    new_lst.sort();\n    new_lst\
    \ == lst\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpn9vjrslb.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\nfn main() {\n    let\
    \ candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpehmqqbfb.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut flag = true;\n    let mut num_of_duplicate = 0;\n   \
    \ for (i, j) in lst.iter().zip(lst.iter().skip(1)) {\n        if *i > *j {\n \
    \           flag = false;\n        }\n        if *i == *j {\n            num_of_duplicate\
    \ += 1;\n        }\n    }\n    if num_of_duplicate > 0 {\n        flag = false;\n\
    \    }\n    flag\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_4j44tok.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut count: isize = 1;\n    for i in 1..lst.len() {\n    \
    \    if lst[i] < lst[i - 1] {\n            return false;\n        }\n        if\
    \ lst[i] == lst[i - 1] {\n            count += 1;\n        }\n    }\n    return\
    \ count == lst.len() as isize;\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpn_u6baet.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    for i in 0..lst.len() - 1 {\n   \
    \     if lst[i] >= lst[i + 1] {\n            sorted = false;\n            break;\n\
    \        }\n    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp358mtjmn.rs:15:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted_lst = lst.clone();\n    sorted_lst.sort();\n \
    \   lst == sorted_lst\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwp276dt1.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted_list = lst.clone();\n    sorted_list.sort();\n\
    \    let list = lst.iter().collect::<HashSet<_>>();\n    list.len() == sorted_list.len()\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp4a33ecgv.rs:16:37\n\
    \   |\n16 |     let list = lst.iter().collect::<HashSet<_>>();\n   |         \
    \                            ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    lst.windows(2).all(|x| x[0] <= x[1])\n}\n\nfn main() {\n    let\
    \ candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0glvvk_5.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut last_value = None;\n    for number in lst {\n       \
    \ if let Some(last) = last_value {\n            if number < last {\n         \
    \       return false;\n            }\n        }\n        last_value = Some(number);\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpun1yq4e7.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut prev = *lst.first().unwrap();\n    let mut dups = 0;\n\
    \    for item in lst {\n        if item == prev {\n            dups += 1;\n  \
    \      }\n        if dups > 1 {\n            return false;\n        }\n      \
    \  if item < prev {\n            return false;\n        }\n        prev = item;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmpajopf5i2.rs:14:33\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    if lst.len() == 1 {\n        return true;\n    }\n    let mut\
    \ previous = lst[0];\n    for i in lst {\n        if i > previous {\n        \
    \    previous = i;\n        } else {\n            return false;\n        }\n \
    \   }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpg0foo085.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    if lst.len() < 2 {\n        return true;\n    }\n    let mut\
    \ prev = lst[0];\n    for i in lst.iter().skip(1) {\n        if prev >= *i {\n\
    \            return false;\n        }\n        prev = *i;\n    }\n    true\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvyx1x54e.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut left = lst.clone();\n    let mut right = lst.clone();\n\
    \    left.sort();\n    right.sort_by(|a, b| b.cmp(a));\n    left == lst || right\
    \ == lst\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp71y0fai8.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\nfn main() {\n    let\
    \ candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpne6zir9c.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut list: Vec<isize> = lst.to_vec();\n    list.sort();\n\
    \    if list == lst {\n        true\n    } else {\n        false\n    }\n}\n\n\
    fn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplal72sm2.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut prev = lst[0];\n    for i in lst.iter() {\n        if\
    \ prev == *i {\n            return false;\n        }\n        if prev > *i {\n\
    \            return false;\n        }\n        prev = *i;\n    }\n    true\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpyromurib.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp2n6q5u3e.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    for (i, &val) in lst.iter().enumerate() {\n        if i < lst.len()\
    \ - 1 && val >= lst[i + 1] {\n            return false;\n        }\n    }\n  \
    \  true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8n8g2uko.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut last_val = 0;\n    for item\
    \ in lst {\n        if item < last_val {\n            sorted = false;\n      \
    \      break;\n        }\n        last_val = item;\n    }\n    sorted\n}\n\nfn\
    \ main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpms6jdxtr.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst = lst;\n    lst.sort();\n    lst.dedup();\n    lst\
    \ == lst.iter().sorted().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sorted` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmprxgw1crq.rs:17:23\n   |\n17 |     lst ==\
    \ lst.iter().sorted().collect::<Vec<_>>()\n   |                       ^^^^^^ method\
    \ not found in `std::slice::Iter<'_, isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut new = lst.clone();\n    new.sort();\n    new == lst\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpphw3057r.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst = lst;\n    lst.sort();\n    let mut prev = None;\n\
    \    for &x in &lst {\n        if prev == Some(x) {\n            return false;\n\
    \        }\n        prev = Some(x);\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmptb2_rs3k.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\nfn main() {\n    let\
    \ candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp092d6sco.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst_iter = lst.iter();\n    lst_iter.next().map_or(true,\
    \ |first| {\n        lst_iter.all(|second| first < second)\n    })\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpbigyadh_.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut s = lst.clone();\n    s.sort();\n    lst == s\n}\n\n\
    fn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp38ujx59k.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted_lst = lst.clone();\n    sorted_lst.sort();\n \
    \   lst == sorted_lst\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpaaycj39j.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst = lst;\n    lst.sort();\n    let mut last = None;\n\
    \    for n in lst {\n        if last == Some(n) {\n            return false;\n\
    \        }\n        last = Some(n);\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpxurpxeb3.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    lst.windows(2).all(|a| a[0] <= a[1])\n}\n\nfn main() {\n    let\
    \ candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpkv5w9ll4.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    if lst.len() <= 1 {\n        return true;\n    }\n    let mut\
    \ count = 0;\n    for i in 0..lst.len() - 1 {\n        if lst[i] <= lst[i + 1]\
    \ {\n            count += 1;\n        }\n    }\n    count == lst.len() - 1\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpedfk7qdy.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = lst.clone();\n    sorted.sort();\n    sorted.dedup();\n\
    \    lst == sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpg3rgvjtp.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst_temp = lst.clone();\n    lst_temp.sort();\n    lst\
    \ == lst_temp\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpfrr0lwsf.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    if lst.len() == 1 {\n        return true;\n    }\n    for x in\
    \ 1..lst.len() {\n        if lst[x - 1] >= lst[x] {\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqzlfbcw5.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp7l8ccfpj.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    for i in 0..lst.len() - 1 {\n   \
    \     if lst[i] >= lst[i + 1] {\n            sorted = false;\n            break;\n\
    \        }\n    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmptl2iegqp.rs:15:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut result = true;\n    let mut prev = 0;\n    for i in lst\
    \ {\n        if i < prev {\n            result = false;\n            break;\n\
    \        }\n        prev = i;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpcf72_93a.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut is_sorted = true;\n    let mut curr = isize::MIN;\n \
    \   for num in lst {\n        if num > curr {\n            curr = num;\n     \
    \   } else {\n            is_sorted = false;\n            break;\n        }\n\
    \    }\n    is_sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8_s4yqub.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut last_val = None;\n    for &num in &lst {\n        if\
    \ let Some(last) = last_val {\n            if num < last {\n                return\
    \ false;\n            }\n        }\n        last_val = Some(num);\n    }\n   \
    \ true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpeakktbx6.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut v: Vec<isize> = lst.clone();\n    v.sort();\n    lst\
    \ == v\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4btpboe3.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let n = lst.len();\n    (0..n - 1).all(|i| lst[i] < lst[i + 1])\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpi998x_xw.rs:15:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    lst.iter().enumerate().all(|(i, v)| {\n        if i == 0 {\n\
    \            true\n        } else {\n            let e = lst[i - 1];\n       \
    \     v > &e\n        }\n    })\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmphjk40bbr.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    for i in 0..lst.len() - 1 {\n        if lst[i] > lst[i + 1] {\n\
    \            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n   \
    \ let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp_nywie5u.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut prev = isize::MIN;\n    for num in lst {\n        if\
    \ num <= prev {\n            return false;\n        }\n        prev = num;\n \
    \   }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpz5nm9co6.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    // Loop the list and compare the current and previous value in\
    \ the loop\n    for i in 1..lst.len() {\n        if lst[i] <= lst[i - 1] {\n \
    \           return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpy48zkcj6.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    if lst.len() <= 1 {\n        return true;\n    }\n    let mut\
    \ prev = lst[0];\n    for &i in lst.iter().skip(1) {\n        if i < prev {\n\
    \            return false;\n        }\n        prev = i;\n    }\n    true\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpc05w8bcs.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    // set up count variable\n    let mut count = 0;\n    // iterate\
    \ over each value in vector\n    for i in 0..lst.len() {\n        // if the current\
    \ value is less than next\n        if lst[i] < lst[i + 1] {\n            // increment\
    \ count\n            count += 1;\n        }\n    }\n    // if count is equal to\
    \ vector length return true, else false\n    count == lst.len()\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 1 but the index\
    \ is 1', /tmp/tmp3x3j8crd.rs:19:21\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    lst.len() <= 1 || lst.windows(2).all(|a| a[0] < a[1])\n}\n\n\
    fn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5gqfajmg.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut new_list = lst.clone();\n    new_list.sort();\n    new_list\
    \ == lst\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpij4x0ssw.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst = lst;\n    lst.sort();\n    lst.dedup();\n    lst\
    \ == lst.iter().cloned().collect::<Vec<isize>>()\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpm8e_6kr0.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst_iter = lst.iter();\n    match lst_iter.next() {\n\
    \        None => true,\n        Some(first) => {\n            let mut prev = first;\n\
    \            for e in lst_iter {\n                if prev >= e {\n           \
    \         return false;\n                }\n                prev = e;\n      \
    \      }\n            true\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpt5flnkvp.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    for i in 0..lst.len() - 1 {\n        if lst[i] == lst[i + 1]\
    \ {\n            return false;\n        }\n        if lst[i] > lst[i + 1] {\n\
    \            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n   \
    \ let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpl_bnl7kw.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let last = lst.len() - 1;\n    let mut arr: Vec<isize> = lst.clone();\n\
    \    arr.sort();\n    let mut count = 0;\n    for i in 0..last {\n        if arr[i]\
    \ == arr[i + 1] {\n            count += 1;\n        }\n    }\n    lst == arr &&\
    \ count == 0\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp7u5fp5rj.rs:14:16\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    lst.iter().zip(lst.iter().skip(1)).all(|(p, s)| p <= s)\n}\n\n\
    fn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpuv2tuz4x.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    lst.into_iter().eq(lst.iter().copied().sorted())\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sorted` found for struct `Copied` in the\
    \ current scope\n  --> /tmp/tmp8ja2yioe.rs:14:44\n   |\n14 |     lst.into_iter().eq(lst.iter().copied().sorted())\n\
    \   |                                            ^^^^^^ method not found in `Copied<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut prev = None;\n    for (i, v) in lst.iter().enumerate()\
    \ {\n        if prev.is_some() && prev.unwrap() >= v {\n            return false;\n\
    \        }\n        prev = Some(v);\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpull0szi4.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\nfn main() {\n    let\
    \ candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpeahhek2c.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    fn bt(lst: &[isize], i: usize, j: usize) -> bool {\n        if\
    \ i == j {\n            true\n        } else if lst[i] > lst[j] {\n          \
    \  false\n        } else {\n            bt(lst, i + 1, j)\n        }\n    }\n\
    \    if lst.len() <= 1 {\n        true\n    } else {\n        bt(&lst, 0, lst.len()\
    \ - 1)\n    }\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpztfus2hr.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let sorted = lst.iter().fold(None, |max, x| {\n        Some(match\
    \ max {\n            Some(m) => {\n                if x <= &m {\n            \
    \        return false;\n                }\n                x\n            }\n\
    \            None => x,\n        })\n    });\n    sorted.is_some()\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvp3k6cd6.rs:18:28\n   |\n\
    18 |                     return false;\n   |                            ^^^^^\
    \ expected enum `Option`, found `bool`\n   |\n   = note: expected enum `Option<_>`\n\
    \              found type `bool`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n18 |                     return Some(false);\n   |                    \
    \        +++++     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvp3k6cd6.rs:15:9\n\
    \   |\n15 | /         Some(match max {\n16 | |             Some(m) => {\n17 |\
    \ |                 if x <= &m {\n18 | |                     return false;\n...\
    \  |\n22 | |             None => x,\n23 | |         })\n   | |__________^ expected\
    \ `isize`, found `&isize`\n   |\n   = note: expected enum `Option<isize>`\n  \
    \            found enum `Option<&isize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    for i in 0..lst.len() - 1 {\n        if lst[i] > lst[i + 1] {\n\
    \            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n   \
    \ let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpsh24j2jm.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    fn is_sorted_inner(lst: &[isize]) -> bool {\n        if lst.len()\
    \ <= 1 {\n            return true;\n        }\n\n        let x = lst[0];\n   \
    \     let y = lst[1];\n\n        if x >= y {\n            return false;\n    \
    \    }\n\n        is_sorted_inner(&lst[1..])\n    }\n\n    if lst.len() <= 1 {\n\
    \        return true;\n    }\n\n    let x = lst[0];\n    let y = lst[1];\n\n \
    \   if x >= y {\n        return false;\n    }\n\n    is_sorted_inner(&lst[1..])\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpy4zn3p7k.rs:56:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    for i in 0..lst.len() - 1 {\n        if lst[i] >= lst[i + 1]\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp50vkuzf2.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut previous: Option<isize> = None;\n    for item in lst\
    \ {\n        if let Some(previous_item) = previous {\n            if previous_item\
    \ >= item {\n                return false;\n            }\n        }\n       \
    \ previous = Some(item);\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprn_sd43h.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut current_num = None;\n    for num in lst {\n        match\
    \ current_num {\n            Some(curr) => {\n                if num < curr {\n\
    \                    return false;\n                }\n            }\n       \
    \     None => {}\n        }\n        current_num = Some(num);\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmppdbref0d.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    for i in 0..lst.len() - 1 {\n        if lst[i] >= lst[i + 1]\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpof2eok0s.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    // TODO: return true if the list is sorted ascending\n    lst.windows(2).all(|w|\
    \ w[0] <= w[1])\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5nxzosqb.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut last = std::isize::MIN;\n    let mut last_distinct =\
    \ false;\n    for v in lst {\n        if last == v {\n            if last_distinct\
    \ {\n                return false;\n            }\n        } else {\n        \
    \    last_distinct = true;\n        }\n        if last > v {\n            return\
    \ false;\n        }\n        last = v;\n    }\n    true\n}\n\nfn main() {\n  \
    \  let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n   \
    \ assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptt8mijb3.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let sorted = lst.iter().cloned().collect::<Vec<isize>>();\n \
    \   sorted == lst.iter().cloned().sorted().collect::<Vec<isize>>()\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sorted` found for struct `Cloned` in the\
    \ current scope\n  --> /tmp/tmpu6pkbohi.rs:15:35\n   |\n15 |     sorted == lst.iter().cloned().sorted().collect::<Vec<isize>>()\n\
    \   |                                   ^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    if lst.len() <= 1 {\n        return true;\n    }\n    let mut\
    \ prev = lst[0];\n    for x in lst.iter().skip(1) {\n        if *x < prev {\n\
    \            return false;\n        }\n        prev = *x;\n    }\n    true\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpreukn5yr.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    for i in 0..lst.len() - 1 {\n        if lst[i] >= lst[i + 1]\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpow0qtb74.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    for i in 0..lst.len() - 1 {\n        if lst[i] >= lst[i + 1]\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpghv1ko66.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    for i in 0..lst.len() - 1 {\n        if lst[i] >= lst[i + 1]\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpycy4ne6g.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut dup = false;\n    for i in 0..lst.len() - 1 {\n     \
    \   if lst[i] > lst[i + 1] {\n            return false;\n        }\n        if\
    \ lst[i] == lst[i + 1] {\n            dup = true;\n        }\n    }\n    !dup\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpyudo6ngk.rs:15:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    (1..lst.len()).all(|x| lst[x - 1] < lst[x])\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2w22ntc9.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let l = lst.len();\n    for i in 0..l - 1 {\n        if lst[i]\
    \ >= lst[i + 1] {\n            return false;\n        }\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp8q4ox219.rs:15:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut current = None;\n    for item in lst {\n        match\
    \ current {\n            Some(v) => {\n                if v >= item {\n      \
    \              return false;\n                }\n            }\n            None\
    \ => {}\n        }\n        current = Some(item);\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp3yrg21wm.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut last = std::isize::MIN;\n    for &n in &lst {\n     \
    \   if n <= last {\n            return false;\n        }\n        last = n;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2vt0men1.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    for i in 0..lst.len() - 1 {\n        if lst[i] > lst[i + 1] {\n\
    \            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n   \
    \ let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpb6lkfsv6.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    for (i, v) in lst.iter().enumerate() {\n        if lst.get(i\
    \ + 1) == None {\n            break;\n        }\n        if v > lst.get(i + 1).unwrap()\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0tnne86x.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    // Your code here!\n    lst.iter().enumerate().all(|(i, v)| {\n\
    \        if i == 0 {\n            true\n        } else {\n            lst[i -\
    \ 1] < *v\n        }\n    })\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp3dbaqp0d.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    lst.iter().eq(lst.iter().sorted())\n}\n\nfn main() {\n    let\
    \ candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sorted` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmp5zxe1qid.rs:14:30\n   |\n14 |     lst.iter().eq(lst.iter().sorted())\n\
    \   |                              ^^^^^^ method not found in `std::slice::Iter<'_,\
    \ isize>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut curr = lst[0];\n    for i\
    \ in &lst {\n        if i > &curr {\n            curr = *i;\n        } else {\n\
    \            sorted = false;\n            break;\n        }\n    }\n    sorted\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpi_oglhz9.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    for i in 0..lst.len() - 1 {\n   \
    \     if lst[i] >= lst[i + 1] {\n            sorted = false;\n            break;\n\
    \        }\n    }\n    sorted\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp31tii8gm.rs:15:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted_lst = lst.clone();\n    sorted_lst.sort();\n \
    \   return lst == sorted_lst\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpu5_r5963.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    if lst.len() == 1 {\n        return true;\n    }\n\n    let mut\
    \ prev = lst[0];\n    for n in lst {\n        if n < prev {\n            return\
    \ false;\n        }\n        prev = n;\n    }\n    true\n}\n\nfn main() {\n  \
    \  let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n   \
    \ assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmprl4ia4vw.rs:18:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst_temp = lst.clone();\n    lst_temp.sort();\n    lst\
    \ == lst_temp\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpne9ov838.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut vec: Vec<isize> = lst.clone();\n    vec.sort();\n   \
    \ let mut check = true;\n    for i in 0..lst.len() {\n        if lst[i] != vec[i]\
    \ {\n            check = false;\n        }\n    }\n    if lst.len() > 1 {\n  \
    \      for i in 0..lst.len() - 1 {\n            if lst[i] == lst[i + 1] {\n  \
    \              check = false;\n            }\n        }\n    }\n    check\n}\n\
    \nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqmzvd7bw.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst = lst;\n    lst.sort();\n    lst.dedup();\n    let\
    \ mut lst2 = lst.clone();\n    lst2.reverse();\n    lst == lst2\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmppclgzt5a.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut dup_check: isize = 0;\n    let mut counter: isize = 0;\n\
    \    for i in 0..lst.len() - 1 {\n        if lst[i] == lst[i + 1] {\n        \
    \    dup_check += 1;\n        }\n        if lst[i] < lst[i + 1] {\n          \
    \  counter += 1;\n        }\n    }\n    return counter == lst.len() as isize -\
    \ 1 && dup_check == 0;\n}\n\nfn main() {\n    let candidate = is_sorted;\n   \
    \ assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n   \
    \ assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmptikd0aza.rs:16:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    // TODO!\n    let mut prev = None;\n    for i in lst {\n    \
    \    match prev {\n            Some(p) => {\n                if p == i {\n   \
    \                 return false;\n                }\n                if p > i {\n\
    \                    return false;\n                }\n            }\n       \
    \     None => (),\n        }\n        prev = Some(i);\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpk53f_fk7.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    for (i, item) in lst.iter().enumerate() {\n        if i == 0\
    \ {\n            continue;\n        }\n        if item < &lst[i - 1] {\n     \
    \       return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp87if037x.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    lst.windows(2).all(|window| window[0] <= window[1])\n}\n\nfn\
    \ main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9ujbqwsa.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    if lst.len() == 1 {\n        return true;\n    }\n    for i in\
    \ 0..lst.len() - 1 {\n        if lst[i] > lst[i + 1] {\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpaaluekva.rs:17:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    lst.windows(2).map(|window| window[0] < window[1]).all(|x| x)\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbpy_buo0.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    // dbg!(&lst);\n    let mut sorted_lst = lst.clone();\n    sorted_lst.sort();\n\
    \    lst == sorted_lst\n}\n\nfn main() {\n    let candidate = is_sorted;\n   \
    \ assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2, 3,\
    \ 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n   \
    \ assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp6cmlk2fv.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    // Your code here\n    unimplemented!();\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmph9iyvmq7.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut result = true;\n    for i in 0..lst.len() - 1 {\n   \
    \     if lst[i] > lst[i + 1] {\n            result = false;\n            break;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpm3hyaum0.rs:15:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut prev = None;\n    for num in lst {\n        match prev\
    \ {\n            Some(p) if p > num => return false,\n            _ => prev =\
    \ Some(num),\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp3tmjrx61.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut new_lst = lst.clone();\n    new_lst.sort();\n    let\
    \ mut val = new_lst[0];\n    for i in new_lst {\n        if i == val {\n     \
    \       return false;\n        }\n        val = i;\n    }\n    lst == new_lst\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `new_lst`\n   --> /tmp/tmpzcpwmwgn.rs:23:12\n\
    \    |\n14  |     let mut new_lst = lst.clone();\n    |         ----------- move\
    \ occurs because `new_lst` has type `Vec<isize>`, which does not implement the\
    \ `Copy` trait\n...\n17  |     for i in new_lst {\n    |              -------\
    \ `new_lst` moved due to this implicit call to `.into_iter()`\n...\n23  |    \
    \ lst == new_lst\n    |            ^^^^^^^ value borrowed here after move\n  \
    \  |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `new_lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content\
    \ to avoid moving into the `for` loop\n    |\n17  |     for i in &new_lst {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let set: HashSet<isize> = lst.iter().cloned().collect();\n  \
    \  let sorted_lst: Vec<isize> = set.into_iter().collect();\n    let mut index\
    \ = 0;\n    let mut sorted = true;\n    while index < lst.len() - 1 {\n      \
    \  if lst[index] > lst[index + 1] {\n            sorted = false;\n           \
    \ break;\n        }\n        index += 1;\n    }\n    sorted && lst == sorted_lst\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmptgr5v5d0.rs:14:14\n\
    \   |\n14 |     let set: HashSet<isize> = lst.iter().cloned().collect();\n   |\
    \              ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    if lst.len() < 2 {\n        return true;\n    }\n    for i in\
    \ 1..lst.len() {\n        if lst[i - 1] >= lst[i] {\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkxwl7lax.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    if lst.len() < 2 {\n        return true;\n    }\n    for i in\
    \ 1..lst.len() {\n        if lst[i - 1] >= lst[i] {\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp529e6flp.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut s = lst.clone();\n    s.sort();\n    lst == s\n}\n\n\
    fn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpba_agc0_.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    if lst.len() < 2 {\n        return true;\n    }\n    lst.windows(2).all(|x|\
    \ x[0] < x[1])\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpei6nlpfp.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut a = lst.clone();\n    a.sort();\n    a.dedup();\n   \
    \ lst == a\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_sfuq6e9.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut prev = -1;\n    let mut count = 0;\n    for i in lst\
    \ {\n        if i == prev {\n            count += 1;\n        }\n        if i\
    \ < prev {\n            return false;\n        }\n        prev = i;\n    }\n \
    \   count == 0\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmposmwuygn.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    if lst.len() <= 1 {\n        return true;\n    }\n    for index\
    \ in 1..lst.len() {\n        if lst[index] < lst[index - 1] {\n            return\
    \ false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwqxg6sm_.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut count = 0;\n    let mut last = -1;\n    for num in lst\
    \ {\n        if num <= last {\n            count += 1;\n        }\n        last\
    \ = num;\n    }\n    count < 2\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmplkqf07ec.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut previous: Option<isize> = None;\n    for n in lst {\n\
    \        if let Some(p) = previous {\n            if p > n {\n               \
    \ return false;\n            }\n        }\n        previous = Some(n);\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpblww0m4v.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut prev = std::isize::MIN;\n    for i in lst {\n       \
    \ if i < prev {\n            return false;\n        }\n        prev = i;\n   \
    \ }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7mb68rfb.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = lst.clone();\n    sorted.sort();\n    sorted.iter().zip(lst.iter()).all(|(a,\
    \ b)| a == b)\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmput8yfl42.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    if lst.len() < 2 {\n        return true;\n    }\n    let mut\
    \ previous = lst[0];\n    for &elem in lst.iter().skip(1) {\n        if elem <\
    \ previous {\n            return false;\n        }\n        previous = elem;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmppgbhx5yz.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut max = None;\n    for el in\
    \ lst {\n        if let Some(v) = max {\n            if el < v {\n           \
    \     sorted = false;\n                break;\n            }\n        }\n    \
    \    max = Some(el);\n    }\n    sorted\n}\n\nfn main() {\n    let candidate =\
    \ is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp6atlhef5.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut last = None;\n    for n in lst {\n        if let Some(l)\
    \ = last {\n            if n < l {\n                return false;\n          \
    \  }\n        }\n        last = Some(n);\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpfleofvxo.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut last = None;\n    for element\
    \ in lst {\n        if let Some(last_element) = last {\n            if element\
    \ < last_element {\n                sorted = false;\n                break;\n\
    \            }\n        }\n        last = Some(element);\n    }\n    sorted\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp8w2oeit_.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmplhpvw01x.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    for i in 0..lst.len() - 1 {\n        if lst[i] > lst[i + 1] {\n\
    \            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n   \
    \ let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp3eyupwdm.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let len = lst.len();\n    let mut sorted = true;\n    let mut\
    \ last = lst[0];\n    for i in 1..len {\n        if last < lst[i] {\n        \
    \    last = lst[i];\n        } else {\n            sorted = false;\n         \
    \   break;\n        }\n    }\n    sorted\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpqy01qtcg.rs:16:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut last = 0;\n    for i in lst\
    \ {\n        if i < last {\n            sorted = false;\n            break;\n\
    \        }\n        last = i;\n    }\n    sorted\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpz40mbesw.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    // initialize set\n    let mut memo: std::collections::HashSet<isize>\
    \ = std::collections::HashSet::new();\n    // init variables\n    let mut prev\
    \ = None;\n    // for each item in the list\n    for i in lst {\n        // if\
    \ there is a previous value\n        if let Some(p) = prev {\n            // if\
    \ new value is less than the previous one return false\n            if i < p {\n\
    \                return false;\n            }\n        }\n        // if new value\
    \ is already in the set return false\n        if memo.contains(&i) {\n       \
    \     return false;\n        }\n        // add new value to the set\n        memo.insert(i);\n\
    \        // set new value as previous\n        prev = Some(i);\n    }\n    //\
    \ return true if it makes it out of the loop\n    true\n}\n\nfn main() {\n   \
    \ let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp03k_i4vl.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut prev = i32::MIN;\n    for item in lst {\n        if item\
    \ as i32 <= prev {\n            return false;\n        }\n        prev = item\
    \ as i32;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmps05l6c8o.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    // YOUR CODE HERE\n    let x = lst.len();\n    if x == 1 {\n\
    \        return true;\n    }\n    let mut z = lst[0];\n    for i in 1..x {\n \
    \       if z >= lst[i] {\n            return false;\n        }\n        z = lst[i];\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpdndgiat4.rs:19:17\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut asc = true;\n    let mut desc = true;\n    let mut diff\
    \ = 1;\n    for i in 0..lst.len() {\n        if lst[i] + diff != lst[i + 1] {\n\
    \            asc = false;\n        }\n        if lst[i] - diff != lst[i + 1] {\n\
    \            desc = false;\n        }\n    }\n    asc || desc\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 1 but the index\
    \ is 1', /tmp/tmp91wbyhm5.rs:18:29\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut prev = None;\n    let mut seen = HashSet::new();\n  \
    \  for n in lst {\n        if prev.map_or(false, |prev| prev > n) {\n        \
    \    return false;\n        }\n        if !seen.insert(n) {\n            return\
    \ false;\n        }\n        prev = Some(n);\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpcnsdt9hy.rs:15:20\n   |\n15 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    for i in 0..lst.len() - 1 {\n        if lst[i] >= lst[i + 1]\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpzhcki7_e.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut res = true;\n    for i in 0..lst.len() - 1 {\n      \
    \  if lst[i] >= lst[i + 1] {\n            res = false;\n            break;\n \
    \       }\n    }\n    res\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmppsntqhk7.rs:15:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    if lst.len() == 1 {\n        return true;\n    }\n    for i in\
    \ 0..lst.len() - 1 {\n        if lst[i] > lst[i + 1] {\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpxnjylc8z.rs:17:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut prev = lst[0];\n    for i in 1..lst.len() {\n       \
    \ if lst[i] < prev {\n            return false;\n        }\n        prev = lst[i];\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp1gy6ybgs.rs:14:20\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut check = Vec::new();\n    let mut c = 0;\n    let mut\
    \ repeat = false;\n    let mut sorted = true;\n    let mut i = 0;\n    while i\
    \ < lst.len() {\n        c = lst[i];\n        if check.contains(&c) {\n      \
    \      repeat = true;\n        }\n        check.push(c);\n        i += 1;\n  \
    \  }\n    check.sort();\n    i = 0;\n    while i < lst.len() {\n        if check[i]\
    \ != lst[i] {\n            sorted = false;\n        }\n        i += 1;\n    }\n\
    \    return !repeat && sorted;\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwc6kkfr5.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut previous_number = 0;\n  \
    \  for n in lst {\n        if n <= previous_number {\n            sorted = false;\n\
    \            break;\n        }\n        previous_number = n;\n    }\n    sorted\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpf05o23it.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    //let mut iter = lst.iter();\n    //for (i, j) in lst.iter().zip(iter.next())\
    \ {\n    //    if i < j {\n    //        return false;\n    //    }\n    //}\n\
    \    //\n    //return true;\n    lst.windows(2).all(|win| win[0] <= win[1])\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpgtoto5m0.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut last = std::isize::MIN;\n    for i in lst {\n       \
    \ if i <= last {\n            return false;\n        }\n        last = i;\n  \
    \  }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpowed7w9v.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\nfn main() {\n    let\
    \ candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpcagfpzef.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst2 = lst.clone();\n    lst2.sort();\n    lst == lst2\n\
    }\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpeg38gpw5.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let set = lst.iter().cloned().collect::<HashSet<isize>>();\n\
    \    let seq = lst.iter().cloned().collect::<Vec<isize>>();\n    if set.len()\
    \ == seq.len() {\n        seq.windows(2).all(|x| x[0] <= x[1])\n    } else {\n\
    \        false\n    }\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp5721x5g9.rs:14:45\n\
    \   |\n14 |     let set = lst.iter().cloned().collect::<HashSet<isize>>();\n \
    \  |                                             ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    // return false if input is empty\n    if lst.len() == 0 {\n\
    \        return false;\n    }\n    // return true if input has only one element\n\
    \    if lst.len() == 1 {\n        return true;\n    }\n    // create a new lst\
    \ to fill with duplicates removed, then check if it is sorted\n    let mut new_lst:\
    \ Vec<isize> = Vec::new();\n    for i in 0..lst.len() {\n        if i == 0 {\n\
    \            new_lst.push(lst[i]);\n        } else {\n            if lst[i] !=\
    \ lst[i - 1] {\n                new_lst.push(lst[i]);\n            }\n       \
    \ }\n    }\n    if new_lst.len() < 2 {\n        return true;\n    }\n    // sort\
    \ the new list and compare it to the original\n    let mut sorted_lst = new_lst.clone();\n\
    \    sorted_lst.sort();\n    new_lst == sorted_lst\n}\n\nfn main() {\n    let\
    \ candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfm0shat6.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = is_sorted;\n\
    \    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1, 2,\
    \ 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpczrh2mor.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    lst.windows(2).all(|w| w[0] <= w[1])\n}\n\nfn main() {\n    let\
    \ candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp8l7v52gf.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    lst.windows(2).all(|x| x[0] <= x[1])\n}\n\nfn main() {\n    let\
    \ candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpbhla8r6p.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    for i in 0..lst.len() - 1 {\n        if lst[i] > lst[i + 1] {\n\
    \            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n   \
    \ let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpxt67i12t.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let len = lst.len();\n    for i in 0..len - 1 {\n        if lst[i]\
    \ > lst[i + 1] {\n            return false;\n        }\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpd785h9tn.rs:15:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut flag = true;\n    let len = lst.len();\n    if len >\
    \ 1 {\n        for i in 0..len - 1 {\n            if lst[i] > lst[i + 1] {\n \
    \               flag = false;\n                break;\n            }\n       \
    \ }\n    }\n    flag\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmprnbrdojn.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    lst == lst.iter().sorted().collect::<Vec<_>>()\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sorted` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmpc5eoyen4.rs:14:23\n   |\n14 |     lst ==\
    \ lst.iter().sorted().collect::<Vec<_>>()\n   |                       ^^^^^^ method\
    \ not found in `std::slice::Iter<'_, isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut count = 0;\n    let mut current = None;\n    for i in\
    \ lst {\n        if current.is_none() {\n            current = Some(i);\n    \
    \        continue;\n        }\n        if current.unwrap() == i {\n          \
    \  count += 1;\n        }\n        if current.unwrap() > i {\n            return\
    \ false;\n        }\n        current = Some(i);\n    }\n    count == 0\n}\n\n\
    fn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpndija82m.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut tmp = lst.clone();\n    tmp.sort();\n    for i in 1..tmp.len()\
    \ {\n        if tmp[i - 1] == tmp[i] {\n            return false;\n        }\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpv5khdynm.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut lst_no_dups = lst.clone();\n    lst_no_dups.sort();\n\
    \    lst_no_dups.dedup();\n    lst == lst_no_dups\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmps6pu5vc7.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut current = 0;\n    let mut\
    \ previous = 0;\n    let mut repetitions = 1;\n    for num in lst {\n        current\
    \ = num;\n        if previous < current {\n            previous = current;\n \
    \           repetitions = 1;\n        } else if previous == current {\n      \
    \      repetitions += 1;\n        } else {\n            sorted = false;\n    \
    \        break;\n        }\n    }\n    sorted && repetitions == 1\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmphjoi7wdj.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut sorted = true;\n    let mut prev: isize = 0;\n    for\
    \ i in lst {\n        if prev != 0 && i < prev {\n            sorted = false;\n\
    \            break;\n        }\n        prev = i;\n    }\n    sorted\n}\n\nfn\
    \ main() {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]),\
    \ true);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmput3skx4d.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut last_num = None;\n    for n in lst {\n        match last_num\
    \ {\n            Some(last) => {\n                if last >= n {\n           \
    \         return false;\n                }\n            }\n            None =>\
    \ {}\n        }\n        last_num = Some(n);\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1,\
    \ 3, 2, 4, 5, 6, 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ true);\n    assert_eq!(candidate(vec![1]), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 2, 2, 3, 4]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 4]), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpddm1pep_.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let mut last_element = lst[0];\n    let mut count = 0;\n    for\
    \ element in lst {\n        if element == last_element {\n            count +=\
    \ 1;\n        }\n        if count > 1 {\n            return false;\n        }\n\
    \        if element < last_element {\n            return false;\n        }\n \
    \       last_element = element;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmppwp84pgx.rs:14:28\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given a list of numbers, return whether or not they are sorted\n///\
    \ in ascending order. If list has more than 1 duplicate of the same\n/// number,\
    \ return False. Assume no negative numbers and only integers.\n/// Examples\n\
    /// is_sorted([5]) \u279E True\n/// is_sorted([1, 2, 3, 4, 5]) \u279E True\n///\
    \ is_sorted([1, 3, 2, 4, 5]) \u279E False\n/// is_sorted([1, 2, 3, 4, 5, 6]) \u279E\
    \ True\n/// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279E True\n/// is_sorted([1, 3,\
    \ 2, 4, 5, 6, 7]) \u279E False\n/// is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n\
    /// is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nfn is_sorted(lst: Vec<isize>)\
    \ -> bool {\n    let s = lst.clone();\n    if lst.len() == 1 {\n        return\
    \ true;\n    }\n    s.windows(2).all(|x| x[0] <= x[1])\n}\n\nfn main() {\n   \
    \ let candidate = is_sorted;\n    assert_eq!(candidate(vec![5]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5]), false);\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7]), true);\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ 7]), false);\n    assert_eq!(candidate(Vec::<isize>::new()), true);\n    assert_eq!(candidate(vec![1]),\
    \ true);\n    assert_eq!(candidate(vec![3, 2, 1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 2, 2, 3, 4]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 3, 3, 4]),\
    \ false);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmprhhavdgu.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
