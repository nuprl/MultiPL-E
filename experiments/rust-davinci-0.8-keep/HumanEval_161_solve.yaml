name: HumanEval_161_solve
language: rust
prompt: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
  \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the\
  \ string contains no letters, reverse the string.\n/// The function should return\
  \ the resulted string.\n/// Examples\n/// solve(\"1234\") = \"4321\"\n/// solve(\"\
  ab\") = \"AB\"\n/// solve(\"#a@C\") = \"#A@c\"\nfn solve(s: String) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
  AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
  )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
  AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
  ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
  ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
  \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
  \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n"
completions: ["    s.chars().rev().map(|c| {\n        match c {\n            'a'...'z'\
    \ => c.to_ascii_uppercase(),\n            'A'...'Z' => c.to_ascii_lowercase(),\n\
    \            _ => c,\n        }\n    }).collect()", "    s.chars().rev().map(|c|\
    \ if c.is_ascii_alphabetic() {\n        c.to_ascii_uppercase()\n    } else {\n\
    \        c\n    }).collect()", "    s.chars().rev().map(|x| {\n        match x\
    \ {\n            'a'...'z' => (x as u8 - 32) as char,\n            'A'...'Z' =>\
    \ (x as u8 + 32) as char,\n            _ => x,\n        }\n    }).collect()",
  "    if s.chars().all(|c| !c.is_alphabetic()) {\n        return s.chars().rev().collect();\n\
    \    }\n    s.chars().map(|c| {\n        if c.is_alphabetic() {\n            if\
    \ c.is_uppercase() {\n                c.to_lowercase().to_string()\n         \
    \   } else {\n                c.to_uppercase().to_string()\n            }\n  \
    \      } else {\n            c.to_string()\n        }\n    }).collect()", "  \
    \  let mut chars: Vec<char> = s.chars().collect();\n    if chars.iter().all(|&c|\
    \ !c.is_alphabetic()) {\n        chars.reverse();\n        return chars.into_iter().collect();\n\
    \    }\n    chars.iter().map(|&c| {\n        if c.is_ascii_uppercase() {\n   \
    \         c.to_ascii_lowercase()\n        } else if c.is_ascii_lowercase() {\n\
    \            c.to_ascii_uppercase()\n        } else {\n            c\n       \
    \ }\n    }).collect()", "    s.chars().rev().map(|c| match c {\n        'a'...'z'\
    \ => c.to_ascii_uppercase(),\n        'A'...'Z' => c.to_ascii_lowercase(),\n \
    \       _ => c,\n    }).collect()", '    s.chars().rev().map(|c| if c.is_alphabetic()
    { c.to_lowercase().next().unwrap() } else { c }).collect()', "    s.chars().rev().map(|c|\
    \ {\n        if c.is_alphabetic() {\n            if c.is_uppercase() {\n     \
    \           c.to_lowercase().to_string()\n            } else {\n             \
    \   c.to_uppercase().to_string()\n            }\n        } else {\n          \
    \  c.to_string()\n        }\n    }).collect()", "    if s.chars().any(|c| c.is_alphabetic())\
    \ {\n        s.chars().map(|c| if c.is_alphabetic() { c.to_ascii_uppercase() }\
    \ else { c }).collect()\n    } else {\n        s.chars().rev().collect()\n   \
    \ }", "    if !s.chars().any(|x| x.is_alphabetic()) {\n        return s.chars().rev().collect::<String>();\n\
    \    }\n    s.chars().map(|x| {\n        if x.is_ascii_uppercase() {\n       \
    \     x.to_ascii_lowercase()\n        } else if x.is_ascii_lowercase() {\n   \
    \         x.to_ascii_uppercase()\n        } else {\n            x\n        }\n\
    \    }).collect::<String>()", "    let mut res = String::new();\n    for c in\
    \ s.chars() {\n        match c {\n            'A'...'Z' => res.push(c.to_ascii_lowercase()),\n\
    \            'a'...'z' => res.push(c.to_ascii_uppercase()),\n            _ =>\
    \ res.push(c),\n        }\n    }\n    if res.chars().all(|c| !c.is_alphabetic())\
    \ {\n        res.chars().rev().collect()\n    } else {\n        res\n    }", '    return
    s.chars().rev().map(|c| c.is_ascii_alphabetic()? c.to_ascii_uppercase(): c.to_ascii_lowercase()).collect();',
  "    if s.is_empty() {\n        return s;\n    }\n    let s = s.chars().map(|c|\
    \ if c.is_uppercase() {\n        c.to_lowercase().next().unwrap()\n    } else\
    \ if c.is_lowercase() {\n        c.to_uppercase().next().unwrap()\n    } else\
    \ {\n        c\n    }).collect::<String>();\n    if s.chars().all(|c| !c.is_alphabetic())\
    \ {\n        s.chars().rev().collect::<String>()\n    } else {\n        s\n  \
    \  }", "    let mut s: Vec<char> = s.chars().collect();\n    if !s.iter().any(|x|\
    \ x.is_alphabetic()) {\n        s.reverse();\n        return s.into_iter().collect();\n\
    \    }\n    for i in 0..s.len() {\n        let current = s[i];\n        if current.is_alphabetic()\
    \ {\n            s[i] = if current.is_uppercase() {\n                current.to_lowercase().next().unwrap()\n\
    \            } else {\n                current.to_uppercase().next().unwrap()\n\
    \            };\n        }\n    }\n    s.into_iter().collect()", "    let mut\
    \ res = String::new();\n    for c in s.chars() {\n        if c.is_alphabetic()\
    \ {\n            res.push(c.to_ascii_uppercase());\n        } else {\n       \
    \     res.push(c);\n        }\n    }\n    if res.chars().any(|c| c.is_alphabetic())\
    \ {\n        res\n    } else {\n        res.chars().rev().collect()\n    }", " \
    \   let mut res = String::new();\n    for ch in s.chars() {\n        match ch\
    \ {\n            'a'..='z' => res.push(ch.to_ascii_uppercase()),\n           \
    \ 'A'..='Z' => res.push(ch.to_ascii_lowercase()),\n            _ => res.push(ch),\n\
    \        }\n    }\n    res.chars().rev().collect()", "    let mut result = String::new();\n\
    \    for ch in s.chars() {\n        if ch.is_ascii_alphabetic() {\n          \
    \  result.push(ch.swap_case());\n        } else {\n            result.push(ch);\n\
    \        }\n    }\n    if result.is_empty() {\n        s.chars().rev().collect()\n\
    \    } else {\n        result\n    }", "  let mut result = s.chars().rev().collect::<String>();\n\
    \  for (i, c) in result.chars().enumerate() {\n    let mut cc = c;\n    if c.is_alphabetic()\
    \ {\n      cc = c.to_uppercase().next().unwrap();\n      if c.is_uppercase() {\n\
    \        cc = c.to_lowercase().next().unwrap();\n      }\n    }\n    result.replace_range(i..i+1,\
    \ &cc.to_string());\n  }\n  result", "    let mut result = String::from(\"\");\n\
    \    let mut s_chars = s.chars();\n    let mut is_str_has_letter = false;\n  \
    \  while let Some(c) = s_chars.next() {\n        let c_len = c.len_utf8();\n \
    \       if c_len == 1 {\n            if c.is_ascii_alphabetic() {\n          \
    \      is_str_has_letter = true;\n                result.push(c.to_ascii_uppercase());\n\
    \            } else {\n                result.push(c);\n            }\n      \
    \  } else {\n            result.push(c);\n        }\n    }\n    if is_str_has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }", "    String::from_iter(s.chars().rev().map(|c| {\n        if c.is_ascii_alphabetic()\
    \ {\n            return c.to_ascii_uppercase();\n        }\n        return c;\n\
    \    }))", "    let mut result = String::new();\n    let s: Vec<char> = s.chars().collect();\n\
    \    let mut has_letters = false;\n    for i in 0..s.len() {\n        if s[i].is_alphabetic()\
    \ {\n            result.push(s[i].to_uppercase().next().unwrap());\n         \
    \   has_letters = true;\n        } else {\n            result.push(s[i]);\n  \
    \      }\n    }\n    if !has_letters {\n        result = result.chars().rev().collect();\n\
    \    }\n    result", "    let mut res = String::new();\n    for c in s.chars()\
    \ {\n        if c.is_ascii_alphabetic() {\n            res.push(c.to_ascii_uppercase());\n\
    \        } else {\n            res.push(c);\n        }\n    }\n    if !res.is_empty()\
    \ {\n        res\n    } else {\n        s.chars().rev().collect()\n    }", " \
    \   s.chars().rev().map(|x| x.is_alphabetic() && x.is_lowercase()\n          \
    \                                     || x.is_uppercase()\n                  \
    \                                && x.is_alphabetic() ? x.to_uppercase().to_string()\n\
    \                                                                          : x.to_lowercase().to_string()).collect()",
  "    //method 1: use fold\n    //s.chars().fold(String::new(), |mut acc, c| {\n\
    \    //    acc.push(if c.is_alphabetic() {\n    //        c.to_ascii_uppercase()\n\
    \    //    } else {\n    //        c.to_ascii_lowercase()\n    //    });\n   \
    \ //    acc\n    //})\n\n    //method 2: by hand\n    if s.is_empty() {\n    \
    \    return s;\n    }\n    let mut str_vec: Vec<char> = s.chars().collect();\n\
    \    for i in 0..str_vec.len() {\n        if str_vec[i].is_alphabetic() {\n  \
    \          if str_vec[i].is_lowercase() {\n                str_vec[i] = str_vec[i].to_ascii_uppercase();\n\
    \            } else {\n                str_vec[i] = str_vec[i].to_ascii_lowercase();\n\
    \            }\n        }\n    }\n    str_vec.iter().collect()", "    if s.chars().all(|c|\
    \ !c.is_alphabetic()) {\n        return s.chars().rev().collect();\n    }\n  \
    \  s.chars().map(|c| if c.is_alphabetic() { c.to_ascii_uppercase() } else { c.to_ascii_lowercase()\
    \ }).collect()", "    s.chars().rev().map(|c| match c {\n        'A'..='Z' =>\
    \ c.to_ascii_lowercase(),\n        'a'..='z' => c.to_ascii_uppercase(),\n    \
    \    _ => c,\n    }).collect()", "    let mut res = String::new();\n    for c\
    \ in s.chars() {\n        if c.is_alphabetic() {\n            res.push(c.to_lowercase().next().unwrap());\n\
    \        } else {\n            res.push(c);\n        }\n    }\n    if res.is_empty()\
    \ {\n        return s.chars().rev().collect();\n    }\n    res", "    if s.chars().all(|c|\
    \ !c.is_alphabetic()) {\n        s.chars().rev().collect()\n    } else {\n   \
    \     s.chars().map(|c| if c.is_ascii_lowercase() {\n            c.to_ascii_uppercase()\n\
    \        } else if c.is_ascii_uppercase() {\n            c.to_ascii_lowercase()\n\
    \        } else {\n            c\n        }).collect()\n    }", "    if !s.contains(char::is_alphabetic)\
    \ {\n        s.chars().rev().collect()\n    } else {\n        s.chars().map(|c|\
    \ if c.is_alphabetic() {\n            c.to_ascii_uppercase()\n        } else {\n\
    \            c.to_ascii_lowercase()\n        }).collect()\n    }", "    let mut\
    \ lower_case = vec![];\n    let mut upper_case = vec![];\n    for c in (b'a'..=b'z').rev()\
    \ {\n        lower_case.push(c as char);\n    }\n    for c in (b'A'..=b'Z').rev()\
    \ {\n        upper_case.push(c as char);\n    }\n    let mut result = String::new();\n\
    \    for c in s.chars() {\n        if let Some(x) = lower_case.iter().position(|&r|\
    \ r == c) {\n            result.push(upper_case[x]);\n        } else if let Some(x)\
    \ = upper_case.iter().position(|&r| r == c) {\n            result.push(lower_case[x]);\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    result",
  '    s.chars().rev().map(|c| if c.is_ascii_alphabetic() { c.to_ascii_uppercase()
    } else { c }).collect()', "    if s.chars().filter(|c| c.is_alphabetic()).count()\
    \ == 0 {\n        return s.chars().rev().collect::<String>();\n    }\n    s.chars().map(|c|\
    \ if c.is_alphabetic() {\n        if c.is_lowercase() {\n            c.to_uppercase().next().unwrap()\n\
    \        } else {\n            c.to_lowercase().next().unwrap()\n        }\n \
    \   } else {\n        c\n    }).collect::<String>()", '    return s.chars().map(|c|
    if c.is_alphabetic() { c.to_ascii_uppercase() } else { c.to_ascii_lowercase()
    }).collect::<String>();', "    s.chars().map(|c| {\n        if c.is_ascii_alphabetic()\
    \ {\n            if c.is_lowercase() {\n                c.to_ascii_uppercase()\n\
    \            } else {\n                c.to_ascii_lowercase()\n            }\n\
    \        } else {\n            c\n        }\n    }).collect()", "    let mut new_string\
    \ = String::new();\n    for i in s.chars() {\n        if i.is_alphabetic() {\n\
    \            new_string.push(i.to_ascii_uppercase());\n        } else {\n    \
    \        new_string.push(i);\n        }\n    }\n    new_string", "    let mut\
    \ ch_vec: Vec<char> = s.chars().collect();\n    let mut res = String::from(\"\"\
    );\n    for ch in ch_vec {\n        if ch.is_alphabetic() {\n            if ch.is_lowercase()\
    \ {\n                res.push(ch.to_uppercase().next().unwrap());\n          \
    \  } else {\n                res.push(ch.to_lowercase().next().unwrap());\n  \
    \          }\n        } else {\n            res.push(ch);\n        }\n    }\n\
    \    if s.len() == res.len() {\n        res.chars().rev().collect()\n    } else\
    \ {\n        res\n    }", "    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            result.push(if c.is_uppercase()\
    \ { c.to_lowercase().to_string() } else { c.to_uppercase().to_string() });\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if result.chars().any(|c|\
    \ c.is_alphabetic()) {\n        result\n    } else {\n        result.chars().rev().collect()\n\
    \    }", "    let mut res = String::new();\n    let mut cnt = 0;\n    for c in\
    \ s.chars() {\n        if !c.is_ascii_alphabetic() {\n            cnt += 1;\n\
    \            res.push(c);\n        } else {\n            if c.is_lowercase() {\n\
    \                res.push(c.to_uppercase().to_string());\n            } else {\n\
    \                res.push(c.to_lowercase().to_string());\n            }\n    \
    \    }\n    }\n    if cnt == res.len() {\n        res.chars().rev().collect()\n\
    \    } else {\n        res\n    }", "    let mut result: Vec<char> = Vec::new();\n\
    \    let mut has_letter = false;\n    for c in s.chars() {\n        if c.is_alphabetic()\
    \ {\n            result.push(c.to_lowercase().to_string().chars().next().unwrap());\n\
    \            has_letter = true;\n        } else {\n            result.push(c);\n\
    \        }\n    }\n    if !has_letter {\n        result.reverse();\n    }\n  \
    \  let mut string = result.into_iter().collect::<String>();\n    for i in 0..string.len()\
    \ {\n        if string.chars().nth(i).unwrap().is_alphabetic() {\n           \
    \ string.replace_range(i..i+1, &string.chars().nth(i).unwrap().to_uppercase().to_string());\n\
    \        }\n    }\n    string", '    s.chars().rev().map(|x| x.to_ascii_lowercase()).collect()',
  "    let mut res = String::new();\n    for c in s.chars() {\n        if c.is_alphabetic()\
    \ {\n            res.push(c.to_lowercase().to_string().parse::<char>().unwrap());\n\
    \        } else {\n            res.push(c);\n        }\n    }\n    res.chars().rev().collect::<String>()",
  "    let mut result = String::new();\n    let mut letter_found = false;\n    for\
    \ c in s.chars() {\n        if !c.is_alphabetic() {\n            result.push(c);\n\
    \        } else {\n            letter_found = true;\n            result.push(c.to_ascii_uppercase());\n\
    \        }\n    }\n    if !letter_found {\n        result.chars().rev().collect()\n\
    \    } else {\n        result\n    }", "    s.chars().rev().map(|c| c.is_alphabetic()\
    \ && c.is_lowercase()\n        || c.is_alphabetic() && c.is_uppercase() ? c.to_ascii_uppercase()\
    \ : c).collect()", "    let mut res = String::new();\n    for c in s.chars() {\n\
    \        res.push(match c {\n            'a'...'z' => c.to_ascii_uppercase(),\n\
    \            'A'...'Z' => c.to_ascii_lowercase(),\n            _ => c,\n     \
    \   });\n    }\n    res.chars().rev().collect()", "    s.chars().rev().map(|c|\
    \ if c.is_lowercase() {\n        c.to_uppercase().next().unwrap()\n    } else\
    \ if c.is_uppercase() {\n        c.to_lowercase().next().unwrap()\n    } else\
    \ {\n        c\n    }).collect()", "    s.chars().rev().map(|c| {\n        if\
    \ c.is_ascii_alphabetic() {\n            c.swap_case()\n        } else {\n   \
    \         c\n        }\n    }).collect()", "    let mut result = String::new();\n\
    \    for c in s.chars() {\n        if c.is_alphabetic() {\n            result.push(c.to_uppercase().next().unwrap());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    result.chars().rev().collect()",
  "    s.chars().map(|c| {\n        if !c.is_alphabetic() {\n            c\n     \
    \   } else if c.is_uppercase() {\n            c.to_lowercase().next().unwrap()\n\
    \        } else {\n            c.to_uppercase().next().unwrap()\n        }\n \
    \   }).collect()", "    let mut s: Vec<char> = s.chars().collect();\n    let mut\
    \ has_letter = false;\n    for i in 0..s.len() {\n        if s[i].is_alphabetic()\
    \ {\n            has_letter = true;\n            if s[i].is_lowercase() {\n  \
    \              s[i] = s[i].to_uppercase().next().unwrap();\n            } else\
    \ {\n                s[i] = s[i].to_lowercase().next().unwrap();\n           \
    \ }\n        }\n    }\n    if !has_letter {\n        s.reverse();\n    }\n   \
    \ s.into_iter().collect()", "    let mut s = s.chars().collect::<Vec<char>>();\n\
    \    if s.iter().any(|c| c.is_alphabetic()) {\n        for c in s.iter_mut() {\n\
    \            if c.is_alphabetic() {\n                *c = c.to_uppercase().next().unwrap();\n\
    \            } else {\n                *c = c.to_lowercase().next().unwrap();\n\
    \            }\n        }\n    } else {\n        s.reverse();\n    }\n    s.into_iter().collect()",
  '    unimplemented!();', "  let mut s: Vec<char> = s.chars().collect();\n  let mut\
    \ no_letters = true;\n  for i in 0..s.len() {\n    if s[i].is_alphabetic() {\n\
    \      no_letters = false;\n      if s[i].is_lowercase() {\n        s[i] = s[i].to_uppercase().next().unwrap();\n\
    \      } else {\n        s[i] = s[i].to_lowercase().next().unwrap();\n      }\n\
    \    }\n  }\n  if no_letters {\n    s.reverse();\n  }\n  s.into_iter().collect()",
  "    s.chars().rev().map(|c|\n        if c.is_lowercase() {\n            c.to_uppercase().to_string()\n\
    \        } else if c.is_uppercase() {\n            c.to_lowercase().to_string()\n\
    \        } else {\n            c.to_string()\n        }\n    ).collect()", " \
    \   s.chars().rev().map(|ch| match ch {\n        'a'...'z' => ch.to_ascii_uppercase(),\n\
    \        'A'...'Z' => ch.to_ascii_lowercase(),\n        _ => ch,\n    }).collect()",
  "    s.chars().rev().map(|c| {\n        match c {\n            'a' | 'A' => 'A',\n\
    \            'b' | 'B' => 'B',\n            'c' | 'C' => 'C',\n            'd'\
    \ | 'D' => 'D',\n            'e' | 'E' => 'E',\n            'f' | 'F' => 'F',\n\
    \            'g' | 'G' => 'G',\n            'h' | 'H' => 'H',\n            'i'\
    \ | 'I' => 'I',\n            'j' | 'J' => 'J',\n            'k' | 'K' => 'K',\n\
    \            'l' | 'L' => 'L',\n            'm' | 'M' => 'M',\n            'n'\
    \ | 'N' => 'N',\n            'o' | 'O' => 'O',\n            'p' | 'P' => 'P',\n\
    \            'q' | 'Q' => 'Q',\n            'r' | 'R' => 'R',\n            's'\
    \ | 'S' => 'S',\n            't' | 'T' => 'T',\n            'u' | 'U' => 'U',\n\
    \            'v' | 'V' => 'V',\n            'w' | 'W' => 'W',\n            'x'\
    \ | 'X' => 'X',\n            'y' | 'Y' => 'Y',\n            'z' | 'Z' => 'Z',\n\
    \            _ => c,\n        }\n    }).collect()", "    s.chars().rev().map(|x|\
    \ {\n        if x.is_alphabetic() {\n            x.to_ascii_uppercase()\n    \
    \    } else {\n            x\n        }\n    }).collect()", "    let mut result\
    \ = String::new();\n    for c in s.chars() {\n        if c.is_ascii_alphabetic()\
    \ {\n            if c.is_ascii_lowercase() {\n                result.push(c.to_ascii_uppercase());\n\
    \            } else {\n                result.push(c.to_ascii_lowercase());\n\
    \            }\n        } else {\n            result.push(c);\n        }\n   \
    \ }\n    if result.is_empty() {\n        return s;\n    }\n    result", "    if\
    \ s.chars().any(|c| c.is_alphabetic()) {\n        s.chars().map(|c| if c.is_alphabetic()\
    \ { c.to_lowercase().next().unwrap() } else { c }).collect()\n    } else {\n \
    \       s.chars().rev().collect()\n    }", "    s.chars().rev().map(|c| match\
    \ c {\n        'a'...'z' => c.to_ascii_uppercase(),\n        'A'...'Z' => c.to_ascii_lowercase(),\n\
    \        _ => c,\n    }).collect()", "    let s = s.as_bytes();\n    let mut chars\
    \ = vec![];\n    for c in s {\n        let x = match *c {\n            b'a'...b'z'\
    \ => {\n                c - b'a' + b'A'\n            },\n            b'A'...b'Z'\
    \ => {\n                c - b'A' + b'a'\n            },\n            _ => *c,\n\
    \        };\n        chars.push(x);\n    }\n    unsafe { String::from_utf8_unchecked(chars)\
    \ }", '    s.chars().rev().map(|c| if c.is_ascii_alphabetic() { c.to_ascii_uppercase()
    } else { c }).collect()', "    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            result.push(c.to_uppercase().to_string().chars().next().unwrap());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    if result.len()\
    \ == 0 {\n        return s.chars().rev().collect();\n    } else {\n        return\
    \ result;\n    }", "    let mut r = String::from(\"\");\n    let mut c: char;\n\
    \    for i in s.chars() {\n        if (65 <= i as u8 && i as u8 <= 90) || (97\
    \ <= i as u8 && i as u8 <= 122) {\n            c = if i.is_uppercase() {\n   \
    \             i.to_lowercase().next().unwrap()\n            } else {\n       \
    \         i.to_uppercase().next().unwrap()\n            };\n            r.push(c);\n\
    \        } else {\n            r.push(i);\n        }\n    }\n    if r.is_empty()\
    \ {\n        s.chars().rev().collect()\n    } else {\n        r\n    }", "  s.chars().map(|c|\
    \ match c {\n    'A'..='Z' => c.to_ascii_lowercase(),\n    'a'..='z' => c.to_ascii_uppercase(),\n\
    \    _ => c\n  }).collect()", "    s.chars().rev().map(|c| {\n        if c.is_alphabetic()\
    \ {\n            c.to_lowercase().next().unwrap()\n        } else {\n        \
    \    c\n        }\n    }).collect()", "    let mut result = String::new();\n \
    \   for c in s.chars() {\n        match c {\n            'A'...'Z' => result.push(c.to_ascii_lowercase()),\n\
    \            'a'...'z' => result.push(c.to_ascii_uppercase()),\n            _\
    \ => result.push(c),\n        }\n    }\n    result.chars().rev().collect()", '    s.chars().rev().map(|i|
    if i.is_alphabetic() { i.to_ascii_uppercase() } else { i }).collect()', "    let\
    \ mut s = s.chars().collect::<Vec<char>>();\n    let mut letters = Vec::new();\n\
    \    let mut rev = Vec::new();\n    for c in s.iter_mut() {\n        match c {\n\
    \            'A'..='Z' => {\n                letters.push(c.clone());\n      \
    \          rev.push(c.to_ascii_lowercase());\n            }\n            'a'..='z'\
    \ => {\n                letters.push(c.clone());\n                rev.push(c.to_ascii_uppercase());\n\
    \            }\n            _ => continue,\n        }\n    }\n    rev.reverse();\n\
    \    for (i, c) in letters.iter().enumerate() {\n        *s.iter_mut().find(|&&x|\
    \ x == *c).unwrap() = rev[i];\n    }\n    s.iter().collect()", "    s.chars().rev().map(|c|\
    \ match c {\n        'a'...'z' => c.to_ascii_uppercase(),\n        'A'...'Z' =>\
    \ c.to_ascii_lowercase(),\n        _ => c,\n    }).collect()", "    s.chars().rev().map(|c|\
    \ c.is_ascii_alphabetic() && c.is_ascii_lowercase()\n        || c.is_ascii_alphabetic()\
    \ && c.is_ascii_uppercase()\n            ? c.to_ascii_uppercase()\n          \
    \  : c.to_ascii_lowercase()).collect()", "    s.chars().rev().map(|c| if c.is_ascii_alphabetic()\
    \ {\n        c.to_ascii_uppercase()\n    } else {\n        c\n    }).collect()",
  "    let mut result = String::new();\n    for character in s.chars() {\n       \
    \ if character.is_alphabetic() {\n            result.push(character.to_uppercase().next().unwrap());\n\
    \        } else {\n            result.push(character);\n        }\n    }\n   \
    \ result.chars().rev().collect()", "    s.chars().rev().map(|x| match x {\n  \
    \      'a'..='z' => x.to_ascii_uppercase(),\n        'A'..='Z' => x.to_ascii_lowercase(),\n\
    \        _ => x,\n    }).collect()", "    s.chars().rev().map(|c| match c {\n\
    \        'a'..='z' => c.to_ascii_uppercase(),\n        'A'..='Z' => c.to_ascii_lowercase(),\n\
    \        c => c,\n    }).collect()", "    s.chars().rev().map(|c| match c {\n\
    \        'a'...'z' => c.to_ascii_uppercase(),\n        'A'...'Z' => c.to_ascii_lowercase(),\n\
    \        _ => c,\n    }).collect()", "    let mut result: String = String::new();\n\
    \    for c in s.chars() {\n        if c.is_alphabetic() {\n            if c.is_uppercase()\
    \ {\n                result.push(c.to_lowercase().collect::<String>());\n    \
    \        } else {\n                result.push(c.to_uppercase().collect::<String>());\n\
    \            }\n        } else {\n            result.push(c);\n        }\n   \
    \ }\n    result.chars().rev().collect::<String>()", "    let mut vec = Vec::new();\n\
    \    for c in s.chars() {\n        if c.is_ascii_alphabetic() {\n            if\
    \ c.is_lowercase() {\n                vec.push(c.to_ascii_uppercase());\n    \
    \        } else {\n                vec.push(c.to_ascii_lowercase());\n       \
    \     }\n        } else {\n            vec.push(c);\n        }\n    }\n    if\
    \ vec.is_empty() {\n        s.chars().rev().collect()\n    } else {\n        vec.into_iter().collect()\n\
    \    }", "    let mut res = String::new();\n    let mut has_letters = false;\n\
    \    for ch in s.chars() {\n        if ch.is_alphabetic() {\n            has_letters\
    \ = true;\n            res.push(ch.to_ascii_uppercase());\n        } else {\n\
    \            res.push(ch);\n        }\n    }\n    if has_letters {\n        res\n\
    \    } else {\n        s.chars().rev().collect()\n    }", "    let mut s: Vec<char>\
    \ = s.chars().collect();\n    let mut counter = 0;\n    for i in 0..s.len() {\n\
    \        if s[i].is_alphabetic() {\n            counter += 1;\n        }\n   \
    \ }\n    if counter > 0 {\n        for i in 0..s.len() {\n            if s[i].is_alphabetic()\
    \ {\n                s[i] = if s[i].is_lowercase() {\n                    s[i].to_uppercase().next().unwrap()\n\
    \                } else {\n                    s[i].to_lowercase().next().unwrap()\n\
    \                };\n            }\n        }\n    } else {\n        for i in\
    \ 0..s.len() / 2 {\n            s.swap(i, s.len() - i - 1);\n        }\n    }\n\
    \    s.into_iter().collect()", '    s.chars().rev().map(|c| c.toggle_case()).collect()',
  "    s.chars().rev().map(|c| match c {\n        'A'...'Z' => c.to_ascii_lowercase(),\n\
    \        'a'...'z' => c.to_ascii_uppercase(),\n        _ => c,\n    }).collect()",
  '    s.chars().rev().map(|c| if c.is_alphabetic() { c.to_lowercase().nth(0).unwrap()
    } else { c }).collect()', "    s.chars().rev().map(|c| match c {\n        'A'..='Z'\
    \ => c.to_ascii_lowercase(),\n        'a'..='z' => c.to_ascii_uppercase(),\n \
    \       _ => c,\n    }).collect()", "  s.chars().map(|c| if c.is_ascii_alphabetic()\
    \ {\n    if c.is_lowercase() {\n      c.to_ascii_uppercase()\n    } else {\n \
    \     c.to_ascii_lowercase()\n    }\n  } else {\n    c\n  }).collect()", "   \
    \ let mut chars: Vec<char> = s.chars().collect();\n    chars.reverse();\n    chars.iter().map(|x|\
    \ {\n        match x {\n            'a'...'z' => *x = x.to_ascii_uppercase(),\n\
    \            'A'...'Z' => *x = x.to_ascii_lowercase(),\n            _ => {}\n\
    \        }\n        x\n    }).collect()", "    s.chars().rev().map(|ch| match\
    \ ch {\n        'A' ... 'Z' => ch.to_ascii_lowercase(),\n        'a' ... 'z' =>\
    \ ch.to_ascii_uppercase(),\n        _ => ch,\n    }).collect()", '    s.chars().rev().map(|c|
    if c.is_alphabetic() { c.to_ascii_uppercase() } else { c }).collect()', "  let\
    \ mut result: String = String::new();\n  let mut reverse: bool = true;\n  for\
    \ i in s.chars() {\n    if i.is_alphabetic() {\n      reverse = false;\n     \
    \ result.push(if i.is_lowercase() { i.to_uppercase().next().unwrap() } else {\
    \ i.to_lowercase().next().unwrap() });\n    } else {\n      result.push(i);\n\
    \    }\n  }\n  if reverse {\n    let mut chars: Vec<char> = s.chars().collect();\n\
    \    chars.reverse();\n    result = chars.into_iter().collect();\n  }\n  result",
  "    s.chars().rev().map(|c| {\n        if c.is_ascii_alphabetic() {\n         \
    \   if c.is_lowercase() {\n                c.to_ascii_uppercase()\n          \
    \  } else {\n                c.to_ascii_lowercase()\n            }\n        }\
    \ else {\n            c\n        }\n    }).collect()", "  s.chars().rev().map(|c|\
    \ match c {\n      'a'...'z' => c.to_ascii_uppercase(),\n      'A'...'Z' => c.to_ascii_lowercase(),\n\
    \      _ => c\n  }).collect()", "    let mut res = String::new();\n    for c in\
    \ s.chars() {\n        match c {\n            'a'...'z' => res.push(c.to_ascii_uppercase()),\n\
    \            'A'...'Z' => res.push(c.to_ascii_lowercase()),\n            _ =>\
    \ res.push(c),\n        }\n    }\n    if res.chars().all(|c| !c.is_alphabetic())\
    \ {\n        res.chars().rev().collect()\n    } else {\n        res\n    }", " \
    \   s.chars().fold(String::new(), |mut acc, c| {\n        if c.is_alphabetic()\
    \ {\n            let is_upper = c.is_uppercase();\n            acc.push(c.to_ascii_lowercase());\n\
    \            if is_upper {\n                acc.pop();\n                acc.push(c.to_ascii_uppercase());\n\
    \            }\n        } else {\n            acc.push(c);\n        }\n      \
    \  acc\n    })", "    let mut output: String = String::new();\n    for c in s.chars()\
    \ {\n        match c {\n            x if x.is_alphabetic() => {\n            \
    \    output.push(x.to_ascii_uppercase());\n            },\n            x if x.is_ascii_uppercase()\
    \ => {\n                output.push(x.to_ascii_lowercase());\n            },\n\
    \            _ => {\n                output.push(c);\n            }\n        }\n\
    \    }\n    if output.chars().any(|c| c.is_alphabetic()) {\n        output\n \
    \   } else {\n        s.chars().rev().collect()\n    }", "    s.chars().rev().map(|c|\
    \ match c {\n        'a'..='z' => c.to_ascii_uppercase(),\n        'A'..='Z' =>\
    \ c.to_ascii_lowercase(),\n        _ => c,\n    }).collect()", "    s.chars().rev().map(|c|\
    \ {\n        match c {\n            'a'...'z' => c.to_ascii_uppercase(),\n   \
    \         'A'...'Z' => c.to_ascii_lowercase(),\n            _ => c,\n        }\n\
    \    }).collect()", "    let s = s.chars();\n    let mut res = String::new();\n\
    \    for i in s {\n        if i.is_alphabetic() {\n            res.push(i.to_lowercase().next().unwrap());\n\
    \        } else {\n            res.push(i);\n        }\n    }\n    res.chars().rev().collect::<String>()",
  "    // https://stackoverflow.com/questions/38406736/how-to-convert-a-char-to-uppercase-in-rust\n\
    \    s.chars().map(|c| match c {\n        'a'...'z' => c.to_ascii_uppercase(),\n\
    \        'A'...'Z' => c.to_ascii_lowercase(),\n        _ => c,\n    }).collect()",
  "    s.chars().rev().map(|c| {\n        if c.is_alphabetic() {\n            if c.is_lowercase()\
    \ {\n                c.to_uppercase().next().unwrap()\n            } else {\n\
    \                c.to_lowercase().next().unwrap()\n            }\n        } else\
    \ {\n            c\n        }\n    }).collect()", "    let mut res = String::new();\n\
    \    for c in s.chars() {\n        if c.is_ascii_lowercase() {\n            res.push(c.to_ascii_uppercase());\n\
    \        } else if c.is_ascii_uppercase() {\n            res.push(c.to_ascii_lowercase());\n\
    \        } else {\n            res.push(c);\n        }\n    }\n    if res.chars().all(|c|\
    \ !c.is_ascii_alphabetic()) {\n        res.chars().rev().collect()\n    } else\
    \ {\n        res\n    }", '    s.chars().rev().map(|c| if c.is_lowercase() { c.to_ascii_uppercase()
    } else { c.to_ascii_lowercase() }).collect()', "    let mut ret = String::new();\n\
    \    for c in s.chars() {\n        if c.is_alphabetic() {\n            ret.push(c.to_ascii_uppercase());\n\
    \        } else {\n            ret.push(c);\n        }\n    }\n    if ret.is_empty()\
    \ {\n        ret = s;\n    }\n    ret.chars().rev().collect()", "    if s.chars().any(|x|\
    \ x.is_alphabetic()) {\n        s.chars().map(|x| if x.is_alphabetic() {x.to_ascii_uppercase()}\
    \ else {x}).collect()\n    } else {\n        s.chars().rev().collect()\n    }",
  "    s.chars().rev().map(|c| match c {\n        'a'...'z' => c.to_ascii_uppercase(),\n\
    \        'A'...'Z' => c.to_ascii_lowercase(),\n        _ => c,\n    }).collect()",
  "    let mut result = String::new();\n    for c in s.chars() {\n        if c.is_alphabetic()\
    \ {\n            result.push(c.to_ascii_uppercase());\n        } else {\n    \
    \        result.push(c);\n        }\n    }\n    if result.len() == 0 {\n     \
    \   s.chars().rev().collect()\n    } else {\n        result\n    }", "    s.chars().rev().map(|c|\
    \ match c {\n        a if a.is_lowercase() => a.to_uppercase().next().unwrap(),\n\
    \        a if a.is_uppercase() => a.to_lowercase().next().unwrap(),\n        _\
    \ => c\n    }).collect()", "    let mut res = String::new();\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            res.push(if c.is_lowercase()\
    \ { c.to_uppercase().nth(0).unwrap() } else { c.to_lowercase().nth(0).unwrap()\
    \ });\n        } else {\n            res.push(c);\n        }\n    }\n    if res.is_empty()\
    \ {\n        s.chars().rev().collect()\n    } else {\n        res\n    }", '    s.chars().rev().map(|x|
    if x.is_alphabetic() { x.to_ascii_uppercase() } else { x }).collect()', "    s.chars().rev().map(|c|\
    \ {\n        match c {\n            'a'..='z' => c.to_ascii_uppercase(),\n   \
    \         'A'..='Z' => c.to_ascii_lowercase(),\n            _ => c,\n        }\n\
    \    }).collect()", "    s.chars().rev().map(|c| match c {\n        'a'...'z'\
    \ => c.to_ascii_uppercase(),\n        'A'...'Z' => c.to_ascii_lowercase(),\n \
    \       _ => c,\n    }).collect()", "    let mut iter = s.chars();\n    let mut\
    \ res = String::new();\n    while let Some(c) = iter.next() {\n        match c\
    \ {\n            'A'...'Z' => res.push((c as u8 + 32) as char),\n            'a'...'z'\
    \ => res.push((c as u8 - 32) as char),\n            _ => res.push(c),\n      \
    \  }\n    }\n    if res.is_empty() {\n        s.chars().rev().collect()\n    }\
    \ else {\n        res\n    }", "    let mut answer = String::new();\n    for c\
    \ in s.chars() {\n        if c.is_alphabetic() {\n            answer.push(c.to_ascii_uppercase());\n\
    \        } else {\n            answer.push(c);\n        }\n    }\n    answer",
  "    s.chars().rev().map(|c| match c {\n        'a'...'z' => c.to_ascii_uppercase(),\n\
    \        'A'...'Z' => c.to_ascii_lowercase(),\n        _ => c,\n    }).collect()",
  "    let mut c = s.chars();\n    let mut iter = s.chars();\n    let mut result =\
    \ String::new();\n    let mut no_letter = true;\n    while let Some(v) = c.next()\
    \ {\n        if v.is_ascii_letter() {\n            no_letter = false;\n      \
    \      break;\n        }\n    }\n    if no_letter {\n        while let Some(v)\
    \ = iter.next() {\n            result.push(v);\n        }\n        return result.chars().rev().collect();\n\
    \    }\n\n    for c in s.chars() {\n        if c.is_ascii_uppercase() {\n    \
    \        result.push(c.to_ascii_lowercase());\n        } else if c.is_ascii_lowercase()\
    \ {\n            result.push(c.to_ascii_uppercase());\n        } else {\n    \
    \        result.push(c);\n        }\n    }\n    result", '    unimplemented!()',
  "    let mut chars = s.chars();\n    if let Some(c) = chars.next() {\n        let\
    \ mut r = String::new();\n        if c.is_ascii_lowercase() {\n            r.push(c.to_ascii_uppercase());\n\
    \        } else if c.is_ascii_uppercase() {\n            r.push(c.to_ascii_lowercase());\n\
    \        } else {\n            r.push(c);\n        }\n        for c in chars {\n\
    \            if c.is_ascii_lowercase() {\n                r.push(c.to_ascii_uppercase());\n\
    \            } else if c.is_ascii_uppercase() {\n                r.push(c.to_ascii_lowercase());\n\
    \            } else {\n                r.push(c);\n            }\n        }\n\
    \        r\n    } else {\n        s\n    }", "    // TODO\n    unimplemented!();",
  "    return s.chars().map(|x| {\n        if x.is_uppercase() {\n            x.to_lowercase().next().unwrap()\n\
    \        } else if x.is_lowercase() {\n            x.to_uppercase().next().unwrap()\n\
    \        } else {\n            x\n        }\n    }).collect();", '    s.chars().rev().collect::<String>()',
  "    s.chars().map(|c| if c.is_alphabetic() {\n        c.to_ascii_uppercase()\n\
    \    } else {\n        c\n    }).rev().collect()", "    let mut res = String::new();\n\
    \    for c in s.chars() {\n        match c {\n            'a'..='z' => res.push(c.to_ascii_uppercase()),\n\
    \            'A'..='Z' => res.push(c.to_ascii_lowercase()),\n            _ =>\
    \ res.push(c),\n        }\n    }\n    if res.chars().all(|c| !c.is_alphabetic())\
    \ {\n        res.chars().rev().collect()\n    } else {\n        res\n    }", " \
    \   // let mut result = String::new();\n    // for c in s.chars() {\n    //  \
    \   if c.is_alphabetic() {\n    //         if c.is_lowercase() {\n    //     \
    \        result.push(c.to_uppercase().next().unwrap());\n    //         } else\
    \ {\n    //             result.push(c.to_lowercase().next().unwrap());\n    //\
    \         }\n    //     } else {\n    //         result.push(c);\n    //     }\n\
    \    // }\n    // if result.is_empty() {\n    //     result = s.chars().rev().collect();\n\
    \    // }\n    // result\n\n    // Alternative solution\n    // if s.chars().any(|x|\
    \ x.is_alphabetic()) {\n    //     s.chars().map(|x| if x.is_alphabetic() {\n\
    \    //         if x.is_lowercase() {\n    //             x.to_uppercase().next().unwrap()\n\
    \    //         } else {\n    //             x.to_lowercase().next().unwrap()\n\
    \    //         }\n    //     } else {\n    //         x\n    //     }).collect()\n\
    \    // } else {\n    //     s.chars().rev().collect()\n    // }\n\n    // Alternative\
    \ solution\n    s.chars().map(|x| if x.is_alphabetic() {\n        if x.is_lowercase()\
    \ {\n            x.to_uppercase().next().unwrap()\n        } else {\n        \
    \    x.to_lowercase().next().unwrap()\n        }\n    } else {\n        x\n  \
    \  }).collect::<String>().chars().rev().collect()", "    s.chars().rev().map(|x|\
    \ match x {\n        x if x.is_ascii_lowercase() => x.to_ascii_uppercase(),\n\
    \        x if x.is_ascii_uppercase() => x.to_ascii_lowercase(),\n        _ =>\
    \ x,\n    }).collect()", "    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        if c.is_ascii_lowercase() {\n            result.push(c.to_ascii_uppercase());\n\
    \        } else if c.is_ascii_uppercase() {\n            result.push(c.to_ascii_lowercase());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    if result.chars().all(|x|\
    \ !x.is_ascii_alphabetic()) {\n        result.chars().rev().collect()\n    } else\
    \ {\n        result\n    }", "    let mut result = String::new();\n    for c in\
    \ s.chars() {\n        if c.is_alphabetic() {\n            result.push(c.to_uppercase().next().unwrap());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    if result.len()\
    \ == 0 {\n        s.chars().rev().collect()\n    } else {\n        result\n  \
    \  }", "    let mut r: String = String::from(\"\");\n    for i in s.chars() {\n\
    \        match i {\n            'a'...'z' => r.push(i.to_ascii_uppercase()),\n\
    \            'A'...'Z' => r.push(i.to_ascii_lowercase()),\n            _ => r.push(i),\n\
    \        }\n    }\n    if r.chars().any(|x| x.is_ascii_alphabetic()) {\n     \
    \   r\n    } else {\n        r.chars().rev().collect()\n    }", "    s.chars().rev().map(|c|\
    \ match c {\n        'a'..='z' => c.to_ascii_uppercase(),\n        'A'..='Z' =>\
    \ c.to_ascii_lowercase(),\n        _ => c,\n    }).collect()", "    let mut result\
    \ = s.chars().rev().collect::<String>();\n    if s.chars().any(|c| c.is_alphabetic())\
    \ {\n        result = result.chars().map(|c| c.to_lowercase().next().unwrap_or(c)).collect();\n\
    \    }\n    result", "    let mut answer = String::new();\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            if c.is_lowercase() {\n     \
    \           answer.push(c.to_uppercase().to_string());\n            } else {\n\
    \                answer.push(c.to_lowercase().to_string());\n            }\n \
    \       } else {\n            answer.push(c.to_string());\n        }\n    }\n\
    \    if answer.is_empty() {\n        s.chars().rev().collect()\n    } else {\n\
    \        answer\n    }", "    s.chars().rev().map(|c| {\n        match c {\n \
    \           'a'..='z' => c.to_ascii_uppercase(),\n            'A'..='Z' => c.to_ascii_lowercase(),\n\
    \            _ => c,\n        }\n    }).collect()", "    if s.chars().any(|c|\
    \ c.is_alphabetic()) {\n        return s.chars().map(|c| if c.is_alphabetic()\
    \ {\n            c.to_ascii_uppercase()\n        } else {\n            c.to_ascii_lowercase()\n\
    \        }).collect();\n    }\n    s.chars().rev().collect()", "    let mut solution\
    \ = String::new();\n    let mut char_count = 0;\n    for character in s.chars()\
    \ {\n        if character.is_alphabetic() {\n            char_count += 1;\n  \
    \          if character.is_uppercase() {\n                solution.push(character.to_lowercase().next().unwrap());\n\
    \            } else {\n                solution.push(character.to_uppercase().next().unwrap());\n\
    \            }\n        } else {\n            solution.push(character);\n    \
    \    }\n    }\n    if char_count == 0 {\n        solution.chars().rev().collect()\n\
    \    } else {\n        solution\n    }", "    let mut s: Vec<char> = s.chars().collect();\n\
    \    let mut has_letter = false;\n    for i in 0..s.len() {\n        if s[i].is_alphabetic()\
    \ {\n            has_letter = true;\n            if s[i].is_uppercase() {\n  \
    \              s[i] = s[i].to_lowercase().next().unwrap();\n            } else\
    \ {\n                s[i] = s[i].to_uppercase().next().unwrap();\n           \
    \ }\n        }\n    }\n    if !has_letter {\n        s.reverse();\n    }\n   \
    \ s.into_iter().collect()", "    s.chars().rev().map(|c| {\n        match c {\n\
    \            'a'...'z' => c.to_ascii_uppercase(),\n            'A'...'Z' => c.to_ascii_lowercase(),\n\
    \            _ => c,\n        }\n    }).collect()", "    let mut res = String::from(\"\
    \");\n    for ch in s.chars() {\n        if ch.is_alphabetic() {\n           \
    \ res.push(ch.to_lowercase().next().unwrap());\n        } else {\n           \
    \ res.push(ch);\n        }\n    }\n    if res == s {\n        return s.chars().rev().collect();\n\
    \    }\n    res", "    s.chars().rev().map(|x| {\n        match x {\n        \
    \    'a'...'z' => x.to_ascii_uppercase(),\n            'A'...'Z' => x.to_ascii_lowercase(),\n\
    \            _ => x,\n        }\n    }).collect()", "    let iter = s.chars();\n\
    \    let mut ss = String::new();\n    for c in iter {\n        if c.is_alphabetic()\
    \ {\n            if c.is_uppercase() {\n                ss.push(c.to_lowercase().next().unwrap());\n\
    \            } else {\n                ss.push(c.to_uppercase().next().unwrap());\n\
    \            }\n        } else {\n            ss.push(c);\n        }\n    }\n\
    \    if ss.is_empty() {\n        ss = s;\n    }\n    ss.chars().rev().collect()",
  "    let mut res = String::from(\"\");\n    for c in s.chars() {\n        if c.is_alphabetic()\
    \ {\n            res.push(c.to_uppercase().next().unwrap());\n        } else {\n\
    \            res.push(c);\n        }\n    }\n    if res.len() == 0 {\n       \
    \ res = s;\n    }\n    res.chars().rev().collect()", "    let mut is_letter_found\
    \ = false;\n    s.chars().map(|c| {\n        if c.is_ascii_alphabetic() {\n  \
    \          is_letter_found = true;\n            c.to_ascii_uppercase()\n     \
    \   } else {\n            c\n        }\n    }).collect::<String>().chars().rev().map(|c|\
    \ {\n        if c.is_ascii_alphabetic() {\n            c.to_ascii_lowercase()\n\
    \        } else {\n            c\n        }\n    }).collect::<String>()", '    s.chars().rev().map(|c|
    c.is_ascii_alphabetic() ? c.to_ascii_uppercase() : c.to_ascii_lowercase()).collect()',
  "    let mut res = String::new();\n    for ch in s.chars() {\n        match ch {\n\
    \            'a'...'z' => res.push((ch as u8 - 'a' as u8 + 'A' as u8) as char),\n\
    \            'A'...'Z' => res.push((ch as u8 - 'A' as u8 + 'a' as u8) as char),\n\
    \            _ => res.push(ch),\n        }\n    }\n    if res.is_empty() {\n \
    \       s.chars().rev().collect()\n    } else {\n        res\n    }", "    if\
    \ s.len() < 1 { return s; }\n    let mut result = String::new();\n    let mut\
    \ contains_letter = false;\n    for c in s.chars() {\n        if c.is_ascii_alphabetic()\
    \ {\n            contains_letter = true;\n            result.push(if c.is_ascii_lowercase()\
    \ { c.to_ascii_uppercase() } else { c.to_ascii_lowercase() });\n        } else\
    \ {\n            result.push(c);\n        }\n    }\n    if !contains_letter {\
    \ result.chars().rev().collect() } else { result }", "    let mut result = s.chars().rev().collect::<String>();\n\
    \    if result.is_empty() {\n        return result;\n    }\n    let result_vec:\
    \ Vec<char> = result.chars().collect();\n    for (i, c) in result_vec.iter().enumerate()\
    \ {\n        if c.is_lowercase() {\n            result = result.replace(c, &c.to_ascii_uppercase().to_string());\n\
    \        } else if c.is_uppercase() {\n            result = result.replace(c,\
    \ &c.to_ascii_lowercase().to_string());\n        }\n    }\n    result", "    s.chars().rev().map(|c|\
    \ if c.is_alphabetic() {\n        c.to_ascii_uppercase()\n    } else {\n     \
    \   c\n    }).collect()", "    // Your code here\n    if s.chars().all(|c| c.is_numeric())\
    \ {\n        s.chars().rev().collect()\n    } else {\n        s.chars().map(|c|\
    \ c.to_lowercase().next().unwrap_or(c)).rev().collect()\n    }", "    s.chars().rev().map(|x|\
    \ match x {\n        'a'..='z' => x.to_ascii_uppercase(),\n        'A'..='Z' =>\
    \ x.to_ascii_lowercase(),\n        _ => x,\n    }).collect()", "    s.chars().rev().map(|c|\
    \ {\n        match c {\n            'a'...'z' => c.to_ascii_uppercase(),\n   \
    \         'A'...'Z' => c.to_ascii_lowercase(),\n            _ => c,\n        }\n\
    \    }).collect()", "    let reverse = |ch: char| {\n        match ch {\n    \
    \        'a'..='z' => ch.to_ascii_uppercase(),\n            'A'..='Z' => ch.to_ascii_lowercase(),\n\
    \            _ => ch,\n        }\n    };\n    let chars: Vec<char> = s.chars().map(reverse).collect();\n\
    \    let len = chars.len();\n    if len == 0 {\n        return s;\n    }\n   \
    \ chars[..len / 2]\n        .iter()\n        .rev()\n        .chain(chars[len\
    \ / 2..].iter())\n        .collect()", "    let mut str = s.chars().rev().collect::<String>();\n\
    \    str.chars().enumerate().for_each(|(i, c)| {\n        let mut v = c;\n   \
    \     if v.is_ascii_alphabetic() {\n            v = v.to_ascii_lowercase();\n\
    \            if c.is_ascii_lowercase() {\n                v = v.to_ascii_uppercase();\n\
    \            }\n        }\n        str.replace_range(i..i+1, &v.to_string());\n\
    \    });\n    str", "    let v: Vec<char> = s.chars().collect();\n    let mut\
    \ nv: Vec<char> = Vec::new();\n    for i in 0..v.len() {\n        if v[i].is_alphabetic()\
    \ {\n            if v[i].is_lowercase() {\n                nv.push(v[i].to_uppercase().next().unwrap());\n\
    \            } else {\n                nv.push(v[i].to_lowercase().next().unwrap());\n\
    \            }\n        } else {\n            nv.push(v[i]);\n        }\n    }\n\
    \    if nv.len() == 0 {\n        nv = v.clone();\n        nv.reverse();\n    }\n\
    \    nv.iter().collect()", "    s.chars().rev().map(|c| {\n        match c {\n\
    \            'A'...'Z' => c.to_lowercase().next().unwrap(),\n            'a'...'z'\
    \ => c.to_uppercase().next().unwrap(),\n            _ => c,\n        }\n    }).collect()",
  "    s.chars().map(|c| {\n        if c.is_alphabetic() {\n            if c.is_lowercase()\
    \ {\n                c.to_uppercase().next().unwrap()\n            } else {\n\
    \                c.to_lowercase().next().unwrap()\n            }\n        } else\
    \ {\n            c\n        }\n    }).collect()", "    if s.is_empty() {\n   \
    \     return s;\n    }\n    let mut result = String::with_capacity(s.len());\n\
    \    let mut letter_found = false;\n    for c in s.chars() {\n        if c.is_ascii_alphabetic()\
    \ {\n            result.push(if c.is_lowercase() {\n                c.to_ascii_uppercase()\n\
    \            } else {\n                c.to_ascii_lowercase()\n            });\n\
    \            letter_found = true;\n        } else {\n            result.push(c);\n\
    \        }\n    }\n    if !letter_found {\n        result.chars().rev().collect()\n\
    \    } else {\n        result\n    }", "    let mut new_string = String::new();\n\
    \    for (index, character) in s.chars().enumerate() {\n        if character.is_ascii_alphabetic()\
    \ {\n            if character.is_lowercase() {\n                new_string.push(character.to_ascii_uppercase());\n\
    \            } else {\n                new_string.push(character.to_ascii_lowercase());\n\
    \            }\n        } else {\n            new_string.push(character);\n  \
    \      }\n    }\n    if new_string.is_empty() {\n        return s.chars().rev().collect();\n\
    \    }\n    new_string", "    s.chars().map(|c| {\n        if c.is_ascii_alphabetic()\
    \ {\n            match c.is_ascii_uppercase() {\n                true => c.to_ascii_lowercase(),\n\
    \                false => c.to_ascii_uppercase(),\n            }\n        } else\
    \ {\n            c\n        }\n    }).collect()", "    s.chars().rev().map(|c|\
    \ {\n        if c.is_alphabetic() {\n            c.to_ascii_uppercase()\n    \
    \    } else {\n            c\n        }\n    }).collect()", "    String::from_iter(s.chars().rev().map(|ch|\
    \ match ch {\n        'a'..='z' => ch.to_ascii_uppercase(),\n        'A'..='Z'\
    \ => ch.to_ascii_lowercase(),\n        _ => ch,\n    }))", "    let is_alpha =\
    \ |c: char| c.is_alphabetic();\n    let mut res = s.chars().map(|c| {\n      \
    \  if is_alpha(c) {\n            if c.is_uppercase() {\n                c.to_lowercase().next().unwrap()\n\
    \            } else {\n                c.to_uppercase().next().unwrap()\n    \
    \        }\n        } else {\n            c\n        }\n    }).collect::<String>();\n\
    \    res.chars().rev().collect::<String>()", "    s.chars().map(|c| if c.is_alphabetic()\
    \ {\n        c.to_ascii_uppercase()\n    } else {\n        c\n    }).rev().collect()",
  "    let mut new = String::new();\n    for c in s.chars() {\n        new.push(match\
    \ c {\n            'a'...'z' => c.to_ascii_uppercase(),\n            'A'...'Z'\
    \ => c.to_ascii_lowercase(),\n            _ => c,\n        });\n    }\n    new",
  "    let mut new_s = String::new();\n    for c in s.chars() {\n        if c.is_alphabetic()\
    \ {\n            new_s.push(c.to_ascii_uppercase());\n        } else {\n     \
    \       new_s.push(c);\n        }\n    }\n    new_s.chars().rev().collect()",
  '    s.chars().rev().map(|c| if c.is_alphabetic() { c.to_ascii_uppercase() } else
    { c }).collect()', "    return s.chars().rev().map(|ch| {\n        match ch {\n\
    \            'a'...'z' => ch.to_ascii_uppercase(),\n            'A'...'Z' => ch.to_ascii_lowercase(),\n\
    \            _ => ch\n        }\n    }).collect::<String>();", "    let mut v:\
    \ Vec<char> = s.chars().collect();\n    let mut i = 0;\n    let mut is_letter_found\
    \ = false;\n    while i < v.len() {\n        if v[i].is_alphabetic() {\n     \
    \       is_letter_found = true;\n            if v[i].is_lowercase() {\n      \
    \          v[i] = v[i].to_uppercase().collect::<Vec<char>>()[0];\n           \
    \ } else {\n                v[i] = v[i].to_lowercase().collect::<Vec<char>>()[0];\n\
    \            }\n        }\n        i += 1;\n    }\n    if !is_letter_found {\n\
    \        v.reverse();\n    }\n    v.into_iter().collect()", "    let mut res =\
    \ String::new();\n    for c in s.chars() {\n        if c.is_alphabetic() {\n \
    \           res.push(if c.is_uppercase() { c.to_lowercase().next().unwrap() }\
    \ else { c.to_uppercase().next().unwrap() });\n        } else {\n            res.push(c);\n\
    \        }\n    }\n    res.chars().rev().collect::<String>()", "    let mut result\
    \ = String::new();\n    for c in s.chars() {\n        match c {\n            'a'...'z'\
    \ => result.push(c.to_ascii_uppercase()),\n            'A'...'Z' => result.push(c.to_ascii_lowercase()),\n\
    \            _ => result.push(c),\n        }\n    }\n    if result.chars().all(|c|\
    \ !c.is_alphabetic()) {\n        result.chars().rev().collect()\n    } else {\n\
    \        result\n    }", "    let letters = b\"abcdefghijklmnopqrstuvwxyz\";\n\
    \    let mut res = String::new();\n    let mut letters_count = 0;\n    for c in\
    \ s.chars() {\n        if c.is_alphabetic() {\n            letters_count += 1;\n\
    \            let cc = if c.is_uppercase() {\n                let cci = letters.iter().position(|&x|\
    \ x == c.to_ascii_lowercase() as u8).unwrap();\n                letters[cci].to_ascii_uppercase()\
    \ as char\n            } else {\n                let cci = letters.iter().position(|&x|\
    \ x == c.to_ascii_uppercase() as u8).unwrap();\n                letters[cci].to_ascii_lowercase()\
    \ as char\n            };\n            res.push(cc);\n        } else {\n     \
    \       res.push(c);\n        }\n    }\n    if letters_count == 0 {\n        res.chars().rev().collect()\n\
    \    } else {\n        res\n    }", "    let mut new_string = String::new();\n\
    \    for c in s.chars() {\n        if c.is_alphabetic() {\n            new_string.push(c.to_ascii_uppercase());\n\
    \        } else {\n            new_string.push(c);\n        }\n    }\n    if new_string\
    \ == s {\n        let mut s = s.chars().rev().collect::<String>();\n        return\
    \ s;\n    } else {\n        let s = new_string.chars().rev().collect::<String>();\n\
    \        return s;\n    }", "    let mut r: String = s.chars().map(|c| match c\
    \ {\n        'a'...'z' => c.to_ascii_uppercase(),\n        'A'...'Z' => c.to_ascii_lowercase(),\n\
    \        _ => c,\n    }).collect();\n    if r.chars().any(|c| c.is_alphabetic())\
    \ {\n        r\n    } else {\n        r.chars().rev().collect()\n    }", "   \
    \ let mut answer = s.chars().map(|c| {\n        match c {\n            'a'..='z'\
    \ => c.to_ascii_uppercase(),\n            'A'..='Z' => c.to_ascii_lowercase(),\n\
    \            _ => c,\n        }\n    }).collect::<String>();\n    if answer.chars().all(|c|\
    \ c.is_numeric()) {\n        answer.chars().rev().collect()\n    } else {\n  \
    \      answer\n    }", "    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            result.push(if c.is_lowercase()\
    \ {\n                c.to_uppercase().next().unwrap()\n            } else {\n\
    \                c.to_lowercase().next().unwrap()\n            });\n        }\
    \ else {\n            result.push(c);\n        }\n    }\n    if result.chars().all(|c|\
    \ !c.is_alphabetic()) {\n        result.chars().rev().collect()\n    } else {\n\
    \        result\n    }", "    s.chars().rev().map(|x| {\n        if x.is_alphabetic()\
    \ {\n            if x.is_lowercase() {\n                x.to_uppercase().collect::<String>()\n\
    \            } else {\n                x.to_lowercase().collect::<String>()\n\
    \            }\n        } else {\n            x.to_string()\n        }\n    }).collect::<String>()",
  "    s.chars().rev().map(|c| {\n        if c.is_alphabetic() {\n            c.to_lowercase().next().unwrap()\n\
    \        } else {\n            c\n        }\n    }).collect()", "    let mut result:\
    \ Vec<u8> = vec![];\n    for c in s.as_bytes() {\n        match c {\n        \
    \    b'A'..=b'Z' => result.push(*c + b'a' - b'A'),\n            b'a'..=b'z' =>\
    \ result.push(*c + b'A' - b'a'),\n            _ => result.push(*c),\n        }\n\
    \    }\n    String::from_utf8(result).unwrap()", "    let mut chars: Vec<char>\
    \ = s.chars().collect();\n    let mut index = 0;\n    let mut find = false;\n\
    \    let mut rev: Vec<char> = Vec::new();\n    while index < chars.len() {\n \
    \       if chars[index].is_alphabetic() {\n            find = true;\n        \
    \    rev.push(chars[index].to_ascii_uppercase());\n        } else {\n        \
    \    rev.push(chars[index]);\n        }\n        index += 1;\n    }\n    if find\
    \ {\n        rev.iter().rev().collect()\n    } else {\n        s\n    }", "  \
    \  s.chars().rev().map(|c| {\n        if c.is_alphabetic() {\n            c.to_uppercase().chain(c.to_lowercase()).nth(0).unwrap()\n\
    \        } else {\n            c\n        }\n    }).collect()", "    let mut str\
    \ = String::new();\n    for c in s.chars() {\n        if !c.is_alphabetic() {\n\
    \            str.push(c);\n        } else {\n            if c.is_uppercase() {\n\
    \                str.push(c.to_lowercase().next().unwrap());\n            } else\
    \ {\n                str.push(c.to_uppercase().next().unwrap());\n           \
    \ }\n        }\n    }\n    if str.is_empty() {\n        s.chars().rev().collect()\n\
    \    } else {\n        str\n    }", "    s.chars().rev().map(|ch| if ch.is_ascii_alphabetic()\
    \ {\n        ch.to_ascii_uppercase()\n    } else {\n        ch\n    }).collect()",
  "    //if s.is_empty() { return s; }\n    s.chars().rev().map(|c| if c.is_alphabetic()\
    \ { c.to_ascii_uppercase() } else { c }).collect()", "    let mut ret = String::with_capacity(s.len());\n\
    \    for c in s.chars() {\n        match c {\n            'a' ... 'z' => ret.push((c\
    \ as u8 - 32) as char),\n            'A' ... 'Z' => ret.push((c as u8 + 32) as\
    \ char),\n            _ => ret.push(c),\n        }\n    }\n    if ret.len() ==\
    \ 0 {\n        return s;\n    }\n    ret", "    s.chars().rev().map(|c| match\
    \ c {\n        'a'...'z' => c.to_ascii_uppercase(),\n        'A'...'Z' => c.to_ascii_lowercase(),\n\
    \        _ => c,\n    }).collect()", "    s.chars().rev().map(|c| {\n        if\
    \ c.is_alphabetic() {\n            if c.is_lowercase() {\n                c.to_uppercase().collect::<String>()\n\
    \            } else {\n                c.to_lowercase().collect::<String>()\n\
    \            }\n        } else {\n            c.to_string()\n        }\n    }).collect::<String>()",
  "    if s.chars().all(|c| !c.is_alphabetic()) {\n        return s.chars().rev().collect::<String>();\n\
    \    }\n    s.chars().map(|c| if c.is_alphabetic() { c.to_uppercase().next().unwrap()\
    \ } else { c }).collect::<String>()", "    let mut str = String::new();\n    for\
    \ c in s.chars() {\n        if !c.is_alphabetic() {\n            str.push(c);\n\
    \        } else {\n            if c.is_lowercase() {\n                str.push(c.to_uppercase().nth(0).unwrap());\n\
    \            } else {\n                str.push(c.to_lowercase().nth(0).unwrap());\n\
    \            }\n        }\n    }\n    if str.is_empty() {\n        str = s;\n\
    \    }\n    str.chars().rev().collect::<String>()", "    s.chars().map(|c| match\
    \ c {\n        'a' ... 'z' => c.to_ascii_uppercase(),\n        'A' ... 'Z' =>\
    \ c.to_ascii_lowercase(),\n        _ => c\n    }).collect()", "    let mut result:\
    \ String = String::new();\n    for c in s.chars() {\n        if c.is_alphabetic()\
    \ {\n            result.push(c.to_uppercase().to_string().pop().unwrap());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if result.chars().all(|x|\
    \ !x.is_alphabetic()) {\n        result.chars().rev().collect()\n    } else {\n\
    \        result\n    }", "    s.chars().rev().map(|ch| match ch {\n        'a'...'z'\
    \ => ch.to_ascii_uppercase(),\n        'A'...'Z' => ch.to_ascii_lowercase(),\n\
    \        _ => ch,\n    }).collect()", "    // let mut res = String::from(\"\"\
    );\n    // for c in s.chars() {\n    //     if c.is_ascii_lowercase() {\n    //\
    \         res.push(c.to_ascii_uppercase());\n    //     } else if c.is_ascii_uppercase()\
    \ {\n    //         res.push(c.to_ascii_lowercase());\n    //     } else {\n \
    \   //         res.push(c);\n    //     }\n    // }\n    // res\n    s.chars().rev().collect::<String>()",
  "    if s.chars().all(|c| !c.is_alphabetic()) {\n        s.chars().rev().collect()\n\
    \    } else {\n        s.chars().map(|c| if c.is_alphabetic() { c.to_ascii_uppercase()\
    \ } else { c }).collect()\n    }", "    let mut result = s.chars().rev().map(|c|\
    \ c.to_ascii_lowercase()).collect::<String>();\n    if result.chars().find(|c|\
    \ c.is_alphabetic()).is_some() {\n        result = result.chars().map(|c| if c.is_alphabetic()\
    \ { c.to_ascii_uppercase() } else { c }).collect();\n    }\n    result", "   \
    \ let mut result = String::new();\n    let mut is_letter = false;\n    for character\
    \ in s.chars() {\n        if character.is_alphabetic() {\n            is_letter\
    \ = true;\n            if character.is_lowercase() {\n                result.push(character.to_uppercase().to_string());\n\
    \            } else {\n                result.push(character.to_lowercase().to_string());\n\
    \            }\n        } else {\n            result.push(character);\n      \
    \  }\n    }\n    if !is_letter {\n        let mut reversed = String::new();\n\
    \        for character in result.chars().rev() {\n            reversed.push(character);\n\
    \        }\n        return reversed;\n    }\n    result", "    if s.chars().all(|c|\
    \ !c.is_alphabetic()) {\n        return s.chars().rev().collect();\n    }\n  \
    \  s.chars().map(|c| if c.is_alphabetic() { c.to_ascii_uppercase() } else { c\
    \ }).collect()", "    s.chars().rev().map(|c| match c {\n        'a' | 'A' =>\
    \ { 'A' + ('a' - c) }\n        'b' | 'B' => { 'B' + ('b' - c) }\n        'c' |\
    \ 'C' => { 'C' + ('c' - c) }\n        'd' | 'D' => { 'D' + ('d' - c) }\n     \
    \   'e' | 'E' => { 'E' + ('e' - c) }\n        'f' | 'F' => { 'F' + ('f' - c) }\n\
    \        'g' | 'G' => { 'G' + ('g' - c) }\n        'h' | 'H' => { 'H' + ('h' -\
    \ c) }\n        'i' | 'I' => { 'I' + ('i' - c) }\n        'j' | 'J' => { 'J' +\
    \ ('j' - c) }\n        'k' | 'K' => { 'K' + ('k' - c) }\n        'l' | 'L' =>\
    \ { 'L' + ('l' - c) }\n        'm' | 'M' => { 'M' + ('m' - c) }\n        'n' |\
    \ 'N' => { 'N' + ('n' - c) }\n        'o' | 'O' => { 'O' + ('o' - c) }\n     \
    \   'p' | 'P' => { 'P' + ('p' - c) }\n        'q' | 'Q' => { 'Q' + ('q' - c) }\n\
    \        'r' | 'R' => { 'R' + ('r' - c) }\n        's' | 'S' => { 'S' + ('s' -\
    \ c) }\n        't' | 'T' => { 'T' + ('t' - c) }\n        'u' | 'U' => { 'U' +\
    \ ('u' - c) }\n        'v' | 'V' => { 'V' + ('v' - c) }\n        'w' | 'W' =>\
    \ {", "    // return s.chars().rev().collect::<String>();\n    let mut res = s.chars().rev().map(|x|\
    \ if x.is_alphabetic() {\n        x.to_string().to_uppercase()\n    } else {\n\
    \        x.to_string()\n    }).collect::<String>();\n    if res.chars().any(|x|\
    \ x.is_alphabetic()) {\n        res\n    } else {\n        s\n    }", "    let\
    \ mut s = s.chars().collect::<Vec<char>>();\n    for i in 0..s.len() {\n     \
    \   match s[i] {\n            'a'..='z' => s[i] = s[i].to_ascii_uppercase(),\n\
    \            'A'..='Z' => s[i] = s[i].to_ascii_lowercase(),\n            _ =>\
    \ continue,\n        }\n    }\n    s.iter().collect()", "    let mut res = String::new();\n\
    \    let mut empty = true;\n    for c in s.chars() {\n        match c {\n    \
    \        'a'...'z' => {\n                empty = false;\n                res.push(c.to_ascii_uppercase());\n\
    \            },\n            'A'...'Z' => {\n                empty = false;\n\
    \                res.push(c.to_ascii_lowercase());\n            },\n         \
    \   _ => res.push(c),\n        }\n    }\n    if empty {\n        res.chars().rev().collect()\n\
    \    } else {\n        res\n    }", '    s.chars().rev().map(|c| if c.is_ascii_alphabetic()
    { c.to_ascii_uppercase() } else { c }).collect()', "    let mut buf = String::new();\n\
    \    for c in s.chars() {\n        if c.is_alphabetic() {\n            buf.push(c.to_ascii_uppercase());\n\
    \        } else {\n            buf.push(c);\n        }\n    }\n    if buf.len()\
    \ > 0 {\n        buf\n    } else {\n        s.chars().rev().collect()\n    }",
  "    let mut chars = s.chars();\n    let mut res = String::new();\n    while let\
    \ Some(c) = chars.next() {\n        if c.is_alphabetic() {\n            res.push(if\
    \ c.is_uppercase() {\n                c.to_lowercase().to_string()\n         \
    \   } else {\n                c.to_uppercase().to_string()\n            });\n\
    \        } else {\n            res.push(c);\n        }\n    }\n    if res.is_empty()\
    \ {\n        s.chars().rev().collect()\n    } else {\n        res\n    }", '    s.chars().rev().map(|x|
    if x.is_alphabetic() { x.swap_case() } else { x }).collect()', '    s.chars().rev().collect::<String>()']
stop_tokens:
- "\n}"
