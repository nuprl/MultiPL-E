name: HumanEval_21_rescale_to_unit
language: rust
prompt: "/// Given list of numbers (of at least two elements), apply a linear transform\
  \ to that list,\n/// such that the smallest number will become 0 and the largest\
  \ will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n/// [0.0, 0.25,\
  \ 0.5, 0.75, 1.0]\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n"
tests: "}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
  \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
  \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
  \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
  \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
  \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
completions: ["    let mut numbers = numbers;\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    let range = numbers[numbers.len() - 1] - numbers[0];\n    numbers.iter().map(|&x|\
    \ (x - numbers[0]) / range).collect()", "    let nums = numbers.clone();\n   \
    \ let max = nums.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n    let min\
    \ = nums.iter().cloned().fold(f64::INFINITY, f64::min);\n    nums.iter().map(|&x|\
    \ (x - min) / (max - min)).collect()", "    let min = *numbers.iter().min().unwrap();\n\
    \    let max = *numbers.iter().max().unwrap();\n    if min == max {\n        numbers\n\
    \    } else {\n        let scale = 1.0 / (max - min);\n        numbers.iter().map(|x|\
    \ (x - min) * scale).collect()\n    }", "    if numbers.len() < 2 {\n        panic!(\"\
    Input vector must have at least two elements\");\n    }\n    let max = numbers.iter().cloned().fold(numbers[0],\
    \ f64::max);\n    let min = numbers.iter().cloned().fold(numbers[0], f64::min);\n\
    \    numbers.iter().map(|n| (n - min) / (max - min)).collect()", "    let max\
    \ = numbers.iter().max().unwrap();\n    let min = numbers.iter().min().unwrap();\n\
    \    let diff = max - min;\n    numbers.iter().map(|&n| (n - min) / diff).collect()",
  "    let (min, max) = numbers.iter().fold((numbers[0], numbers[0]), |(mi, ma), &n|\
    \ {\n        (cmp::min(mi, n), cmp::max(ma, n))\n    });\n    let diff = max -\
    \ min;\n    numbers.iter().map(|&n| (n - min) / diff).collect()", "    if numbers.len()\
    \ < 2 {\n        panic!(\"Can't rescale list with less than 2 elements!\");\n\
    \    }\n    let min = numbers.iter().cloned().fold(std::f64::MAX, f64::min);\n\
    \    let max = numbers.iter().cloned().fold(std::f64::MIN, f64::max);\n    let\
    \ scale = max - min;\n    let translated = numbers.iter().map(|x| x - min).collect::<Vec<f64>>();\n\
    \    translated.iter().map(|x| x / scale).collect::<Vec<f64>>()", "    let minimum\
    \ = numbers.iter().min().unwrap();\n    let maximum = numbers.iter().max().unwrap();\n\
    \    let delta = maximum - minimum;\n    numbers.iter().map(|i| (i - minimum)\
    \ / delta).collect()", "    let min = numbers.iter().cloned().fold(f64::INFINITY,\
    \ f64::min);\n    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n\
    \    let factor = 1.0 / (max - min);\n    let mut data = numbers.into_iter().map(|x|\
    \ factor * (x - min)).collect::<Vec<_>>();\n    data", "    assert!(numbers.len()\
    \ >= 2);\n    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let range = max - min;\n    numbers.iter().map(|n| (n - min) / range).collect()",
  "    let mut min = numbers[0];\n    let mut max = numbers[0];\n    for number in\
    \ numbers.iter() {\n        if number < &min {\n            min = *number;\n \
    \       }\n        if number > &max {\n            max = *number;\n        }\n\
    \    }\n    numbers.iter().map(|x| (x - min) / (max - min)).collect()", "    let\
    \ largest_number = *numbers.iter().max().unwrap();\n    let smallest_number =\
    \ *numbers.iter().min().unwrap();\n    numbers.iter().map(|x| (x - smallest_number)\
    \ / (largest_number - smallest_number)).collect()", "    // Find largest and smallest\
    \ numbers\n    let max = numbers.iter().fold(f64::NEG_INFINITY, |acc, x| f64::max(acc,\
    \ *x));\n    let min = numbers.iter().fold(f64::INFINITY, |acc, x| f64::min(acc,\
    \ *x));\n\n    // Linear transform is y = (x - min) / (max - min)\n    numbers.iter().map(|x|\
    \ (x - min) / (max - min)).collect()", "    let mut numbers = numbers;\n    let\
    \ min_val = numbers.iter().min().unwrap();\n    let max_val = numbers.iter().max().unwrap();\n\
    \    let scaling_factor = 1.0 / (max_val - min_val);\n    numbers = numbers.iter().map(|&n|\
    \ n * scaling_factor).collect();\n    numbers = numbers.iter().map(|&n| n - min_val).collect();\n\
    \    numbers", "    let max_num = *numbers.iter().max().unwrap();\n    let min_num\
    \ = *numbers.iter().min().unwrap();\n    numbers.iter().map(|n| (n - min_num)\
    \ / (max_num - min_num)).collect()", "    let minimum = numbers.iter().fold(f64::INFINITY,\
    \ |min, x| if x < &min { *x } else { min });\n    let maximum = numbers.iter().fold(f64::NEG_INFINITY,\
    \ |max, x| if x > &max { *x } else { max });\n    numbers.iter().map(|x| (x -\
    \ minimum) / (maximum - minimum)).collect()", "    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    numbers.iter().map(|&x| (x\
    \ - min) / (max - min)).collect()", "    let minimum: f64 = numbers.iter().min().unwrap().clone();\n\
    \    let maximum: f64 = numbers.iter().max().unwrap().clone();\n    let diff:\
    \ f64 = maximum - minimum;\n    numbers.iter().map(|x| (x - minimum) / diff).collect()",
  "    let mut result = Vec::new();\n    let max = numbers.iter().max().unwrap();\n\
    \    let min = numbers.iter().min().unwrap();\n    let range = max - min;\n  \
    \  for n in numbers {\n        result.push((n - min) / range);\n    }\n    result",
  "    let mut result = Vec::new();\n    let (min, max) = (\n        numbers.iter().min_by(|a,\
    \ b| a.partial_cmp(b).unwrap()).unwrap(),\n        numbers.iter().max_by(|a, b|\
    \ a.partial_cmp(b).unwrap()).unwrap(),\n    );\n    for n in numbers {\n     \
    \   result.push((n - min) / (max - min));\n    }\n    result", "    let min =\
    \ numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY,\
    \ f64::max);\n    let delta = max - min;\n    if delta == 0.0 {\n        return\
    \ numbers;\n    }\n    numbers.iter().map(|n| (*n - min) / delta).collect()",
  "    if numbers.len() < 2 {\n        panic!(\"Cannot rescale a list with less than\
    \ 2 elements!\");\n    }\n    let min = numbers.iter().cloned().fold(std::f64::MAX,\
    \ f64::min);\n    let max = numbers.iter().cloned().fold(std::f64::MIN, f64::max);\n\
    \    let range = max - min;\n    numbers.iter().map(|x| (x - min) / range).collect()",
  "    let min = *numbers.iter().min().unwrap();\n    let max = *numbers.iter().max().unwrap();\n\
    \    let sub = max - min;\n    numbers.iter().map(|x| (x - min) / sub).collect()",
  "    let n = numbers.len();\n    let min = numbers.iter().min().unwrap();\n    let\
    \ max = numbers.iter().max().unwrap();\n    let delta = (max - min) / (n as f64\
    \ - 1.0);\n    numbers.iter().map(|x| (x - min) / delta).collect()", "    let\
    \ mut numbers = numbers;\n    let min = numbers.iter().min().unwrap();\n    let\
    \ max = numbers.iter().max().unwrap();\n    let range = max - min;\n    numbers.iter_mut().for_each(|n|\
    \ *n = (*n - min) / range);\n    numbers", "    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    let diff = max - min;\n   \
    \ numbers.iter().map(|v| (*v - min) / diff).collect()", "    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    numbers.iter().map(|x| (x -\
    \ min) / (max - min)).collect()", "    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    numbers.iter().map(|x| (*x\
    \ - min) / (max - min)).collect()", "    let (min, max) = numbers.iter().fold((numbers[0],\
    \ numbers[0]), |(min, max), &n| {\n        if n < min {\n            (n, max)\n\
    \        } else if n > max {\n            (min, n)\n        } else {\n       \
    \     (min, max)\n        }\n    });\n    numbers.iter().map(|&x| (x - min) /\
    \ (max - min)).collect()", "    assert!(numbers.len() >= 2);\n    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    let diff = max - min;\n   \
    \ if diff == 0.0 {\n        // There is no way to rescale numbers in this case\n\
    \        return numbers;\n    }\n    numbers.iter().map(|n| (*n - min) / diff).collect()",
  "    let min_value = numbers.iter().min().unwrap();\n    let max_value = numbers.iter().max().unwrap();\n\
    \    let range = max_value - min_value;\n    numbers.iter().map(|x| (x - min_value)\
    \ / range).collect()", "    if numbers.len() < 2 {\n        panic!(\"Cannot do\
    \ rescaling with less than 2 elements\");\n    }\n    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    let delta = max - min;\n  \
    \  let mut normalized = Vec::new();\n    for number in numbers {\n        normalized.push((number\
    \ - min) / delta);\n    }\n    normalized", "    let min = numbers.iter().cloned().fold(f64::MAX,\
    \ f64::min);\n    let max = numbers.iter().cloned().fold(f64::MIN, f64::max);\n\
    \    let delta = max - min;\n    if delta == 0.0 {\n        numbers\n    } else\
    \ {\n        numbers.iter().map(|n| (*n - min) / delta).collect()\n    }", " \
    \   let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    if min == max {\n        return numbers;\n    }\n    numbers.iter().map(|x|\
    \ (x - min) / (max - min)).collect()", "    let min = numbers.iter().cloned().fold(std::f64::MAX,\
    \ f64::min);\n    let max = numbers.iter().cloned().fold(std::f64::MIN, f64::max);\n\
    \    let delta = max - min;\n    let scaled = numbers.iter().map(|number| (number\
    \ - min) / delta).collect();\n    assert!(scaled.iter().cloned().fold(std::f64::MIN,\
    \ f64::max) == 1.0);\n    assert!(scaled.iter().cloned().fold(std::f64::MAX, f64::min)\
    \ == 0.0);\n    scaled", "    let max_n = numbers.iter().max().unwrap();\n   \
    \ let min_n = numbers.iter().min().unwrap();\n    let scale = 1.0 / (max_n - min_n);\n\
    \    numbers.iter().map(|x| (x - min_n) * scale).collect()", "    assert!(numbers.len()\
    \ >= 2);\n    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n\
    \    let min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let\
    \ range = max - min;\n    let a = (1.0 - 0.0) / range;\n    let b = 0.0 - a *\
    \ min;\n    numbers.iter().map(|x| a * x + b).collect()", "    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    let span = max - min;\n   \
    \ numbers.iter().map(|&x| (x - min) / span).collect()", "    let min_value = numbers.iter().min().unwrap();\n\
    \    let max_value = numbers.iter().max().unwrap();\n    numbers.iter().map(|x|\
    \ (x - min_value) / (max_value - min_value)).collect()", "    let min = *numbers.iter().min().unwrap();\n\
    \    let max = *numbers.iter().max().unwrap();\n    numbers.iter().map(|&n| (n\
    \ - min) / (max - min)).collect()", "    let max = numbers.iter().cloned().fold(0.0,\
    \ f64::max);\n    let min = numbers.iter().cloned().fold(0.0, f64::min);\n   \
    \ let range = max - min;\n    numbers.iter().map(|num| (num - min) / range).collect()",
  "    if numbers.len() < 2 {\n        return numbers;\n    }\n\n    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n\n    numbers.iter().map(|&x| (x\
    \ - min) / (max - min)).collect()", "    let (min, max) = get_min_max(numbers);\n\
    \    rescale_to_range(numbers, min, max)", "    let len = numbers.len();\n   \
    \ let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let range = max - min;\n    if range == 0.0 {\n        let ones = vec![1.0;\
    \ len];\n        return ones;\n    }\n    let mut scaled = vec![0.0; len];\n \
    \   for (i, num) in numbers.iter().enumerate() {\n        scaled[i] = (num - min)\
    \ / range;\n    }\n    scaled", "    let scale_factor = 1.0 / (numbers.iter().max().unwrap()\
    \ - numbers.iter().min().unwrap());\n    let offset = -numbers.iter().min().unwrap();\n\
    \    let mut scaled = Vec::new();\n    for i in numbers {\n        scaled.push(scale_factor\
    \ * (i + offset));\n    }\n    scaled", "    assert!(numbers.len() >= 2);\n  \
    \  let (min, max) = (numbers.iter().min().unwrap(), numbers.iter().max().unwrap());\n\
    \    let denom = max - min;\n    if denom == 0.0 {\n        // for the degenerate\
    \ case of identical numbers\n        let len = numbers.len();\n        let unit\
    \ = 1.0 / (len as f64);\n        numbers.iter().map(|_| unit).collect()\n    }\
    \ else {\n        numbers.iter().map(|x| (x - min) / denom).collect()\n    }",
  "    let min_value = numbers[0];\n    let max_value = numbers[0];\n    let mut res\
    \ = Vec::new();\n\n    for value in numbers {\n        res.push(value);\n    \
    \    if value < min_value {\n            min_value = value;\n        }\n     \
    \   if value > max_value {\n            max_value = value;\n        }\n    }\n\
    \n    for value in res.iter_mut() {\n        *value = (*value - min_value) / (max_value\
    \ - min_value);\n    }\n\n    res", "    let min = numbers.iter().cloned().fold(f64::INFINITY,\
    \ f64::min);\n    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n\
    \    numbers.iter().map(|x| (*x - min) / (max - min)).collect()", "    // Find\
    \ the minimum and maximum values of the input\n    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n\n    // Apply the transformation\
    \ to each element of the input list\n    numbers.iter().map(|num| (num - min)\
    \ / (max - min)).collect()", "    assert!(numbers.len() >= 2);\n    let min =\
    \ numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let scale = *max - *min;\n    if scale != 0.0 {\n        return numbers.iter().map(|n|\
    \ (*n - *min) / scale).collect();\n    } else {\n        return numbers.iter().map(|n|\
    \ 0.0).collect();\n    }", "    let (min, max) = (numbers.iter().min().unwrap(),\
    \ numbers.iter().max().unwrap());\n    let (min, max) = (*min, *max);\n    if\
    \ min == max {\n        numbers\n    } else {\n        let range = max - min;\n\
    \        numbers.iter().map(|num| (num - min) / range).collect()\n    }", "  \
    \  // define some variables\n    let mut max = numbers[0];\n    let mut min =\
    \ numbers[0];\n    let mut result = Vec::new();\n\n    // find the min and max\n\
    \    for number in numbers {\n        if number > max {\n            max = number;\n\
    \        }\n        if number < min {\n            min = number;\n        }\n\
    \    }\n\n    // calculate the rescaled list\n    for number in numbers {\n  \
    \      let scaled_value = (number - min) / (max - min);\n        result.push(scaled_value);\n\
    \    }\n\n    result", "    // TODO: Fill in the body of this function.\n    let\
    \ mut unit_vec = Vec::new();\n    let min_value = numbers.iter().min().unwrap();\n\
    \    let max_value = numbers.iter().max().unwrap();\n    for item in numbers {\n\
    \        unit_vec.push((item - min_value) / (max_value - min_value));\n    }\n\
    \    unit_vec", "    let minimum = numbers.iter().min().unwrap();\n    let maximum\
    \ = numbers.iter().max().unwrap();\n    numbers.iter().map(|x| (x - minimum) /\
    \ (maximum - minimum)).collect()", "    let mut numbers = numbers;\n    numbers.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    let lowest = numbers[0];\n    let highest\
    \ = numbers[numbers.len() - 1];\n    numbers.iter().map(|x| (*x - lowest) / (highest\
    \ - lowest)).collect()", "    let min = numbers.iter().min().unwrap();\n    let\
    \ max = numbers.iter().max().unwrap();\n    let span = max - min;\n    let offset\
    \ = -min;\n    numbers.iter().map(|&x| (x + offset) / span).collect()", "    let\
    \ n = numbers.len();\n    let (min, max) = find_min_max(&numbers);\n    let mut\
    \ new_numbers = Vec::new();\n    for num in numbers {\n        new_numbers.push((num\
    \ - min) / (max - min));\n    }\n    new_numbers", "    // let max_number = numbers.iter().max().unwrap();\n\
    \    // let min_number = numbers.iter().min().unwrap();\n    // let max_number\
    \ = numbers.into_iter().max().unwrap();\n    // let min_number = numbers.into_iter().min().unwrap();\n\
    \    let max_number = numbers.into_iter().max().cloned().unwrap();\n    let min_number\
    \ = numbers.into_iter().min().cloned().unwrap();\n    let scale = 1.0 / (max_number\
    \ - min_number);\n    numbers.into_iter().map(|n| scale * (n - min_number)).collect()",
  "    let mut numbers = numbers;\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    let max = numbers[numbers.len() - 1];\n    let min = numbers[0];\n    let\
    \ diff = max - min;\n    let rescaled: Vec<f64> = numbers.iter().map(|x| (*x -\
    \ min) / diff).collect();\n    rescaled", "    // compute the minimum and maximum\
    \ of a list in a single pass\n    let (min, max) = {\n        let mut it = numbers.iter();\n\
    \        let mut min = it.next().unwrap();\n        let mut max = min;\n     \
    \   for num in it {\n            if *num < *min {\n                min = num;\n\
    \            }\n            if *num > *max {\n                max = num;\n   \
    \         }\n        }\n        (*min, *max)\n    };\n\n    let mut result = Vec::with_capacity(numbers.len());\n\
    \    for num in numbers {\n        result.push((num - min) / (max - min));\n \
    \   }\n    result", "    let min = numbers.iter().min().unwrap();\n    let max\
    \ = numbers.iter().max().unwrap();\n    let scale = 1.0 / (max - min);\n    numbers.iter().map(|x|\
    \ (x - min) * scale).collect()", "    // Return the rescaled list, using range\
    \ to get the max and min values\n    // (minus `&` to get the list elements as\
    \ numbers, not references to them)\n    rescale(numbers, numbers.iter().min().unwrap()\
    \ - &0.0, numbers.iter().max().unwrap() - &0.0)", "    if numbers.len() < 2 {\n\
    \        panic!(\"Cannot rescale a list of less than two numbers\")\n    }\n \
    \   let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|x| (x - min) / (max - min)).collect()", "    let min_max\
    \ = min_max(&numbers);\n    let min = min_max.0;\n    let max = min_max.1;\n \
    \   let len = numbers.len();\n    let mut rescaled = Vec::with_capacity(len);\n\
    \    for i in 0..len {\n        rescaled.push((numbers[i] - min) / (max - min));\n\
    \    }\n    rescaled", "    // find min and max\n    let min = numbers.iter().fold(f64::INFINITY,\
    \ |a, &b| a.min(b));\n    let max = numbers.iter().fold(f64::NEG_INFINITY, |a,\
    \ &b| a.max(b));\n\n    let range = max - min;\n\n    numbers.iter().map(|&x|\
    \ (x - min) / range).collect()", "    let mut numbers = numbers;\n    numbers.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    let (min, max) = (numbers[0], numbers[numbers.len()\
    \ - 1]);\n    numbers.iter().map(|x| (*x - min) / (max - min)).collect()", " \
    \   let numbers_min = numbers.iter().min().unwrap();\n    let numbers_max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|x| ((x - numbers_min) / (numbers_max - numbers_min))).collect()",
  "    let smallest = numbers.iter().fold(numbers[0], |a, &b| {\n        if a < b\
    \ {\n            a\n        } else {\n            b\n        }\n    });\n    let\
    \ largest = numbers.iter().fold(numbers[0], |a, &b| {\n        if a > b {\n  \
    \          a\n        } else {\n            b\n        }\n    });\n    let delta\
    \ = largest - smallest;\n    numbers.iter().map(|&x| (x - smallest) / delta).collect()",
  "    let mut result = Vec::with_capacity(numbers.len());\n    let max = *numbers.iter().max().unwrap();\n\
    \    let min = *numbers.iter().min().unwrap();\n    for n in numbers {\n     \
    \   result.push((n - min) / (max - min));\n    }\n    result", "    let max =\
    \ numbers.iter().cloned().fold(0.0, f64::max);\n    let min = numbers.iter().cloned().fold(0.0,\
    \ f64::min);\n    let max_minus_min = max - min;\n    let result = numbers.iter().map(|x|\
    \ (x - min) / max_minus_min).collect();\n    result", "    let max_value = numbers.iter().cloned().fold(0.0,\
    \ f64::max);\n    let min_value = numbers.iter().cloned().fold(0.0, f64::min);\n\
    \    let scale = 1.0 / (max_value - min_value);\n    numbers.iter().map(|v| (v\
    \ - min_value) * scale).collect()", "    let max = numbers.iter().cloned().fold(0.0,\
    \ f64::max);\n    let min = numbers.iter().cloned().fold(std::f64::MAX, f64::min);\n\
    \    let range = max - min;\n    numbers.iter().map(|x| (x - min) / range).collect()",
  "    let max = numbers.iter().max().unwrap();\n    let min = numbers.iter().min().unwrap();\n\
    \    let scale = max - min;\n    let mut new_numbers = Vec::new();\n    for n\
    \ in numbers {\n        new_numbers.push((n - min) / scale);\n    }\n    new_numbers",
  "    let (min, max) = min_max(numbers);\n    let delta = max - min;\n    return\
    \ numbers.iter().map(|n| ((n - min) / delta)).collect();", "    let mut rescaled\
    \ = numbers.clone();\n    let min = numbers.iter().cloned().fold(f64::MAX, f64::min);\n\
    \    let max = numbers.iter().cloned().fold(f64::MIN, f64::max);\n    let scale\
    \ = max - min;\n    for num in rescaled.iter_mut() {\n        *num = (*num - min)\
    \ / scale;\n    }\n    rescaled", "    // this will panic for empty lists, which\
    \ is ok for now\n    let xmin = numbers.iter().min().unwrap();\n    let xmax =\
    \ numbers.iter().max().unwrap();\n    numbers.iter().map(|x| (*x - xmin) / (xmax\
    \ - xmin)).collect()", "    let min = numbers.iter().min().unwrap();\n    let\
    \ max = numbers.iter().max().unwrap();\n    let scale = 1.0 / (max - min);\n \
    \   let offset = -min * scale;\n    numbers.iter().map(|x| x * scale + offset).collect()",
  "    let min = *numbers.iter().min().unwrap();\n    let max = *numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|x| (x - min) / (max - min)).collect()", "    let max\
    \ = numbers.iter().max().unwrap();\n    let min = numbers.iter().min().unwrap();\n\
    \    let n = numbers.len();\n    let mut result = Vec::new();\n    for num in\
    \ numbers {\n        result.push((num - min) / (max - min));\n    }\n    result",
  "    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|x| (x - min) / (max - min)).collect()", "    let min_number\
    \ = numbers.iter().min().unwrap();\n    let max_number = numbers.iter().max().unwrap();\n\
    \    if (*min_number - *max_number).abs() < std::f64::EPSILON {\n        vec![0.0;\
    \ numbers.len()]\n    } else {\n        numbers\n            .iter()\n       \
    \     .map(|number| (*number - *min_number) / (*max_number - *min_number))\n \
    \           .collect()\n    }", "    let max = numbers.iter().max().unwrap();\n\
    \    let min = numbers.iter().min().unwrap();\n    let sub = *min;\n    let div\
    \ = *max - *min;\n    let scaled: Vec<f64> = numbers.iter().map(|&x| (x - sub)\
    \ / div).collect();\n    scaled", "    let min_number = numbers.iter().min().unwrap();\n\
    \    let max_number = numbers.iter().max().unwrap();\n    let span = max_number\
    \ - min_number;\n    numbers.iter().map(|n| (*n - min_number) / span).collect()",
  "    // find the minimum and maximum numbers\n    let min_number = numbers.iter().min().unwrap();\n\
    \    let max_number = numbers.iter().max().unwrap();\n\n    // turn everything\
    \ into a 1-dimensional vector\n    let numbers_iter = numbers.iter();\n\n    //\
    \ create a new vector of all 0s\n    let mut rescaled = vec![0f64; numbers.len()];\n\
    \n    for (index, number) in numbers_iter.enumerate() {\n        // rescale every\
    \ number with:\n        // (value - min) / (max - min)\n        rescaled[index]\
    \ = (*number - min_number) / (max_number - min_number);\n    }\n\n    rescaled",
  "    let (min, max) = {\n        let mut min = numbers[0];\n        let mut max\
    \ = numbers[0];\n        for number in numbers.iter() {\n            if *number\
    \ < min {\n                min = *number;\n            }\n            if *number\
    \ > max {\n                max = *number;\n            }\n        }\n        (min,\
    \ max)\n    };\n    let range = max - min;\n    let mut rescaled_numbers = Vec::with_capacity(numbers.len());\n\
    \    for number in numbers.iter() {\n        let rescaled_number = (*number -\
    \ min) / range;\n        rescaled_numbers.push(rescaled_number);\n    }\n    rescaled_numbers",
  "    let mut numbers_unit = numbers.clone();\n    let mut minimum: f64 = numbers[0];\n\
    \    let mut maximum: f64 = numbers[0];\n    for number in numbers {\n       \
    \ if number < minimum {\n            minimum = number;\n        }\n        if\
    \ number > maximum {\n            maximum = number;\n        }\n    }\n    let\
    \ scale = 1.0 / (maximum - minimum);\n    for i in 0..numbers.len() {\n      \
    \  numbers_unit[i] = (numbers[i] - minimum) * scale;\n    }\n    numbers_unit",
  "    let mut result = numbers.clone();\n    let max = numbers.iter().max().unwrap();\n\
    \    let min = numbers.iter().min().unwrap();\n    let delta = max - min;\n  \
    \  for num in &mut result {\n        *num = (num - min) / delta;\n    }\n    result",
  "    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let diff = max - min;\n    numbers.iter().map(|&n| (n - min) / diff).collect()",
  "    let mut numbers = numbers;\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    let min = numbers[0];\n    let max = numbers[numbers.len() - 1];\n    numbers.iter().map(|i|\
    \ (i - min) / (max - min)).collect()", "    let min = *numbers.iter().min().unwrap();\n\
    \    let max = *numbers.iter().max().unwrap();\n    let numbers = numbers.iter().map(|n|\
    \ (n - min) / (max - min)).collect();\n    numbers", "    let mut transformed_list\
    \ = numbers.clone();\n    let max = transformed_list.iter().max().unwrap();\n\
    \    let min = transformed_list.iter().min().unwrap();\n    for i in 0..transformed_list.len()\
    \ {\n        transformed_list[i] = (transformed_list[i] - min) / (max - min);\n\
    \    }\n    transformed_list", "    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    let range = max - min;\n  \
    \  numbers.iter().map(|x| (x - min) / range).collect()", "    let min_val = numbers.iter().cloned().fold(f64::INFINITY,\
    \ f64::min);\n    let max_val = numbers.iter().cloned().fold(f64::NEG_INFINITY,\
    \ f64::max);\n    let scale = max_val - min_val;\n    let offset = min_val;\n\
    \    numbers.iter().map(|&n| (n - offset) / scale).collect()", "    if numbers.len()\
    \ < 2 {\n        panic!(\"too few numbers: {:?}\", numbers);\n    }\n    let min\
    \ = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY,\
    \ f64::max);\n    println!(\"min {} max {}\", min, max);\n    numbers.iter().map(|&value|\
    \ value / (max - min)).collect()", "    let (minimum, maximum) = find_extremes(&numbers);\n\
    \    let range = maximum - minimum;\n    let scaled_numbers = numbers.iter().map(|value|\
    \ (value - minimum) / range).collect();\n    scaled_numbers", "    let min_number\
    \ = *numbers.iter().min().unwrap();\n    let max_number = *numbers.iter().max().unwrap();\n\
    \    let distance = max_number - min_number;\n    numbers.iter().map(|number|\
    \ {\n        if distance == 0.0 {\n            0.0\n        } else {\n       \
    \     (number - min_number) / distance\n        }\n    }).collect()", "    let\
    \ n = numbers.len();\n    if n < 2 {\n        panic!(\"At least two elements are\
    \ needed to rescale.\");\n    }\n    let mut result = vec![0.0; n];\n    // find\
    \ the minimum and maximum values in the given list of numbers\n    let min_number\
    \ = numbers[0];\n    let max_number = numbers[0];\n    for i in 1..n {\n     \
    \   if numbers[i] < min_number {\n            min_number = numbers[i];\n     \
    \   }\n        if numbers[i] > max_number {\n            max_number = numbers[i];\n\
    \        }\n    }\n    // the linear transform\n    let a = 1.0 / (max_number\
    \ - min_number);\n    let b = -min_number * a;\n    for i in 0..n {\n        result[i]\
    \ = a * numbers[i] + b;\n    }\n    result", "    let mut numbers = numbers;\n\
    \    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    let min = numbers[0];\n\
    \    let max = numbers[numbers.len() - 1];\n    // println!(\"{:?}\", numbers);\n\
    \    numbers.iter().map(|x| {\n        let x = x - min;\n        let x = x / (max\
    \ - min);\n        // println!(\"{}\", x);\n        x\n    }).collect()", "  \
    \  let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let min_max_diff = max - min;\n    numbers.iter().map(|x| (x - min) / min_max_diff).collect()",
  "    let mut numbers = numbers;\n    let mut min = numbers[0];\n    let mut max\
    \ = numbers[0];\n    for n in numbers.iter() {\n        if *n < min {\n      \
    \      min = *n;\n        }\n        if *n > max {\n            max = *n;\n  \
    \      }\n    }\n    for n in numbers.iter_mut() {\n        *n = (*n - min) /\
    \ (max - min);\n    }\n    numbers", "    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    let range = max - min;\n  \
    \  numbers.iter().map(|x| (x - min) / range).collect()", "    let min_value =\
    \ numbers.iter().min().unwrap();\n    let max_value = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|x| (x - min_value) / (max_value - min_value)).collect()",
  "    // There was an attempt to implement this as an iterator but that\n    // was\
    \ too hard for me (see the commented out code below)\n\n    // let min = numbers.iter().min();\n\
    \    // let max = numbers.iter().max();\n    // numbers.iter().map(|&x| rescale(x,\
    \ min, max)).collect()\n\n    let mut out = Vec::with_capacity(numbers.len());\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    for n in numbers {\n        out.push(rescale(n, min, max));\n    }\n    out",
  "    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    return numbers.iter().map(|x| (x - min) / (max - min)).collect();", "   \
    \ let (mut min, mut max) = (numbers[0], numbers[0]);\n    for number in numbers.iter()\
    \ {\n        if *number < min {\n            min = *number;\n        }\n     \
    \   if *number > max {\n            max = *number;\n        }\n    }\n    let\
    \ interval = max - min;\n    return numbers.iter().map(|number| (*number - min)\
    \ / interval).collect();", "    let min = numbers.iter().min().unwrap();\n   \
    \ let max = numbers.iter().max().unwrap();\n    let denominator = max - min;\n\
    \    numbers.iter().map(|x| (x - min) / denominator).collect()", "    let mut\
    \ result = Vec::new();\n    if numbers.len() < 2 {\n        return result;\n \
    \   }\n    let x_min = numbers.iter().min().unwrap();\n    let x_max = numbers.iter().max().unwrap();\n\
    \    let a = 1.0 / (x_max - x_min);\n    let b = -a * x_min;\n    for x in numbers\
    \ {\n        result.push(a * x + b);\n    }\n    result", "    let min = numbers.iter().cloned().fold(numbers[0],\
    \ f64::min);\n    let max = numbers.iter().cloned().fold(numbers[0], f64::max);\n\
    \    let scale = 1.0 / (max - min);\n    numbers.iter().map(|&x| (x - min) * scale).collect()",
  "    let min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let max\
    \ = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n    numbers.iter().map(|x|\
    \ (x - min) / (max - min)).collect()", "    let min = *numbers.iter().min().unwrap();\n\
    \    let max = *numbers.iter().max().unwrap();\n    let mut numbers = numbers;\n\
    \    numbers.iter_mut().for_each(|n| *n = (*n - min) / (max - min));\n    numbers",
  "    let min_value = numbers\n        .iter()\n        .min_by(|x, y| x.partial_cmp(y).unwrap())\n\
    \        .unwrap();\n    let max_value = numbers\n        .iter()\n        .max_by(|x,\
    \ y| x.partial_cmp(y).unwrap())\n        .unwrap();\n    numbers\n        .iter()\n\
    \        .map(|n| (n - min_value) / (max_value - min_value))\n        .collect()",
  "    // TODO: It might be better to use an iterator here\n    let min = *numbers.iter().min().unwrap();\n\
    \    let max = *numbers.iter().max().unwrap();\n    let mut new_numbers = Vec::with_capacity(numbers.len());\n\
    \    for number in numbers {\n        let new_number = rescale_to_unit_single(number,\
    \ min, max);\n        new_numbers.push(new_number);\n    }\n    new_numbers",
  "    let mut numbers = numbers;\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    let min = numbers[0];\n    let max = numbers[numbers.len() - 1];\n    let\
    \ diff = max - min;\n    if diff > 0.0 {\n        numbers.iter().map(|n| (n -\
    \ min) / diff).collect()\n    } else {\n        numbers\n    }", "    // Find\
    \ the minimum and maximum of the vector so we know by how much to shift\n    let\
    \ mut min = std::f64::MAX;\n    let mut max = std::f64::MIN;\n    for number in\
    \ numbers.iter() {\n        if *number < min {\n            min = *number;\n \
    \       }\n        if *number > max {\n            max = *number;\n        }\n\
    \    }\n    // Rescale the values\n    let scaled_numbers: Vec<f64> = numbers\n\
    \        .iter()\n        .map(|number| (number - min) / (max - min))\n      \
    \  .collect();\n    scaled_numbers", "    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    let mut result = Vec::new();\n\
    \    for num in numbers {\n        result.push((num - min) / (max - min));\n \
    \   }\n    result", "    assert!(numbers.len() >= 2);\n    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    numbers.iter().map(|num| (num\
    \ - min) / (max - min)).collect()", "    let mut smallest = numbers[0];\n    let\
    \ mut largest = numbers[0];\n    for &n in numbers.iter() {\n        if n < smallest\
    \ {\n            smallest = n;\n        }\n        if n > largest {\n        \
    \    largest = n;\n        }\n    }\n    let range = largest - smallest;\n   \
    \ numbers.iter().map(|&x| (x - smallest) / range).collect()", "    let max_number\
    \ = *numbers.iter().max().unwrap();\n    let min_number = *numbers.iter().min().unwrap();\n\
    \    let rescaled = numbers.iter().map(|number| {\n        if max_number != min_number\
    \ {\n            (number - min_number) / (max_number - min_number)\n        }\
    \ else {\n            number.clone()\n        }\n    }).collect();\n    rescaled",
  "    let min = numbers.iter().cloned().fold(std::f64::MAX, f64::min);\n    let max\
    \ = numbers.iter().cloned().fold(std::f64::MIN, f64::max);\n    let range = max\
    \ - min;\n    numbers.iter().map(|x| (x - min) / range).collect()", "    assert!(numbers.len()\
    \ >= 2);\n    let smallest = numbers.iter().min().unwrap();\n    let largest =\
    \ numbers.iter().max().unwrap();\n    let min_max_diff = largest - smallest;\n\
    \    let diff_one = 1.0 - 0.0;\n    numbers.iter().map(|number| {\n        (number\
    \ - smallest) * (diff_one / min_max_diff)\n    }).collect()", "    let (min, max)\
    \ = (numbers.iter().min().unwrap(), numbers.iter().max().unwrap());\n    numbers.iter().map(|&x|\
    \ (x - min) / (max - min)).collect()", "    let sorted = numbers.iter().sorted_by(|a,\
    \ b| a.partial_cmp(b).unwrap()).collect::<Vec<&f64>>();\n    let min = *sorted[0];\n\
    \    let max = *sorted[sorted.len() - 1];\n    let scale = 1.0 / (max - min);\n\
    \    numbers.iter().map(|x| (x - min) * scale).collect()", "    let minimum =\
    \ numbers.iter().fold(numbers[0], |acc, x| acc.min(*x));\n    let maximum = numbers.iter().fold(numbers[0],\
    \ |acc, x| acc.max(*x));\n    let range = maximum - minimum;\n    numbers.iter().map(|x|\
    \ (x - minimum) / range).collect()", "    let min = numbers.iter().cloned().fold(f64::INFINITY,\
    \ f64::min);\n    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n\
    \    let diff = max - min;\n    numbers.iter().map(|x| (x - min) / diff).collect()",
  "    let min_val = numbers.iter().min().unwrap();\n    let max_val = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|x| (x - min_val) / (max_val - min_val)).collect()", " \
    \   let min = numbers.iter().cloned().fold(f64::MAX, f64::min);\n    let max =\
    \ numbers.iter().cloned().fold(f64::MIN, f64::max);\n    let range = max - min;\n\
    \    numbers.iter().map(|x| (x - min) / range).collect()", "    let max_number\
    \ = *numbers.iter().max().unwrap();\n    let min_number = *numbers.iter().min().unwrap();\n\
    \    let range = max_number - min_number;\n    let to_unit_scale = 1.0 / range;\n\
    \    numbers.iter().map(|x| (x - min_number) * to_unit_scale).collect()", "  \
    \  let mut out = numbers.clone();\n    let min_n = out.iter().min().unwrap();\n\
    \    let max_n = out.iter().max().unwrap();\n    for o in out.iter_mut() {\n \
    \       *o = (*o - min_n) / (max_n - min_n);\n    }\n    out", "    let mut numbers\
    \ = numbers;\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    let\
    \ min = numbers[0];\n    let max = numbers[numbers.len() - 1];\n    let range\
    \ = max - min;\n    numbers.iter().map(|x| (x - min) / range).collect()", "  \
    \  let min = numbers.iter().cloned().fold(f64::MAX, f64::min);\n    let max =\
    \ numbers.iter().cloned().fold(f64::MIN, f64::max);\n    let range = max - min;\n\
    \    numbers.iter().map(|x| (x - min) / range).collect()", "    if numbers.len()\
    \ < 2 {\n        panic!(\"Empty list of numbers!\");\n    }\n    let min_number\
    \ = numbers.iter().min().unwrap();\n    let max_number = numbers.iter().max().unwrap();\n\
    \    let range = max_number - min_number;\n    numbers.iter().map(|n| (n - min_number)\
    \ / range).collect()", "    let mut sorted_numbers = numbers.clone();\n    sorted_numbers.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    let mut rescaled = Vec::new();\n    let\
    \ min = sorted_numbers[0];\n    let max = sorted_numbers[sorted_numbers.len()\
    \ - 1];\n    for number in numbers {\n        rescaled.push((number - min) / (max\
    \ - min));\n    }\n    rescaled", "    if numbers.len() < 2 {\n        panic!(\"\
    A list of numbers must have at least two elements\");\n    }\n    let min_value\
    \ = numbers.iter().min().unwrap();\n    let max_value = numbers.iter().max().unwrap();\n\
    \    let offset = min_value.clone();\n    let scaling_factor = (max_value - min_value).recip();\n\
    \    numbers.iter().map(|value| (value - offset) * scaling_factor).collect()",
  "    let min_val = numbers.iter().min().unwrap();\n    let max_val = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|&n| (n - min_val) / (max_val - min_val)).collect()",
  "    if numbers.len() < 2 {\n        panic!(\"Cannot rescale list of length < 2\"\
    )\n    }\n    let mut result = numbers.clone();\n    let min = result.iter().min().unwrap();\n\
    \    let max = result.iter().max().unwrap();\n    for x in result.iter_mut() {\n\
    \        *x = (*x - min) / (max - min);\n    }\n    result", "    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    numbers.iter().map(|x| (*x\
    \ - min) / (max - min)).collect()", "    let min_element = numbers.iter().min().unwrap();\n\
    \    let max_element = numbers.iter().max().unwrap();\n    let difference = max_element\
    \ - min_element;\n    numbers.iter().map(|&x| (x - min_element) / difference).collect()",
  "    let (min, max) = find_min_max(&numbers);\n    if min == max {\n        vec![0.0;\
    \ numbers.len()]\n    } else {\n        numbers.iter().map(|number| (number -\
    \ min) / (max - min)).collect()\n    }", "    let (min, max) = find_min_max(&numbers);\n\
    \    let denominator = max - min;\n    numbers.iter().map(|x| (x - min) / denominator).collect()",
  "    // find the minimum and maximum in the vector\n    let mut numbers = numbers;\n\
    \    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n  \
    \  let min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n\n    //\
    \ calculate the transformation constants\n    let delta = max - min;\n    let\
    \ offset = min;\n\n    // apply the transform\n    numbers.iter_mut().for_each(|n|\
    \ *n = (*n - offset) / delta);\n\n    numbers", "    let min = numbers.iter().cloned().fold(f64::INFINITY,\
    \ f64::min);\n    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n\
    \    let diff = max - min;\n    numbers.iter().map(|n| (*n - min) / diff).collect()",
  "    let min = *numbers.iter().min().unwrap();\n    let max = *numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|&x| (x - min) / (max - min)).collect()", "    let min\
    \ = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|&x| (x - min) / (max - min)).collect()", "    let minimum\
    \ = numbers.iter().fold(1.0e100, |a, &b| a.min(b));\n    let maximum = numbers.iter().fold(-1.0e100,\
    \ |a, &b| a.max(b));\n    let range = maximum - minimum;\n    numbers.iter().map(|n|\
    \ (n - minimum) / range).collect()", "    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    let range = max - min;\n  \
    \  let mut rescaled = Vec::new();\n    for number in numbers {\n        let rescaled_value\
    \ = (number - min) / range;\n        rescaled.push(rescaled_value);\n    }\n \
    \   rescaled", "    let min_n = numbers.iter().cloned().fold(f64::MAX, f64::min);\n\
    \    let max_n = numbers.iter().cloned().fold(f64::MIN, f64::max);\n    // In\
    \ the formula below, I'm guessing the inputs x and y should be normalized to 0..1\
    \ range\n    let normalize = |x: f64| (x - min_n) / (max_n - min_n);\n    numbers.iter().map(normalize).collect()",
  "    let minimum = numbers.iter().fold(std::f64::MAX, |acc, x| if x < &acc { *x\
    \ } else { acc });\n    let maximum = numbers.iter().fold(std::f64::MIN, |acc,\
    \ x| if x > &acc { *x } else { acc });\n    numbers.iter().map(|x| (x - minimum)\
    \ / (maximum - minimum)).collect()", "    let min = numbers.iter().cloned().fold(f64::INFINITY,\
    \ f64::min);\n    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n\
    \    numbers.iter().map(|&x| (x - min) / (max - min)).collect()", "    let min\
    \ = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|&x| (x - min) / (max - min)).collect()", "    let min\
    \ = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let delta = max - min;\n    let is_delta_zero = delta == 0.0;\n    numbers.iter().map(|x|\
    \ if is_delta_zero {\n        0.0\n    } else {\n        (x - min) / delta\n \
    \   }).collect()", "    let min = numbers.iter().min().unwrap();\n    let max\
    \ = numbers.iter().max().unwrap();\n    numbers.iter().map(|number| number.clone()\
    \ / (max - min)).collect()", "    let mut numbers = numbers;\n    numbers.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    let min = numbers[0];\n    let max = numbers[numbers.len()\
    \ - 1];\n    numbers.iter().map(|num| (num - min) / (max - min)).collect()", " \
    \   let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    if min == max {\n        vec![0.0; numbers.len()]\n    } else {\n       \
    \ numbers.iter().map(|x| (x - min) / (max - min)).collect()\n    }", "    let\
    \ delta = numbers.iter().max().unwrap() - numbers.iter().min().unwrap();\n   \
    \ numbers.iter().map(|num| (num - numbers.iter().min().unwrap()) / delta).collect()",
  "    let (min, max) = (numbers.iter().cloned().min().unwrap(), numbers.iter().cloned().max().unwrap());\n\
    \    let denom = max - min;\n    if denom != 0.0 {\n        return numbers.iter().map(|x|\
    \ (x - min) / denom).collect();\n    }\n    numbers", "    let min = numbers.iter().cloned().fold(f64::INFINITY,\
    \ f64::min);\n    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n\
    \    numbers.iter().map(|&x| (x - min) / (max - min)).collect()", "    let min\
    \ = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    if max == min {\n        return numbers;\n    }\n    numbers.iter().map(|&x|\
    \ (x - min) / (max - min)).collect()", "    let mut ret: Vec<f64> = Vec::new();\n\
    \    let min_value = numbers.iter().fold(std::f64::MAX, |m, i| m.min(*i));\n \
    \   let max_value = numbers.iter().fold(std::f64::MIN, |m, i| m.max(*i));\n  \
    \  for n in numbers {\n        ret.push((n - min_value) / (max_value - min_value));\n\
    \    }\n    ret", "    let min = numbers.iter().min().unwrap();\n    let max =\
    \ numbers.iter().max().unwrap();\n    numbers.iter().map(|n| (n - min) / (max\
    \ - min)).collect()", "    let max = numbers.iter().cloned().fold(std::f64::NEG_INFINITY,\
    \ f64::max);\n    let min = numbers.iter().cloned().fold(std::f64::INFINITY, f64::min);\n\
    \    let range = max - min;\n    numbers.iter().map(|x| (x - min) / range).collect()",
  "    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let range = max - min;\n    numbers.iter().map(|x| (x - min) / range).collect()",
  "    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let diff = max - min;\n    numbers.iter().map(|num| (num - min) / diff).collect()",
  "    //unimplemented!()\n    let (nmin, nmax) = (numbers.iter().cloned().min().unwrap(),\
    \ numbers.iter().cloned().max().unwrap());\n    let (nmin, nmax) = (nmin as f64,\
    \ nmax as f64);\n    numbers.iter().map(|&x| (x - nmin) / (nmax - nmin)).collect()",
  "    let min_number = numbers.iter().min().unwrap();\n    let max_number = numbers.iter().max().unwrap();\n\
    \    let number_range = max_number - min_number;\n    numbers.iter().map(|x| (x\
    \ - min_number) / number_range).collect()", "    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    let mut rescaled = numbers;\n\
    \    for i in 0..rescaled.len() {\n        rescaled[i] = rescaled[i] - min;\n\
    \        rescaled[i] = rescaled[i] / (max - min);\n    }\n    rescaled", "   \
    \ assert!(numbers.len() >= 2);\n    let max_ = *numbers.iter().max().unwrap();\n\
    \    let min_ = *numbers.iter().min().unwrap();\n    numbers.iter().map(|number|\
    \ (number - min_) / (max_ - min_)).collect()", "    let min = numbers.iter().cloned().fold(f64::INFINITY,\
    \ f64::min);\n    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n\
    \    let diff = max - min;\n    if diff > 0.0 {\n        numbers.iter().map(|x|\
    \ (x - min) / diff).collect()\n    } else {\n        numbers\n    }", "    let\
    \ mut numbers = numbers;\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    let (a, b) = (numbers[0], numbers[numbers.len() - 1]);\n    numbers.iter().map(|number|\
    \ (number - a) / (b - a)).collect()", "    if numbers.len() < 2 {\n        panic!(\"\
    Cannot rescale to unit a list with less than 2 elements\");\n    }\n    let min\
    \ = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let norm_diff = max - min;\n    numbers.iter().map(|x| (x - min) / norm_diff).collect()",
  "    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let range = max - min;\n    numbers.iter().map(|x| (x - min) / range).collect()",
  "    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let diff = max - min;\n    numbers.iter().map(|x| (x - min) / diff).collect()",
  "    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let delta = max - min;\n    if delta == 0.0 {\n        vec![0.0; numbers.len()]\n\
    \    } else {\n        numbers.iter().map(|&x| (x - min) / delta).collect()\n\
    \    }", "    let mut rescaled_numbers = numbers.clone();\n    if let Some(min)\
    \ = rescaled_numbers.iter().min() {\n        rescaled_numbers = rescaled_numbers.iter().map(|x|\
    \ x - min).collect();\n    }\n    if let Some(max) = rescaled_numbers.iter().max()\
    \ {\n        rescaled_numbers = rescaled_numbers.iter().map(|x| x / max).collect();\n\
    \    }\n    rescaled_numbers", "    let min = numbers.iter().cloned().fold(f64::INFINITY,\
    \ f64::min);\n    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n\
    \    let range = max - min;\n    numbers.iter().map(|n| (n - min) / range).collect()",
  "    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let range = max - min;\n    numbers.iter().map(|number| (number - min) /\
    \ range).collect()", "    let max = numbers.iter().cloned().fold(0.0, f64::max);\n\
    \    let min = numbers.iter().cloned().fold(0.0, f64::min);\n    let diff = max\
    \ - min;\n    numbers.iter().map(|n| (n - min) / diff).collect()", "    let min\
    \ = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let range = max - min;\n    let rescaled = numbers.iter().map(|x| (x - min)\
    \ / range).collect();\n    rescaled", "    let min_num = numbers.iter().cloned().fold(numbers[0],\
    \ f64::min);\n    let max_num = numbers.iter().cloned().fold(numbers[0], f64::max);\n\
    \    numbers.iter().map(|x| {\n        let num = x - min_num;\n        let denom\
    \ = max_num - min_num;\n        num / denom\n    }).collect()", "    assert!(numbers.len()\
    \ >= 2);\n    let min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n\
    \    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n  \
    \  assert!(min < max);\n    let scale = 1.0 / (max - min);\n    numbers.iter().map(|x|\
    \ (x - min) * scale).collect()", "    let min = numbers.iter().cloned().fold(f64::INFINITY,\
    \ f64::min);\n    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n\
    \    numbers.iter().map(|x| (x - min) / (max - min)).collect()", "    let mut\
    \ rescaled = numbers.clone();\n    let min = rescaled.iter().min().unwrap();\n\
    \    let max = rescaled.iter().max().unwrap();\n    rescaled.iter_mut().for_each(|n|\
    \ *n = (*n - min) / (max - min));\n    rescaled", "    let mut scaled_numbers\
    \ = Vec::with_capacity(numbers.len());\n    let min_number = numbers.iter().min().unwrap();\n\
    \    let max_number = numbers.iter().max().unwrap();\n    for number in numbers\
    \ {\n        let scaled_number = (number - min_number) / (max_number - min_number);\n\
    \        scaled_numbers.push(scaled_number);\n    }\n    scaled_numbers", "  \
    \  let maximum = numbers.iter().max().unwrap();\n    let minimum = numbers.iter().min().unwrap();\n\
    \    let range = maximum - minimum;\n    numbers.iter().map(|&x| (x - minimum)\
    \ / range).collect()", "    //calculate the minimum and maximum\n    let (max,\
    \ min) = numbers.iter().fold((std::f64::NEG_INFINITY, std::f64::INFINITY), |(max,\
    \ min), x| (x.max(max), x.min(min)));\n    //get the scale factor\n    let scale\
    \ = 1.0 / (max - min);\n    //rescale the data\n    numbers.iter().map(|x| (x\
    \ - min) * scale).collect()", "    let mut rescaled = numbers.clone();\n    let\
    \ max = numbers.iter().max().unwrap();\n    let min = numbers.iter().min().unwrap();\n\
    \    let range = *max - *min;\n    for i in 0..rescaled.len() {\n        rescaled[i]\
    \ = (rescaled[i] - *min) / range;\n    }\n    rescaled", "    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    let range = max - min;\n  \
    \  let mut result = Vec::with_capacity(numbers.len());\n    for number in numbers\
    \ {\n        result.push((number - min) / range);\n    }\n    result", "    let\
    \ max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n    let min\
    \ = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let range = max\
    \ - min;\n    let convert = |v: f64| (v - min) / range;\n    numbers.iter().map(convert).collect()",
  "    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let numbers = numbers.iter().map(|x| (x - min) / (max - min)).collect();\n\
    \    numbers", "    if numbers.len() == 0 {\n        return numbers;\n    }\n\
    \    let max = numbers.iter().max().unwrap();\n    let min = numbers.iter().min().unwrap();\n\
    \    let diff = max - min;\n    if diff == 0.0 {\n        return numbers;\n  \
    \  }\n    numbers.iter().map(|x| (x - min) / diff).collect()", "    let max =\
    \ numbers.iter().cloned().fold(0.0 / 0.0, f64::max);\n    let min = numbers.iter().cloned().fold(0.0\
    \ / 0.0, f64::min);\n    let range = max - min;\n    let scale = 1.0 / range;\n\
    \    numbers.iter().map(|x| (x - min) * scale).collect()", "    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    let span = max - min;\n   \
    \ numbers.iter().map(|x| (x - min) / span).collect()", "    let min = *numbers.iter().min().unwrap();\n\
    \    let max = *numbers.iter().max().unwrap();\n    let diff = max - min;\n  \
    \  numbers.iter().map(|n| (n - min) / diff).collect()", "    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    let scale = (max - min) / 1.0;\n\
    \    let mut rescaled = vec![];\n    for &number in numbers.iter() {\n       \
    \ rescaled.push((number - min) / scale);\n    }\n    rescaled", "    let (min,\
    \ max) = numbers.iter().cloned().fold((numbers[0], numbers[0]), |(min, max), x|\
    \ {\n        (\n            if x < min { x } else { min },\n            if x >\
    \ max { x } else { max },\n        )\n    });\n    let (min, max) = (min as f64,\
    \ max as f64);\n    numbers\n        .iter()\n        .cloned()\n        .map(|n|\
    \ (n - min) / (max - min))\n        .collect()", "    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    numbers.iter().map(|x| (x -\
    \ min) / (max - min)).collect()", "    let min = numbers.iter().cloned().fold(f64::INFINITY,\
    \ f64::min);\n    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n\
    \    let scale = max - min;\n    numbers.iter().map(|x| (*x - min) / scale).collect()",
  "    // find max & min\n    let mut max = numbers[0];\n    let mut min = numbers[0];\n\
    \    for number in numbers.iter() {\n        if number > &max {\n            max\
    \ = *number;\n        }\n        if number < &min {\n            min = *number;\n\
    \        }\n    }\n    // rescale\n    let mut scaled_numbers = Vec::new();\n\
    \    for number in numbers.iter() {\n        scaled_numbers.push((number - min)\
    \ / (max - min));\n    }\n    scaled_numbers", "    let min_number = numbers.iter().min().unwrap();\n\
    \    let max_number = numbers.iter().max().unwrap();\n    let range = max_number\
    \ - min_number;\n    numbers.iter().map(|i| (i - min_number) / range).collect()",
  "    let min = numbers.iter().cloned().fold(f64::MAX, f64::min);\n    let max =\
    \ numbers.iter().cloned().fold(f64::MIN, f64::max);\n    let diff = max - min;\n\
    \    let unit_space = 1.0 / diff;\n    numbers.iter().map(|&n| unit_space * (n\
    \ - min)).collect()", "    let min = numbers.iter().cloned().fold(f64::INFINITY,\
    \ f64::min);\n    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n\
    \    let span = max - min;\n    numbers.iter().map(|&x| (x - min) / span).collect()"]
stop_tokens:
- "\n}"
