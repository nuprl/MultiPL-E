name: HumanEval_12_longest
language: rust
results:
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    strings.into_iter().max_by_key(|s| s.len()).map(|s|\
    \ s.to_string())\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpw1keukvc.rs:15:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpuoyh2wcj.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    strings.into_iter().max_by_key(|s| s.len()).cloned()\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Option<String>` is not an iterator\n   --> /tmp/tmpa0xzeqv_.rs:9:49\n\
    \    |\n9   |       strings.into_iter().max_by_key(|s| s.len()).cloned()\n   \
    \ |                                                   ^^^^^^ `Option<String>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<String>: Iterator`\n            which is required by `&mut\
    \ Option<String>: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    if strings.is_empty() {\n        return None;\n   \
    \ }\n    let mut longest = &strings[0];\n    for s in &strings {\n        if s.len()\
    \ > longest.len() {\n            longest = s;\n        }\n    }\n    Some(longest.to_string())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp1v2xu25a.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    if strings.is_empty() {\n        return None;\n   \
    \ }\n    let mut longest_string = &strings[0];\n    for string in &strings {\n\
    \        if string.len() > longest_string.len() {\n            longest_string\
    \ = string;\n        }\n    }\n    Some(longest_string.to_string())\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut longest_so_far = None;\n    for s in strings\
    \ {\n        longest_so_far = Some(match longest_so_far {\n            None =>\
    \ s,\n            Some(ref so_far) => if s.len() > so_far.len() { s } else { so_far.clone()\
    \ },\n        });\n    }\n    longest_so_far\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `Option<T>`\n  --> /tmp/tmpjcvel4fo.rs:13:13\n\
    \   |\n9  |     let mut longest_so_far = None;\n   |         ------------------\
    \ consider giving `longest_so_far` the explicit type `Option<T>`, where the type\
    \ parameter `T` is specified\n...\n13 |             Some(ref so_far) => if s.len()\
    \ > so_far.len() { s } else { so_far.clone() },\n   |             ^^^^^^^^^^^^^^^^\
    \ cannot infer type for type parameter `T` declared on the enum `Option`\n   |\n\
    \   = note: type must be known at this point\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    if strings.is_empty() {\n        return None;\n   \
    \ }\n    let mut max_len = 0;\n    let mut max_str = &strings[0];\n    for i in\
    \ 1..strings.len() {\n        if strings[i].len() > max_len {\n            max_len\
    \ = strings[i].len();\n            max_str = &strings[i];\n        }\n    }\n\
    \    Some(max_str.to_string())\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"y\")`,\n right: `Some(\"x\")`', /tmp/tmpop_pzrvz.rs:26:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    strings.into_iter().max_by_key(|s| s.len()).cloned()\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Option<String>` is not an iterator\n   --> /tmp/tmpnl4noer7.rs:9:49\n\
    \    |\n9   |       strings.into_iter().max_by_key(|s| s.len()).cloned()\n   \
    \ |                                                   ^^^^^^ `Option<String>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<String>: Iterator`\n            which is required by `&mut\
    \ Option<String>: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    // Implement `longest` here\n    if strings.len() ==\
    \ 0 {\n        return None;\n    }\n    let mut longest = strings[0].clone();\n\
    \    for s in strings.iter() {\n        if s.len() > longest.len() {\n       \
    \     longest = s.clone();\n        }\n    }\n    Some(longest)\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut longest = None;\n    for string in strings\
    \ {\n        match longest {\n            None => longest = Some(string),\n  \
    \          Some(cur) => {\n                if string.len() > cur.len() {\n   \
    \                 longest = Some(string);\n                }\n            }\n\
    \        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value\n  --> /tmp/tmplc43xdt5.rs:13:18\n   |\n\
    13 |             Some(cur) => {\n   |                  ^^^ value moved here, in\
    \ previous iteration of loop\n   |\nnote: these 2 reinitializations might get\
    \ skipped\n  --> /tmp/tmplc43xdt5.rs:12:21\n   |\n12 |             None => longest\
    \ = Some(string),\n   |                     ^^^^^^^\n...\n15 |               \
    \      longest = Some(string);\n   |                     ^^^^^^^\n   = note: move\
    \ occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp8n71cd0p.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpxe5pg7dh.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmprji9dxim.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    if strings.is_empty() {\n        return None;\n   \
    \ }\n    let mut max_len = 0;\n    let mut max_index = 0;\n    for (i, s) in strings.iter().enumerate()\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_index = i;\n        }\n    }\n    Some(strings[max_index].clone())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    strings.into_iter().max_by_key(|string| string.len()).clone()\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmp3mr7qpgm.rs:15:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    // TODO: implement longest(strings) here\n    let mut\
    \ output: Option<String> = None;\n    let mut max: usize = 0;\n    for i in 0..strings.len()\
    \ {\n        if max < strings[i].len() {\n            max = strings[i].len();\n\
    \            output = Some(strings[i].clone());\n        }\n    }\n    output\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    if strings.is_empty() {\n        return None;\n   \
    \ }\n    let mut result = None;\n    for string in strings {\n        if result.is_none()\
    \ || string.len() > result.unwrap().len() {\n            result = Some(string);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `Option<T>`\n  --> /tmp/tmpl_wy6dac.rs:14:54\n\
    \   |\n12 |     let mut result = None;\n   |         ---------- consider giving\
    \ `result` the explicit type `Option<T>`, where the type parameter `T` is specified\n\
    13 |     for string in strings {\n14 |         if result.is_none() || string.len()\
    \ > result.unwrap().len() {\n   |                                            \
    \          ^^^^^^ cannot infer type for type parameter `T`\n   |\n   = note: type\
    \ must be known at this point\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut longest = String::new();\n    for string in\
    \ strings {\n        if string.len() > longest.len() {\n            longest =\
    \ string;\n        }\n    }\n    if longest.is_empty() {\n        None\n    }\
    \ else {\n        Some(longest)\n    }\n}\n\nfn main() {\n    let candidate =\
    \ longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    match strings.len() {\n        0 => None,\n       \
    \ 1 => Some(strings[0].clone()),\n        _ => {\n            let mut first =\
    \ strings[0].clone();\n            for string in strings {\n                if\
    \ string.len() > first.len() {\n                    first = string.clone();\n\
    \                }\n            }\n            Some(first)\n        }\n    }\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    if strings.is_empty() {\n        return None;\n   \
    \ }\n    let mut longest_length = 0;\n    let mut longest_word = &strings[0];\n\
    \    for string in strings {\n        if string.len() > longest_length {\n   \
    \         longest_length = string.len();\n            longest_word = &string;\n\
    \        }\n    }\n    Some(longest_word.to_string())\n}\n\nfn main() {\n    let\
    \ candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0505]: cannot move out of `strings` because it is borrowed\n  -->\
    \ /tmp/tmp138njet3.rs:14:19\n   |\n13 |     let mut longest_word = &strings[0];\n\
    \   |                             ------- borrow of `strings` occurs here\n14\
    \ |     for string in strings {\n   |                   ^^^^^^^ move out of `strings`\
    \ occurs here\n...\n20 |     Some(longest_word.to_string())\n   |          ------------------------\
    \ borrow later used here\n\nerror[E0597]: `string` does not live long enough\n\
    \  --> /tmp/tmp138njet3.rs:17:28\n   |\n17 |             longest_word = &string;\n\
    \   |                            ^^^^^^^ borrowed value does not live long enough\n\
    18 |         }\n19 |     }\n   |     - `string` dropped here while still borrowed\n\
    20 |     Some(longest_word.to_string())\n   |          ------------------------\
    \ borrow later used here\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0505, E0597.\nFor more information about an error,\
    \ try `rustc --explain E0505`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut longest = None;\n    for s in strings {\n \
    \       longest = match longest {\n            None => Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n                Some(l.clone())\n            }\n  \
    \      }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    strings.into_iter().max_by_key(|s| s.len()).map(Clone::clone)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0631]: type mismatch in function arguments\n   --> /tmp/tmpmd_2hel6.rs:9:53\n\
    \    |\n9   |     strings.into_iter().max_by_key(|s| s.len()).map(Clone::clone)\n\
    \    |                                                 --- ^^^^^^^^^^^^\n    |\
    \                                                 |   |\n    |               \
    \                                  |   expected signature of `fn(String) -> _`\n\
    \    |                                                 |   found signature of\
    \ `for<'r> fn(&'r _) -> _`\n    |                                            \
    \     required by a bound introduced by this call\n    |\nnote: required by a\
    \ bound in `Option::<T>::map`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0631`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    if strings.is_empty() {\n        return None;\n   \
    \ }\n    let mut max_len = strings[0].len();\n    let mut max_index = 0;\n   \
    \ for (i, s) in strings.iter().enumerate() {\n        if s.len() > max_len {\n\
    \            max_len = s.len();\n            max_index = i;\n        }\n    }\n\
    \    Some(strings[max_index].clone())\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut len: Option<usize> = None;\n    let mut index:\
    \ Option<usize> = None;\n    for (i, string) in strings.iter().enumerate() {\n\
    \        if let Some(l) = len {\n            if string.len() > l {\n         \
    \       len = Some(string.len());\n                index = Some(i);\n        \
    \    }\n        } else {\n            len = Some(string.len());\n            index\
    \ = Some(i);\n        }\n    }\n    if let Some(i) = index {\n        Some(strings[i].clone())\n\
    \    } else {\n        None\n    }\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmph0e41v73.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpw2om40xa.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    // Get max length\n    let max_len = strings.iter().map(|x|\
    \ x.len()).max();\n    // Filter\n    let filtered = strings.into_iter().filter(|x|\
    \ x.len() == max_len);\n    // Return\n    filtered.collect::<Vec<String>>().first().cloned()\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwwltgfkb.rs:12:62\n   |\n\
    12 |     let filtered = strings.into_iter().filter(|x| x.len() == max_len);\n\
    \   |                                                              ^^^^^^^ expected\
    \ `usize`, found enum `Option`\n   |\n   = note: expected type `usize`\n     \
    \         found enum `Option<usize>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut longest_so_far = None;\n    for s in strings\
    \ {\n        if longest_so_far.is_none() || longest_so_far.as_ref().unwrap().len()\
    \ < s.len() {\n            longest_so_far = Some(s);\n        }\n    }\n    longest_so_far\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `Option<T>`\n  --> /tmp/tmp7r4agjru.rs:11:55\n\
    \   |\n9  |     let mut longest_so_far = None;\n   |         ------------------\
    \ consider giving `longest_so_far` the explicit type `Option<T>`, where the type\
    \ parameter `T` is specified\n10 |     for s in strings {\n11 |         if longest_so_far.is_none()\
    \ || longest_so_far.as_ref().unwrap().len() < s.len() {\n   |                \
    \                                       ^^^^^^ cannot infer type for type parameter\
    \ `T`\n   |\n   = note: type must be known at this point\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut longest = strings.first().cloned();\n    for\
    \ string in strings {\n        longest = match longest {\n            Some(s)\
    \ => Some(match s.len().cmp(&string.len()) {\n                Ordering::Greater\
    \ => s,\n                _ => string,\n            }),\n            None => Some(string),\n\
    \        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmp6___6lm8.rs:13:17\n   |\n13 |                 Ordering::Greater => s,\n\
    \   |                 ^^^^^^^^ use of undeclared type `Ordering`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    if strings.is_empty() {\n        return None;\n   \
    \ }\n    let mut strings_iter = strings.iter();\n    let mut max_len = 0;\n  \
    \  let mut max_string = &strings_iter.next().unwrap();\n    for s in strings_iter\
    \ {\n        if s.len() > max_len {\n            max_len = s.len();\n        \
    \    max_string = s;\n        }\n    }\n    Some(max_string.to_string())\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7isjitdb.rs:18:26\n   |\n\
    14 |     let mut max_string = &strings_iter.next().unwrap();\n   |           \
    \               ----------------------------- expected due to this value\n...\n\
    18 |             max_string = s;\n   |                          ^ expected `&String`,\
    \ found struct `String`\n   |\n   = note: expected reference `&&String`\n    \
    \          found reference `&String`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp39ggj2ok.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    if strings.is_empty() {\n        return None;\n   \
    \ }\n    let mut longest_string = String::new();\n    for s in strings {\n   \
    \     if s.len() > longest_string.len() {\n            longest_string = s;\n \
    \       }\n    }\n    Some(longest_string)\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut result = String::new();\n    for s in strings\
    \ {\n        if s.len() > result.len() {\n            result = s;\n        }\n\
    \    }\n    if result.len() == 0 {\n        None\n    } else {\n        Some(result)\n\
    \    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    if strings.is_empty() {\n        return None;\n   \
    \ }\n    let mut longest = &strings[0];\n    for s in &strings {\n        if s.len()\
    \ > longest.len() {\n            longest = s;\n        }\n    }\n    Some(longest.to_string())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    strings.into_iter().max_by_key(|s| s.len()).or(None)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpempunm_d.rs:15:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    // TODO(you)\n    // unimplemented!()\n    let mut\
    \ result = strings.clone();\n    if result.len() == 0 {\n        None\n    } else\
    \ {\n        result.sort_by(|a, b| b.len().cmp(&a.len()));\n        Some(result[0].clone())\n\
    \    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    strings.into_iter().fold(None, |x, y| {\n        match\
    \ x {\n            None => Some(y),\n            Some(a) => if a.len() > y.len()\
    \ { Some(a) } else { Some(y) },\n        }\n    })\n}\n\nfn main() {\n    let\
    \ candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmp5sd7map3.rs:20:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpthx97k3f.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    // TODO: implement this function.\n    let mut longest_string\
    \ = String::new();\n    for string in strings {\n        if string.len() > longest_string.len()\
    \ {\n            longest_string = string;\n        }\n    }\n    if longest_string.len()\
    \ == 0 {\n        None\n    } else {\n        Some(longest_string)\n    }\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut answer = None;\n    for s in strings {\n  \
    \      match answer {\n            None => answer = Some(s),\n            Some(t)\
    \ => if s.len() > t.len() {\n                answer = Some(s);\n            }\n\
    \        }\n    }\n    answer\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value\n  --> /tmp/tmp90cntwum.rs:13:18\n   |\n\
    13 |             Some(t) => if s.len() > t.len() {\n   |                  ^ value\
    \ moved here, in previous iteration of loop\n   |\nnote: these 2 reinitializations\
    \ might get skipped\n  --> /tmp/tmp90cntwum.rs:12:21\n   |\n12 |             None\
    \ => answer = Some(s),\n   |                     ^^^^^^\n13 |             Some(t)\
    \ => if s.len() > t.len() {\n14 |                 answer = Some(s);\n   |    \
    \             ^^^^^^\n   = note: move occurs because value has type `String`,\
    \ which does not implement the `Copy` trait\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut max_len = 0;\n    let mut longest_string =\
    \ None;\n    for s in strings {\n        if s.len() > max_len {\n            max_len\
    \ = s.len();\n            longest_string = Some(s);\n        }\n    }\n    longest_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmppd824j0x.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    if strings.is_empty() {\n        return None;\n   \
    \ }\n    let mut max_length = 0;\n    let mut longest_string = String::new();\n\
    \    for string in strings {\n        if string.len() > max_length {\n       \
    \     max_length = string.len();\n            longest_string = string;\n     \
    \   }\n    }\n    Some(longest_string)\n}\n\nfn main() {\n    let candidate =\
    \ longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    if strings.is_empty() {\n        return None;\n   \
    \ }\n    let mut longest = strings[0].clone();\n    for string in strings.iter()\
    \ {\n        if string.len() > longest.len() {\n            longest = string.clone();\n\
    \        }\n    }\n    Some(longest)\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut longest = String::new();\n    for s in strings\
    \ {\n        if s.len() > longest.len() {\n            longest = s;\n        }\n\
    \    }\n    if longest.len() > 0 {\n        Some(longest)\n    } else {\n    \
    \    None\n    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpfdzsxxn5.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    strings.into_iter().fold(None, |best, s| {\n      \
    \  match best {\n            None => Some(s),\n            Some(r) => if r.len()\
    \ < s.len() { Some(s) } else { Some(r) }\n        }\n    })\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpdb0_b_bg.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    strings.into_iter().max_by_key(|s| s.len()).map(|s|\
    \ s.to_string())\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmprch9kvqp.rs:15:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    // TODO: fill the function definition here\n    None\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(\"x\")`', /tmp/tmpq5r_536h.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp3ayrwu23.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    // Write code here\n    None\n}\n\nfn main() {\n  \
    \  let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(\"x\")`', /tmp/tmpk97c3903.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut longest = None;\n    for string in strings\
    \ {\n        longest = match longest {\n            None => Some(string),\n  \
    \          Some(s) => if s.len() > string.len() {\n                Some(s)\n \
    \           } else {\n                Some(string)\n            }\n        }\n\
    \    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpwt4l1cca.rs:26:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    if strings.is_empty() {\n        return None;\n   \
    \ }\n    let mut max_len = 0;\n    let mut max_str = String::new();\n    for s\
    \ in strings {\n        if s.len() > max_len {\n            max_len = s.len();\n\
    \            max_str = s;\n        }\n    }\n    Some(max_str)\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    None\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(\"x\")`', /tmp/tmpk5r51wc9.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut longest_str = None;\n    let mut longest_str_len\
    \ = 0;\n    for s in strings {\n        if s.len() > longest_str_len {\n     \
    \       longest_str = Some(s);\n            longest_str_len = s.len();\n     \
    \   }\n    }\n    longest_str\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpjf10t896.rs:14:31\n\
    \   |\n11 |     for s in strings {\n   |         - move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n12 |         if s.len()\
    \ > longest_str_len {\n13 |             longest_str = Some(s);\n   |         \
    \                       - value moved here\n14 |             longest_str_len =\
    \ s.len();\n   |                               ^^^^^^^ value borrowed here after\
    \ move\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    strings.into_iter().fold(None, |acc, x| {\n       \
    \ match acc {\n            None => Some(x),\n            Some(y) => if x.len()\
    \ > y.len() { Some(x) } else { Some(y) },\n        }\n    })\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut longest_word = String::new();\n    for string\
    \ in strings {\n        if string.len() > longest_word.len() {\n            longest_word\
    \ = string;\n        }\n    }\n    if longest_word.is_empty() {\n        None\n\
    \    } else {\n        Some(longest_word)\n    }\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut longest = None;\n    for x in strings {\n \
    \       match longest {\n            None => longest = Some(x),\n            Some(ref\
    \ s) => if x.len() > s.len() {\n                longest = Some(x);\n         \
    \   }\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    // TODO\n    unimplemented!()\n}\n\nfn main() {\n \
    \   let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp8dqowhlg.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    None\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(\"x\")`', /tmp/tmpmg3do8yl.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp78fvftro.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut strings_ = strings;\n    strings_.sort_by(|a,\
    \ b| a.len().cmp(&b.len()));\n    strings_.pop()\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpnn4fja9m.rs:17:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpyby2r__i.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpprwcyphn.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    if strings.is_empty() {\n        return None;\n   \
    \ }\n    let mut longest = strings[0].clone();\n    for s in strings {\n     \
    \   if s.len() > longest.len() {\n            longest = s;\n        }\n    }\n\
    \    Some(longest)\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut result = None;\n    for string in strings {\n\
    \        match result {\n            None => result = Some(string),\n        \
    \    Some(longest) => if string.len() > longest.len() {\n                result\
    \ = Some(string);\n            },\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value\n  --> /tmp/tmpufaggcht.rs:13:18\n   |\n\
    13 |             Some(longest) => if string.len() > longest.len() {\n   |    \
    \              ^^^^^^^ value moved here, in previous iteration of loop\n   |\n\
    note: these 2 reinitializations might get skipped\n  --> /tmp/tmpufaggcht.rs:12:21\n\
    \   |\n12 |             None => result = Some(string),\n   |                 \
    \    ^^^^^^\n13 |             Some(longest) => if string.len() > longest.len()\
    \ {\n14 |                 result = Some(string);\n   |                 ^^^^^^\n\
    \   = note: move occurs because value has type `String`, which does not implement\
    \ the `Copy` trait\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    if strings.is_empty() {\n        return None;\n   \
    \ }\n    let mut longest_string = strings[0].clone();\n    for s in strings {\n\
    \        if s.len() > longest_string.len() {\n            longest_string = s;\n\
    \        }\n    }\n    Some(longest_string)\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    if strings.is_empty() {\n        return None;\n   \
    \ }\n    let mut longest_string = &strings[0];\n    for current_string in &strings\
    \ {\n        if current_string.len() > longest_string.len() {\n            longest_string\
    \ = current_string;\n        }\n    }\n    Some(longest_string.to_string())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    strings.into_iter().max_by_key(|s| s.len()).cloned()\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Option<String>` is not an iterator\n   --> /tmp/tmp2f6y015a.rs:9:49\n\
    \    |\n9   |       strings.into_iter().max_by_key(|s| s.len()).cloned()\n   \
    \ |                                                   ^^^^^^ `Option<String>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<String>: Iterator`\n            which is required by `&mut\
    \ Option<String>: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    if strings.is_empty() {\n        return None;\n   \
    \ }\n    let mut max_string = &strings[0];\n    for string in &strings {\n   \
    \     if string.len() > max_string.len() {\n            max_string = string;\n\
    \        }\n    }\n    Some(max_string.to_string())\n}\n\nfn main() {\n    let\
    \ candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    if strings.is_empty() {\n        return None;\n   \
    \ }\n    let mut longest_word = strings[0].clone();\n    for string in strings\
    \ {\n        if string.len() > longest_word.len() {\n            longest_word\
    \ = string.clone();\n        }\n    }\n    Some(longest_word)\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    if strings.is_empty() {\n        return None;\n   \
    \ }\n    let mut l = &strings[0];\n    for s in &strings {\n        if s.len()\
    \ > l.len() {\n            l = s;\n        }\n    }\n    Some(l.to_string())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpj0loksln.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut longest_string = None;\n    let mut longest_string_length\
    \ = 0;\n    for string in strings {\n        if string.len() > longest_string_length\
    \ {\n            longest_string = Some(string);\n            longest_string_length\
    \ = string.len();\n        }\n    }\n    longest_string\n}\n\nfn main() {\n  \
    \  let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `string`\n  --> /tmp/tmphta4n4fu.rs:14:37\n\
    \   |\n11 |     for string in strings {\n   |         ------ move occurs because\
    \ `string` has type `String`, which does not implement the `Copy` trait\n12 |\
    \         if string.len() > longest_string_length {\n13 |             longest_string\
    \ = Some(string);\n   |                                   ------ value moved here\n\
    14 |             longest_string_length = string.len();\n   |                 \
    \                    ^^^^^^^^^^^^ value borrowed here after move\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    if strings.is_empty() {\n        return None;\n   \
    \ }\n    let mut longest = strings[0].clone();\n    for s in strings.iter() {\n\
    \        if s.len() > longest.len() {\n            longest = s.clone();\n    \
    \    }\n    }\n    Some(longest)\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    // Find the longest string in strings, return None\
    \ in case of empty list.\n    // TODO: replace this with your code\n    None\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(\"x\")`', /tmp/tmpubamtzuo.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpai0zijb6.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    strings.into_iter().max_by_key(|s| s.len()).map(|s|\
    \ s.to_string())\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmp__inaiul.rs:15:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    if strings.is_empty() {\n        return None;\n   \
    \ }\n    let mut longest_string = strings[0].clone();\n    for s in strings {\n\
    \        if s.len() > longest_string.len() {\n            longest_string = s;\n\
    \        }\n    }\n    Some(longest_string)\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    match strings.len() {\n        0 => None,\n       \
    \ _ => {\n            let mut result = strings[0].clone();\n            for s\
    \ in strings {\n                if s.len() > result.len() {\n                \
    \    result = s;\n                }\n            }\n            Some(result)\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    strings.into_iter().max_by_key(|s| s.len()).cloned()\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Option<String>` is not an iterator\n   --> /tmp/tmp4jeisjwi.rs:9:49\n\
    \    |\n9   |       strings.into_iter().max_by_key(|s| s.len()).cloned()\n   \
    \ |                                                   ^^^^^^ `Option<String>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<String>: Iterator`\n            which is required by `&mut\
    \ Option<String>: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    // TODO #1\n    None\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(\"x\")`', /tmp/tmpefmhmtej.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    match strings.is_empty() {\n        true => None,\n\
    \        false => {\n            let mut result = String::new();\n           \
    \ for x in strings {\n                if x.len() > result.len() {\n          \
    \          result = x;\n                }\n            }\n            Some(result)\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    if strings.is_empty() {\n        return None;\n   \
    \ }\n    let mut longest = &strings[0];\n    for string in &strings {\n      \
    \  if string.len() > longest.len() {\n            longest = string;\n        }\n\
    \    }\n    Some(longest.to_string())\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut longest = \"\".to_string();\n    for s in strings\
    \ {\n        if s.len() > longest.len() {\n            longest = s;\n        }\n\
    \    }\n    if longest.len() == 0 {\n        None\n    } else {\n        Some(longest)\n\
    \    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    None\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(\"x\")`', /tmp/tmpqkys9on8.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    // TODO: implement this function\n    None\n}\n\nfn\
    \ main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(\"x\")`', /tmp/tmp3jrd_qro.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut longest_string = String::new();\n    let mut\
    \ longest_length = 0;\n    for s in strings {\n        if s.len() > longest_length\
    \ {\n            longest_string = s;\n            longest_length = s.len();\n\
    \        }\n    }\n    if longest_length == 0 {\n        None\n    } else {\n\
    \        Some(longest_string)\n    }\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpjrke3mlh.rs:14:30\n\
    \   |\n11 |     for s in strings {\n   |         - move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n12 |         if s.len()\
    \ > longest_length {\n13 |             longest_string = s;\n   |             \
    \                 - value moved here\n14 |             longest_length = s.len();\n\
    \   |                              ^^^^^^^ value borrowed here after move\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    None\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(\"x\")`', /tmp/tmpeokme0ia.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut longest_string = None;\n    for s in strings\
    \ {\n        match longest_string {\n            None => longest_string = Some(s),\n\
    \            Some(v) => {\n                if v.len() < s.len() {\n          \
    \          longest_string = Some(s);\n                }\n            }\n     \
    \   }\n    }\n    longest_string\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value\n  --> /tmp/tmpogjk84b9.rs:13:18\n   |\n\
    13 |             Some(v) => {\n   |                  ^ value moved here, in previous\
    \ iteration of loop\n   |\nnote: these 2 reinitializations might get skipped\n\
    \  --> /tmp/tmpogjk84b9.rs:12:21\n   |\n12 |             None => longest_string\
    \ = Some(s),\n   |                     ^^^^^^^^^^^^^^\n...\n15 |             \
    \        longest_string = Some(s);\n   |                     ^^^^^^^^^^^^^^\n\
    \   = note: move occurs because value has type `String`, which does not implement\
    \ the `Copy` trait\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut result = String::new();\n    for s in strings\
    \ {\n        if s.len() > result.len() {\n            result = s;\n        }\n\
    \    }\n    if result.len() == 0 {\n        None\n    } else {\n        Some(result)\n\
    \    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    // TODO: Implement me.\n    return None;\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(\"x\")`', /tmp/tmpqns76p10.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut result = None;\n    let mut size: usize = 0;\n\
    \    for s in strings {\n        if s.len() > size {\n            result = Some(s);\n\
    \            size = s.len();\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpb3nj5dzz.rs:14:20\n\
    \   |\n11 |     for s in strings {\n   |         - move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n12 |         if s.len()\
    \ > size {\n13 |             result = Some(s);\n   |                         \
    \  - value moved here\n14 |             size = s.len();\n   |                \
    \    ^^^^^^^ value borrowed here after move\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    match strings.len() {\n        0 => None,\n       \
    \ _ => {\n            let mut long = strings[0].clone();\n            for s in\
    \ strings {\n                if s.len() > long.len() {\n                    long\
    \ = s;\n                }\n            }\n            Some(long)\n        }\n\
    \    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut longest_len = 0;\n    let mut result = None;\n\
    \    for s in strings {\n        if s.len() > longest_len {\n            longest_len\
    \ = s.len();\n            result = Some(s);\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    // here, strings has type Vec<String>, i.e. vector\
    \ of strings.\n    if strings.is_empty() {\n        None\n    } else {\n     \
    \   // If a vector is not empty, calling get(0) will return the first item in\
    \ the vector.\n        let mut tmp = strings.get(0).unwrap();\n        // strings.iter()\
    \ returns an iterator over the vector.\n        for string in strings.iter() {\n\
    \            if string.len() > tmp.len() {\n                tmp = string;\n  \
    \          }\n        }\n        Some(tmp.to_string())\n    }\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    strings.into_iter().fold(None, |acc, x| {\n       \
    \ match acc {\n            None => Some(x),\n            Some(longest) => if x.len()\
    \ > longest.len() {\n                Some(x)\n            } else {\n         \
    \       Some(longest)\n            }\n        }\n    })\n}\n\nfn main() {\n  \
    \  let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut longest_string = None;\n    for string in strings\
    \ {\n        if longest_string.as_ref().map_or(true, |v| v.len() < string.len())\
    \ {\n            longest_string = Some(string);\n        }\n    }\n    longest_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `&T`\n  --> /tmp/tmp00ioiyqr.rs:11:50\n\
    \   |\n11 |         if longest_string.as_ref().map_or(true, |v| v.len() < string.len())\
    \ {\n   |                                                  ^ consider giving this\
    \ closure parameter the explicit type `&T`, where the type parameter `T` is specified\n\
    \   |\n   = note: type must be known at this point\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    // FIXME: Implement\n    None\n}\n\nfn main() {\n \
    \   let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(\"x\")`', /tmp/tmp8tyhi0dw.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut longest = None;\n    for s in strings {\n \
    \       match longest {\n            None => longest = Some(s),\n            Some(s_longest)\
    \ => {\n                if s.len() > s_longest.len() {\n                    longest\
    \ = Some(s);\n                }\n            }\n        }\n    }\n    longest\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value\n  --> /tmp/tmp4whi_gqq.rs:13:18\n   |\n\
    13 |             Some(s_longest) => {\n   |                  ^^^^^^^^^ value moved\
    \ here, in previous iteration of loop\n   |\nnote: these 2 reinitializations might\
    \ get skipped\n  --> /tmp/tmp4whi_gqq.rs:12:21\n   |\n12 |             None =>\
    \ longest = Some(s),\n   |                     ^^^^^^^\n...\n15 |            \
    \         longest = Some(s);\n   |                     ^^^^^^^\n   = note: move\
    \ occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut result = None;\n    for string in strings {\n\
    \        match result {\n            None => result = Some(string),\n        \
    \    Some(ref r) => if string.len() > r.len() {\n                result = Some(string);\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    if strings.is_empty() {\n        return None;\n   \
    \ }\n    let mut result = &strings[0];\n    for string in &strings {\n       \
    \ if string.len() > result.len() {\n            result = string;\n        }\n\
    \    }\n    Some(result.to_string())\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpibaziw4f.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut long = None;\n    for s in strings {\n    \
    \    match long {\n            None => long = Some(s),\n            Some(ref l)\
    \ => if s.len() > l.len() { long = Some(s) },\n        }\n    }\n    long\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut longest_string = None;\n    for string in strings\
    \ {\n        match longest_string {\n            None => longest_string = Some(string),\n\
    \            Some(ref string_ref) => {\n                if string.len() > string_ref.len()\
    \ {\n                    longest_string = Some(string);\n                }\n \
    \           }\n        }\n    }\n    longest_string\n}\n\nfn main() {\n    let\
    \ candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    None\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(\"x\")`', /tmp/tmpam0c_no_.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    match strings.len() {\n        0 => None,\n       \
    \ _ => {\n            let mut strings = strings;\n            strings.sort_by(|a,\
    \ b| a.len().cmp(&b.len()));\n            let s = strings.pop().unwrap();\n  \
    \          Some(s)\n        }\n    }\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmph3ae9cc_.rs:23:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut longest = None;\n    for s in strings {\n \
    \       match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ l) => if s.len() > l.len() {\n                longest = Some(s);\n         \
    \   },\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    strings.into_iter().max_by_key(|s| s.len()).cloned()\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Option<String>` is not an iterator\n   --> /tmp/tmp69fp5xp9.rs:9:49\n\
    \    |\n9   |       strings.into_iter().max_by_key(|s| s.len()).cloned()\n   \
    \ |                                                   ^^^^^^ `Option<String>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<String>: Iterator`\n            which is required by `&mut\
    \ Option<String>: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    strings.into_iter().max_by_key(|s| s.len()).cloned()\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Option<String>` is not an iterator\n   --> /tmp/tmpp2679lk9.rs:9:49\n\
    \    |\n9   |       strings.into_iter().max_by_key(|s| s.len()).cloned()\n   \
    \ |                                                   ^^^^^^ `Option<String>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<String>: Iterator`\n            which is required by `&mut\
    \ Option<String>: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    if strings.is_empty() {\n        return None;\n   \
    \ }\n    let mut longest_string = &strings[0];\n    for string in &strings {\n\
    \        if string.len() > longest_string.len() {\n            longest_string\
    \ = string;\n        }\n    }\n    Some(longest_string.to_string())\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    // todo!()\n    match strings.len() {\n        0 =>\
    \ None,\n        _ => {\n            let mut long = strings[0].clone();\n    \
    \        for i in strings {\n                if i.len() > long.len() {\n     \
    \               long = i.clone();\n                }\n            }\n        \
    \    Some(long)\n        }\n    }\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpvckm6xvu.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    if strings.is_empty() {\n        return None;\n   \
    \ }\n    let mut max = &strings[0];\n    for s in &strings {\n        if s.len()\
    \ > max.len() {\n            max = s;\n        }\n    }\n    Some(max.to_string())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut longest = None;\n    for s in strings {\n \
    \       match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ mut l) => {\n                if s.len() > l.len() {\n                    *l\
    \ = s;\n                }\n            }\n        }\n    }\n    longest\n}\n\n\
    fn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    strings.into_iter().max_by_key(|x| x.len()).cloned()\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Option<String>` is not an iterator\n   --> /tmp/tmp9tajlerr.rs:9:49\n\
    \    |\n9   |       strings.into_iter().max_by_key(|x| x.len()).cloned()\n   \
    \ |                                                   ^^^^^^ `Option<String>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<String>: Iterator`\n            which is required by `&mut\
    \ Option<String>: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    if strings.is_empty() {\n        return None;\n   \
    \ }\n    let mut length = 0;\n    let mut index = 0;\n    for (i, s) in strings.iter().enumerate()\
    \ {\n        if s.len() > length {\n            length = s.len();\n          \
    \  index = i;\n        }\n    }\n    Some(strings[index].clone())\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut longest = None;\n    for string in strings\
    \ {\n        longest = match longest {\n            None => Some(string),\n  \
    \          Some(current) => if string.len() > current.len() {\n              \
    \  Some(string)\n            } else {\n                Some(current)\n       \
    \     }\n        }\n    }\n    longest\n}\n\nfn main() {\n    let candidate =\
    \ longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    if strings.is_empty() {\n        return None;\n   \
    \ }\n    strings.iter().fold(None, |acc, x| {\n        match acc {\n         \
    \   None => Some(x.clone()),\n            Some(y) => Some(if x.len() > y.len()\
    \ { x.clone() } else { y })\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut longest_string: Option<String> = None;\n  \
    \  for s in strings {\n        if longest_string.is_none() || s.len() > longest_string.unwrap().len()\
    \ {\n            longest_string = Some(s);\n        }\n    }\n    longest_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `longest_string`\n   --> /tmp/tmp3lwxv6pz.rs:11:12\n\
    \    |\n9   |     let mut longest_string: Option<String> = None;\n    |      \
    \   ------------------ move occurs because `longest_string` has type `Option<String>`,\
    \ which does not implement the `Copy` trait\n10  |     for s in strings {\n11\
    \  |         if longest_string.is_none() || s.len() > longest_string.unwrap().len()\
    \ {\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^                             --------\
    \ `longest_string` moved due to this method call, in previous iteration of loop\n\
    \    |            |\n    |            value borrowed here after move\n12  |  \
    \           longest_string = Some(s);\n    |             -------------- this reinitialization\
    \ might get skipped\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `longest_string`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmphb8gk2_w.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut length = 0;\n    let mut longest = None;\n\
    \    for s in strings {\n        if s.len() > length {\n            length = s.len();\n\
    \            longest = Some(s);\n        }\n    }\n    longest\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    strings.into_iter().fold(None, |prev, next| match prev\
    \ {\n        None => Some(next),\n        Some(s) => Some(if s.len() > next.len()\
    \ { s } else { next }),\n    })\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpa30x5qwc.rs:18:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    match strings.len() {\n        0 => None,\n       \
    \ _ => {\n            let mut max = &strings[0];\n            for i in 1..strings.len()\
    \ {\n                if strings[i].len() > max.len() {\n                    max\
    \ = &strings[i];\n                }\n            }\n            Some(max.to_string())\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    strings.into_iter().max_by_key(|s| s.len()).or(None)\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmprr49m5pc.rs:15:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    if strings.is_empty() {\n        return None;\n   \
    \ }\n    strings.iter().fold(None, |acc, cur| {\n        match acc {\n       \
    \     None => Some(cur.clone()),\n            Some(acc) => {\n               \
    \ if acc.len() < cur.len() {\n                    Some(cur.clone())\n        \
    \        } else {\n                    Some(acc)\n                }\n        \
    \    }\n        }\n    })\n}\n\nfn main() {\n    let candidate = longest;\n  \
    \  assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    match strings.len() {\n        0 => None,\n       \
    \ _ => {\n            let mut iter = strings.iter();\n            let mut longest_string\
    \ = iter.next().unwrap();\n            for string in iter {\n                if\
    \ string.len() > longest_string.len() {\n                    longest_string =\
    \ string;\n                }\n            }\n            Some(longest_string.to_string())\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    strings.into_iter().max_by_key(|s| s.len()).clone()\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpb_zi0v_o.rs:15:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    match strings.len() {\n        0 => None,\n       \
    \ _ => Some(strings.iter().max_by_key(|s| s.len()).unwrap().to_string()),\n  \
    \  }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpm1wbxbfs.rs:18:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut longest_str = None;\n    let mut longest_len\
    \ = 0;\n    for s in strings {\n        if s.len() > longest_len {\n         \
    \   longest_str = Some(s);\n            longest_len = s.len();\n        }\n  \
    \  }\n    longest_str\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpx99vl10q.rs:14:27\n\
    \   |\n11 |     for s in strings {\n   |         - move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n12 |         if s.len()\
    \ > longest_len {\n13 |             longest_str = Some(s);\n   |             \
    \                   - value moved here\n14 |             longest_len = s.len();\n\
    \   |                           ^^^^^^^ value borrowed here after move\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    if strings.is_empty() {\n        return None;\n   \
    \ }\n    let mut max = &strings[0];\n    for s in &strings {\n        if s.len()\
    \ > max.len() {\n            max = s;\n        }\n    }\n    Some(max.to_string())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    if strings.is_empty() {\n        return None;\n   \
    \ }\n    let mut result = strings[0].clone();\n    for string in strings {\n \
    \       if string.len() > result.len() {\n            result = string;\n     \
    \   }\n    }\n    Some(result)\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut max_len = 0;\n    let mut max_string = None;\n\
    \    for s in strings {\n        if s.len() > max_len {\n            max_len =\
    \ s.len();\n            max_string = Some(s);\n        }\n    }\n    max_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut res = None;\n    for s in strings {\n     \
    \   match res {\n            None => res = Some(s),\n            Some(ref str)\
    \ => {\n                if s.len() > str.len() {\n                    res = Some(s);\n\
    \                }\n            }\n        }\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpx5efzfj2.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpp5ghvl23.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut biggest_size = 0;\n    let mut longest_string\
    \ = String::new();\n    for s in strings {\n        if s.len() > biggest_size\
    \ {\n            biggest_size = s.len();\n            longest_string = s;\n  \
    \      }\n    }\n    if biggest_size == 0 {\n        None\n    } else {\n    \
    \    Some(longest_string)\n    }\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    // You need to implement this\n    let mut longest\
    \ = None;\n    for string in strings {\n        if longest.is_none() || string.len()\
    \ > longest.as_ref().unwrap().len() {\n            longest = Some(string);\n \
    \       }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `Option<T>`\n  --> /tmp/tmpbvq_u6ub.rs:12:56\n\
    \   |\n10 |     let mut longest = None;\n   |         ----------- consider giving\
    \ `longest` the explicit type `Option<T>`, where the type parameter `T` is specified\n\
    11 |     for string in strings {\n12 |         if longest.is_none() || string.len()\
    \ > longest.as_ref().unwrap().len() {\n   |                                  \
    \                      ^^^^^^ cannot infer type for type parameter `T`\n   |\n\
    \   = note: type must be known at this point\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut max_length = 0;\n    let mut longest = None;\n\
    \    for string in strings {\n        if string.len() > max_length {\n       \
    \     max_length = string.len();\n            longest = Some(string);\n      \
    \  }\n    }\n    longest\n}\n\nfn main() {\n    let candidate = longest;\n   \
    \ assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut longest = None;\n    for string in strings\
    \ {\n        longest = match longest {\n            None => Some(string),\n  \
    \          Some(l) => {\n                if l.len() > string.len() {\n       \
    \             Some(l)\n                } else {\n                    Some(string)\n\
    \                }\n            }\n        }\n    }\n    longest\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmp1pcyezl1.rs:28:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    // TODO: Replace the implementation with a correct\
    \ one.\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpuf2kx4wf.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut longest_str = None;\n    let mut max_len =\
    \ 0;\n    for s in strings {\n        if s.len() > max_len {\n            max_len\
    \ = s.len();\n            longest_str = Some(s);\n        }\n    }\n    longest_str\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    if strings.is_empty() {\n        return None;\n   \
    \ }\n    let mut max_len = 0;\n    let mut max_str = \"\".to_string();\n    for\
    \ s in strings {\n        if s.len() > max_len {\n            max_len = s.len();\n\
    \            max_str = s;\n        }\n    }\n    Some(max_str)\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    strings.into_iter().max().map(|x| x.to_string())\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpn8gh_o7y.rs:15:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut longest = None;\n    for s in strings {\n \
    \       match longest {\n            None => longest = Some(s),\n            Some(ref\
    \ ls) => {\n                if s.len() > ls.len() {\n                    longest\
    \ = Some(s);\n                }\n            }\n        }\n    }\n    longest\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    strings.into_iter().fold(None, |longest, s| {\n   \
    \     if longest.is_none() || longest.as_ref().unwrap().len() < s.len() {\n  \
    \          Some(s)\n        } else {\n            longest\n        }\n    })\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut longest_string: Option<String> = None;\n  \
    \  for s in strings {\n        if longest_string.is_none() || longest_string.as_ref().unwrap().len()\
    \ < s.len() {\n            longest_string = Some(s);\n        }\n    }\n    longest_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut longest_string = None;\n    let mut max_len\
    \ = 0;\n    for string in strings {\n        if string.len() > max_len {\n   \
    \         max_len = string.len();\n            longest_string = Some(string);\n\
    \        }\n    }\n    longest_string\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    // TODO\n    unimplemented!()\n}\n\nfn main() {\n \
    \   let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp3pbbnkm_.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut max_length = 0;\n    let mut max_string = String::new();\n\
    \    for string in strings {\n        if string.len() > max_length {\n       \
    \     max_length = string.len();\n            max_string = string;\n        }\n\
    \    }\n    if max_length == 0 {\n        None\n    } else {\n        Some(max_string)\n\
    \    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpdecg6j6f.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    strings.into_iter().fold(None, |acc, x| {\n       \
    \ match acc {\n            None => Some(x),\n            Some(y) => if x.len()\
    \ >= y.len() { Some(x) } else { Some(y) },\n        }\n    })\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmp9k06bhnt.rs:20:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut max_length = 0;\n    let mut output = String::new();\n\
    \    for s in strings {\n        if s.len() > max_length {\n            max_length\
    \ = s.len();\n            output = s;\n        }\n    }\n    match output.len()\
    \ {\n        0 => None,\n        _ => Some(output),\n    }\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    strings.into_iter().max().cloned()\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Option<String>` is not an iterator\n   --> /tmp/tmp4qiwnywb.rs:9:31\n\
    \    |\n9   |       strings.into_iter().max().cloned()\n    |                \
    \                 ^^^^^^ `Option<String>` is not an iterator\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `Option<String>:\
    \ Iterator`\n            which is required by `&mut Option<String>: Iterator`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    // TODO\n    if strings.len() == 0 {\n        return\
    \ None;\n    }\n    let mut longest = strings[0].clone();\n    for i in 1..strings.len()\
    \ {\n        if strings[i].len() > longest.len() {\n            longest = strings[i].clone();\n\
    \        }\n    }\n    Some(longest)\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpy2u27_xt.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    if strings.is_empty() {\n        return None;\n   \
    \ }\n    let mut longest = strings[0].clone();\n    for (i, _) in strings.iter().enumerate()\
    \ {\n        if longest.len() < strings[i].len() {\n            longest = strings[i].clone();\n\
    \        }\n    }\n    Some(longest)\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpgd07cac1.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp0ygp808f.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpyi09w6sy.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    // Imperative solution\n    //\n    // let mut max\
    \ = None;\n    // for i in strings {\n        // if max.is_none() || i.len() >\
    \ max.unwrap().len() {\n            // max = Some(i);\n        // }\n    // }\n\
    \    // max\n\n    // Functional solution\n    strings.into_iter().fold(None,\
    \ |max, i| {\n        match max {\n            None => Some(i),\n            Some(m)\
    \ => Some(if i.len() > m.len() { i } else { m })\n        }\n    })\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    // TODO: Shorten the code\n    if strings.len() ==\
    \ 0 {\n        return None;\n    }\n    let mut max = strings[0].clone();\n  \
    \  for i in strings {\n        if i.len() > max.len() {\n            max = i;\n\
    \        }\n    }\n    Some(max)\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    if strings.is_empty() {\n        return None;\n   \
    \ }\n    let mut max_len = 0;\n    let mut max_str = &strings[0];\n    for s in\
    \ &strings {\n        if s.len() > max_len {\n            max_len = s.len();\n\
    \            max_str = s;\n        }\n    }\n    Some(max_str.to_string())\n}\n\
    \nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    // YOUR CODE HERE\n    let mut longest = String::new();\n\
    \    for string in strings {\n        if string.len() > longest.len() {\n    \
    \        longest = string;\n        }\n    }\n    if longest.len() == 0 {\n  \
    \      None\n    } else {\n        Some(longest)\n    }\n}\n\nfn main() {\n  \
    \  let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpnnj_0ied.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpdmxykkz7.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut max_len = 0;\n    let mut max_str = String::new();\n\
    \    for s in strings {\n        if s.len() > max_len {\n            max_len =\
    \ s.len();\n            max_str = s;\n        }\n    }\n    if max_len > 0 {\n\
    \        Some(max_str)\n    } else {\n        None\n    }\n}\n\nfn main() {\n\
    \    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut max_length = 0;\n    let mut max_string = None;\n\
    \    for s in strings {\n        if s.len() > max_length {\n            max_length\
    \ = s.len();\n            max_string = Some(s);\n        }\n    }\n    max_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut max = String::new();\n    for string in strings\
    \ {\n        if string.len() > max.len() {\n            max = string;\n      \
    \  }\n    }\n    if !max.is_empty() {\n        Some(max)\n    } else {\n     \
    \   None\n    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    strings.into_iter().max_by_key(|s| s.len()).cloned()\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Option<String>` is not an iterator\n   --> /tmp/tmpxa2_eyrx.rs:9:49\n\
    \    |\n9   |       strings.into_iter().max_by_key(|s| s.len()).cloned()\n   \
    \ |                                                   ^^^^^^ `Option<String>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<String>: Iterator`\n            which is required by `&mut\
    \ Option<String>: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    match strings.len() {\n        0 => None,\n       \
    \ 1 => Some(strings[0].clone()),\n        _ => {\n            let first = strings[0].clone();\n\
    \            let mut iter = strings.iter();\n            iter.next();\n      \
    \      match iter.max_by_key(|s| s.len()) {\n                Some(s) => if s.len()\
    \ > first.len() { Some(s.clone()) } else { Some(first) },\n                None\
    \ => Some(first),\n            }\n        }\n    }\n}\n\nfn main() {\n    let\
    \ candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"), String::from(\"\
    z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"kkkk\")`,\n right: `Some(\"zzzz\")`', /tmp/tmprmm5jdb0.rs:28:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    if strings.is_empty() {\n        return None;\n   \
    \ }\n    let mut tmp = &strings[0];\n    for string in &strings {\n        if\
    \ string.len() > tmp.len() {\n            tmp = string;\n        }\n    }\n  \
    \  Some(tmp.to_string())\n}\n\nfn main() {\n    let candidate = longest;\n   \
    \ assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    if strings.is_empty() {\n        return None;\n   \
    \ }\n    let mut longest = strings[0].clone();\n    for string in strings {\n\
    \        if string.len() > longest.len() {\n            longest = string;\n  \
    \      }\n    }\n    Some(longest)\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    strings.into_iter().max().cloned()\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Option<String>` is not an iterator\n   --> /tmp/tmpbmfg98vo.rs:9:31\n\
    \    |\n9   |       strings.into_iter().max().cloned()\n    |                \
    \                 ^^^^^^ `Option<String>` is not an iterator\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `Option<String>:\
    \ Iterator`\n            which is required by `&mut Option<String>: Iterator`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut longest = String::new();\n    for string in\
    \ strings {\n        if string.len() > longest.len() {\n            longest =\
    \ string;\n        }\n    }\n    if longest.is_empty() {\n        None\n    }\
    \ else {\n        Some(longest)\n    }\n}\n\nfn main() {\n    let candidate =\
    \ longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpc_pb2o19.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    // TODO\n    match strings.len() {\n        0 => None,\n\
    \        _ => {\n            let mut x = strings[0].clone();\n            for\
    \ j in strings {\n                if j.len() > x.len() {\n                   \
    \ x = j.clone();\n                }\n            }\n            Some(x)\n    \
    \    }\n    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp5kqclyf_.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    strings.into_iter().max_by_key(|string| string.len()).into()\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `Some(\"z\")`,\n right: `Some(\"x\")`', /tmp/tmpwg2rmlud.rs:15:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpkdmw2mq3.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    strings.into_iter().max_by_key(|s| s.len()).cloned()\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `Option<String>` is not an iterator\n   --> /tmp/tmpchf_clh4.rs:9:49\n\
    \    |\n9   |       strings.into_iter().max_by_key(|s| s.len()).cloned()\n   \
    \ |                                                   ^^^^^^ `Option<String>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<String>: Iterator`\n            which is required by `&mut\
    \ Option<String>: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpq07cf_ho.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpkz5_thtq.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp0yf1tico.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut result = None;\n    for s in strings {\n  \
    \      match result {\n            None => result = Some(s),\n            Some(longest)\
    \ => {\n                if s.len() > longest.len() {\n                    result\
    \ = Some(s);\n                }\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value\n  --> /tmp/tmp7as5f9xw.rs:13:18\n   |\n\
    13 |             Some(longest) => {\n   |                  ^^^^^^^ value moved\
    \ here, in previous iteration of loop\n   |\nnote: these 2 reinitializations might\
    \ get skipped\n  --> /tmp/tmp7as5f9xw.rs:12:21\n   |\n12 |             None =>\
    \ result = Some(s),\n   |                     ^^^^^^\n...\n15 |              \
    \       result = Some(s);\n   |                     ^^^^^^\n   = note: move occurs\
    \ because value has type `String`, which does not implement the `Copy` trait\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpmxddk_vh.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    // TODO find the longest string. If there are multiple\
    \ strings with the same\n    // length, return the first one. If the vector is\
    \ empty, return None.\n    None\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `None`,\n right: `Some(\"x\")`', /tmp/tmpfvztwjst.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut longest_so_far = String::new();\n    for string\
    \ in strings {\n        if string.len() > longest_so_far.len() {\n           \
    \ longest_so_far = string;\n        }\n    }\n    match longest_so_far.len() {\n\
    \        0 => None,\n        _ => Some(longest_so_far),\n    }\n}\n\nfn main()\
    \ {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    if strings.is_empty() {\n        return None;\n   \
    \ }\n    let mut longest = strings[0].clone();\n    for s in strings {\n     \
    \   if s.len() > longest.len() {\n            longest = s;\n        }\n    }\n\
    \    Some(longest)\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut longest_string: Option<String> = None;\n  \
    \  for s in strings {\n        if longest_string.is_none() || longest_string.as_ref().unwrap().len()\
    \ < s.len() {\n            longest_string = Some(s);\n        }\n    }\n    longest_string\n\
    }\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    strings.into_iter().fold(None, |longest, s| {\n   \
    \     match longest {\n            None => Some(s),\n            Some(l) => {\n\
    \                if s.len() > l.len() {\n                    Some(s)\n       \
    \         } else {\n                    Some(l)\n                }\n         \
    \   }\n        }\n    })\n}\n\nfn main() {\n    let candidate = longest;\n   \
    \ assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut longest = \"\".to_string();\n    for s in strings\
    \ {\n        if s.len() > longest.len() {\n            longest = s;\n        }\n\
    \    }\n    if longest == \"\" {\n        None\n    } else {\n        Some(longest)\n\
    \    }\n}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
    \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
    ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
    kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut longest_string: Option<String> = None;\n  \
    \  for string in strings {\n        if longest_string.is_none() || string.len()\
    \ > longest_string.unwrap().len() {\n            longest_string = Some(string);\n\
    \        }\n    }\n    longest_string\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `longest_string`\n   --> /tmp/tmpkvfj7g1m.rs:11:12\n\
    \    |\n9   |     let mut longest_string: Option<String> = None;\n    |      \
    \   ------------------ move occurs because `longest_string` has type `Option<String>`,\
    \ which does not implement the `Copy` trait\n10  |     for string in strings {\n\
    11  |         if longest_string.is_none() || string.len() > longest_string.unwrap().len()\
    \ {\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^ value borrowed here after move\
    \   -------- `longest_string` moved due to this method call, in previous iteration\
    \ of loop\n12  |             longest_string = Some(string);\n    |           \
    \  -------------- this reinitialization might get skipped\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `longest_string`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    let mut result = None;\n    for s in strings {\n  \
    \      match result {\n            None => result = Some(s),\n            Some(ref\
    \ r) => if s.len() > r.len() {\n                result = Some(s);\n          \
    \  }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = longest;\n\
    \    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpikdtoyk0.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp9n86tfbu.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpfid5lio0.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Out of list of strings, return the longest one. Return the first one\
    \ in case of multiple\n/// strings of the same length. Return None in case the\
    \ input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfn longest(strings: Vec<String>)\
    \ -> Option<String> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = longest;\n    assert_eq!(candidate(Vec::<String>::new()), None);\n    assert_eq!(candidate(vec![String::from(\"\
    x\"), String::from(\"y\"), String::from(\"z\")]), Some(String::from(\"x\")));\n\
    \    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"yyy\"), String::from(\"\
    zzzz\"), String::from(\"www\"), String::from(\"kkkk\"), String::from(\"abc\")]),\
    \ Some(String::from(\"zzzz\")));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpkwbb0gzk.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
