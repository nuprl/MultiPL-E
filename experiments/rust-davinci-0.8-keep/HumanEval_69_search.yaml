name: HumanEval_69_search
language: rust
prompt: "/// You are given a non-empty list of positive integers. Return the greatest\
  \ integer that is greater than \n/// zero, and has a frequency greater than or equal\
  \ to the value of the integer itself. \n/// The frequency of an integer is the number\
  \ of times it appears in the list.\n/// If no such a value exist, return -1.\n///\
  \ Examples:\n/// search([4, 1, 2, 2, 3, 1]) == 2\n/// search([1, 2, 2, 3, 3, 3,\
  \ 4, 4, 4]) == 3\n/// search([5, 5, 4, 4, 4]) == -1\nfn search(lst: Vec<isize>)\
  \ -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![5,\
  \ 5, 5, 5, 1]), 1);\n    assert_eq!(candidate(vec![4, 1, 4, 1, 4, 4]), 4);\n   \
  \ assert_eq!(candidate(vec![3, 3]), -1);\n    assert_eq!(candidate(vec![8, 8, 8,\
  \ 8, 8, 8, 8, 8]), 8);\n    assert_eq!(candidate(vec![2, 3, 3, 2, 2]), 2);\n   \
  \ assert_eq!(candidate(vec![2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1,\
  \ 7, 4, 10, 8, 1]), 1);\n    assert_eq!(candidate(vec![3, 2, 8, 2]), 2);\n    assert_eq!(candidate(vec![6,\
  \ 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]), 1);\n    assert_eq!(candidate(vec![8, 8, 3,\
  \ 6, 5, 6, 4]), -1);\n    assert_eq!(candidate(vec![6, 9, 6, 7, 1, 4, 7, 1, 8, 8,\
  \ 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]), 1);\n    assert_eq!(candidate(vec![1,\
  \ 9, 10, 1, 3]), 1);\n    assert_eq!(candidate(vec![6, 9, 7, 5, 8, 7, 5, 3, 7, 5,\
  \ 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]), 5);\n    assert_eq!(candidate(vec![1]),\
  \ 1);\n    assert_eq!(candidate(vec![8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6,\
  \ 10, 4, 2, 1, 10, 2, 1, 1, 5]), 4);\n    assert_eq!(candidate(vec![2, 10, 4, 8,\
  \ 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]), 2);\n    assert_eq!(candidate(vec![1,\
  \ 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]), 1);\n    assert_eq!(candidate(vec![9, 2,\
  \ 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8,\
  \ 10, 9, 4]), 4);\n    assert_eq!(candidate(vec![2, 6, 4, 2, 8, 7, 5, 6, 4, 10,\
  \ 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]), 4);\n    assert_eq!(candidate(vec![9,\
  \ 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]), 2);\n    assert_eq!(candidate(vec![5,\
  \ 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]), -1);\n    assert_eq!(candidate(vec![10]),\
  \ -1);\n    assert_eq!(candidate(vec![9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]),\
  \ 2);\n    assert_eq!(candidate(vec![5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]), 1);\n\
  \    assert_eq!(candidate(vec![7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5,\
  \ 6, 7, 6, 7, 7, 6]), 1);\n    assert_eq!(candidate(vec![3, 10, 10, 9, 2]), -1);\n\
  }\n"
completions: ['    unimplemented!()', "    let max = *lst.iter().max().unwrap();\n\
    \    let mut v = vec![0; max as usize + 1];\n    for n in lst {\n        v[n as\
    \ usize] += 1;\n    }\n    for n in lst {\n        if v[n as usize] >= n {\n \
    \           return n;\n        }\n    }\n    -1", "    if lst.len() == 0 {\n \
    \       return -1;\n    }\n    let mut max = lst[0];\n    let mut max_count =\
    \ 1;\n    let mut current = lst[0];\n    let mut current_count = 1;\n    for i\
    \ in 1..lst.len() {\n        if lst[i] == current {\n            current_count\
    \ += 1;\n        } else {\n            if current_count > max_count {\n      \
    \          max = current;\n                max_count = current_count;\n      \
    \      }\n            current = lst[i];\n            current_count = 1;\n    \
    \    }\n    }\n    if current_count > max_count {\n        max = current;\n  \
    \      max_count = current_count;\n    }\n    if max_count < max {\n        return\
    \ -1;\n    }\n    return max;", "    let mut m = HashMap::new();\n    for i in\
    \ lst {\n        *m.entry(i).or_insert(0) += 1;\n    }\n    let mut max = -1;\n\
    \    for (k, v) in m {\n        if k <= v && k > max {\n            max = k;\n\
    \        }\n    }\n    max", "    // Brute force solution\n    // let mut result\
    \ = -1;\n    // for i in 1..lst.len() + 1 {\n    //     if lst.iter().filter(|x|\
    \ x == &&i).count() as isize >= i {\n    //         result = i;\n    //     }\n\
    \    // }\n    // result\n\n    // Solution with hashmap\n    let mut map = HashMap::new();\n\
    \    for i in lst {\n        *map.entry(i).or_insert(0) += 1;\n    }\n    let\
    \ mut result = -1;\n    for (key, value) in map {\n        if key >= value &&\
    \ key > result {\n            result = key;\n        }\n    }\n    result", " \
    \   let mut counts = HashMap::new();\n    for n in lst {\n        let count =\
    \ counts.entry(n).or_insert(0);\n        *count += 1;\n    }\n    let mut sorted_counts:\
    \ Vec<_> = counts.iter().collect();\n    sorted_counts.sort_by(|a, b| b.1.cmp(a.1));\n\
    \    let mut result = -1;\n    for &(n, &c) in sorted_counts.iter() {\n      \
    \  if *n <= c {\n            result = *n;\n            break;\n        }\n   \
    \ }\n    result", "    let mut max = lst[0];\n    let mut count = 1;\n    for\
    \ (i, &n) in lst.iter().enumerate() {\n        let mut tmp = n;\n        let mut\
    \ tmp_count = 1;\n        if i > 0 {\n            for j in i..lst.len() {\n  \
    \              if n == lst[j] {\n                    tmp_count += 1;\n       \
    \         }\n            }\n            if (tmp_count >= tmp) && (tmp_count >=\
    \ count) {\n                max = tmp;\n                count = tmp_count;\n \
    \           }\n        }\n    }\n    if count >= max {\n        max\n    } else\
    \ {\n        -1\n    }", "    // works on list\n    let mut counter = HashMap::new();\n\
    \    for n in lst {\n        *counter.entry(n).or_insert(0) += 1;\n    }\n   \
    \ for n in lst {\n        if counter.get(&n).unwrap() >= &n {\n            return\
    \ n;\n        }\n    }\n    -1", "    let mut map = HashMap::new();\n    for n\
    \ in lst {\n        let count = map.entry(n).or_insert(0);\n        *count +=\
    \ 1;\n    }\n    let mut max = -1;\n    for (n, count) in map {\n        if n\
    \ > max && count >= n {\n            max = n;\n        }\n    }\n    max", " \
    \   let mut vec: Vec<(isize, isize)> = Vec::new();\n    for item in lst {\n  \
    \      let mut found = false;\n        for iter in vec.iter_mut() {\n        \
    \    if iter.0 == item {\n                iter.1 += 1;\n                found\
    \ = true;\n                break;\n            }\n        }\n        if !found\
    \ {\n            vec.push((item, 1));\n        }\n    }\n    vec.sort_by(|a, b|\
    \ b.0.cmp(&a.0));\n    for item in vec {\n        if item.0 <= item.1 {\n    \
    \        return item.0;\n        }\n    }\n    -1", "    lst.iter().fold(HashMap::new(),\
    \ |mut acc, &cur| {\n        *acc.entry(cur).or_insert(0) += 1;\n        acc\n\
    \    }).into_iter().filter(|&(k, v)| k <= v).map(|(k, _)| k).max().unwrap_or(-1)",
  "    let mut result = -1;\n    let mut frequency = 0;\n    let mut counts = HashMap::new();\n\
    \    for n in lst {\n        let counter = counts.entry(n).or_insert(0);\n   \
    \     *counter += 1;\n        if *counter >= n && n > frequency {\n          \
    \  frequency = n;\n            result = n;\n        }\n    }\n    result", " \
    \   let mut lst = lst;\n    lst.sort();\n    for i in 0..lst.len() - 1 {\n   \
    \     if lst[i] == lst[i + 1] {\n            let elem = lst[i];\n            let\
    \ freq = lst.iter().filter(|&x| *x == elem).count();\n            if freq >= elem\
    \ as usize {\n                return elem;\n            }\n        }\n    }\n\
    \    -1", "    // create a hashmap from integer to frequency\n    let mut map\
    \ = HashMap::new();\n    for &item in lst.iter() {\n        let count = map.entry(item).or_insert(0);\n\
    \        *count += 1;\n    }\n    // collect into a vec\n    let mut vec = Vec::new();\n\
    \    for (&item, &count) in map.iter() {\n        vec.push((item, count));\n \
    \   }\n    // get the max value\n    let max = vec.iter().map(|&(item, count)|\
    \ {\n        if item <= count {\n            item\n        } else {\n        \
    \    0\n        }\n    }).max().unwrap_or(0);\n    if max == 0 {\n        -1\n\
    \    } else {\n        max\n    }", "    let mut counts = HashMap::new();\n  \
    \  for i in lst {\n        let v = counts.entry(i).or_insert(0);\n        *v +=\
    \ 1;\n    }\n    for i in counts.keys() {\n        if counts[i] >= *i {\n    \
    \        return *i;\n        }\n    }\n    -1", "    let mut count = HashMap::new();\n\
    \    let mut max = 0;\n    for i in lst {\n        *count.entry(i).or_insert(0)\
    \ += 1;\n        if i > max {\n            max = i;\n        }\n    }\n    for\
    \ i in 1..=max {\n        if count.get(&i).unwrap_or(&0) >= &i {\n           \
    \ return i;\n        }\n    }\n    -1", "    let mut freq: HashMap<isize, isize>\
    \ = HashMap::new();\n    for i in &lst {\n        let count = freq.entry(*i).or_insert(0);\n\
    \        *count += 1;\n    }\n    let mut answer = -1;\n    for i in 1..=lst.len()\
    \ as isize {\n        let count = match freq.get(&i) {\n            Some(c) =>\
    \ *c,\n            None => 0,\n        };\n        if count >= i {\n         \
    \   answer = i;\n        }\n    }\n    answer", "    let mut m: HashMap<isize,\
    \ isize> = HashMap::new();\n    for x in lst {\n        *m.entry(x).or_insert(0)\
    \ += 1;\n    }\n    let mut res = -1;\n    for (k, v) in m {\n        if v >=\
    \ k && k > res {\n            res = k;\n        }\n    }\n    res", "    let mut\
    \ freq = HashMap::new();\n    for i in lst {\n        *freq.entry(i).or_insert(0)\
    \ += 1;\n    }\n    let mut freq = freq.into_iter().collect::<Vec<_>>();\n   \
    \ freq.sort_by(|&(a, freq_a), &(b, freq_b)| freq_b.cmp(&freq_a).then(a.cmp(&b)));\n\
    \    match freq.iter().find(|&&(i, freq)| i <= freq) {\n        Some(&(i, _))\
    \ => i,\n        None => -1,\n    }", "    let mut d: HashMap<isize, usize> =\
    \ HashMap::new();\n    for v in lst {\n        *d.entry(v).or_insert(0) += 1;\n\
    \    }\n    let mut k: isize = -1;\n    for (key, val) in d {\n        if key\
    \ > k && val >= key as usize {\n            k = key;\n        }\n    }\n    k",
  "    let mut arr: Vec<isize> = vec![0; lst.len() + 1];\n    for i in 0..lst.len()\
    \ {\n        arr[lst[i] as usize] += 1;\n    }\n    for i in (1..arr.len()).rev()\
    \ {\n        if arr[i] >= i as isize {\n            return i as isize;\n     \
    \   }\n    }\n    -1", "    let counts = count_freq(&lst);\n    let mut max_count:\
    \ Option<usize> = None;\n    for n in 1..counts.len() {\n        if counts[n]\
    \ < n {\n            continue;\n        }\n        max_count = Some(n);\n    }\n\
    \    max_count.unwrap_or(0) as isize", "    if lst.len() == 0 {\n        return\
    \ -1;\n    }\n    let mut counts = HashMap::new();\n    let mut max_count = 0;\n\
    \    for &n in &lst {\n        let c = counts.entry(n).or_insert(0);\n       \
    \ *c += 1;\n        max_count = max(max_count, *c);\n    }\n    for n in 1..=max_count\
    \ {\n        if let Some(v) = counts.get(&n) {\n            if n <= *v {\n   \
    \             return n;\n            }\n        }\n    }\n    -1", "    let mut\
    \ map = std::collections::HashMap::new();\n    let mut result = -1;\n    for i\
    \ in lst {\n        if !map.contains_key(&i) {\n            map.insert(i, 1);\n\
    \        } else {\n            let v = map.get_mut(&i).unwrap();\n           \
    \ *v += 1;\n        }\n    }\n    for (k, v) in map {\n        if v >= k && k\
    \ > result {\n            result = k;\n        }\n    }\n    result", "    let\
    \ mut lst: Vec<_> = lst.into_iter().collect();\n    lst.sort();\n    for (i, &x)\
    \ in lst.iter().enumerate() {\n        if lst.len() - i >= x as usize {\n    \
    \        return x;\n        }\n    }\n    -1", "    // Make a vector that contains\
    \ tuples of (index, value, repeat count)\n    let mut list_of_tuples: Vec<(usize,\
    \ isize, usize)> = lst.iter().enumerate().map(|(i, x)| (i, *x, 1)).collect();\n\
    \    // Remove duplicate values\n    list_of_tuples.sort_by(|a, b| b.1.cmp(&a.1));\n\
    \    list_of_tuples.dedup_by(|a, b| a.1 == b.1);\n    // Put in ascending order\n\
    \    list_of_tuples.sort_by(|a, b| a.1.cmp(&b.1));\n    // Find repeating values\n\
    \    for (i, x) in lst.iter().enumerate() {\n        for (_, _, v) in list_of_tuples.iter_mut()\
    \ {\n            if *x == *v as isize {\n                *v += 1;\n          \
    \  }\n        }\n    }\n    for (i, val, count) in list_of_tuples.iter() {\n \
    \       if val > &0 && val <= count {\n            return *val;\n        }\n \
    \   }\n    -1", "    let min_ele = lst.iter().min().unwrap();\n    let max_ele\
    \ = lst.iter().max().unwrap();\n    for i in (min_ele..=max_ele).rev() {\n   \
    \     if i == 0 {\n            continue;\n        }\n        if lst.iter().filter(|&x|\
    \ x == i).count() >= i {\n            return i;\n        }\n    }\n    -1", " \
    \   let mut freq = HashMap::new();\n    for n in lst {\n        *freq.entry(n).or_insert(0)\
    \ += 1;\n    }\n    // Must be called after map is populated.\n    let mut max_freq\
    \ = 0;\n    for (key, &value) in &freq {\n        if key > &max_freq && value\
    \ >= *key {\n            max_freq = *key;\n        }\n    }\n    if max_freq ==\
    \ 0 {\n        return -1;\n    }\n    max_freq", "    let mut m = std::collections::HashMap::new();\n\
    \    for i in lst {\n        *m.entry(i).or_insert(0) += 1;\n    }\n    let mut\
    \ res = -1;\n    for (k, v) in m {\n        if v >= k && k > res {\n         \
    \   res = k;\n        }\n    }\n    res", "    let mut frequencies = HashMap::new();\n\
    \    for i in lst {\n        let count = frequencies.entry(i).or_insert(0);\n\
    \        *count += 1;\n    }\n    let result = frequencies.iter().fold(0, |acc,\
    \ (key, value)| {\n        if key >= value && key > acc {\n            *key\n\
    \        } else {\n            acc\n        }\n    });\n    if result == 0 {\n\
    \        -1\n    } else {\n        result\n    }", "    lst.iter().fold(\n   \
    \     vec![0; lst.len()],\n        |mut a, &b| {\n            if a[b as usize]\
    \ != 0 {\n                a[b as usize] += 1;\n            } else {\n        \
    \        a[b as usize] = 1;\n            }\n            a\n        }\n    ).iter().enumerate().filter(|&(i,\
    \ &n)| n >= i as isize).map(|(i, _)| i as isize).max().unwrap_or(-1)", "    if\
    \ lst.is_empty() { return -1; }\n    let mut greatest = -1;\n    let mut frequencies\
    \ = HashMap::new();\n    for n in lst {\n        let count = frequencies.entry(n).or_insert(0);\n\
    \        *count += 1;\n    }\n    for (k, v) in frequencies.iter() {\n       \
    \ if *k > greatest && *v >= k {\n            greatest = *k;\n        }\n    }\n\
    \    greatest", "    let mut filtered = lst.iter().filter(|&&x| x > 0).collect::<Vec<_>>();\n\
    \    filtered.sort();\n    let mut counts = HashMap::new();\n    for val in filtered.iter()\
    \ {\n        let count = counts.entry(val).or_insert(0);\n        *count += 1;\n\
    \    }\n    for val in filtered.iter().rev() {\n        let count = counts.get(val).unwrap();\n\
    \        if count >= val {\n            return *val;\n        }\n    }\n    -1",
  "    // Your code here\n    unimplemented!();", "    // map the frequencies\n  \
    \  let mut frequencies = std::collections::HashMap::new();\n    for num in lst\
    \ {\n        *frequencies.entry(num).or_insert(0) += 1;\n    }\n\n    // sort\
    \ frequencies\n    let mut nums: Vec<_> = frequencies.keys().cloned().collect();\n\
    \    nums.sort();\n\n    // check to see if there are any that match\n    let\
    \ mut i = nums.len() - 1;\n    while i >= 0 {\n        if nums[i] == frequencies[&nums[i]]\
    \ as isize {\n            return nums[i];\n        }\n        i -= 1;\n    }\n\
    \n    -1", "    let mut map: HashMap<isize, isize> = HashMap::new();\n    for\
    \ i in &lst {\n        if map.contains_key(i) {\n            *map.get_mut(i).unwrap()\
    \ += 1;\n        } else {\n            map.insert(*i, 1);\n        }\n    }\n\
    \    let mut max = -1;\n    for (k, v) in &map {\n        if *k >= *v && *k >\
    \ max {\n            max = *k;\n        }\n    }\n    max", "    let mut map =\
    \ std::collections::HashMap::new();\n    for i in lst {\n        let count = map.entry(i).or_insert(0);\n\
    \        *count += 1;\n    }\n    let mut list: Vec<(&isize, &isize)> = map.iter().collect();\n\
    \    list.sort_by(|a, b| b.1.cmp(a.1));\n    println!(\"{:?}\", list);\n    for\
    \ i in list {\n        if i.0 >= i.1 {\n            return **i.0;\n        }\n\
    \    }\n    -1", "    let mut occurrences = [0;50];\n    for x in lst {\n    \
    \    occurrences[x as usize] += 1;\n    }\n    for i in (0..lst.len()).rev() {\n\
    \        if occurrences[i] >= i as isize && occurrences[i] > 0 {\n           \
    \ return i as isize;\n        }\n    }\n    -1", "    let mut table = HashMap::new();\n\
    \    for i in lst {\n        let count = table.entry(i).or_insert(0);\n      \
    \  *count += 1;\n    }\n    for (key, val) in table {\n        if key <= val {\n\
    \            return key;\n        }\n    }\n    -1", "    let mut v = lst.clone();\n\
    \    v.sort();\n    for &i in v.iter() {\n        let freq = v.iter().filter(|&x|\
    \ *x == i).count();\n        if freq >= i as usize {\n            return i;\n\
    \        }\n    }\n    -1", "    let mut res = vec![];\n    for i in 0..lst.len()\
    \ {\n        let count = lst.iter().filter(|&n| *n == lst[i]).count();\n     \
    \   res.push((lst[i], count));\n    }\n    let res = res.iter().filter(|&(n, c)|\
    \ *n <= *c as isize).max_by_key(|&(n, c)| (c, -n));\n    match res {\n       \
    \ Some((_, _)) => res.unwrap().0,\n        None => -1,\n    }", "    lst.iter().max().map_or(-1,\
    \ |max| {\n        lst.iter().filter(|&&x| x == *max).count() as isize\n    })",
  '  -1', "    let mut max_freq = 0;\n    let mut frequencies = std::collections::HashMap::new();\n\
    \    for item in lst {\n        *frequencies.entry(item).or_insert(0) += 1;\n\
    \        if item > max_freq {\n            max_freq = item;\n        }\n    }\n\
    \    for i in (1..max_freq + 1).rev() {\n        if let Some(frequency) = frequencies.get(&i)\
    \ {\n            if i == *frequency {\n                return i;\n           \
    \ }\n        }\n    }\n    -1", "    let mut freq = HashMap::new();\n    for num\
    \ in lst {\n        *freq.entry(num).or_insert(0) += 1;\n    }\n    let mut max_num\
    \ = -1;\n    for (num, count) in freq {\n        if count >= num && num > max_num\
    \ {\n            max_num = num;\n        }\n    }\n    max_num", "    // Create\
    \ map with frequencies\n    let mut freq_map = HashMap::new();\n    for num in\
    \ lst {\n        *freq_map.entry(num).or_insert(0) += 1;\n    }\n\n    // Find\
    \ greatest integer\n    let mut greatest = 0;\n    for (num, freq) in freq_map\
    \ {\n        if freq >= num && num > greatest {\n            greatest = num;\n\
    \        }\n    }\n\n    // Return -1 if nothing found\n    if greatest == 0 {\n\
    \        -1\n    } else {\n        greatest\n    }", "    let mut result = 0;\n\
    \    let mut m = std::collections::HashMap::new();\n    for &i in &lst {\n   \
    \     *m.entry(i).or_insert(0) += 1;\n    }\n    for &i in &lst {\n        if\
    \ m.get(&i).unwrap() >= &i && i > result {\n            result = i;\n        }\n\
    \    }\n    if result == 0 {\n        -1\n    } else {\n        result\n    }",
  "    let h = lst.iter().fold(HashMap::new(), |mut m, &x| {\n        *m.entry(x).or_insert(0)\
    \ += 1;\n        m\n    });\n    for (&n, &c) in h.iter() {\n        if n <= c\
    \ {\n            return n;\n        }\n    }\n    -1", "    let mut occ = HashMap::new();\n\
    \    for i in lst {\n        *occ.entry(i).or_insert(0) += 1;\n    }\n    let\
    \ mut max_key = -1;\n    for (key, val) in occ {\n        if key <= val && key\
    \ > max_key {\n            max_key = key;\n        }\n    }\n    max_key", " \
    \   let mut cnt = HashMap::new();\n    for x in lst {\n        *cnt.entry(x).or_insert(0)\
    \ += 1;\n    }\n    for x in lst {\n        if let Some(n) = cnt.get(&x) {\n \
    \           if x <= *n {\n                return x;\n            }\n        }\n\
    \    }\n    -1", "    let mut counts = HashMap::new();\n    for item in lst {\n\
    \        let count = counts.entry(item).or_insert(0);\n        *count += 1;\n\
    \    }\n    for item in lst {\n        let entry = counts.get(&item);\n      \
    \  if entry.is_some() && item <= *entry.unwrap() {\n            return item;\n\
    \        }\n    }\n    -1", "    if lst.len() == 0 {\n        return -1;\n   \
    \ }\n    let mut counts = HashMap::new();\n    for n in lst {\n        let count\
    \ = counts.entry(n).or_insert(0);\n        *count += 1;\n    }\n    let mut max_freq\
    \ = -1;\n    for (num, freq) in counts {\n        if num <= freq {\n         \
    \   max_freq = std::cmp::max(max_freq, num);\n        }\n    }\n    max_freq",
  "    use std::collections::BTreeMap;\n    let mut map = BTreeMap::new();\n    for\
    \ i in lst {\n        let count = map.entry(i).or_insert(0);\n        *count +=\
    \ 1;\n    }\n    let mut res = None;\n    for (key, val) in map {\n        if\
    \ val >= key {\n            res = match res {\n                Some(x) => Some(if\
    \ x > key { x } else { key }),\n                None => Some(key),\n         \
    \   }\n        }\n    }\n    res.unwrap_or(-1)", "    // Complete the function\n\
    \    let mut map: HashMap<isize, isize> = HashMap::new();\n    for &x in lst.iter()\
    \ {\n        *map.entry(x).or_insert(0) += 1;\n    }\n    for &x in lst.iter()\
    \ {\n        if let Some(v) = map.get(&x) {\n            if *v >= x {\n      \
    \          return x;\n            }\n        }\n    }\n    -1", "    let mut freq\
    \ = HashMap::new();\n    for n in lst {\n        *freq.entry(n).or_insert(0) +=\
    \ 1;\n    }\n    let mut res = -1;\n    for (k, v) in freq {\n        if k <=\
    \ v && k > res {\n            res = k;\n        }\n    }\n    res", "    let mut\
    \ map: HashMap<isize, isize> = HashMap::new();\n    for i in lst {\n        *map.entry(i).or_insert(0)\
    \ += 1;\n    }\n    let mut res = -1;\n    for (k, v) in map {\n        if k <=\
    \ v && k > res {\n            res = k;\n        }\n    }\n    res", "    let len\
    \ = lst.len();\n    for i in 0..len {\n        let num = lst[i];\n        let\
    \ count = lst.iter().filter(|&&x| x == num).count();\n        if count >= num\
    \ as usize {\n            return num;\n        }\n    }\n    -1", "    // TODO:\
    \ return the correct value\n    0", "    // TODO!\n    lst.iter().max().unwrap()",
  "    if lst.len() < 1 { return -1; }\n    let mut freq: BTreeMap<isize, usize> =\
    \ BTreeMap::new();\n    for i in lst {\n        if freq.contains_key(&i) {\n \
    \           *freq.get_mut(&i).unwrap() += 1;\n        } else {\n            freq.insert(i,\
    \ 1);\n        }\n    }\n    let mut ans = -1;\n    for (k, v) in freq {\n   \
    \     if k > 0 && v >= k as usize && k > ans {\n            ans = k;\n       \
    \ }\n    }\n    ans", '    lst.iter().cloned().filter(|x| x == lst.iter().filter(|&y|
    y == x).count() as isize).max().unwrap_or(-1)', "    let mut cnt = HashMap::new();\n\
    \    let mut freq = HashMap::new();\n    let mut max = -1;\n    for e in lst {\n\
    \        cnt.entry(e).and_modify(|c| *c += 1).or_insert(1);\n        max = std::cmp::max(max,\
    \ e);\n    }\n    for e in 0..=max {\n        if cnt.contains_key(&e) {\n    \
    \        freq.insert(e, cnt[&e]);\n        }\n    }\n    for e in freq.keys()\
    \ {\n        if *e <= freq[e] {\n            return *e;\n        }\n    }\n  \
    \  -1", "    let mut counter = std::collections::HashMap::new();\n    for val\
    \ in lst {\n        let entry = counter.entry(val).or_insert(0);\n        *entry\
    \ += 1;\n    }\n    // println!(\"{:?}\", counter);\n    let mut max = -1;\n \
    \   for (k, v) in counter {\n        if v >= k && k > max {\n            max =\
    \ k;\n        }\n    }\n    return max;", "    let mut result = -1;\n    let mut\
    \ count = 0;\n    for i in 0..lst.len() {\n        for j in i..lst.len() {\n \
    \           if lst[i] == lst[j] {\n                count += 1;\n            }\n\
    \        }\n        if count >= lst[i] as usize && lst[i] > result {\n       \
    \     result = lst[i];\n        }\n        count = 0;\n    }\n    result", " \
    \   if lst.is_empty() {\n        return -1;\n    }\n    let mut output = -1;\n\
    \    let mut last = lst[0];\n    let mut count = 1;\n    for num in lst.iter().skip(1)\
    \ {\n        if *num == last {\n            count += 1;\n        } else {\n  \
    \          if last == count {\n                output = std::cmp::max(output,\
    \ last);\n            }\n            last = *num;\n            count = 1;\n  \
    \      }\n    }\n    if last == count {\n        output = std::cmp::max(output,\
    \ last);\n    }\n    output", "    let mut hash: HashMap<isize, isize> = HashMap::new();\n\
    \    for x in lst {\n        let val = hash.entry(x).or_insert(0);\n        *val\
    \ += 1;\n    }\n    let mut max = -1;\n    for (key, val) in hash {\n        if\
    \ key <= val && key > max {\n            max = key;\n        }\n    }\n    max",
  "    let mut freq = HashMap::new();\n    for val in lst {\n        *freq.entry(val).or_insert(0)\
    \ += 1;\n    }\n    for val in lst {\n        if freq.get(&val).unwrap() >= &val\
    \ {\n            return val;\n        }\n    }\n    -1", "    let mut m = HashMap::new();\n\
    \    let mut max = 0;\n    for item in lst {\n        *m.entry(item).or_insert(0)\
    \ += 1;\n        if item > max {\n            max = item;\n        }\n    }\n\
    \    for i in (1..max + 1).rev() {\n        match m.get(&i) {\n            Some(v)\
    \ => {\n                if i <= *v {\n                    return i;\n        \
    \        }\n            }\n            None => continue,\n        }\n    }\n \
    \   -1", "    let m = lst.iter().max().unwrap();\n    let c = lst.iter().filter(|&x|\
    \ x == m).count();\n    if c < *m as usize {\n        -1\n    } else {\n     \
    \   *m\n    }", "    // Given that the input list is non-empty and contains positive\
    \ integers, we can assume a valid maximum\n    // value exists. Let's find it.\n\
    \    let max = lst.iter().max().unwrap();\n    // If the maximum value itself\
    \ is greater than zero, we can use it to determine if we have a value to return.\n\
    \    if *max > 0 {\n        // Create a histogram of the list, which maps values\
    \ to the number of times they appear in the list.\n        let mut histogram =\
    \ histogram(lst);\n        // Iterate over the values in the histogram starting\
    \ with the maximum value.\n        for i in (*max)..0 {\n            // If the\
    \ current value appears in the histogram, and the number of times it appears is\
    \ greater than\n            // or equal to the value, then return the value.\n\
    \            if histogram.contains_key(&i) && *histogram.get(&i).unwrap() >= i\
    \ {\n                return i;\n            }\n        }\n    }\n    // If we\
    \ reach this point, there is no value to return.\n    -1", "    let mut freq:\
    \ HashMap<isize, isize> = HashMap::new();\n    let mut res: isize = -1;\n    for\
    \ i in lst {\n        match freq.get(&i) {\n            Some(&x) => {\n      \
    \          freq.insert(i, x + 1);\n            }\n            None => {\n    \
    \            freq.insert(i, 1);\n            }\n        }\n    }\n    for i in\
    \ lst {\n        match freq.get(&i) {\n            Some(&x) => {\n           \
    \     if i == x && res < i {\n                    res = i;\n                }\n\
    \            }\n            None => {}\n        }\n    }\n    res", "    let mut\
    \ d: HashMap<isize, isize> = HashMap::new();\n    for i in &lst {\n        match\
    \ d.get_mut(i) {\n            Some(n) => *n += 1,\n            None => {\n   \
    \             d.insert(*i, 1);\n            }\n        }\n    }\n    let mut max\
    \ = -1;\n    for (k, v) in &d {\n        if *k > *v && *k > max {\n          \
    \  max = *k;\n        }\n    }\n    max", "    let mut counter = HashMap::new();\n\
    \    for x in lst {\n        let count = counter.entry(x).or_insert(0);\n    \
    \    *count += 1;\n    }\n    let mut pairs: Vec<(isize, isize)> = counter.iter().map(|(k,\
    \ v)| (*k, *v)).collect();\n    pairs.sort_by(|a, b| b.1.cmp(&a.1));\n    let\
    \ mut result = -1;\n    for pair in pairs {\n        if pair.0 > pair.1 {\n  \
    \          break;\n        }\n        result = pair.0;\n    }\n    result", " \
    \   let mut lst = lst;\n    lst.sort();\n    let lst_len = lst.len();\n    let\
    \ mut cur_val = lst[0];\n    let mut cur_cnt = 1;\n    for i in 1..lst_len {\n\
    \        if lst[i] == cur_val {\n            cur_cnt += 1;\n        } else {\n\
    \            if cur_val >= cur_cnt {\n                return cur_val;\n      \
    \      }\n            cur_val = lst[i];\n            cur_cnt = 1;\n        }\n\
    \    }\n    if cur_val >= cur_cnt {\n        return cur_val;\n    }\n    -1",
  "    let mut count = HashMap::new();\n    for n in lst {\n        let val = *count.get(&n).unwrap_or(&0);\n\
    \        count.insert(n, val + 1);\n    }\n    let mut max_i = -1;\n    for (&k,\
    \ &v) in &count {\n        if k >= v && k > max_i {\n            max_i = k;\n\
    \        }\n    }\n    max_i", "    let mut map = HashMap::new();\n    for x in\
    \ lst {\n        *map.entry(x).or_insert(0) += 1;\n    }\n    map.iter()\n   \
    \     .filter(|(key, val)| **key <= *val)\n        .map(|(key, _)| *key)\n   \
    \     .max()\n        .unwrap_or(-1)", "    use std::collections::HashMap;\n \
    \   let mut counter = HashMap::new();\n    for i in lst {\n        *counter.entry(i).or_insert(0)\
    \ += 1;\n    }\n    for (&key, &val) in counter.iter() {\n        if val >= key\
    \ {\n            return key;\n        }\n    }\n    -1", "    // TODO\n    unimplemented!()",
  "    let mut frequency: HashMap<isize, isize> = HashMap::new();\n    for &i in &lst\
    \ {\n        *frequency.entry(i).or_insert(0) += 1;\n    }\n    let mut answer\
    \ = -1;\n    for &i in &lst {\n        if i > answer && frequency[&i] >= i {\n\
    \            answer = i;\n        }\n    }\n    answer", "    let mut m = std::collections::HashMap::new();\n\
    \    for i in lst {\n        let v = m.entry(i).or_insert(0);\n        *v += 1;\n\
    \    }\n    let mut max = -1;\n    for (k, v) in m {\n        if k > v && k >\
    \ max {\n            max = k;\n        }\n    }\n    max", "    let mut occur_map:\
    \ HashMap<isize, isize> = HashMap::new();\n    for item in lst {\n        *occur_map.entry(item).or_insert(0)\
    \ += 1;\n    }\n    let mut max = -1;\n    for (&k, &v) in &occur_map {\n    \
    \    if k <= v && k > max {\n            max = k;\n        }\n    }\n    max",
  "    let mut m = std::collections::HashMap::new();\n    for x in lst {\n       \
    \ *m.entry(x).or_insert(0) += 1;\n    }\n    let mut max_k = -1;\n    for (&k,\
    \ &v) in m.iter() {\n        if k <= v && k > max_k {\n            max_k = k;\n\
    \        }\n    }\n    max_k", "    let mut hm = HashMap::new();\n    for n in\
    \ lst {\n        *hm.entry(n).or_insert(0) += 1;\n    }\n    let mut pairs: Vec<(isize,\
    \ isize)> = hm.into_iter().collect();\n    pairs.sort_by(|a, b| if a.1 == b.1\
    \ { b.0.cmp(&a.0) } else { a.1.cmp(&b.1) });\n    let greatest = pairs.get(0).unwrap();\n\
    \    if greatest.0 >= greatest.1 {\n        greatest.0\n    } else {\n       \
    \ -1\n    }", '    lst.iter().cloned().filter(|&x| lst.iter().filter(|&y| x ==
    y).count() >= x as usize).max().unwrap_or(-1)', "    let mut freq = HashMap::new();\n\
    \    for i in lst {\n        *freq.entry(i).or_insert(0) += 1;\n    }\n    let\
    \ mut result = -1;\n    for (key, value) in freq {\n        if key <= value &&\
    \ key > result {\n            result = key;\n        }\n    }\n    result", " \
    \   let mut m: HashMap<isize, isize> = HashMap::new();\n    let mut max: isize\
    \ = 0;\n    for elem in lst {\n        let counter = m.entry(elem).or_insert(0);\n\
    \        *counter += 1;\n        if elem > max && *counter >= elem {\n       \
    \     max = elem;\n        }\n    }\n    if max > 0 { max } else { -1 }", "  \
    \  use std::collections::HashMap;\n    let mut counts = HashMap::new();\n    for\
    \ &value in &lst {\n        let entry = counts.entry(value).or_insert(0);\n  \
    \      *entry += 1;\n    }\n    counts.into_iter()\n        .filter(|&(k, v)|\
    \ k <= v)\n        .max_by_key(|&(k, v)| (v, -k))\n        .map(|(k, _)| k)\n\
    \        .unwrap_or(-1)", "    use std::collections::HashMap;\n    let mut counts\
    \ = HashMap::new();\n    for &i in &lst {\n        let entry = counts.entry(i).or_insert(0);\n\
    \        *entry += 1;\n    }\n    (1..).take_while(|i| i <= &counts.len()).filter(|i|\
    \ counts.contains_key(i)).next().unwrap_or(-1)", "    // Create a frequency map\n\
    \    let mut freq = HashMap::new();\n    for elt in lst {\n        let counter\
    \ = freq.entry(elt).or_insert(0);\n        *counter += 1;\n    }\n    // Find\
    \ the max value\n    let mut max = -1;\n    for (key, val) in freq {\n       \
    \ if val >= key && key > max {\n            max = key;\n        }\n    }\n   \
    \ max", "    let mut frequency = HashMap::new();\n    for x in lst {\n       \
    \ *frequency.entry(x).or_insert(0) += 1;\n    }\n    let mut k = 0;\n    for (key,\
    \ value) in frequency {\n        if key >= value && key > k {\n            k =\
    \ key;\n        }\n    }\n    if k == 0 {\n        return -1;\n    }\n    k",
  "    let mut frequencies = std::collections::HashMap::new();\n    for number in\
    \ lst {\n        let counter = frequencies.entry(number).or_insert(0);\n     \
    \   *counter += 1;\n    }\n    let mut frequencies: Vec<_> = frequencies.into_iter().collect();\n\
    \    frequencies.sort_by(|a, b| b.1.cmp(&a.1));\n    for (i, (number, _)) in frequencies.iter().enumerate()\
    \ {\n        if number <= &frequencies[i].1 {\n            return *number;\n \
    \       }\n    }\n    -1", "    let mut dict = HashMap::new();\n    for i in lst\
    \ {\n        let counter = dict.entry(i).or_insert(0);\n        *counter += 1;\n\
    \    }\n    let mut max = -1;\n    for (key, value) in dict {\n        if key\
    \ == value && key > max {\n            max = key;\n        }\n    }\n    max",
  "    // Brute force\n    let mut max = 0;\n    for i in 1..lst.len()+1 {\n     \
    \   let a = lst.iter().filter(|x| **x == i as isize).count();\n        if (a >=\
    \ i) && (a > max) {\n            max = a;\n        }\n    }\n    if max > 0 {\n\
    \        max as isize\n    } else {\n        -1\n    }", "    let mut c: Vec<(isize,\
    \ isize)> = lst.iter().map(|x| (*x, 1)).collect();\n    c.sort_by(|a, b| a.0.cmp(&b.0));\n\
    \    for i in 0..c.len() {\n        if c[i].0 == c[i].1 {\n            return\
    \ c[i].0;\n        }\n        if i == c.len() - 1 {\n            return -1;\n\
    \        }\n        if c[i].0 != c[i + 1].0 {\n            for j in (i + 1)..c.len()\
    \ {\n                if c[j].0 == c[j].1 {\n                    return c[j].0;\n\
    \                }\n                if c[j].0 != c[j + 1].0 {\n              \
    \      break;\n                }\n            }\n        }\n        c[i + 1].1\
    \ += 1;\n    }\n    return -1;", "    let mut map = HashMap::new();\n    for item\
    \ in lst {\n        let count = map.entry(item).or_insert(0);\n        *count\
    \ += 1;\n    }\n    let mut max = -1;\n    for (k, v) in map {\n        if k >\
    \ max && k <= v {\n            max = k;\n        }\n    }\n    max", "    let\
    \ counts = {\n        let mut counts = HashMap::new();\n        for i in lst {\n\
    \            *counts.entry(i).or_insert(0) += 1;\n        }\n        counts\n\
    \    };\n    // println!(\"counts: {:?}\", counts);\n    let max_keys = {\n  \
    \      let mut m = HashMap::new();\n        for (key, val) in counts {\n     \
    \       if val >= key {\n                *m.entry(val).or_insert(key) = key;\n\
    \            }\n        }\n        m\n    };\n    // println!(\"max_keys: {:?}\"\
    , max_keys);\n    let mut max_val = -1;\n    for (key, val) in max_keys {\n  \
    \      if val > max_val {\n            max_val = val;\n        }\n    }\n    max_val",
  "    let mut items = HashMap::new();\n    for i in lst {\n        let x = items.entry(i).or_insert(0);\n\
    \        *x += 1;\n    }\n    let mut greatest_frequency = 0;\n    let mut greatest_frequency_number\
    \ = 0;\n    for (k, v) in items {\n        if k > greatest_frequency {\n     \
    \       greatest_frequency = k;\n            greatest_frequency_number = v;\n\
    \        }\n    }\n    if greatest_frequency_number >= greatest_frequency {\n\
    \        greatest_frequency\n    } else {\n        -1\n    }", "    let mut list:\
    \ HashMap<isize, isize> = HashMap::new();\n    let mut a: isize = -1;\n    for\
    \ x in lst {\n        *list.entry(x).or_insert(0) += 1;\n    }\n    for (k, v)\
    \ in list {\n        if v >= k && k > a {\n            a = k;\n        }\n   \
    \ }\n    a", "    let mut hash = HashMap::new();\n    for i in &lst {\n      \
    \  if !hash.contains_key(i) {\n            hash.insert(*i, 1);\n        } else\
    \ {\n            let new_val = hash.get(i).unwrap() + 1;\n            hash.insert(*i,\
    \ new_val);\n        }\n    }\n    let mut max = -1;\n    for i in &lst {\n  \
    \      if i <= &hash.get(i).unwrap() && i > &max {\n            max = *i;\n  \
    \      }\n    }\n    max", "    use std::collections::HashMap;\n    let mut hash_map:\
    \ HashMap<isize, isize> = HashMap::new();\n    for i in lst {\n        let entry\
    \ = hash_map.entry(i).or_insert(0);\n        *entry += 1;\n    }\n    let mut\
    \ max_value = 0;\n    for (key, value) in hash_map {\n        if value >= key\
    \ && key > max_value {\n            max_value = key;\n        }\n    }\n    if\
    \ max_value > 0 {\n        max_value\n    } else {\n        -1\n    }", "    let\
    \ mut m: HashMap<isize, isize> = HashMap::new();\n    for i in lst {\n       \
    \ *m.entry(i).or_insert(0) += 1;\n    }\n    for (k, v) in m.iter() {\n      \
    \  if *k <= *v {\n            return *k;\n        }\n    }\n    -1", "    let\
    \ mut frequencies = HashMap::new();\n    for item in lst {\n        *frequencies.entry(item).or_insert(0)\
    \ += 1;\n    }\n    let mut res = -1;\n    for (&item, &freq) in &frequencies\
    \ {\n        if item <= freq && item > res {\n            res = item;\n      \
    \  }\n    }\n    res", "    let mut count: Vec<isize> = vec![0; 11];\n    for\
    \ i in lst {\n        count[i as usize] += 1;\n    }\n    for i in (1..count.len()).rev()\
    \ {\n        if count[i] >= i as isize {\n            return i as isize;\n   \
    \     }\n    }\n    -1", "    let mut m: HashMap<isize, isize> = HashMap::new();\n\
    \    for i in lst {\n        let freq = match m.get(&i) {\n            Some(value)\
    \ => value + 1,\n            None => 1,\n        };\n        m.insert(i, freq);\n\
    \    }\n    let mut res = -1;\n    for (key, value) in m.iter() {\n        if\
    \ value >= key && key > &res {\n            res = *key;\n        }\n    }\n  \
    \  res", "    lst.iter().cloned().fold(HashMap::new(), |mut h, e| {\n        *h.entry(e).or_insert(0)\
    \ += 1;\n        h\n    }).into_iter().filter(|&(k, v)| k <= v).map(|(k, _)| k).max().unwrap_or(-1)",
  "    let mut sorted = lst.clone();\n    sorted.sort();\n    println!(\"sorted: {:?}\"\
    , sorted);\n    let mut count = 1;\n    let mut max_num = 0;\n    let mut max_num_count\
    \ = 0;\n    for i in 1..sorted.len() {\n        if sorted[i] == sorted[i - 1]\
    \ {\n            count += 1;\n        } else {\n            if count >= sorted[i\
    \ - 1] as usize && count > max_num_count {\n                max_num = sorted[i\
    \ - 1];\n                max_num_count = count;\n            }\n            count\
    \ = 1;\n        }\n    }\n    if count >= sorted[sorted.len() - 1] as usize &&\
    \ count > max_num_count {\n        max_num = sorted[sorted.len() - 1];\n    }\n\
    \    if max_num == 0 { -1 } else { max_num }", "    let mut cnt = HashMap::new();\n\
    \    for num in lst {\n        let e = cnt.entry(num).or_insert(0);\n        *e\
    \ += 1;\n    }\n    let mut max = -1;\n    for (num, freq) in cnt {\n        if\
    \ num <= freq && num > max {\n            max = num;\n        }\n    }\n    max",
  "    let lst_len = lst.len();\n    let mut max_value: isize = -1;\n    for n in\
    \ lst {\n        let count = lst.iter().filter(|&x| *x == n).count();\n      \
    \  if n > max_value && count >= n as usize {\n            max_value = n;\n   \
    \     }\n    }\n    max_value", "    let mut cnts = std::collections::HashMap::new();\n\
    \    for num in lst {\n        *cnts.entry(num).or_insert(0) += 1;\n    }\n  \
    \  let mut res = -1;\n    for (num, cnt) in cnts {\n        if num <= cnt && num\
    \ > res {\n            res = num;\n        }\n    }\n    res", "    let mut res:\
    \ HashMap<isize, isize> = HashMap::new();\n    for i in lst {\n        match res.get_mut(&i)\
    \ {\n            Some(x) => *x += 1,\n            None => {\n                res.insert(i,\
    \ 1);\n            }\n        }\n    }\n    let mut x = res.clone();\n    x.remove(&0);\n\
    \    let mut y = res.clone();\n    y.remove(&0);\n    y.remove(&1);\n    let x:\
    \ Vec<isize> = x.keys().map(|x| *x).collect();\n    let y: Vec<isize> = y.keys().map(|x|\
    \ *x).collect();\n    if x.is_empty() {\n        return -1;\n    }\n    if y.is_empty()\
    \ {\n        return 1;\n    }\n    let max = x.iter().max().unwrap();\n    if\
    \ res.get(max).unwrap() >= max {\n        return *max;\n    }\n    let max = y.iter().max().unwrap();\n\
    \    if res.get(max).unwrap() >= max {\n        return *max;\n    }\n    -1",
  "    let mut frequencies = HashMap::new();\n    let mut highest = 1;\n    for number\
    \ in lst {\n        if number > highest {\n            highest = number;\n   \
    \     }\n        if let Some(value) = frequencies.get_mut(&number) {\n       \
    \     *value += 1;\n        } else {\n            frequencies.insert(number, 1);\n\
    \        }\n    }\n    for i in (0..highest).rev() {\n        if let Some(f) =\
    \ frequencies.get(&i) {\n            if *f >= i {\n                return i;\n\
    \            }\n        }\n    }\n    -1", "    // your code\n    let mut occur\
    \ = [0; 100];\n    for i in lst {\n        occur[i as usize] += 1;\n    }\n  \
    \  for i in (1..100).rev() {\n        if occur[i] >= i as usize {\n          \
    \  return i as isize;\n        }\n    }\n    -1", "    let mut res: HashMap<isize,\
    \ isize> = HashMap::new();\n    for e in lst {\n        *res.entry(e).or_insert(0)\
    \ += 1;\n    }\n    let mut max = -1;\n    for (&key, &value) in &res {\n    \
    \    if value >= key && value > max {\n            max = value;\n        }\n \
    \   }\n    max", "    let len = lst.len();\n    for i in 1..=len {\n        let\
    \ it = lst.iter().filter(|&x| *x == i as isize).count();\n        if i <= it {\n\
    \            return i as isize;\n        }\n    }\n    -1", "    // This function\
    \ is not optimized and will take forever to solve !\n    if lst.is_empty() { return\
    \ -1; }\n    let mut big_int = 0;\n    for i in lst.iter() {\n        let val\
    \ = *i;\n        let frequency = lst.iter().filter(|&i| *i == val).count();\n\
    \        if val > big_int && frequency >= val as usize {\n            big_int\
    \ = val;\n        }\n    }\n    if big_int == 0 {\n        return -1;\n    }\n\
    \    big_int", "    let (mut count, mut num) = (-1, -1);\n    for x in lst {\n\
    \        let c = lst.iter().filter(|&x| *x == x).count();\n        if x >= c &&\
    \ c > count {\n            count = c;\n            num = x;\n        }\n    }\n\
    \    num", '    unimplemented!()', "    let mut dict = HashMap::new();\n    for\
    \ i in lst {\n        *dict.entry(i).or_insert(0) += 1;\n    }\n    let mut list\
    \ = dict.into_iter().collect::<Vec<(isize, isize)>>();\n    list.sort_by(|a, b|\
    \ a.0.cmp(&b.0));\n    for j in list {\n        if j.0 <= j.1 {\n            return\
    \ j.0;\n        }\n    }\n    -1", "    let mut count = HashMap::new();\n    for\
    \ el in lst {\n        let entry = count.entry(el).or_insert(0);\n        *entry\
    \ += 1;\n    }\n    let mut max = -1;\n    for (key, &val) in count.iter() {\n\
    \        if key > &val {\n            continue;\n        }\n        max = cmp::max(max,\
    \ *key);\n    }\n    max", "    let mut m = HashMap::new();\n    for n in lst\
    \ {\n        *m.entry(n).or_insert(0) += 1;\n    }\n    let mut t = -1;\n    for\
    \ n in lst {\n        if n > 0 && n <= m[&n] && n > t {\n            t = n;\n\
    \        }\n    }\n    t", '    unimplemented!()', "    // TODO: Write your code\
    \ here\n    unimplemented!();", "    let mut map: HashMap<isize, isize> = HashMap::new();\n\
    \    for num in lst {\n        if !map.contains_key(&num) {\n            map.insert(num,\
    \ 1);\n        } else {\n            *map.get_mut(&num).unwrap() += 1;\n     \
    \   }\n    }\n    let mut max = -1;\n    for (k, v) in map {\n        if k >=\
    \ v && k > max {\n            max = k;\n        }\n    }\n    max", "    let mut\
    \ frequency: Vec<isize> = vec![0; lst.len() + 1];\n    for i in lst {\n      \
    \  frequency[i as usize] += 1;\n    }\n    for i in (1..frequency.len()).rev()\
    \ {\n        if frequency[i] >= i as isize {\n            return i as isize;\n\
    \        }\n    }\n    -1", "    // Create a map of frequencies. \n    let mut\
    \ freq = HashMap::new();\n    for &x in &lst {\n        let counter = freq.entry(x).or_insert(0);\n\
    \        *counter += 1;\n    }\n    // Find the largest value that has a frequency\
    \ at least equal to itself.\n    let mut max = -1;\n    for (&key, &value) in\
    \ &freq {\n        if key == value && key > max {\n            max = key;\n  \
    \      }\n    }\n    max", "    // Create a vector with the frequency of each\
    \ element.\n    let mut occurences: Vec<isize> = Vec::new();\n    for i in 0..(*lst.iter().max().unwrap()\
    \ + 1) {\n        occurences.push(lst.iter().filter(|&x| *x == i).count() as isize);\n\
    \    }\n    // Search the first element that has a frequency greater or equal\
    \ to its value.\n    for (i, &occurence) in occurences.iter().enumerate() {\n\
    \        if occurence >= i as isize {\n            return i as isize;\n      \
    \  }\n    }\n    // If no element is found, return -1.\n    return -1;", "   \
    \ let mut map: HashMap<isize, isize> = HashMap::new();\n    for elem in lst {\n\
    \        *map.entry(elem).or_insert(0) += 1;\n    }\n    let mut res = -1;\n \
    \   for (key, value) in map {\n        if key >= value && key > res {\n      \
    \      res = key;\n        }\n    }\n    res", "    let mut result = -1;\n   \
    \ let mut counter = HashMap::new();\n    for item in lst {\n        *counter.entry(item).or_insert(0)\
    \ += 1;\n    }\n    for item in lst {\n        if counter.get(&item).unwrap()\
    \ >= &item && item > result {\n            result = item;\n        }\n    }\n\
    \    result", "    let mut lst: Vec<isize> = lst.iter().map(|&x| x).collect();\n\
    \    lst.sort();\n    let mut i = 0;\n    let mut v = None;\n    let len = lst.len();\n\
    \    while i < len {\n        let n = lst[i];\n        let c = lst.iter().filter(|&x|\
    \ *x == n).count();\n        if c >= n as usize {\n            v = Some(n);\n\
    \        }\n        i += c;\n    }\n    v.unwrap_or(-1)", "    let mut cnt = HashMap::new();\n\
    \    let mut max = 0;\n    for &num in &lst {\n        let freq = cnt.entry(num).or_insert(0);\n\
    \        *freq += 1;\n        if *freq >= num && num > max {\n            max\
    \ = num;\n        }\n    }\n    if max == 0 {\n        -1\n    } else {\n    \
    \    max\n    }", "    let mut s = lst.clone();\n    s.sort();\n    let mut map\
    \ = HashMap::new();\n    for i in s {\n        if i > 0 {\n            let count\
    \ = map.entry(i).or_insert(0);\n            *count += 1;\n        }\n    }\n \
    \   let mut sorted = map.iter().collect::<Vec<_>>();\n    sorted.sort_by(|a, b|\
    \ {\n        if a.1 == b.1 {\n            return a.0.cmp(b.0);\n        }\n  \
    \      return b.1.cmp(a.1);\n    });\n    for i in sorted {\n        if i.0 >=\
    \ i.1 {\n            return *i.0;\n        }\n    }\n    return -1;", "    let\
    \ mut vec = vec![0; 1000];\n    let mut max = -1;\n    for i in lst {\n      \
    \  vec[i as usize] += 1;\n        if vec[i as usize] >= i && i > max {\n     \
    \       max = i;\n        }\n    }\n    max", "    let mut hm = HashMap::new();\n\
    \    for i in lst {\n        *hm.entry(i).or_insert(0) += 1;\n    }\n    let mut\
    \ res = -1;\n    for (k, v) in hm {\n        if k >= v && k > res {\n        \
    \    res = k;\n        }\n    }\n    res", "    let mut counts = HashMap::new();\n\
    \    for i in lst {\n        let cnt = counts.entry(i).or_insert(0);\n       \
    \ *cnt += 1;\n    }\n    let mut max = -1;\n    for (&i, &cnt) in &counts {\n\
    \        if i <= cnt && i > max {\n            max = i;\n        }\n    }\n  \
    \  max", "    let mut frequencies = HashMap::new();\n    for num in lst {\n  \
    \      let value = frequencies.entry(num).or_insert(0);\n        *value += 1;\n\
    \    }\n    for (key, value) in frequencies.iter() {\n        if *key <= *value\
    \ {\n            return *key;\n        }\n    }\n    -1", "    let max_freq =\
    \ lst.iter().max().unwrap();\n    let count_map = lst.iter().fold(HashMap::new(),\
    \ |mut acc, x| {\n        *acc.entry(x).or_insert(0) += 1;\n        acc\n    });\n\
    \    for i in 1..max_freq + 1 {\n        if count_map.get(&i).is_some() && *count_map.get(&i).unwrap()\
    \ >= i {\n            return i;\n        }\n    }\n    -1", "    let mut cnt =\
    \ lst.iter().fold(HashMap::new(), |mut map, x| {\n        *map.entry(x).or_insert(0)\
    \ += 1;\n        map\n    });\n    cnt.remove(&0);\n    cnt.remove(&1);\n    if\
    \ cnt.len() == 0 { return -1; }\n    let mut vec: Vec<isize> = cnt.into_iter().collect();\n\
    \    vec.sort_by(|a, b| a.1.cmp(&b.1));\n    vec.last().unwrap().0", "    let\
    \ mut result = -1;\n    let mut map = HashMap::new();\n    for value in lst {\n\
    \        if let Some(prev_value) = map.get_mut(&value) {\n            *prev_value\
    \ += 1;\n        } else {\n            map.insert(value, 1);\n        }\n    }\n\
    \    for (value, freq) in map {\n        if value < freq && value > result {\n\
    \            result = value;\n        }\n    }\n    result", "    let mut map\
    \ = HashMap::new();\n    for number in lst {\n        *map.entry(number).or_insert(0)\
    \ += 1;\n    }\n    let mut result = 0;\n    for (n, c) in map {\n        if c\
    \ >= n && n > result {\n            result = n;\n        }\n    }\n    if result\
    \ == 0 { -1 } else { result }", '    -1', "    let mut frequencies = HashMap::new();\n\
    \    for element in lst {\n        let mut frequency = frequencies.entry(element).or_insert(0);\n\
    \        *frequency += 1;\n    }\n    let mut valid_values = HashSet::new();\n\
    \    for (value, frequency) in frequencies {\n        if value <= frequency {\n\
    \            valid_values.insert(value);\n        }\n    }\n    if valid_values.is_empty()\
    \ {\n        return -1;\n    }\n    let max = valid_values.iter().max().unwrap();\n\
    \    return *max;", "    let mut freq = vec![0; lst.len()];\n    for i in lst\
    \ {\n        if i < 1 || i as usize > lst.len() {\n            continue;\n   \
    \     }\n        freq[i as usize - 1] += 1;\n    }\n    let mut max = 0;\n   \
    \ for i in 0..freq.len() {\n        if freq[i] >= i as isize + 1 && freq[i] >\
    \ freq[max] {\n            max = i;\n        }\n    }\n    if freq[max] == 0 {\n\
    \        -1\n    } else {\n        max as isize + 1\n    }", "    use std::collections::HashMap;\n\
    \    let mut hash = HashMap::new();\n    for e in lst {\n        *hash.entry(e).or_insert(0)\
    \ += 1;\n    }\n    let mut max = -1;\n    for (k, v) in hash {\n        if v\
    \ >= k && k > max {\n            max = k;\n        }\n    }\n    max", "    let\
    \ mut count: HashMap<isize, isize> = HashMap::new();\n    for i in lst {\n   \
    \     if let Some(x) = count.get_mut(&i) {\n            *x += 1;\n        } else\
    \ {\n            count.insert(i, 1);\n        }\n    }\n    let mut ret = -1;\n\
    \    for (k, v) in count {\n        if k > v && v >= k {\n            ret = k;\n\
    \        }\n    }\n    ret", "    let mut counter = HashMap::new();\n    for num\
    \ in lst {\n        *counter.entry(num).or_insert(0) += 1;\n    }\n    let mut\
    \ max = -1;\n    for (k, v) in counter {\n        if k > max && v >= k {\n   \
    \         max = k;\n        }\n    }\n    max", "    // The value at index 0 is\
    \ the count for the value 1. \n    // The value at index 4 is the count for the\
    \ value 5, etc.\n    let mut counts = vec![0; lst.len()];\n    for &num in &lst\
    \ {\n        counts[(num - 1) as usize] += 1;\n    }\n    for (i, count) in counts.iter().enumerate()\
    \ {\n        if *count >= i as isize + 1 {\n            return i as isize + 1;\n\
    \        }\n    }\n    -1", "    if lst.is_empty() {\n        return -1;\n   \
    \ }\n    let mut frequencies = HashMap::new();\n    for i in lst {\n        *frequencies.entry(i).or_insert(0)\
    \ += 1;\n    }\n    let answer = frequencies.iter().max_by_key(|(key, value)|\
    \ {\n        if *value >= **key {\n            **key\n        } else {\n     \
    \       0\n        }\n    });\n    match answer {\n        Some((key, _)) => *key,\n\
    \        None => -1,\n    }", "    let mut counts = HashMap::new();\n    for n\
    \ in lst {\n        let e = counts.entry(n).or_insert(0);\n        *e += 1;\n\
    \    }\n    for (n, count) in counts {\n        if n <= count {\n            return\
    \ n;\n        }\n    }\n    -1", "    let mut result = -1;\n    for i in 1..lst.len()\
    \ + 1 {\n        let mut count = 0;\n        for j in lst.iter() {\n         \
    \   if i == *j {\n                count += 1;\n            }\n        }\n    \
    \    if count >= i as usize {\n            result = i as isize;\n        }\n \
    \   }\n    result", "    let mut freq = BTreeMap::new();\n    let mut set = BTreeSet::new();\n\
    \    for &v in &lst {\n        *freq.entry(v).or_insert(0) += 1;\n        set.insert(v);\n\
    \    }\n    for &v in set.iter().rev() {\n        let f = freq.get(&v).unwrap();\n\
    \        if v <= *f {\n            return v;\n        }\n    }\n    -1", "   \
    \ let mut hash_map: HashMap<isize, isize> = HashMap::new();\n    for i in &lst\
    \ {\n        let count = hash_map.entry(*i).or_insert(0);\n        *count += 1;\n\
    \    }\n    let mut re = 0;\n    for key in hash_map.keys() {\n        if key\
    \ > &0 && hash_map[key] >= key {\n            if *key > re {\n               \
    \ re = *key;\n            }\n        }\n    }\n    if re > 0 {\n        re\n \
    \   } else {\n        -1\n    }", "    let mut m: HashMap<isize, isize> = HashMap::new();\n\
    \    for n in lst {\n        if !m.contains_key(&n) {\n            m.insert(n,\
    \ 1);\n        } else {\n            let mut count = m.get(&n).unwrap().clone();\n\
    \            count += 1;\n            m.insert(n, count);\n        }\n    }\n\
    \    for (k, v) in m.iter() {\n        if k >= v {\n            return k.clone();\n\
    \        }\n    }\n    -1", "    let mut v = lst.clone();\n    v.sort();\n   \
    \ v.dedup();\n    for i in v {\n        if lst.iter().filter(|x| **x == i).count()\
    \ >= i as usize {\n            return i;\n        }\n    }\n    -1", "    let\
    \ mut m: HashMap<isize, isize> = HashMap::new();\n    for i in lst {\n       \
    \ *m.entry(i).or_insert(0) += 1;\n    }\n    for k in 1..100 {\n        if m.contains_key(&k)\
    \ && k <= *m.get(&k).unwrap() {\n            return k;\n        }\n    }\n   \
    \ -1", "    use std::collections::HashMap;\n    if lst.len() == 0 {\n        return\
    \ -1;\n    }\n    let mut map = HashMap::new();\n    for e in lst {\n        *map.entry(e).or_insert(0)\
    \ += 1;\n    }\n    let mut acc = Vec::new();\n    for e in lst {\n        if\
    \ let Some(v) = map.get(&e) {\n            if e > 0 && e as isize <= *v {\n  \
    \              acc.push(e);\n            }\n        }\n    }\n    if acc.len()\
    \ == 0 {\n        return -1;\n    }\n    acc.sort();\n    acc[acc.len() - 1]",
  "    let l = lst.len();\n    if l == 0 {\n        return -1;\n    }\n    let mut\
    \ arr = vec![0; l as usize];\n    for i in lst {\n        if i > 0 {\n       \
    \     let i: usize = i as usize;\n            if i > l {\n                continue;\n\
    \            }\n            arr[i-1] += 1;\n        }\n    }\n    let mut max\
    \ = 0;\n    for i in 0..l {\n        if arr[i] >= i+1 && arr[i] > arr[max] {\n\
    \            max = i;\n        }\n    }\n    if arr[max] == 0 {\n        return\
    \ -1;\n    }\n    (max+1) as isize", "    // Convert the given list to a hash\
    \ map and a list of keys.\n    let freq = lst.iter().fold(HashMap::new(), |mut\
    \ acc, &key| {\n        let count = acc.entry(key).or_insert(0);\n        *count\
    \ += 1;\n        acc\n    });\n    let keys: Vec<isize> = freq.keys().map(|&x|\
    \ x).collect();\n\n    // Find the keys which satisfy the criteria and return\
    \ the biggest one.\n    let result = keys.iter().filter(|&&x| x <= freq[&x]).max();\n\
    \    match result {\n        Some(result) => *result,\n        None => -1,\n \
    \   }", '    // ...', '    unimplemented!()', "  lst.iter().cloned().fold(vec![0;\
    \ 10], |mut acc, cur| {\n    acc[cur as usize] += 1;\n    acc\n  }).iter().enumerate().rev().fold(-1,\
    \ |cur, (i, &n)| if n >= i as isize { i as isize } else { cur })", "    let mut\
    \ seen: HashMap<isize, usize> = HashMap::new();\n    for num in lst {\n      \
    \  *seen.entry(num).or_insert(0) += 1;\n    }\n    let mut max = -1;\n    for\
    \ (key, count) in seen {\n        if count >= key as usize && key > max {\n  \
    \          max = key;\n        }\n    }\n    max", "    // Use BTreeMap as a frequency\
    \ map\n    let mut freq = BTreeMap::new();\n    // O(n)\n    for &n in &lst {\n\
    \        *freq.entry(n).or_insert(0) += 1;\n    }\n    // O(n)\n    for &n in\
    \ &lst {\n        if n > 0 && n <= *freq.get(&n).unwrap() {\n            return\
    \ n;\n        }\n    }\n    -1", "    let counter = lst.iter().fold(HashMap::new(),\
    \ |mut acc, x| {\n        let c = acc.entry(x).or_insert(0);\n        *c += 1;\n\
    \        acc\n    });\n    let lst = lst.into_iter().max().unwrap();\n    (1..=lst).rev().find(|x|\
    \ counter.get(x).unwrap_or(&0) >= x).unwrap_or(-1)", "    let mut count: HashMap<isize,\
    \ isize> = HashMap::new();\n    for item in lst {\n        *count.entry(item).or_insert(0)\
    \ += 1;\n    }\n    let mut result = -1;\n    for (k, v) in count {\n        if\
    \ k <= v && k > result {\n            result = k;\n        }\n    }\n    result",
  "    // your code\n    lst.iter().fold(HashMap::new(), |mut acc, &v| {\n       \
    \ *acc.entry(v).or_insert(0) += 1;\n        acc\n    }).into_iter().filter(|(k,\
    \ v)| k >= v).max_by_key(|(k, v)| *k).map(|(k, _)| k).unwrap_or(-1)", "    let\
    \ mut frequency: Vec<isize> = vec![0;lst.len()+1];\n    for number in lst {\n\
    \        frequency[number as usize] = frequency[number as usize] + 1;\n    }\n\
    \    for index in (1..frequency.len()).rev() {\n        if frequency[index] >=\
    \ index as isize {\n            return index as isize;\n        }\n    }\n   \
    \ return -1;", "    let mut greatest_map = HashMap::new();\n    let mut greatest_num\
    \ = -1;\n    let mut greatest_count = 0;\n    for num in lst {\n        let count\
    \ = greatest_map.entry(num).or_insert(0);\n        *count += 1;\n        if *count\
    \ >= num && num > greatest_num {\n            greatest_num = num;\n          \
    \  greatest_count = *count;\n        }\n    }\n    if greatest_count < greatest_num\
    \ {\n        return -1;\n    }\n    greatest_num", "    let mut max_freq = 0;\n\
    \    let mut max_int = 0;\n    let mut freq_map = HashMap::new();\n    for num\
    \ in lst {\n        let freq = match freq_map.get(&num) {\n            Some(x)\
    \ => x + 1,\n            None => 1,\n        };\n        freq_map.insert(num,\
    \ freq);\n        if freq >= num && freq > max_freq {\n            max_freq =\
    \ freq;\n            max_int = num;\n        }\n    }\n    if max_freq == 0 {\n\
    \        -1\n    } else {\n        max_int\n    }", "    if lst.is_empty() {\n\
    \        return -1;\n    }\n    let mut result = -1;\n    let mut map = HashMap::new();\n\
    \    for i in &lst {\n        if let Some(val) = map.get_mut(i) {\n          \
    \  *val += 1;\n        } else {\n            map.insert(*i, 1);\n        }\n \
    \   }\n    map.retain(|k, v| *k <= *v);\n    if !map.is_empty() {\n        result\
    \ = *map.keys().max().unwrap();\n    }\n    result", "    let frequency = lst.iter().fold(HashMap::new(),\
    \ |mut acc, &v| {\n        *acc.entry(v).or_insert(0) += 1;\n        acc\n   \
    \ });\n    let max_value = *frequency.keys().max().unwrap();\n    for n in (1..max_value\
    \ + 1).rev() {\n        match frequency.get(&n) {\n            Some(m) if n <=\
    \ *m => return n,\n            _ => continue,\n        }\n    }\n    -1", "  \
    \  use std::collections::HashMap;\n    let mut map = HashMap::new();\n    for\
    \ i in lst {\n        *map.entry(i).or_insert(0) += 1;\n    }\n    map.into_iter()\n\
    \        .filter(|&(i, freq)| freq >= i)\n        .map(|(i, _)| i)\n        .max()\n\
    \        .unwrap_or(-1)", "    let mut max_val = -1;\n    let mut val_map = HashMap::new();\n\
    \    for i in lst {\n        val_map.entry(i).and_modify(|x| *x += 1).or_insert(1);\n\
    \    }\n    for (k, v) in val_map {\n        if v >= k && k > max_val {\n    \
    \        max_val = k;\n        }\n    }\n    max_val", "    let len = lst.len();\n\
    \    if len == 0 {\n        return -1;\n    }\n    let mut freq = HashMap::new();\n\
    \    let mut max = -1;\n    for i in lst {\n        *freq.entry(i).or_insert(0)\
    \ += 1;\n        if i > max {\n            max = i;\n        }\n    }\n    if\
    \ freq.get(&max).unwrap() == &max {\n        return max;\n    }\n    for i in\
    \ (1..max).rev() {\n        if freq.get(&i).unwrap() >= &i {\n            return\
    \ i;\n        }\n    }\n    -1", "    let mut map: HashMap<isize, isize> = HashMap::new();\n\
    \    for i in lst {\n        *map.entry(i).or_insert(0) += 1;\n    }\n    let\
    \ mut res = -1;\n    for i in &map {\n        if *i.1 >= *i.0 && *i.0 > res {\n\
    \            res = *i.0;\n        }\n    }\n    res", "    let mut freq: HashMap<isize,\
    \ isize> = HashMap::new();\n    let mut res: isize = -1;\n    let mut max: isize\
    \ = 0;\n    for x in lst {\n        if !freq.contains_key(&x) {\n            freq.insert(x,\
    \ 1);\n        } else {\n            let mut tmp = freq.get(&x).unwrap();\n  \
    \          *tmp += 1;\n            freq.insert(x, *tmp);\n        }\n    }\n \
    \   for (k, v) in freq {\n        if k >= v && v > max {\n            max = v;\n\
    \            res = k;\n        }\n    }\n    res", "    let mut map: HashMap<isize,\
    \ isize> = HashMap::new();\n    for &i in &lst {\n        *map.entry(i).or_insert(0)\
    \ += 1;\n    }\n    let mut max = -1;\n    for (&i, &count) in &map {\n      \
    \  if i > count {\n            continue;\n        }\n        if i > max {\n  \
    \          max = i;\n        }\n    }\n    max", "    let mut counter = std::collections::HashMap::new();\n\
    \    for x in lst {\n        *counter.entry(x).or_insert(0) += 1;\n    }\n   \
    \ let mut max = -1;\n    for (&x, c) in counter.iter() {\n        if x > max &&\
    \ x <= *c {\n            max = x;\n        }\n    }\n    max", "    let mut sorted\
    \ = lst.clone();\n    sorted.sort();\n    let max = sorted.last().unwrap();\n\
    \    let counts = {\n        let mut counts = HashMap::new();\n        for n in\
    \ lst {\n            let count = counts.entry(n).or_insert(0);\n            *count\
    \ += 1;\n        }\n        counts\n    };\n    for n in (1..*max).rev() {\n \
    \       let count = counts.get(&n).unwrap();\n        if *count >= n {\n     \
    \       return n;\n        }\n    }\n    -1", "    let mut h: HashMap<isize, isize>\
    \ = HashMap::new();\n    for i in lst {\n        let c = h.entry(i).or_insert(0);\n\
    \        *c += 1;\n    }\n    let mut m: isize = -1;\n    for (k, v) in h.iter()\
    \ {\n        if *k > v && v >= k {\n            m = std::cmp::max(m, *k);\n  \
    \      }\n    }\n    m", "    lst.iter().fold(HashMap::new(), |mut acc, item|\
    \ {\n        let counter = acc.entry(item).or_insert(0);\n        *counter +=\
    \ 1;\n        acc\n    })\n    .iter()\n    .filter(|(key, val)| {\n        if\
    \ **key > 0 && **val >= **key {\n            true\n        } else {\n        \
    \    false\n        }\n    })\n    .map(|(key, _)| key)\n    .max()\n    .unwrap_or(&-1)\n\
    \    .clone()", "    let mut lst: Vec<isize> = lst;\n    lst.sort();\n    let\
    \ mut count = 1;\n    let mut max = -1;\n    let mut last = lst[0];\n    for i\
    \ in lst {\n        if i == last {\n            count += 1;\n        } else {\n\
    \            count = 1;\n            last = i;\n        }\n        if count >=\
    \ i {\n            max = i;\n        }\n    }\n    max", "    // Your code here\n\
    \    let mut result: isize = -1;\n    for i in 1..(lst.len() + 1) {\n        let\
    \ mut count: usize = 0;\n        for j in 0..lst.len() {\n            if lst[j]\
    \ == i as isize {\n                count += 1;\n            }\n        }\n   \
    \     if count >= i && count >= result as usize {\n            result = i as isize;\n\
    \        }\n    }\n    result", "    let mut res = -1;\n    let mut map = HashMap::new();\n\
    \    for i in lst {\n        *map.entry(i).or_insert(0) += 1;\n    }\n    for\
    \ (k, v) in map {\n        if k <= v && k > res {\n            res = k;\n    \
    \    }\n    }\n    res", "    let mut map = std::collections::HashMap::new();\n\
    \    for x in lst {\n        let count = map.entry(x).or_insert(0);\n        *count\
    \ += 1;\n    }\n    let mut res = -1;\n    for (&key, &val) in &map {\n      \
    \  if key > 0 && key <= val && key > res {\n            res = key;\n        }\n\
    \    }\n    res", "    let mut num_frequencies = Vec::new();\n    for num in lst\
    \ {\n        if num_frequencies.len() < num as usize {\n            num_frequencies.resize(num\
    \ as usize, 0);\n        }\n        num_frequencies[num as usize - 1] += 1;\n\
    \    }\n    for num in lst {\n        if num_frequencies[num as usize - 1] >=\
    \ num {\n            return num;\n        }\n    }\n    -1", "    let mut maximum:\
    \ isize = -1;\n    let mut largest: usize = 0;\n    let mut counter: isize = 0;\n\
    \    let mut temp_arr: Vec<isize> = vec![];\n    let mut arr: Vec<isize> = vec![];\n\
    \    for i in lst {\n        temp_arr.push(i);\n    }\n    for i in lst {\n  \
    \      for j in temp_arr.iter_mut() {\n            if i == *j {\n            \
    \    counter += 1;\n                *j = 0;\n            }\n        }\n      \
    \  if counter > 0 {\n            if counter >= i as usize {\n                arr.push(i);\n\
    \            }\n        }\n        counter = 0;\n    }\n    for i in arr {\n \
    \       if i as usize > largest {\n            largest = i as usize;\n       \
    \     maximum = i;\n        }\n    }\n    maximum", "    let mut map = HashMap::new();\n\
    \    for v in lst {\n        let count = map.entry(v).or_insert(0);\n        *count\
    \ += 1;\n    }\n    let mut result = -1;\n    for (k, v) in map {\n        if\
    \ v >= k && k > result {\n            result = k;\n        }\n    }\n    result",
  "    if lst.is_empty() {\n        return -1;\n    }\n    let mut lst = lst;\n  \
    \  lst.sort();\n    lst.dedup();\n    let mut result = -1;\n    for num in lst\
    \ {\n        if num < 0 {\n            continue;\n        }\n        let mut count\
    \ = 0;\n        for num_ in lst.iter() {\n            if num_ == &num {\n    \
    \            count += 1;\n            }\n        }\n        if num as usize <=\
    \ count {\n            result = num;\n        }\n    }\n    result", "    let\
    \ mut max_i = -1;\n    let mut count = 0;\n    let mut max_count = 0;\n    for\
    \ (i, num) in lst.iter().enumerate() {\n        if *num == lst[i - 1] {\n    \
    \        count += 1;\n        } else {\n            count = 1;\n        }\n  \
    \      if count >= *num && count > max_count {\n            max_count = count;\n\
    \            max_i = i;\n        }\n    }\n    if max_i == -1 {\n        return\
    \ -1;\n    }\n    lst[max_i]", "    let mut m: HashMap<isize, isize> = HashMap::new();\n\
    \    for i in lst {\n        let c = m.entry(i).or_insert(0);\n        *c += 1;\n\
    \    }\n    let mut r: Vec<isize> = m.into_iter().filter(|&(_,v)| v >= &_).map(|(&k,_)|\
    \ k).collect();\n    r.sort();\n    if r.is_empty() {\n        return -1;\n  \
    \  }\n    r.into_iter().rev().nth(0).unwrap()", "    lst.iter().fold(HashMap::new(),\
    \ |mut acc, num| {\n        *acc.entry(*num).or_insert(0) += 1;\n        acc\n\
    \    })\n    .iter()\n    .fold(Vec::new(), |mut acc, (num, freq)| {\n       \
    \ if *num > 0 && *freq >= *num {\n            acc.push(*num);\n        }\n   \
    \     acc\n    })\n    .iter()\n    .max()\n    .unwrap_or(&-1)\n    .clone()",
  "    let mut count = vec![0; lst.len()];\n    let mut result = -1;\n    for num\
    \ in lst {\n        if num <= lst.len() as isize {\n            count[(num - 1)\
    \ as usize] += 1;\n        }\n    }\n    for i in 0..lst.len() {\n        if count[i]\
    \ >= i as isize + 1 {\n            result = i as isize + 1;\n        }\n    }\n\
    \    result", '    lst.iter().map(|i| (i, lst.iter().filter(|&j| j == i).count()
    as isize)).filter(|&(i, c)| c >= *i).max_by_key(|&(_, c)| c).map(|(i, _)| *i).unwrap_or(-1)',
  '    -1', "    // your code here\n    let mut count = 0;\n    let mut max_num =\
    \ 0;\n    for i in 0..lst.len() {\n        let count_this = lst.iter().filter(|&n|\
    \ *n == lst[i]).count();\n        if lst[i] == count_this as isize && count_this\
    \ as isize > max_num {\n            count = count_this;\n            max_num =\
    \ lst[i];\n        }\n    }\n    if count == 0 {\n        -1\n    } else {\n \
    \       max_num\n    }", "    let mut hash: HashMap<isize, usize> = HashMap::new();\n\
    \    let mut max_count = 0;\n    let mut result = -1;\n    for i in lst {\n  \
    \      *hash.entry(i).or_insert(0) += 1;\n        if i > max_count && hash[&i]\
    \ >= i as usize {\n            max_count = i;\n            result = i;\n     \
    \   }\n    }\n    result", "    // your code\n    -1", "    // TODO\n    -1",
  "    let mut counts = HashMap::new();\n    for item in lst {\n        let counter\
    \ = counts.entry(item).or_insert(0);\n        *counter += 1;\n    }\n    for (item,\
    \ counter) in counts {\n        if item <= counter && item > 0 {\n           \
    \ return item;\n        }\n    }\n    -1", "    if lst.len() < 2 {\n        return\
    \ -1;\n    }\n    let mut freq = HashMap::new();\n    for e in lst {\n       \
    \ let counter = freq.entry(e).or_insert(0);\n        *counter += 1;\n    }\n \
    \   let mut res = -1;\n    for (e, f) in freq {\n        if e > 0 && f >= e {\n\
    \            res = cmp::max(res, e);\n        }\n    }\n    res"]
stop_tokens:
- "\n}"
