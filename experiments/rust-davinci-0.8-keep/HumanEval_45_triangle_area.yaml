name: HumanEval_45_triangle_area
language: rust
prompt: "/// Given length of a side and high return area for a triangle.\n/// >>>\
  \ triangle_area(5, 3)\n/// 7.5\nfn triangle_area(a: isize, h: isize) -> f64 {\n"
tests: "}\n\nfn main() {\n    let candidate = triangle_area;\n    assert_eq!(candidate(5,\
  \ 3), 7.5);\n    assert_eq!(candidate(2, 2), 2.0);\n    assert_eq!(candidate(10,\
  \ 8), 40.0);\n}\n"
completions: ['    (a as f64) * (h as f64) / 2.0', '    a as f64 * h as f64 / 2.0',
  '    ((a as f64) * (h as f64)) / 2f64', "    let res = 0.5 * a as f64 * h as f64;\n\
    \    res", "    let area = (a as f64 * h as f64) / 2.0;\n    area", '    (a as
    f64 * h as f64) / 2.0', '    0.5 * a as f64 * h as f64', "    let a = a as f64;\n\
    \    let h = h as f64;\n    (a * h) / 2.0", "    let res = a as f64 * h as f64\
    \ * 0.5;\n    println!(\"{}\", res);\n    res", '    (a as f64 * h as f64) / 2.0',
  '    ((a * h) as f64) / 2.0', '    (a as f64) * (h as f64) / 2.0', '    ((a * h)
    as f64) / 2.0', '    (a as f64 * h as f64) / 2.0', '    f64::from(a) * f64::from(h)
    / 2.0', '  (a as f64 * h as f64) / 2f64', "    if a < 0 || h < 0 {\n        return\
    \ 0f64;\n    }\n    ((a as f64) * (h as f64)) / 2f64", '    (a as f64 * h as f64)
    / 2.0', "    // a is side, h is high\n    let area = (a as f64 * h as f64) / 2.0;\n\
    \    area", '    ((a as f64 / 2.0) * h as f64).abs()', '    a as f64 * h as f64
    / 2 as f64', '    a as f64 * h as f64 / 2.0', "    // input\n    assert!(a > 0);\n\
    \    assert!(h > 0);\n    // output\n    (a * h / 2) as f64", "    let area =\
    \ 0.5 * (a as f64) * (h as f64);\n    println!(\"Area: {}\", area);\n    area",
  '  (a as f64 * h as f64) / 2.0', "    let a: f64 = a as f64;\n    let h: f64 = h\
    \ as f64;\n    0.5 * a * h", '    a as f64 * h as f64 / 2.0', '    ((a as f64)
    * (h as f64)) / 2.0', '    0.5 * (a as f64) * (h as f64)', '    (a as f64 * h
    as f64) / 2.0', "    // calculate the area of triangle\n    (a as f64 * h as f64)\
    \ / 2.0", '    (a as f64 * h as f64) / 2.0', '    0.5 * a as f64 * h as f64',
  '    0.5 * (a as f64) * (h as f64)', "    let res = (a as f64) * (h as f64) / 2.0;\n\
    \    res", '    (a as f64) * (h as f64) / 2.0', '    (0.5 * a as f64 * h as f64)
    as f64', '    (a as f64 * h as f64) / 2.0', '    ((a as f64) * (h as f64)) / 2.0',
  "    let area = (a as f64) * (h as f64) / 2.0;\n    area", "    let s = a as f64;\n\
    \    let h = h as f64;\n    0.5 * s * h", '    (a as f64) * (h as f64) / 2.0',
  '    0.5 * a as f64 * h as f64', "    let res = (a * h) as f64 / 2.0;\n    res",
  "    if a <= 0 || h <= 0 {\n        return 0.0;\n    }\n    (a as f64 * h as f64)\
    \ / 2.0", '    f64::from(a * h) / 2f64', '    ((a as f64) * (h as f64)) / 2.0',
  '    (a as f64 * h as f64) / 2.0', '    a as f64 * h as f64 / 2.0', '    (a as f64
    * h as f64) / 2.0', '    return 0.5 * a as f64 * h as f64;', "  let A = (a * h)\
    \ as f64 / 2_f64;\n  A", "    let triangle_area = 0.5 * a as f64 * h as f64;\n\
    \    triangle_area", '    (a as f64 * h as f64) / 2.0', '    (a as f64 * h as
    f64) / 2.0', "    if a <= 0 || h <= 0 {\n        panic!(\"Side a cannot be less\
    \ than 0!\");\n    }\n    let result = 0.5 * a as f64 * h as f64;\n    result",
  '    (a as f64 * h as f64 / 2.0)', '    0.5 * a as f64 * h as f64', '    (a as f64)
    * (h as f64) / 2.0', '    return a as f64 * h as f64 / 2.0;', '    (a as f64 *
    h as f64) / 2.0', '    (a as f64) * (h as f64) / 2.0', '    (a as f64) * (h as
    f64) / 2.0', '    a as f64 * h as f64 / 2.0', '    (a as f64 * h as f64) / 2.0',
  '    (a as f64) * (h as f64) / 2.0', "    // TODO: Fill this function according\
    \ to docstring\n    (a * h) as f64 / 2.0", '    (a as f64 * h as f64) / 2.0',
  '    ((a as f64 / 2.0) * h as f64).round() / 2.0', '    (a as f64 * h as f64 / 2.0).floor()',
  '    (a as f64 * h as f64) / 2.0', "    let area = 0.5 * a as f64 * h as f64;\n\
    \    area", '    return (a as f64) * (h as f64) / 2.0;', '    (a as f64 * h as
    f64) / 2.0', '    ((a as f64) * (h as f64)) / 2.0', "    let x = a as f64;\n \
    \   let y = h as f64;\n    x * y / 2.0", '    a as f64 * h as f64 / 2.0', '    (a
    as f64) * (h as f64) / 2.0', "    let a = a as f64;\n    let h = h as f64;\n \
    \   let area = a * h / 2.0;\n    area", '    (a as f64 * h as f64 / 2_f64).abs()',
  "    let a = a as f64;\n    let h = h as f64;\n    a * h / 2.0", '    (a as f64)
    * (h as f64) / 2.0', '    a as f64 * h as f64 / 2.0', "    let a = a as f64;\n\
    \    let h = h as f64;\n    (a * h) / 2.0", '    (a as f64 * h as f64) / 2f64',
  '    (0.5 * a as f64 * h as f64) as f64', '    unimplemented!();', '    a as f64
    * h as f64 / 2.0', "    let area = (a as f64 * h as f64) / 2.0;\n    area", '    0.5
    * (a as f64) * (h as f64)', '    (a as f64 * h as f64) / 2.0', '    unimplemented!();',
  '    (a as f64 * h as f64) / 2.0', '    0.5 * a as f64 * h as f64', '    (a as f64)
    * (h as f64) / 2.0', '    (a as f64) * (h as f64) / 2.0', "    let float_a = a\
    \ as f64;\n    let float_h = h as f64;\n    (float_a * float_h) / 2.0", '    (a
    as f64 * h as f64) / 2.0', '    (a as f64) * (h as f64) / 2.0', '    (a as f64
    * h as f64) / 2.0', "    let a = a as f64;\n    let h = h as f64;\n    (a * h)\
    \ / 2.0", '    (a as f64) * (h as f64) / 2.0', '    ((a * h) as f64 / 2.0).abs()',
  '    f64::from(a * h) / 2.0', "    let area = (a as f64 * h as f64) / 2f64;\n  \
    \  return area;", '    (a as f64 * h as f64) / 2.0', '    (a as f64) * (h as f64)
    / 2.0', '    (a as f64 * h as f64) / 2.0', '    unimplemented!()', '    unimplemented!()',
  "    let area = (a as f64) * (h as f64) / 2.0;\n    area", '    0.5 * a as f64 *
    h as f64', '    a as f64 * h as f64 / 2.0', '    (a as f64 * h as f64 / 2.0).abs()',
  "    let area = (a as f64 * h as f64) / 2.0;\n    area", '    (a as f64 * h as f64)
    / 2.0', '    ((a as f64) * (h as f64)) / 2.0', '    (a as f64 * h as f64 / 2.0).round()',
  '    (a as f64) * (h as f64) / 2.0', '    (a as f64 * h as f64) / 2.0', "    //\
    \ TODO\n    let x = a * h;\n    x as f64 / 2.0", '    ((a as f64) * (h as f64))
    / 2f64', '    (a as f64 * h as f64) / 2.0', '    (a as f64 * h as f64) / 2.0',
  '    return (a as f64) * (h as f64) / 2.0;', '    (a as f64 * h as f64) / 2.0',
  '    (a as f64 * h as f64) / 2.0', '    a as f64 * h as f64 / 2.0', '    ((a as
    f64) * (h as f64)) / 2.0', '    (a as f64) * (h as f64) / 2.0', '    (a as f64)
    * (h as f64) / 2.0', '    (0.5 * a as f64 * h as f64) as f64', '    (a as f64
    * h as f64) / 2.0', '    return (a as f64) * (h as f64) / 2.0;', '    ((a * h)
    as f64) / 2.0', "    let area = (a as f64 * h as f64) / 2 as f64;\n    area",
  '    a as f64 * h as f64 / 2.0', '    return ((a as f64) * (h as f64)) / 2.0;',
  '    (a as f64 * h as f64) / 2.0', '    unimplemented!()', '    (0.5 * a as f64
    * h as f64) as f64', '    return (a as f64 * h as f64) / 2.0;', '    0.5 * a as
    f64 * h as f64', '    (a as f64 * h as f64) / 2.0', '    a as f64 * h as f64 /
    2.0', '    (a as f64) * (h as f64) / 2.0', "    // First we compute by casting\
    \ both arguments to f64.\n    let result = (a as f64) * (h as f64) / 2.0;\n  \
    \  // then we print it.\n    println!(\"triangle area with f64: {}\", result);\n\
    \    // and we return it.\n    result", '    (a as f64 * h as f64) / 2.0', " \
    \   let float_a = a as f64;\n    let float_h = h as f64;\n    0.5 * float_a *\
    \ float_h", "    let res = (a * h) as f64;\n    res / 2.0", '    0.5 * a as f64
    * h as f64', '    0.5*(a as f64)*(h as f64)', '    (a as f64 * h as f64) / 2.0',
  '    0.5 * (a as f64) * (h as f64)', "    let a = a as f64;\n    let h = h as f64;\n\
    \    (a * h) / 2.0", '    (a as f64 * h as f64) / 2.0', '    (a as f64) * (h as
    f64) / 2.0', "    let  area: f64 = ((a as f64) * (h as f64)) / 2.0;\n    area",
  '    (a as f64 * h as f64) / 2.0', '    (a as f64) * (h as f64) / 2.0', '    (a
    as f64) * (h as f64) / 2.0', '    return (0.5 * a as f64 * h as f64).round();',
  '    a as f64 * h as f64 / 2 as f64', '    (a as f64) * (h as f64) / 2.0', '    (a
    as f64 * h as f64) / 2.0', "    let area = (a as f64 * h as f64) / 2f64;\n   \
    \ area", '    return a as f64 * h as f64 / 2.0;', '    (a as f64 * h as f64) /
    2.0', '    (a as f64 * h as f64) / 2.0', "  if a <= 0 || h <= 0 {\n    return\
    \ 0.0;\n  }\n  (a as f64 * h as f64) / 2.0", '    (a as f64 * h as f64) / 2.0',
  '    (a as f64 * h as f64) / 2.0', '    (a as f64 * h as f64) / 2.0', '    (0.5
    * a as f64 * h as f64) as f64', '    (a as f64 * h as f64) / 2.0', '    ((a as
    f64) * (h as f64)) / 2.0', '    ((a as f64) * (h as f64)) / 2.0', '    a as f64
    * h as f64 / 2f64', '    (a as f64 * h as f64) / 2.0', '    (a as f64 * h as f64)
    / 2.0', '    ((a as f64) * (h as f64)) / 2.0', "    let t_area = (a as f64) *\
    \ (h as f64) / 2.0;\n    t_area", '    ((a as f64) * (h as f64)) / 2_f64', '    unimplemented!()',
  "    if a < 0 || h < 0 {\n        return 0.0;\n    }\n    return (a as f64 * h as\
    \ f64) / 2.0;", '    (a as f64 * h as f64) / 2.0', '    (a as f64 * h as f64 /
    2.0).round() / 1.0', '    (a as f64 * h as f64) / 2f64', '    a as f64 * h as
    f64 / 2 as f64', '    (a as f64 * h as f64) / 2.0', '    (a as f64 * h as f64)
    / 2.0', "    let a = a as f64;\n    let h = h as f64;\n    a * h / 2.0", "   \
    \ let a = a as f64;\n    let h = h as f64;\n    (a * h) / 2.0", '    return (0.5
    * a as f64 * h as f64) as f64;', "    let a_f64 = a as f64;\n    let h_f64 = h\
    \ as f64;\n    a_f64 * h_f64 / 2.0", '    (a as f64 * h as f64) / 2.0', '    (a
    as f64 * h as f64 / 2.0).abs()', '    (a as f64) * (h as f64) / 2.0', '    ((a
    as f64) * (h as f64)) as f64 / 2.0', '    (a as f64 * h as f64) / 2.0']
stop_tokens:
- "\n}"
