name: HumanEval_10_make_palindrome
language: rust
results:
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reverse\
    \ = string.chars().rev().collect::<String>();\n    let mut tail = String::new();\n\
    \    let mut prefix = String::new();\n    let mut suffix = String::new();\n  \
    \  let mut string = string;\n    while string != reverse {\n        tail = string.pop().unwrap().to_string();\n\
    \        prefix.push_str(&tail);\n        reverse.pop();\n        suffix.push_str(&reverse);\n\
    \        reverse = suffix.chars().rev().collect::<String>();\n        suffix.clear();\n\
    \    }\n    string.push_str(&prefix);\n    string\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"zyx\"`,\n right: `\"xyzyx\"`', /tmp/tmp4p0jwn_p.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    // One letter\
    \ is trivially a palindrome.\n    if string.len() == 1 {\n        return string;\n\
    \    }\n\n    // Use a longest common prefix function to find the longest postfix\
    \ that is a palindrome.\n    let rev_string = string.chars().rev().collect::<String>();\n\
    \    let lcp = longest_common_prefix(string.as_str(), rev_string.as_str());\n\n\
    \    // Append to the string the reverse of a string prefix that comes before\
    \ the palindromic suffix.\n    let prefix = &string[0..string.len() - lcp.len()];\n\
    \    let rev_prefix = prefix.chars().rev().collect::<String>();\n    format!(\"\
    {}{}{}\", string, rev_prefix, lcp)\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `longest_common_prefix` in this scope\n\
    \  --> /tmp/tmpwpw7pzlm.rs:19:15\n   |\n19 |     let lcp = longest_common_prefix(string.as_str(),\
    \ rev_string.as_str());\n   |               ^^^^^^^^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return string;\n    }\n\n    let mut string = string;\n    let suffix\
    \ = get_palindromic_postfix(&string);\n    let prefix = get_prefix(&string, &suffix);\n\
    \    string.push_str(&get_reverse(&prefix));\n    string\n}\n\nfn main() {\n \
    \   let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `get_palindromic_postfix` in this scope\n\
    \  --> /tmp/tmpp2wii_qj.rs:17:18\n   |\n17 |     let suffix = get_palindromic_postfix(&string);\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `get_prefix` in this scope\n  --> /tmp/tmpp2wii_qj.rs:18:18\n\
    \   |\n18 |     let prefix = get_prefix(&string, &suffix);\n   |             \
    \     ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `get_reverse` in this scope\n  --> /tmp/tmpp2wii_qj.rs:19:22\n   |\n19 |   \
    \  string.push_str(&get_reverse(&prefix));\n   |                      ^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut substrings\
    \ = get_substrings(string);\n    substrings.sort_by(|a, b| a.chars().count().cmp(&b.chars().count()));\n\
    \    // Now, we just look for the longest palindrome that is a suffix of the string\n\
    \    substrings.reverse();\n    // Have to compare the reversed string to its\
    \ tail - the tail is guaranteed to be smaller than the whole string\n    let string_reversed\
    \ = string.chars().rev().collect::<String>();\n    for substring in substrings\
    \ {\n        if string_reversed.ends_with(&substring) {\n            // If a palindrome\
    \ suffix is found, we can stop looking for more\n            let head = string.split_off(string.len()\
    \ - substring.len());\n            return string + &head.chars().rev().collect::<String>();\n\
    \        }\n    }\n    // If no palindrome suffix has been found, the only palindrome\
    \ that can be made is a reversal of the string\n    string.chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `get_substrings` in this scope\n  -->\
    \ /tmp/tmpfz0nu2cb.rs:12:26\n   |\n12 |     let mut substrings = get_substrings(string);\n\
    \   |                          ^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut str_vec:\
    \ Vec<char> = string.chars().collect();\n    let mut palindrome_suffix = String::from(\"\
    \");\n    let mut palindrome_prefix = String::from(\"\");\n    for i in (0..str_vec.len()).rev()\
    \ {\n        if is_palindrome(&str_vec[i..]) {\n            palindrome_suffix\
    \ = str_vec[i..].iter().collect();\n            palindrome_prefix = str_vec[..i].iter().rev().collect();\n\
    \            break;\n        }\n    }\n    let mut palindrome = String::new();\n\
    \    palindrome.push_str(&string);\n    palindrome.push_str(&palindrome_prefix);\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpqzbse2sm.rs:16:12\n   |\n16 |         if is_palindrome(&str_vec[i..])\
    \ {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let length =\
    \ string.len();\n    let chars = string.chars().collect::<Vec<char>>();\n    let\
    \ mut longest_palindrome_end = 0;\n    let mut longest_palindrome_length = 0;\n\
    \    let mut end = 0;\n    while end < length {\n        if is_palindrome(&chars,\
    \ end, end) {\n            longest_palindrome_end = end;\n            longest_palindrome_length\
    \ = 1;\n        }\n        end += 1;\n    }\n    let mut left = longest_palindrome_end;\n\
    \    while left > 0 {\n        if chars[left - 1] == chars[longest_palindrome_end\
    \ + 1] {\n            if is_palindrome(&chars, left - 1, longest_palindrome_end\
    \ + 1) {\n                longest_palindrome_end = longest_palindrome_end + 1;\n\
    \                longest_palindrome_length = longest_palindrome_end - left + 1;\n\
    \            }\n        }\n        left -= 1;\n    }\n    let mut builder = String::with_capacity(2\
    \ * length);\n    for index in (0..longest_palindrome_end + 1 - longest_palindrome_length).rev()\
    \ {\n        builder.push(chars[index]);\n    }\n    for index in 0..length {\n\
    \        builder.push(chars[index]);\n    }\n    builder\n}\n\nfn main() {\n \
    \   let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp1qumcuuc.rs:18:12\n   |\n18 |         if is_palindrome(&chars, end,\
    \ end) {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_palindrome` in this scope\n  --> /tmp/tmp1qumcuuc.rs:27:16\n\
    \   |\n27 |             if is_palindrome(&chars, left - 1, longest_palindrome_end\
    \ + 1) {\n   |                ^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_prefix\
    \ = String::new();\n    let mut it = string.chars().rev();\n    loop {\n     \
    \   match it.next() {\n            Some(ch) => {\n                reversed_prefix.push(ch);\n\
    \                if is_palindrome(&string, &reversed_prefix) {\n             \
    \       break;\n                }\n            }\n            None => break,\n\
    \        }\n    }\n    format!(\"{}{}\", string, reversed_prefix)\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp7p3c5myh.rs:18:20\n   |\n18 |                 if is_palindrome(&string,\
    \ &reversed_prefix) {\n   |                    ^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    // First find longest palindromic suffix for the given string.\n\
    \    let mut suffix = vec![0; string.len()];\n    for i in (0..suffix.len()).rev()\
    \ {\n        let substring = &string[i..];\n        suffix[i] = if is_palindrome(substring)\
    \ {\n            substring.len()\n        } else {\n            0\n        };\n\
    \    }\n    // Now create a reverse of the prefix and append it to the original\
    \ string.\n    let mut prefix = vec![];\n    for i in 1..suffix.len() {\n    \
    \    let len = if i == suffix.len() - 1 {\n            suffix[i]\n        } else\
    \ {\n            suffix[i + 1]\n        };\n        if len > 0 {\n           \
    \ prefix.push_str(&string[i..i + len]);\n        }\n    }\n    string.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpc09cmqkz.rs:17:24\n   |\n17 |         suffix[i] = if is_palindrome(substring)\
    \ {\n   |                        ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `push_str` found for struct `Vec<_>` in the current scope\n\
    \  --> /tmp/tmpc09cmqkz.rs:32:20\n   |\n32 |             prefix.push_str(&string[i..i\
    \ + len]);\n   |                    ^^^^^^^^ help: there is an associated function\
    \ with a similar name: `push`\n\nerror[E0599]: no method named `chars` found for\
    \ struct `Vec<_>` in the current scope\n  --> /tmp/tmpc09cmqkz.rs:35:29\n   |\n\
    35 |     string.push_str(&prefix.chars().rev().collect::<String>());\n   |   \
    \                          ^^^^^ method not found in `Vec<_>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut rev = string.clone();\n    rev.reverse();\n    let mut\
    \ longest_palindrome = String::new();\n    for i in 0..string.len() {\n      \
    \  if string[i..].eq(&rev[string.len() - i..]) {\n            longest_palindrome\
    \ = string[i..].to_string();\n        }\n    }\n    string.push_str(&rev[..string.len()\
    \ - longest_palindrome.len()].chars().rev().collect::<String>());\n    string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpm4lp9wnt.rs:14:9\n   |\n14 |     rev.reverse();\n\
    \   |         ^^^^^^^ help: there is an associated function with a similar name:\
    \ `reserve`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return string;\n    }\n\n    let input_size = string.len();\n   \
    \ let mut postfix_end = input_size;\n    while !is_palindrome(&string[..postfix_end])\
    \ {\n        postfix_end -= 1;\n    }\n\n    let postfix_size = input_size - postfix_end;\n\
    \    let mut prefix = String::with_capacity(postfix_size);\n    for i in 0..postfix_size\
    \ {\n        prefix.push(string.chars().nth(postfix_size - i - 1).unwrap());\n\
    \    }\n\n    prefix + &string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp81e2rupy.rs:18:12\n   |\n18 |     while !is_palindrome(&string[..postfix_end])\
    \ {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let reversed\
    \ = string.chars().rev().collect::<String>();\n    if string == reversed {\n \
    \       return string;\n    }\n    let combined = string + &reversed;\n    let\
    \ mut longest_palindrome_length = 0;\n    let mut longest_palindrome_end = 0;\n\
    \    let mut previous_lengths = vec![0; combined.len()];\n    for (current_idx,\
    \ _) in combined.char_indices() {\n        let mut current_length = 0;\n     \
    \   if current_idx > 0 {\n            let mut low = current_idx - 1 - longest_palindrome_length;\n\
    \            let mut high = current_idx - 1;\n            while low >= 0 && high\
    \ < combined.len() && combined.chars().nth(low) == combined.chars().nth(high)\
    \ {\n                current_length += 1;\n                low -= 1;\n       \
    \         high += 1;\n            }\n            previous_lengths[current_idx\
    \ - 1] = current_length;\n            if current_idx + current_length - 1 > longest_palindrome_end\
    \ {\n                longest_palindrome_length = current_length;\n           \
    \     longest_palindrome_end = current_idx + current_length - 1;\n           \
    \ }\n        }\n    }\n    let mut result = string;\n    let mut cut_off = string.len()\
    \ - longest_palindrome_length;\n    while cut_off > 0 {\n        result = result\
    \ + &reversed[reversed.len() - cut_off..].to_string();\n        cut_off = cut_off\
    \ - previous_lengths[cut_off - 1];\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `string`\n  --> /tmp/tmp7z_a1be0.rs:37:22\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \       ------ move occurs because `string` has type `String`, which does not\
    \ implement the `Copy` trait\n...\n16 |     let combined = string + &reversed;\n\
    \   |                    ------ value moved here\n...\n37 |     let mut result\
    \ = string;\n   |                      ^^^^^^ value used here after move\n\nerror[E0382]:\
    \ borrow of moved value: `string`\n  --> /tmp/tmp7z_a1be0.rs:38:23\n   |\n11 |\
    \ fn make_palindrome(string: String) -> String {\n   |                    ------\
    \ move occurs because `string` has type `String`, which does not implement the\
    \ `Copy` trait\n...\n37 |     let mut result = string;\n   |                 \
    \     ------ value moved here\n38 |     let mut cut_off = string.len() - longest_palindrome_length;\n\
    \   |                       ^^^^^^^^^^^^ value borrowed here after move\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let input = string.into_bytes();\n\
    \    let mut output = Vec::new();\n    let mut palindrome_begin = 0;\n    let\
    \ mut palindrome_length = 0;\n    for i in 0..input.len() {\n        let mut begin\
    \ = i - palindrome_length - 1;\n        let mut length = palindrome_length + 2;\n\
    \        while begin >= 0 && input[begin] == input[i] {\n            begin -=\
    \ 1;\n            length += 1;\n        }\n        if length > palindrome_length\
    \ {\n            palindrome_begin = begin + 1;\n            palindrome_length\
    \ = length;\n        }\n    }\n    let prefix = &input[0..palindrome_begin];\n\
    \    let prefix_reversed = prefix.iter().rev();\n    output.extend(input.iter());\n\
    \    output.extend(prefix_reversed);\n    String::from_utf8(output).unwrap()\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpv3n3mx95.rs:17:25\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return string;\n    }\n\n    let (mut palindrome_end, mut palindrome_start)\
    \ = get_palindrome_bounds(&string);\n    let is_already_palindrome = palindrome_end\
    \ == palindrome_start;\n\n    if is_already_palindrome {\n        return string;\n\
    \    }\n\n    let prefix = string[..palindrome_start].chars().rev().collect::<String>();\n\
    \    let mut result = String::new();\n    result.push_str(&string);\n    result.push_str(&prefix);\n\
    \n    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `get_palindrome_bounds` in this scope\n\
    \  --> /tmp/tmpmj5u7f24.rs:16:54\n   |\n16 |     let (mut palindrome_end, mut\
    \ palindrome_start) = get_palindrome_bounds(&string);\n   |                  \
    \                                    ^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let reversed\
    \ = string.chars().rev().collect::<String>();\n    let string_len = string.len();\n\
    \    let mut index: usize = 0;\n    while index < string_len {\n        if string[index..]\
    \ == reversed[string_len - index..] {\n            break;\n        }\n       \
    \ index += 1;\n    }\n    string + &reversed[..string_len - index]\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xyz\"`,\n right: `\"xyzyx\"`', /tmp/tmpns67uz08.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let sl = string.len();\n\
    \    let mut n = sl;\n    while n > 0 {\n        let prefix = &string[..n];\n\
    \        let suffix = &string[sl - n..];\n        if prefix == suffix {\n    \
    \        break;\n        }\n        n -= 1;\n    }\n    let mut result = string;\n\
    \    let prefix = &string[..n];\n    result.push_str(prefix.chars().rev().collect::<String>().as_str());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `string`\n  --> /tmp/tmpr7y72qs0.rs:23:19\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \       ------ move occurs because `string` has type `String`, which does not\
    \ implement the `Copy` trait\n...\n22 |     let mut result = string;\n   |   \
    \                   ------ value moved here\n23 |     let prefix = &string[..n];\n\
    \   |                   ^^^^^^ value borrowed here after move\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return string;\n    }\n\n    let string_len = string.len();\n   \
    \ let mut prefix_len = 0;\n    while let Some(character) = string.chars().nth(prefix_len)\
    \ {\n        let suffix_len = string_len - prefix_len - 1;\n        if character\
    \ == string.chars().nth(suffix_len).unwrap() {\n            prefix_len += 1;\n\
    \        } else {\n            break;\n        }\n    }\n\n    // Remainder of\
    \ the string that is not in the palindromic prefix.\n    let remainder = string[prefix_len..].chars().rev().collect::<String>();\n\
    \    return string + &remainder;\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xyzzyx\"`,\n right: `\"xyzyx\"`', /tmp/tmpf9fj7t64.rs:36:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let string =\
    \ string.chars().collect::<Vec<char>>();\n    let mut result = Vec::new();\n \
    \   if let Some(suffix) = find_palindromic_suffix(&string) {\n        let prefix\
    \ = &string[..string.len() - suffix.len()];\n        let prefix = prefix.iter().rev();\n\
    \        result.extend(prefix);\n        result.extend(string);\n    } else {\n\
    \        result.extend(string);\n        result.extend(string.iter().rev());\n\
    \    }\n    result.iter().collect()\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_palindromic_suffix` in this scope\n\
    \  --> /tmp/tmp5y0kwuvl.rs:14:27\n   |\n14 |     if let Some(suffix) = find_palindromic_suffix(&string)\
    \ {\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return string;\n    }\n\n    let mut palindrome_suffix = find_palindrome_suffix(&string);\n\
    \    if palindrome_suffix.is_empty() {\n        return string;\n    }\n\n    let\
    \ prefix_to_reverse = &string[..string.len() - palindrome_suffix.len()];\n   \
    \ let reversed_prefix = prefix_to_reverse.chars().rev().collect::<String>();\n\
    \    return format!(\"{}{}{}\", string, reversed_prefix, palindrome_suffix);\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_palindrome_suffix` in this scope\n\
    \  --> /tmp/tmp0eeduk4m.rs:16:33\n   |\n16 |     let mut palindrome_suffix = find_palindrome_suffix(&string);\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    // Start with\
    \ the longest possible palindromic suffix.\n    let mut palindrome = string.clone();\n\
    \    for i in 0..string.len() {\n        let suffix = &string[i..];\n        let\
    \ prefix = &string[..i];\n        if is_palindrome(suffix) {\n            palindrome.push_str(prefix.chars().rev().collect::<String>().as_str());\n\
    \            break;\n        }\n    }\n    palindrome\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp1bznribs.rs:17:12\n   |\n17 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ help: a local variable with a similar name exists:\
    \ `palindrome`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut prefix_len\
    \ = 1;\n    let mut longest_match_len = 0;\n    let mut string = string.into_bytes();\n\
    \    let mut string_size = string.len();\n    let mut i = 0;\n    let mut matches\
    \ = Vec::new();\n    while prefix_len + i < string_size {\n        if string[i]\
    \ == string[string_size - prefix_len - 1] {\n            if let Some(match_len)\
    \ = matches.get(i) {\n                if *match_len == prefix_len {\n        \
    \            matches.push(prefix_len + 1);\n                    if prefix_len\
    \ + 1 > longest_match_len {\n                        longest_match_len = prefix_len\
    \ + 1;\n                    }\n                }\n            } else {\n     \
    \           matches.push(prefix_len);\n                if prefix_len > longest_match_len\
    \ {\n                    longest_match_len = prefix_len;\n                }\n\
    \            }\n        }\n        i += 1;\n        if i == string_size - prefix_len\
    \ {\n            prefix_len += 1;\n            i = 0;\n        }\n    }\n    for\
    \ j in 0..string_size - longest_match_len {\n        string.push(string[j]);\n\
    \    }\n    String::from_utf8(string).unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xx\"`,\n right: `\"x\"`', /tmp/tmpggj1ca0i.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let suffix = get_longest_palindrome_suffix(&string);\n    let\
    \ reversed_prefix = get_reverse_of_prefix(&string, suffix.len());\n    string.push_str(&reversed_prefix);\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `get_longest_palindrome_suffix` in this\
    \ scope\n  --> /tmp/tmp0om94qzy.rs:13:18\n   |\n13 |     let suffix = get_longest_palindrome_suffix(&string);\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `get_reverse_of_prefix` in this scope\n \
    \ --> /tmp/tmp0om94qzy.rs:14:27\n   |\n14 |     let reversed_prefix = get_reverse_of_prefix(&string,\
    \ suffix.len());\n   |                           ^^^^^^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut suffix_reversed\
    \ = String::new();\n    let mut string = string;\n    while !is_palindrome(&string)\
    \ {\n        suffix_reversed.push(string.pop().unwrap());\n    }\n    string +\
    \ &suffix_reversed\n}\n\nfn main() {\n    let candidate = make_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpnm_c0e9l.rs:14:12\n   |\n14 |     while !is_palindrome(&string) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let rev_string\
    \ = string.chars().rev().collect::<String>();\n    let lcs = LongestCommonSubsequence::new(&string,\
    \ &rev_string);\n    let palindrome_suffix = string.chars().skip(lcs.calculate()).collect::<String>();\n\
    \    return format!(\"{}{}\", string, palindrome_suffix);\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `LongestCommonSubsequence`\n\
    \  --> /tmp/tmpd9ep4d2h.rs:13:15\n   |\n13 |     let lcs = LongestCommonSubsequence::new(&string,\
    \ &rev_string);\n   |               ^^^^^^^^^^^^^^^^^^^^^^^^ use of undeclared\
    \ type `LongestCommonSubsequence`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let string =\
    \ string.as_bytes();\n    if string.len() <= 1 {\n        return string.to_vec().into_iter().collect();\n\
    \    }\n    let mut longest_palindrome_suffix = Vec::new();\n    let mut i = string.len()\
    \ - 1;\n    let mut j = string.len() - 1;\n    while j > 0 {\n        if string[i]\
    \ == string[j] {\n            longest_palindrome_suffix.push(string[i]);\n   \
    \         i -= 1;\n            j -= 1;\n        } else {\n            j -= 1;\n\
    \        }\n    }\n    if i < 0 {\n        return string.to_vec().into_iter().collect();\n\
    \    }\n    for k in 0..=i {\n        longest_palindrome_suffix.push(string[k]);\n\
    \    }\n    let mut prefix = longest_palindrome_suffix.clone();\n    prefix.reverse();\n\
    \    let mut result = string.to_vec();\n    result.extend_from_slice(&prefix);\n\
    \    result.into_iter().collect()\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `String` cannot be built from an iterator\
    \ over elements of type `u8`\n    --> /tmp/tmpuin67j0n.rs:14:44\n     |\n14  \
    \ |         return string.to_vec().into_iter().collect();\n     |            \
    \                                ^^^^^^^ value of type `String` cannot be built\
    \ from `std::iter::Iterator<Item=u8>`\n     |\n     = help: the trait `FromIterator<u8>`\
    \ is not implemented for `String`\n     = help: the following other types implement\
    \ trait `FromIterator<A>`:\n               <String as FromIterator<&'a char>>\n\
    \               <String as FromIterator<&'a str>>\n               <String as FromIterator<Box<str>>>\n\
    \               <String as FromIterator<Cow<'a, str>>>\n               <String\
    \ as FromIterator<String>>\n               <String as FromIterator<char>>\nnote:\
    \ required by a bound in `collect`\n\nerror[E0277]: a value of type `String` cannot\
    \ be built from an iterator over elements of type `u8`\n    --> /tmp/tmpuin67j0n.rs:29:44\n\
    \     |\n29   |         return string.to_vec().into_iter().collect();\n     |\
    \                                            ^^^^^^^ value of type `String` cannot\
    \ be built from `std::iter::Iterator<Item=u8>`\n     |\n     = help: the trait\
    \ `FromIterator<u8>` is not implemented for `String`\n     = help: the following\
    \ other types implement trait `FromIterator<A>`:\n               <String as FromIterator<&'a\
    \ char>>\n               <String as FromIterator<&'a str>>\n               <String\
    \ as FromIterator<Box<str>>>\n               <String as FromIterator<Cow<'a, str>>>\n\
    \               <String as FromIterator<String>>\n               <String as FromIterator<char>>\n\
    note: required by a bound in `collect`\n\nerror[E0277]: a value of type `String`\
    \ cannot be built from an iterator over elements of type `u8`\n    --> /tmp/tmpuin67j0n.rs:38:24\n\
    \     |\n38   |     result.into_iter().collect()\n     |                     \
    \   ^^^^^^^ value of type `String` cannot be built from `std::iter::Iterator<Item=u8>`\n\
    \     |\n     = help: the trait `FromIterator<u8>` is not implemented for `String`\n\
    \     = help: the follo"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut prefix\
    \ = String::new();\n    let mut suffix = String::new();\n    for (i, c) in string.chars().enumerate()\
    \ {\n        prefix.push(c);\n        suffix.insert(0, c);\n        if prefix\
    \ == suffix {\n            break;\n        }\n    }\n    prefix.push_str(&suffix);\n\
    \    prefix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xx\"`,\n right: `\"x\"`', /tmp/tmprz9l6apx.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return string;\n    }\n\n    let mut max_prefix_len = 0;\n    for\
    \ i in (0..string.len()).rev() {\n        let prefix = &string[0..i];\n      \
    \  let suffix = &string[i..];\n        if prefix == suffix.chars().rev().collect::<String>()\
    \ {\n            max_prefix_len = i;\n            break;\n        }\n    }\n\n\
    \    let prefix = &string[0..max_prefix_len];\n    let reverse_prefix = prefix.chars().rev().collect::<String>();\n\
    \    let result = format!(\"{}{}{}\", string, reverse_prefix, string);\n    result\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xx\"`,\n right: `\"x\"`', /tmp/tmp7k9jc3r8.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut palindrome\
    \ = string.clone();\n    let suffix = string.chars().rev().collect::<String>();\n\
    \    let mut n = 0;\n    while n < string.len() && !string.ends_with(&suffix[n..])\
    \ {\n        n += 1;\n    }\n    palindrome.push_str(&suffix[..n]);\n    palindrome\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xyzzyx\"`,\n right: `\"xyzyx\"`', /tmp/tmpfhkfq5xl.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut longest_prefix\
    \ = String::from(string.as_str());\n    for _ in 0..string.len() {\n        if\
    \ is_palindrome(longest_prefix.as_str()) {\n            break;\n        }\n  \
    \      longest_prefix.remove(0);\n    }\n    string + longest_prefix.chars().rev().collect::<String>().as_str()\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmph_lfcaq5.rs:14:12\n   |\n14 |         if is_palindrome(longest_prefix.as_str())\
    \ {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed\
    \ = string.clone();\n    reversed.reverse();\n    let mut s = String::from(string.as_str());\n\
    \    s.push_str(reversed.as_str());\n    let prefix_suffix = s.as_str();\n   \
    \ let lps = find_longest_palindromic_substring(prefix_suffix);\n    let mut prefix\
    \ = String::from(&string[0..string.len() - lps.len()]);\n    prefix.reverse();\n\
    \    let mut palindrome = String::from(string.as_str());\n    palindrome.push_str(prefix.as_str());\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_longest_palindromic_substring`\
    \ in this scope\n  --> /tmp/tmpyxlqx3yp.rs:17:15\n   |\n17 |     let lps = find_longest_palindromic_substring(prefix_suffix);\n\
    \   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0599]: no method named `reverse` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpyxlqx3yp.rs:13:14\n   |\n13 |     reversed.reverse();\n\
    \   |              ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror[E0599]: no method named `reverse` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpyxlqx3yp.rs:19:12\n   |\n19 | \
    \    prefix.reverse();\n   |            ^^^^^^^ help: there is an associated function\
    \ with a similar name: `reserve`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut res =\
    \ string.clone();\n    let len = string.len();\n    for i in 0..len {\n      \
    \  let (prefix, suffix) = string.split_at(len - i);\n        if is_palindrome(suffix)\
    \ {\n            res.push_str(prefix.chars().rev().collect::<String>().as_str());\n\
    \            break;\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpjlqatt9c.rs:16:12\n   |\n16 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let longest_postfix\
    \ = find_longest_palindromic_postfix(&string);\n    let prefix = &string[..string.len()\
    \ - longest_postfix.len()];\n    string + prefix.chars().rev().collect::<String>().as_str()\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_longest_palindromic_postfix` in\
    \ this scope\n  --> /tmp/tmp2u_3x4aw.rs:12:27\n   |\n12 |     let longest_postfix\
    \ = find_longest_palindromic_postfix(&string);\n   |                         \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let len = string.len();\n\
    \    if len == 0 {\n        return string;\n    }\n    let mut substring = string.clone();\n\
    \    let mut substring_suffix = string.clone();\n    let mut result = string.clone();\n\
    \    for i in 0..len {\n        substring.pop();\n        substring_suffix.remove(0);\n\
    \        if is_palindrome(&substring) {\n            result.push_str(&substring_suffix.chars().rev().collect::<String>());\n\
    \            return result;\n        }\n    }\n    // if control reaches this\
    \ point then the supplied string itself is a palindrome\n    result.push_str(&result.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpvr5dk_sd.rs:22:12\n   |\n22 |         if is_palindrome(&substring) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut suffix\
    \ = suffix_palindrome(string.clone());\n    let prefix = string[..string.len()\
    \ - suffix.len()].chars().rev().collect::<String>();\n    suffix.push_str(&prefix);\n\
    \    suffix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `suffix_palindrome` in this scope\n\
    \  --> /tmp/tmps8neay4k.rs:12:22\n   |\n12 |     let mut suffix = suffix_palindrome(string.clone());\n\
    \   |                      ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    // Find the longest\
    \ suffix that is a palindrome\n    let mut max_suffix_length = 0;\n    for (i,\
    \ (letter, other_letter)) in string.chars().zip(string.chars().rev()).enumerate()\
    \ {\n        if letter == other_letter {\n            max_suffix_length = i +\
    \ 1;\n        }\n    }\n\n    // Take the prefix and reverse it\n    let prefix\
    \ = &string[..string.len() - max_suffix_length];\n    let reverse_prefix = prefix.chars().rev().collect::<String>();\n\
    \n    format!(\"{}{}{}\", string, reverse_prefix, string[string.len() - max_suffix_length..].to_string())\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xx\"`,\n right: `\"x\"`', /tmp/tmp_5sec_9w.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let string =\
    \ string.as_bytes();\n    let mut length = string.len();\n    if length <= 1 {\n\
    \        return string.iter().map(|&ch| ch as char).collect();\n    }\n    //\
    \ find a suffix of the string that is a palindrome.\n    // for example for 'cat'\
    \ the longest palindromic suffix is 't'\n    // for 'cata' it is 'ata'\n    while\
    \ !is_palindrome(&string[..length]) {\n        length -= 1;\n    }\n    // now\
    \ add a reverse of the prefix to the string\n    // since in the example above\
    \ we have 'catac' that is a palindrome\n    let mut result = Vec::from(&string[..length]);\n\
    \    result.extend_from_slice(&string[..string.len() - length].iter().rev());\n\
    \    result.iter().map(|&ch| ch as char).collect()\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpxxt5u1ix.rs:20:12\n   |\n20 |     while !is_palindrome(&string[..length])\
    \ {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxxt5u1ix.rs:26:30\n   |\n26 |     result.extend_from_slice(&string[..string.len()\
    \ - length].iter().rev());\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected slice `[u8]`, found struct `Rev`\n   |\n   = note: expected reference\
    \ `&[u8]`\n              found reference `&Rev<std::slice::Iter<'_, u8>>`\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let bytes = string.into_bytes();\n\
    \    let prefix_suffix_pairs = longest_prefix_suffixes(&bytes);\n    let longest_palindrome_length\
    \ = find_longest_palindrome_length(&prefix_suffix_pairs);\n    let prefix_length\
    \ = bytes.len() - longest_palindrome_length;\n    let reversed_prefix = String::from_utf8(bytes[..prefix_length].to_vec()).unwrap().chars().rev().collect::<String>();\n\
    \    let result = format!(\"{}{}\", string, reversed_prefix);\n    result\n}\n\
    \nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `longest_prefix_suffixes` in this scope\n\
    \  --> /tmp/tmpiijil1xu.rs:13:31\n   |\n13 |     let prefix_suffix_pairs = longest_prefix_suffixes(&bytes);\n\
    \   |                               ^^^^^^^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `find_longest_palindrome_length`\
    \ in this scope\n  --> /tmp/tmpiijil1xu.rs:14:37\n   |\n14 |     let longest_palindrome_length\
    \ = find_longest_palindrome_length(&prefix_suffix_pairs);\n   |              \
    \                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let rev_string\
    \ = string.chars().rev().collect::<String>();\n    let mut idx = 1;\n    for i\
    \ in 1..string.len() {\n        if string[i..] == rev_string[..string.len() -\
    \ i] {\n            idx = i;\n        }\n    }\n    format!(\"{}{}\", string,\
    \ &rev_string[idx..])\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'byte index 1 is out of bounds of ``', library/core/src/str/mod.rs:107:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let n = string.len();\n\
    \    let mut s = string.chars().collect::<Vec<_>>();\n    s.extend(string.chars().rev());\n\
    \    let mut z = (0..2 * n).map(|_| 0).collect::<Vec<_>>();\n    z[0] = n;\n \
    \   let mut left = 0;\n    let mut right = 0;\n    for i in 1..2 * n {\n     \
    \   if i > right {\n            left = right = i;\n            while right < 2\
    \ * n && s[right - left] == s[right] {\n                right += 1;\n        \
    \    }\n            z[i] = right - left;\n            right -= 1;\n        } else\
    \ {\n            let k = i - left;\n            if z[k] < right - i + 1 {\n  \
    \              z[i] = z[k];\n            } else {\n                left = i;\n\
    \                while right < 2 * n && s[right - left] == s[right] {\n      \
    \              right += 1;\n                }\n                z[i] = right -\
    \ left;\n                right -= 1;\n            }\n        }\n    }\n    for\
    \ i in (0..2 * n).rev() {\n        if z[i] >= n {\n            return s[i..i +\
    \ n].iter().collect();\n        }\n    }\n    unreachable!();\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdrxd1700.rs:21:20\n   |\n\
    17 |     let mut left = 0;\n   |                    - expected due to this value\n\
    ...\n21 |             left = right = i;\n   |                    ^^^^^^^^^ expected\
    \ integer, found `()`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let rev = result.clone().chars().rev().collect::<String>();\n\
    \    let chars = string.chars().collect::<Vec<char>>();\n    let mut i = chars.len();\n\
    \    while i > 0 {\n        let new_string = rev.clone() + &string[0..i].to_string();\n\
    \        if is_palindrome(&new_string) {\n            result = new_string;\n \
    \           break;\n        }\n        i -= 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp31s5_yp1.rs:18:12\n   |\n18 |         if is_palindrome(&new_string)\
    \ {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let suffix =\
    \ string.split(\"\").rev().take_while(|c| c.chars().next().unwrap() == string.chars().next().unwrap()).collect::<String>();\n\
    \    let prefix = string.split(\"\").rev().skip(suffix.len()).collect::<String>();\n\
    \    format!(\"{}{}{}\", string, prefix, suffix)\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `StrSearcher<'_, '_>: DoubleEndedSearcher<'_>`\
    \ is not satisfied\n    --> /tmp/tmp9ujm3i0a.rs:12:35\n     |\n12   | ...split(\"\
    \").rev().take_while(|c| c.chars().next().unwrap() == string.chars().next().unwrap()).collect::<Str...\n\
    \     |              ^^^ the trait `DoubleEndedSearcher<'_>` is not implemented\
    \ for `StrSearcher<'_, '_>`\n     |\n     = help: the following other types implement\
    \ trait `DoubleEndedSearcher<'a>`:\n               CharPredicateSearcher<'a, F>\n\
    \               CharSearcher<'a>\n               CharSliceSearcher<'a, 'b>\n \
    \              pattern::MultiCharEqSearcher<'a, C>\n     = note: required because\
    \ of the requirements on the impl of `DoubleEndedIterator` for `std::str::Split<'_,\
    \ &str>`\nnote: required by a bound in `rev`\n\nerror[E0599]: the method `take_while`\
    \ exists for struct `Rev<std::str::Split<'_, &str>>`, but its trait bounds were\
    \ not satisfied\n   --> /tmp/tmp9ujm3i0a.rs:12:41\n    |\n12  |       let suffix\
    \ = string.split(\"\").rev().take_while(|c| c.chars().next().unwrap() == string.chars().next().u...\n\
    \    |                                           ^^^^^^^^^^ method cannot be called\
    \ on `Rev<std::str::Split<'_, &str>>` due to unsatisfied trait bounds\n    |\n\
    \    = note: the following trait bounds were not satisfied:\n            `std::str::Split<'_,\
    \ &str>: DoubleEndedIterator`\n            which is required by `Rev<std::str::Split<'_,\
    \ &str>>: Iterator`\n            `Rev<std::str::Split<'_, &str>>: Iterator`\n\
    \            which is required by `&mut Rev<std::str::Split<'_, &str>>: Iterator`\n\
    \nerror[E0277]: the trait bound `StrSearcher<'_, '_>: DoubleEndedSearcher<'_>`\
    \ is not satisfied\n    --> /tmp/tmp9ujm3i0a.rs:13:35\n     |\n13   |     let\
    \ prefix = string.split(\"\").rev().skip(suffix.len()).collect::<String>();\n\
    \     |                                   ^^^ the trait `DoubleEndedSearcher<'_>`\
    \ is not implemented for `StrSearcher<'_, '_>`\n     |\n     = help: the following\
    \ other types implement trait `DoubleEndedSearcher<'a>`:\n               CharPredicateSearcher<'a,\
    \ F>\n               Cha"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return string;\n    }\n\n    let mut result = String::new();\n  \
    \  let mut end = string.len();\n    while !is_palindrome(&string[..end]) {\n \
    \       end -= 1;\n    }\n    result.push_str(&string[..end]);\n    result.push_str(&string[..end].chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpeq7qim1a.rs:18:12\n   |\n18 |     while !is_palindrome(&string[..end])\
    \ {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut new_string\
    \ = string.clone();\n    if new_string.len() == 0 {\n        return new_string;\n\
    \    }\n    let mut palindrome_suffix = longest_palindrome_suffix(&new_string);\n\
    \    let palindrome_prefix = &new_string[..new_string.len() - palindrome_suffix.len()];\n\
    \    new_string.push_str(&palindrome_prefix.chars().rev().collect::<String>());\n\
    \    new_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `longest_palindrome_suffix` in this\
    \ scope\n  --> /tmp/tmpf08q6n8k.rs:16:33\n   |\n16 |     let mut palindrome_suffix\
    \ = longest_palindrome_suffix(&new_string);\n   |                            \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return String::new();\n    }\n\n    let mut rev = string.clone();\n\
    \    rev.reverse();\n\n    let longest_palindrome = find_longest_palindrome(&string).len();\n\
    \    let rest = string.len() - longest_palindrome;\n\n    if rest == 0 {\n   \
    \     return string;\n    }\n\n    let mut result = string.clone();\n    result.push_str(&rev[..rest]);\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_longest_palindrome` in this scope\n\
    \  --> /tmp/tmpgbiz6shr.rs:19:30\n   |\n19 |     let longest_palindrome = find_longest_palindrome(&string).len();\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0599]: no method named `reverse` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpgbiz6shr.rs:17:9\n   |\n17 |     rev.reverse();\n   | \
    \        ^^^^^^^ help: there is an associated function with a similar name: `reserve`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let (p, i) =\
    \ palindrome(string.as_str());\n    if p.len() == 0 {\n        let mut rev = string.clone();\n\
    \        rev.chars().rev().collect()\n    } else {\n        let mut palindrome\
    \ = string;\n        let rev = string[..i].chars().rev().collect::<String>();\n\
    \        palindrome.push_str(&rev);\n        palindrome\n    }\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `palindrome` in this scope\n  --> /tmp/tmp8y4bt0le.rs:12:18\n\
    \   |\n12 |     let (p, i) = palindrome(string.as_str());\n   |              \
    \    ^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.len();\n    if string_length == 0 {\n        return string;\n    }\n\
    \    let mut palindrome = string.clone();\n    let mut prefix_length = 0;\n  \
    \  for suffix_length in (0..string_length).rev() {\n        if string[..suffix_length]\
    \ == string[(string_length - suffix_length)..] {\n            prefix_length =\
    \ string_length - suffix_length;\n            break;\n        }\n    }\n    let\
    \ prefix = string[..prefix_length].chars().rev().collect::<String>();\n    palindrome.push_str(&prefix);\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xx\"`,\n right: `\"x\"`', /tmp/tmph2b_nxtx.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let palindrome_suffix\
    \ = longest_palindrome_suffix(&string);\n    if palindrome_suffix.len() == string.len()\
    \ {\n        return string;\n    }\n    let palindrome_prefix = string.chars().take(string.len()\
    \ - palindrome_suffix.len()).collect::<String>();\n    palindrome_prefix + &palindrome_suffix\
    \ + &palindrome_prefix.chars().rev().collect::<String>()\n}\n\nfn main() {\n \
    \   let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `longest_palindrome_suffix` in this\
    \ scope\n  --> /tmp/tmpka9_rzbw.rs:12:29\n   |\n12 |     let palindrome_suffix\
    \ = longest_palindrome_suffix(&string);\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let string =\
    \ string.into_bytes();\n    let mut suffix = suffix(&string);\n    suffix.reverse();\n\
    \    let mut prefix = suffix(&string);\n    prefix.reverse();\n    let mut result\
    \ = string.clone();\n    result.extend(suffix);\n    result.extend(prefix);\n\
    \    result.into_iter().map(|byte| byte as char).collect()\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `suffix` in this scope\n  --> /tmp/tmp2fguqxzo.rs:13:22\n\
    \   |\n13 |     let mut suffix = suffix(&string);\n   |                      ^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    // This will\
    \ hold index of last character of the longest palindromic substring\n    // that\
    \ starts at a beginning of the string.\n    let mut tail_idx = 0;\n    let chars:\
    \ Vec<char> = string.chars().collect();\n    let mut i = 0;\n    while i < chars.len()\
    \ {\n        if is_palindrome(&chars, 0, i) {\n            tail_idx = i;\n   \
    \     }\n        i += 1;\n    }\n    // Find reverse of the string excluding the\
    \ palindromic postfix.\n    let reversed_chars: Vec<char> = chars[..tail_idx].iter().rev().collect();\n\
    \    // Create and return new string by concatenating original string with reverse\
    \ of its prefix.\n    chars.iter().cloned().chain(reversed_chars.iter().cloned()).collect()\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpoiahq77a.rs:18:12\n   |\n18 |         if is_palindrome(&chars, 0, i)\
    \ {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]: a\
    \ value of type `Vec<char>` cannot be built from an iterator over elements of\
    \ type `&char`\n    --> /tmp/tmpoiahq77a.rs:24:68\n     |\n24   |     let reversed_chars:\
    \ Vec<char> = chars[..tail_idx].iter().rev().collect();\n     |              \
    \                                                      ^^^^^^^ value of type `Vec<char>`\
    \ cannot be built from `std::iter::Iterator<Item=&char>`\n     |\n     = help:\
    \ the trait `FromIterator<&char>` is not implemented for `Vec<char>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    if !result.is_empty() {\n        let mut longest_palindrome_ending_at\
    \ = 0;\n        let mut pivot = 1;\n        while pivot < result.len() {\n   \
    \         if result[..pivot] == result[result.len() - pivot..].chars().rev().collect::<String>()\
    \ {\n                longest_palindrome_ending_at = pivot;\n            }\n  \
    \          pivot += 1;\n        }\n        result += &result[..result.len() -\
    \ longest_palindrome_ending_at].chars().rev().collect::<String>();\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xx\"`,\n right: `\"x\"`', /tmp/tmp4492aiu2.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let palindrome_size = longest_palindrome_size(string.clone());\n\
    \    let prefix = &string[0..string.len() - palindrome_size];\n    let suffix\
    \ = &string[palindrome_size..];\n    string.push_str(prefix.chars().rev().collect::<String>().as_str());\n\
    \    string.push_str(suffix);\n    string\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `longest_palindrome_size` in this scope\n\
    \  --> /tmp/tmp3fbxh0n8.rs:13:27\n   |\n13 |     let palindrome_size = longest_palindrome_size(string.clone());\n\
    \   |                           ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut s = string.clone();\n\
    \    let mut suffix = Vec::new();\n    for c in string.chars().rev() {\n     \
    \   s.push(c);\n        suffix.push(c);\n        if is_palindrome(&s) {\n    \
    \        return s;\n        }\n    }\n    string + suffix.iter().rev().collect::<String>().as_str()\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpgepyui_q.rs:17:12\n   |\n17 |         if is_palindrome(&s) {\n   | \
    \           ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let lps = longest_postfix_palindrome(&string);\n\
    \    let offset = string.len() - lps.len();\n    let mut reversed_prefix = string[..offset].chars().rev().collect::<String>();\n\
    \    reversed_prefix.push_str(&string);\n    reversed_prefix\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `longest_postfix_palindrome` in this\
    \ scope\n  --> /tmp/tmpi15z3f7z.rs:12:15\n   |\n12 |     let lps = longest_postfix_palindrome(&string);\n\
    \   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut rev_string = string.clone();\n    rev_string.reverse();\n\
    \    string.push('#');\n    string.push_str(&rev_string);\n    let mut z = vec![0;\
    \ string.len()];\n    let mut left = 0;\n    let mut right = 0;\n    for i in\
    \ 1..string.len() {\n        if i > right {\n            left = right = i;\n \
    \           while right < string.len() && string.chars().nth(right).unwrap() ==\
    \ string.chars().nth(right - left).unwrap() {\n                right += 1;\n \
    \           }\n            z[i] = right - left;\n            right -= 1;\n   \
    \     } else {\n            let k = i - left;\n            if z[k] < right - i\
    \ + 1 {\n                z[i] = z[k];\n            } else {\n                left\
    \ = i;\n                while right < string.len() && string.chars().nth(right).unwrap()\
    \ == string.chars().nth(right - left).unwrap() {\n                    right +=\
    \ 1;\n                }\n                z[i] = right - left;\n              \
    \  right -= 1;\n            }\n        }\n    }\n    let prefix = string.chars().take(string.len()\
    \ / 2).collect::<String>();\n    prefix.chars().rev().collect::<String>() + &prefix\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpbwk21bxj.rs:14:16\n   |\n14 |     rev_string.reverse();\n\
    \   |                ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbwk21bxj.rs:22:20\n\
    \   |\n18 |     let mut left = 0;\n   |                    - expected due to this\
    \ value\n...\n22 |             left = right = i;\n   |                    ^^^^^^^^^\
    \ expected integer, found `()`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if is_palindrome(&string)\
    \ {\n        return string;\n    }\n\n    let reverse = string.chars().rev().collect::<String>();\n\
    \    let mut shortest_palindrome = String::new();\n    for i in 0..string.len()\
    \ {\n        if is_palindrome(&string[i..]) {\n            shortest_palindrome.push_str(&reverse[..reverse.len()\
    \ - i]);\n            shortest_palindrome.push_str(&string);\n            break;\n\
    \        }\n    }\n\n    shortest_palindrome\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp54aymor4.rs:12:8\n   |\n12 |     if is_palindrome(&string) {\n   | \
    \       ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `is_palindrome` in this scope\n  --> /tmp/tmp54aymor4.rs:19:12\n   |\n19 | \
    \        if is_palindrome(&string[i..]) {\n   |            ^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    match find_longest_palindrome_suffix(string.clone())\
    \ {\n        Some(ps) => string + ps.chars().rev().collect::<String>().as_str(),\n\
    \        None => string,\n    }\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_longest_palindrome_suffix` in\
    \ this scope\n  --> /tmp/tmpbs2o_8x_.rs:12:11\n   |\n12 |     match find_longest_palindrome_suffix(string.clone())\
    \ {\n   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut prefix\
    \ = string.chars().rev().collect::<String>();\n    let suffix = longest_palindromic_postfix(&string).chars().collect::<String>();\n\
    \    let mut result = string;\n    result.push_str(&prefix);\n    prefix.truncate(string.len()\
    \ - suffix.len());\n    result.push_str(&prefix);\n    result\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `longest_palindromic_postfix` in this\
    \ scope\n  --> /tmp/tmp9dm835jn.rs:13:18\n   |\n13 |     let suffix = longest_palindromic_postfix(&string).chars().collect::<String>();\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return string;\n    }\n\n    let mut longest_palindrome = string[0..1].to_string();\n\
    \    for i in 1..string.len() {\n        let new_palindrome = get_longest_palindrome_postfix(&string,\
    \ i);\n        if new_palindrome.len() > longest_palindrome.len() {\n        \
    \    longest_palindrome = new_palindrome;\n        }\n    }\n\n    let suffix_start\
    \ = string.len() - longest_palindrome.len();\n    let prefix = string[0..suffix_start].chars().rev().collect::<String>();\n\
    \    return prefix + &string;\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `get_longest_palindrome_postfix` in\
    \ this scope\n  --> /tmp/tmpprcslvyn.rs:18:30\n   |\n18 |         let new_palindrome\
    \ = get_longest_palindrome_postfix(&string, i);\n   |                        \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut s = string.clone();\n\
    \    if s.is_empty() {\n        return s;\n    }\n    let reversed = s.clone().chars().rev().collect::<String>();\n\
    \    s.push_str(&reversed[string.len()..]);\n    s\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xyz\"`,\n right: `\"xyzyx\"`', /tmp/tmpjd0uzwqr.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let string =\
    \ string.as_bytes();\n    let mut length = longest_postfix_palindrome(string);\n\
    \    if length == string.len() {\n        return String::from_utf8(string.to_vec()).unwrap();\n\
    \    }\n    let mut reverse = &string[..string.len() - length];\n    reverse.reverse();\n\
    \    String::from_utf8(append(&string, reverse)).unwrap()\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `longest_postfix_palindrome` in this\
    \ scope\n  --> /tmp/tmpias4he_8.rs:13:22\n   |\n13 |     let mut length = longest_postfix_palindrome(string);\n\
    \   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `append` in this scope\n  --> /tmp/tmpias4he_8.rs:19:23\n\
    \   |\n19 |     String::from_utf8(append(&string, reverse)).unwrap()\n   |   \
    \                    ^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut reverse_string = string.chars().rev().collect::<String>();\n\
    \    let mut prefix = \"\".to_string();\n    let mut postfix = \"\".to_string();\n\
    \    let mut suffix = \"\".to_string();\n    let mut suffix_length = 0;\n    let\
    \ mut index = 0;\n    while index < reverse_string.len() {\n        if result.starts_with(&reverse_string[index..])\
    \ {\n            suffix_length = result.len() - index;\n            suffix = reverse_string[index..].to_string();\n\
    \            break;\n        }\n        index += 1;\n    }\n    postfix = reverse_string[suffix_length..].to_string();\n\
    \    prefix = reverse_string[..reverse_string.len() - suffix_length].to_string();\n\
    \    result = format!(\"{}{}{}\", postfix, result, prefix);\n    result\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"yxxyzzy\"`,\n right: `\"xyzyx\"`', /tmp/tmp9ytwelw9.rs:37:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    // Append to\
    \ the end of the string reverse of its prefix.\n    let reverse_prefix = string.chars().rev().collect::<String>();\n\
    \    let mut string = string + &reverse_prefix;\n\n    // Find the longest postfix\
    \ of the supplied string that is a palindrome.\n    let mut k = string.len() -\
    \ 1;\n    while k > 0 {\n        if is_palindrome(&string[..k]) {\n          \
    \  break;\n        }\n        k -= 1;\n    }\n\n    // String to the left of the\
    \ palindromic suffix is the prefix of the input string.\n    let prefix = string[..k].to_string();\n\
    \    // String to the right of the palindromic suffix is the reverse of the prefix.\n\
    \    let reverse_prefix = prefix.chars().rev().collect::<String>();\n    // Append\
    \ the reverse of the prefix to the palindromic suffix.\n    string += &reverse_prefix;\n\
    \n    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpwf5h02sl.rs:19:12\n   |\n19 |         if is_palindrome(&string[..k])\
    \ {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return string;\n    }\n\n    let n = string.len();\n    let mut i\
    \ = n - 1;\n    while i > 0 {\n        if string[..i] == string[i..].chars().rev().collect::<String>()\
    \ {\n            break;\n        }\n        i -= 1;\n    }\n\n    format!(\"{}{}\"\
    , string, string[..n - i].chars().rev().collect::<String>())\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xx\"`,\n right: `\"x\"`', /tmp/tmphxqfoy6e.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return string;\n    }\n\n    if string.len() == 1 {\n        return\
    \ string + &string;\n    }\n\n    let mut prefix = string.clone();\n    let mut\
    \ suffix = string.clone();\n    prefix.pop();\n    let mut i = 0;\n    let mut\
    \ longest_palindrome_size = 0;\n    while i < string.len() - 1 {\n        if prefix\
    \ == suffix {\n            longest_palindrome_size = prefix.len();\n        }\n\
    \        prefix.pop();\n        suffix.remove(0);\n        i += 1;\n    }\n\n\
    \    let (suffix, prefix) = suffix.split_at(string.len() - longest_palindrome_size);\n\
    \    string + &prefix.chars().rev().collect::<String>() + suffix\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `string`\n  --> /tmp/tmpnxjvadmh.rs:17:25\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \       ------ move occurs because `string` has type `String`, which does not\
    \ implement the `Copy` trait\n...\n17 |         return string + &string;\n   |\
    \                ------   ^^^^^^^ value borrowed here after move\n   |       \
    \         |\n   |                value moved here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let s: Vec<char>\
    \ = string.chars().collect();\n    let n = s.len();\n    let mut z = vec![0; n];\n\
    \    let mut l = 0;\n    let mut r = 0;\n    for i in 1..n {\n        if i <=\
    \ r {\n            z[i] = min(z[i - l], r - i + 1);\n        }\n        while\
    \ i + z[i] < n && s[z[i]] == s[i + z[i]] {\n            z[i] += 1;\n        }\n\
    \        if i + z[i] - 1 > r {\n            l = i;\n            r = i + z[i] -\
    \ 1;\n        }\n    }\n    let mut prefix_end = z[0];\n    for i in 1..n {\n\
    \        if z[i] + i == n {\n            prefix_end = i;\n            break;\n\
    \        }\n    }\n    let mut result = String::from(string);\n    for i in 0..prefix_end\
    \ {\n        result.push(s[i]);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `min` in this scope\n  --> /tmp/tmp1ahkjooi.rs:19:20\n\
    \   |\n19 |             z[i] = min(z[i - l], r - i + 1);\n   |               \
    \     ^^^\n...\n43 | fn main() {\n   | --------- similarly named function `main`\
    \ defined here\n   |\nhelp: a function with a similar name exists\n   |\n19 |\
    \             z[i] = main(z[i - l], r - i + 1);\n   |                    ~~~~\n\
    help: consider importing this function\n   |\n1  | use std::cmp::min;\n   |\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return string;\n    }\n\n    let mut string = string;\n    for i\
    \ in (0..string.len()).rev() {\n        if is_palindrome(&string[i..]) {\n   \
    \         // i is length of palindromic suffix\n            let prefix = string[..string.len()\
    \ - i].chars().rev().collect::<String>();\n            string.push_str(&prefix);\n\
    \            break;\n        }\n    }\n    string\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpg_72gg4v.rs:18:12\n   |\n18 |         if is_palindrome(&string[i..])\
    \ {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return string;\n    }\n\n    let rev_string = string.chars().rev().collect::<String>();\n\
    \    let str_len = string.len();\n    let mut suffix = String::new();\n    let\
    \ mut i = 0;\n    while i < str_len {\n        if string.starts_with(&rev_string[i..])\
    \ {\n            suffix = rev_string[i..].to_string();\n            break;\n \
    \       }\n        i += 1;\n    }\n\n    format!(\"{}{}\", string, suffix)\n}\n\
    \nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xx\"`,\n right: `\"x\"`', /tmp/tmpai738ugc.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut prefix\
    \ = string.chars().collect::<Vec<char>>();\n    let mut suffix = string.chars().rev().collect::<Vec<char>>();\n\
    \    let mut idx = 0;\n    let mut max_idx = 0;\n    while idx < prefix.len()\
    \ {\n        if prefix[idx] == suffix[idx] {\n            max_idx = idx;\n   \
    \     }\n        idx += 1;\n    }\n    let mut new_string = String::from(&string[..]);\n\
    \    new_string.push_str(&suffix[..max_idx].iter().rev().collect::<String>());\n\
    \    new_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xyzz\"`,\n right: `\"xyzyx\"`', /tmp/tmp_abbsyee.rs:31:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let string =\
    \ string.as_bytes();\n    let mut prefix = string;\n    let mut suffix = string;\n\
    \    loop {\n        if !suffix.is_empty() && is_palindrome(suffix) {\n      \
    \      break;\n        }\n        suffix = &suffix[1..];\n        prefix = &prefix[..prefix.len()\
    \ - 1];\n    }\n    let mut result = String::from_utf8(suffix.to_vec()).unwrap();\n\
    \    result.push_str(&reverse(prefix));\n    result\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpq9t9a4r7.rs:16:34\n   |\n16 |         if !suffix.is_empty() && is_palindrome(suffix)\
    \ {\n   |                                  ^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `reverse` in this scope\n  --> /tmp/tmpq9t9a4r7.rs:23:22\n\
    \   |\n23 |     result.push_str(&reverse(prefix));\n   |                     \
    \ ^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    /// Return the\
    \ longest postfix that is a palindrome.\n    fn postfix_palindrome(string: &str)\
    \ -> String {\n        let mut res = String::new();\n        let mut l = 0;\n\
    \        let mut r = string.len() - 1;\n        loop {\n            if l >= r\
    \ {\n                break;\n            }\n            if string.chars().nth(l)\
    \ == string.chars().nth(r) {\n                res.push(string.chars().nth(l).unwrap());\n\
    \                l += 1;\n                r -= 1;\n            } else {\n    \
    \            res.clear();\n                l = 0;\n                r -= 1;\n \
    \           }\n        }\n        res\n    }\n\n    let mut res = String::new();\n\
    \    let mut l = 0;\n    let prefix = string.clone();\n    let postfix = postfix_palindrome(&string);\n\
    \    for char in prefix.chars() {\n        if l < postfix.len() && char == postfix.chars().nth(l).unwrap()\
    \ {\n            l += 1;\n        } else {\n            res.push(char);\n    \
    \    }\n    }\n    res.reverse();\n    format!(\"{}{}{}\", string, res, postfix)\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp7l5ec4iu.rs:45:9\n   |\n45 |     res.reverse();\n\
    \   |         ^^^^^^^ help: there is an associated function with a similar name:\
    \ `reserve`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let input_str\
    \ = string.as_str();\n    let length = input_str.len();\n    let mut is_palindrome\
    \ = vec![vec![false; length]; length];\n    let mut longest_palindrome_suffix_len\
    \ = vec![1; length];\n    // test all substrings of length 2\n    let mut max_len\
    \ = 1;\n    let mut max_len_index = 0;\n    for i in 0..length {\n        is_palindrome[i][i]\
    \ = true;\n        if i + 1 < length && input_str.chars().nth(i) == input_str.chars().nth(i\
    \ + 1) {\n            is_palindrome[i][i + 1] = true;\n            longest_palindrome_suffix_len[i]\
    \ = 2;\n            max_len = 2;\n            max_len_index = i;\n        }\n\
    \    }\n    // length of substring, starting from the end of the string and going\
    \ to length 1\n    for l in 3..length + 1 {\n        // start index of substring\n\
    \        for i in 0..length - l + 1 {\n            let j = i + l - 1;\n      \
    \      if input_str.chars().nth(i) == input_str.chars().nth(j) && is_palindrome[i\
    \ + 1][j - 1] {\n                is_palindrome[i][j] = true;\n               \
    \ longest_palindrome_suffix_len[i] = l;\n                if l > max_len {\n  \
    \                  max_len = l;\n                    max_len_index = i;\n    \
    \            }\n            }\n        }\n    }\n    let mut result = String::new();\n\
    \    result.push_str(&input_str[max_len_index..max_len_index + max_len]);\n  \
    \  let mut reverse_prefix = input_str[0..max_len_index].chars().rev().collect::<String>();\n\
    \    result.push_str(&reverse_prefix);\n    result\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'byte index 1 is out of bounds of ``', library/core/src/str/mod.rs:107:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let rev = reverse(string);\n    let common_len = longest_common_substring(string,\
    \ rev);\n    let to_append = result.split_off(common_len);\n    result.push_str(&reverse(to_append));\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `reverse` in this scope\n  --> /tmp/tmp6x38nrmi.rs:13:15\n\
    \   |\n13 |     let rev = reverse(string);\n   |               ^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `longest_common_substring`\
    \ in this scope\n  --> /tmp/tmp6x38nrmi.rs:14:22\n   |\n14 |     let common_len\
    \ = longest_common_substring(string, rev);\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `reverse` in this\
    \ scope\n  --> /tmp/tmp6x38nrmi.rs:16:22\n   |\n16 |     result.push_str(&reverse(to_append));\n\
    \   |                      ^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed_string\
    \ = string.clone();\n    reversed_string.chars().rev().collect()\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"zyx\"`,\n right: `\"xyzyx\"`', /tmp/tmpjx4nd_xr.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let rev = string.chars().rev().collect::<String>();\n\
    \    let mut rev_suffix = \"\".to_string();\n    for i in 0..string.len() {\n\
    \        let suffix = &string[i..];\n        let rev_prefix = &rev[..string.len()\
    \ - i];\n        if suffix == rev_prefix {\n            rev_suffix = rev_prefix.to_string();\n\
    \            break;\n        }\n    }\n    format!(\"{}{}\", string, rev_suffix)\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xx\"`,\n right: `\"x\"`', /tmp/tmp2cceo77t.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let string =\
    \ string.into_bytes();\n    let mut string = string.as_slice();\n    let mut result\
    \ = Vec::new();\n    let mut suf = &mut string[..];\n    loop {\n        match\
    \ suf.iter().position(|x| *x == string[0]) {\n            Some(p) => {\n     \
    \           let rev = if p > 0 { &string[..p] } else { &string[1..] };\n     \
    \           let rev = rev.iter().rev().cloned();\n                result.extend(rev);\n\
    \                suf = &mut suf[p..];\n            }\n            None => break,\n\
    \        }\n    }\n    result.extend(string);\n    String::from_utf8(result).unwrap()\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpwnbsfduq.rs:13:9\n\
    \   |\n13 |     let mut string = string.as_slice();\n   |         ----^^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0596]: cannot borrow `*string` as mutable, as it is\
    \ behind a `&` reference\n  --> /tmp/tmpwnbsfduq.rs:15:24\n   |\n13 |     let\
    \ mut string = string.as_slice();\n   |         ---------- help: consider changing\
    \ this to be a mutable reference: `&mut [u8]`\n14 |     let mut result = Vec::new();\n\
    15 |     let mut suf = &mut string[..];\n   |                        ^^^^^^ `string`\
    \ is a `&` reference, so the data it refers to cannot be borrowed as mutable\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let s: Vec<char>\
    \ = string.chars().collect();\n    let n = s.len();\n    if n == 0 {\n       \
    \ return String::new();\n    }\n    let palindrome_suffix = if longest_palindrome_suffix(&s).len()\
    \ > 0 {\n        &s[n - longest_palindrome_suffix(&s).len()..]\n    } else {\n\
    \        &s[n - 1..]\n    };\n    string + reverse(palindrome_suffix).as_str()\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `longest_palindrome_suffix` in this\
    \ scope\n  --> /tmp/tmpgaryhldh.rs:17:32\n   |\n17 |     let palindrome_suffix\
    \ = if longest_palindrome_suffix(&s).len() > 0 {\n   |                       \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `longest_palindrome_suffix` in this scope\n  --> /tmp/tmpgaryhldh.rs:18:16\n\
    \   |\n18 |         &s[n - longest_palindrome_suffix(&s).len()..]\n   |      \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `reverse` in this scope\n  --> /tmp/tmpgaryhldh.rs:22:14\n\
    \   |\n22 |     string + reverse(palindrome_suffix).as_str()\n   |           \
    \   ^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let max_length = string.len();\n    let mut suffix_length = max_length;\n\
    \    while suffix_length > 0 {\n        if is_palindrome(&string[(max_length -\
    \ suffix_length)..max_length]) {\n            return string + &string[0..(max_length\
    \ - suffix_length)].chars().rev().collect::<String>();\n        }\n        suffix_length\
    \ -= 1;\n    }\n    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpimwidsxa.rs:16:12\n   |\n16 |         if is_palindrome(&string[(max_length\
    \ - suffix_length)..max_length]) {\n   |            ^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if is_palindrome(&string)\
    \ {\n        return string;\n    }\n\n    let mut prefix = String::from(\"\");\n\
    \    let chars: Vec<char> = string.chars().collect();\n    for i in 0..chars.len()\
    \ {\n        let is_palindrome = is_palindrome(&chars[i..chars.len()].iter().collect());\n\
    \        if is_palindrome {\n            prefix = string[0..i].to_string();\n\
    \            break;\n        }\n    }\n\n    return prefix + &string;\n}\n\nfn\
    \ main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpno88etmc.rs:12:8\n   |\n12 |     if is_palindrome(&string) {\n   | \
    \       ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `is_palindrome` in this scope\n  --> /tmp/tmpno88etmc.rs:19:29\n   |\n19 | \
    \        let is_palindrome = is_palindrome(&chars[i..chars.len()].iter().collect());\n\
    \   |                             ^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return string;\n    }\n\n    let mut postfix = make_palindrome_with_suffix(&string);\n\
    \    let mut prefix = string.chars().take(string.len() - postfix.len()).collect::<String>();\n\
    \    prefix.chars().rev().for_each(|c| postfix.push(c));\n    postfix\n}\n\nfn\
    \ main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `make_palindrome_with_suffix` in this\
    \ scope\n  --> /tmp/tmp3d3emaa0.rs:16:23\n   |\n16 |     let mut postfix = make_palindrome_with_suffix(&string);\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return string;\n    }\n\n    let mut rev_string = string.clone();\n\
    \    rev_string.chars().rev().collect::<String>();\n\n    let string_len = string.len();\n\
    \    for i in (0..string_len).rev() {\n        if string[..i] == rev_string[string_len\
    \ - i..] {\n            return string + &rev_string[string_len - i..];\n     \
    \   }\n    }\n\n    unreachable!();\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xyz\"`,\n right: `\"xyzyx\"`', /tmp/tmpftrjl4ne.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let reversed = string.chars().rev().collect::<String>();\n  \
    \  let mut i = 1;\n    while !string.ends_with(&reversed[..i]) {\n        i +=\
    \ 1;\n    }\n    string.push_str(&reversed[..i]);\n    string\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'byte index 1 is out of bounds of ``', library/core/src/str/mod.rs:107:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut palindrome\
    \ = string.clone();\n    let max_length = string.len();\n    let mut cur_len =\
    \ max_length;\n    while cur_len >= 1 {\n        if is_palindrome(&string[0..cur_len])\
    \ {\n            break;\n        }\n        cur_len -= 1;\n    }\n    let prefix\
    \ = &string[0..cur_len];\n    let suffix = prefix.chars().rev().collect::<String>();\n\
    \    palindrome.push_str(&suffix);\n    palindrome\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpnz7z257b.rs:16:12\n   |\n16 |         if is_palindrome(&string[0..cur_len])\
    \ {\n   |            ^^^^^^^^^^^^^ help: a local variable with a similar name\
    \ exists: `palindrome`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let s = string.as_bytes();\n\
    \    let mut reversed = Vec::with_capacity(s.len());\n    let mut longest_match\
    \ = 0;\n    let mut last_match = 0;\n    let mut longest_sub_string = Vec::with_capacity(s.len());\n\
    \    let mut tmp = Vec::with_capacity(s.len());\n    // Iterate the chars backwards\
    \ while maintaining the longest prefix match with reversed string.\n    for &c\
    \ in s.iter().rev() {\n        reversed.push(c);\n        tmp.push(c);\n     \
    \   if c == s[longest_match] {\n            longest_match += 1;\n            if\
    \ longest_match == s.len() {\n                // Full prefix match.\n        \
    \        break;\n            }\n        } else {\n            // No match.\n \
    \           longest_match = 0;\n            last_match = 0;\n            longest_sub_string.clear();\n\
    \        }\n        if longest_match > last_match {\n            last_match =\
    \ longest_match;\n            longest_sub_string.clear();\n            longest_sub_string.extend_from_slice(&tmp);\n\
    \        }\n    }\n    let sub_string = String::from_utf8(longest_sub_string.clone()).unwrap();\n\
    \    string + &sub_string.chars().rev().collect::<String>()\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xyzxyz\"`,\n right: `\"xyzyx\"`', /tmp/tmpv3huzwuo.rs:48:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let ln = string.len();\n\
    \    if ln == 0 {\n        return string;\n    }\n    let mut suffix = String::new();\n\
    \    for i in 0..ln {\n        let (h, t) = string.split_at(ln - i);\n       \
    \ if is_palindrome(h) {\n            suffix = t.to_string();\n            break;\n\
    \        }\n    }\n    let mut prefix = String::new();\n    for c in suffix.chars().rev()\
    \ {\n        prefix.push(c);\n    }\n    prefix + &string\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpha_eifr1.rs:19:12\n   |\n19 |         if is_palindrome(h) {\n   |  \
    \          ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut longest_palindrome_suffix\
    \ = String::from(\"\");\n    let reversed_prefix = string.chars().rev().collect::<String>();\n\
    \    for i in 0..string.len() {\n        let prefix = &string[0..i];\n       \
    \ let suffix = &string[i..];\n        if suffix == reversed_prefix[..suffix.len()]\
    \ {\n            longest_palindrome_suffix = suffix.to_string();\n        }\n\
    \    }\n    let mut new_string = string.clone();\n    new_string.push_str(&reversed_prefix[..longest_palindrome_suffix.len()]);\n\
    \    new_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&str` with `str`\n  --> /tmp/tmpkp4qfrso.rs:17:19\n\
    \   |\n17 |         if suffix == reversed_prefix[..suffix.len()] {\n   |     \
    \              ^^ no implementation for `&str == str`\n   |\n   = help: the trait\
    \ `PartialEq<str>` is not implemented for `&str`\n   = help: the following other\
    \ types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string_iter\
    \ = string.chars();\n    match string_iter.next() {\n        None => return string,\n\
    \        Some(first_char) => {\n            let mut longest_postfix = vec![first_char];\n\
    \            let mut reversed_prefix = vec![];\n            for ch in string_iter\
    \ {\n                reversed_prefix.push(ch);\n                if is_palindrome(&longest_postfix)\
    \ {\n                    break;\n                }\n                longest_postfix.push(ch);\n\
    \            }\n            reversed_prefix.reverse();\n            let mut result\
    \ = longest_postfix;\n            result.extend(reversed_prefix);\n          \
    \  result.iter().collect()\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpnlsc0pym.rs:20:20\n   |\n20 |                 if is_palindrome(&longest_postfix)\
    \ {\n   |                    ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let string_ref\
    \ = string.as_ref();\n    let mut longest_suffix_len = 0;\n    let n = string_ref.len();\n\
    \    // `suffix_len` is the length of the suffix we are trying to verify.\n  \
    \  for suffix_len in (1..n).rev() {\n        // The whole suffix must be a palindrome\
    \ for us to keep it.\n        if string_ref[n - suffix_len..] != string_ref[n\
    \ - suffix_len..n - suffix_len / 2].chars().rev().collect::<String>() {\n    \
    \        break;\n        }\n        longest_suffix_len = suffix_len;\n    }\n\
    \    if longest_suffix_len == 0 {\n        return string;\n    }\n    string +\
    \ &string_ref[..n - longest_suffix_len].chars().rev().collect::<String>()\n}\n\
    \nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `&T`\n  --> /tmp/tmpt29xvfn9.rs:12:29\n\
    \   |\n12 |     let string_ref = string.as_ref();\n   |         ----------   \
    \       ^^^^^^ cannot infer type for type parameter `T` declared on the trait\
    \ `AsRef`\n   |         |\n   |         consider giving `string_ref` the explicit\
    \ type `&T`, where the type parameter `T` is specified\n   |\n   = note: type\
    \ must be known at this point\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut palindrome\
    \ = string.clone();\n    palindrome.push_str(&string[..palindrome.len() - suffix_len(&string)].chars().rev().collect::<String>());\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `suffix_len` in this scope\n  --> /tmp/tmpebal623l.rs:13:54\n\
    \   |\n13 |     palindrome.push_str(&string[..palindrome.len() - suffix_len(&string)].chars().rev().collect::<String>());\n\
    \   |                                                      ^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let rev_string\
    \ = string.chars().rev().collect::<String>();\n    let longest_palindrome = longest_common_suffix(string,\
    \ rev_string);\n    let prefix = string.chars().take(string.len() - longest_palindrome.len()).collect::<String>();\n\
    \    return format!(\"{}{}{}\", string, prefix.chars().rev().collect::<String>(),\
    \ longest_palindrome);\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `longest_common_suffix` in this scope\n\
    \  --> /tmp/tmpzimc2ttz.rs:13:30\n   |\n13 |     let longest_palindrome = longest_common_suffix(string,\
    \ rev_string);\n   |                              ^^^^^^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let reverse =\
    \ string.chars().rev().collect::<String>();\n    let mut suffix = longest_common_suffix(&string,\
    \ &reverse);\n    if suffix.len() == string.len() {\n        return string;\n\
    \    }\n    let prefix = string.chars().take(string.len() - suffix.len()).collect::<String>();\n\
    \    suffix.push_str(&prefix.chars().rev().collect::<String>());\n    suffix\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `longest_common_suffix` in this scope\n\
    \  --> /tmp/tmphuwrjfkc.rs:13:22\n   |\n13 |     let mut suffix = longest_common_suffix(&string,\
    \ &reverse);\n   |                      ^^^^^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return String::new();\n    }\n\n    let (suffix, prefix) = find_palindrome_substring(&string);\n\
    \    let mut result = string;\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_palindrome_substring` in this\
    \ scope\n  --> /tmp/tmph_0naas_.rs:16:28\n   |\n16 |     let (suffix, prefix)\
    \ = find_palindrome_substring(&string);\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let rstring =\
    \ string.chars().rev().collect::<String>();\n    let mut suffix = String::new();\n\
    \    let mut prefix = String::new();\n    for (idx, _) in string.char_indices()\
    \ {\n        suffix.push(string.chars().nth(idx).unwrap());\n        if suffix\
    \ == rstring.chars().take(suffix.len()).collect::<String>() {\n            for\
    \ char in string.chars().skip(idx + 1) {\n                prefix.push(char);\n\
    \            }\n            break;\n        }\n    }\n    format!(\"{}{}{}\",\
    \ string, prefix.chars().rev().collect::<String>(), suffix)\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xx\"`,\n right: `\"x\"`', /tmp/tmpi3gp__ay.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    /// Return the\
    \ length of the longest palindromic suffix of a string.\n    fn longest_palindromic_suffix(string:\
    \ &str) -> usize {\n        let (mut right, mut left) = (string.len() - 1, string.len()\
    \ - 1);\n        while right > 0 && left > 0 {\n            if string.chars().nth(right).unwrap()\
    \ == string.chars().nth(left - 1).unwrap() {\n                right -= 1;\n  \
    \              left -= 1;\n            } else {\n                right = string.len()\
    \ - 1;\n                left -= 1;\n            }\n        }\n        string.len()\
    \ - right - 1\n    }\n\n    let palindromic_suffix_length = longest_palindromic_suffix(&string);\n\
    \    let prefix = string.chars().take(string.len() - palindromic_suffix_length).collect::<String>();\n\
    \    let suffix = prefix.chars().rev().collect::<String>();\n    format!(\"{}{}{}\"\
    , string, suffix, &string[palindromic_suffix_length..])\n}\n\nfn main() {\n  \
    \  let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpg7zloc3a.rs:14:38\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let n = string.len();\n\
    \    let mut i = n;\n    while i > 0 {\n        let suffix = &string[(n - i)..];\n\
    \        if is_palindrome(suffix) {\n            let prefix = &string[..(n - i)];\n\
    \            return format!(\"{}{}\", string, reverse(prefix));\n        }\n \
    \       i -= 1;\n    }\n    format!(\"{}{}\", string, reverse(&string))\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpq26pczoj.rs:16:12\n   |\n16 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `reverse` in this scope\n  --> /tmp/tmpq26pczoj.rs:18:44\n   |\n\
    18 |             return format!(\"{}{}\", string, reverse(prefix));\n   |    \
    \                                        ^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `reverse` in this scope\n  --> /tmp/tmpq26pczoj.rs:22:29\n\
    \   |\n22 |     format!(\"{}{}\", string, reverse(&string))\n   |            \
    \                 ^^^^^^^ not found in this scope\n\nerror: aborting due to 3\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let (mut long_suffix, reversed_prefix) = string.split_off(find_palindrome_suffix(&string).unwrap());\n\
    \    long_suffix.reverse();\n    string = format!(\"{}{}\", reversed_prefix, long_suffix);\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_palindrome_suffix` in this scope\n\
    \  --> /tmp/tmp_nx3rsv9.rs:13:63\n   |\n13 |     let (mut long_suffix, reversed_prefix)\
    \ = string.split_off(find_palindrome_suffix(&string).unwrap());\n   |        \
    \                                                       ^^^^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_nx3rsv9.rs:13:9\n\
    \   |\n13 |     let (mut long_suffix, reversed_prefix) = string.split_off(find_palindrome_suffix(&string).unwrap());\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ----------------------------------------------------------\
    \ this expression has type `String`\n   |         |\n   |         expected struct\
    \ `String`, found tuple\n   |\n   = note: expected struct `String`\n         \
    \      found tuple `(_, _)`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let longest_palindrome_suffix = find_longest_palindrome_suffix(&string);\n\
    \    let mut prefix = string.split_off(string.len() - longest_palindrome_suffix);\n\
    \    prefix.reverse();\n    string.push_str(&prefix);\n    string\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_longest_palindrome_suffix` in\
    \ this scope\n  --> /tmp/tmp60qfxvq_.rs:13:37\n   |\n13 |     let longest_palindrome_suffix\
    \ = find_longest_palindrome_suffix(&string);\n   |                           \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `reverse` found for struct `String` in the current scope\n \
    \ --> /tmp/tmp60qfxvq_.rs:15:12\n   |\n15 |     prefix.reverse();\n   |      \
    \      ^^^^^^^ help: there is an associated function with a similar name: `reserve`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let chars: Vec<char>\
    \ = string.chars().collect();\n    let reverse: Vec<char> = chars.iter().rev().map(|&c|\
    \ c).collect();\n    let (longest_palindrome, offset) = find_longest_palindrome(&chars,\
    \ &reverse);\n    let mut result = string;\n    result.push_str(&reverse[0..chars.len()\
    \ - offset].iter().collect::<String>());\n    result\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_longest_palindrome` in this scope\n\
    \  --> /tmp/tmp3oy58kw5.rs:14:40\n   |\n14 |     let (longest_palindrome, offset)\
    \ = find_longest_palindrome(&chars, &reverse);\n   |                         \
    \               ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return string;\n    }\n\n    let mut string_chars = string.chars().collect::<Vec<char>>();\n\
    \    string_chars.reverse();\n    let reversed_string = string_chars.iter().collect::<String>();\n\
    \n    if string == reversed_string {\n        return string;\n    }\n\n    let\
    \ string_len = string.len();\n    let reversed_string_len = reversed_string.len();\n\
    \n    let mut max_len = 0;\n    let mut i = 0;\n    while i < string_len {\n \
    \       let mut j = 0;\n        while i + j < string_len && j < reversed_string_len\
    \ {\n            if string.chars().nth(i + j) != reversed_string.chars().nth(j)\
    \ {\n                break;\n            }\n            j += 1;\n        }\n \
    \       if j > max_len {\n            max_len = j;\n        }\n        i += 1;\n\
    \    }\n\n    let mut result = string.clone();\n    for ch in reversed_string.chars().take(string_len\
    \ - max_len) {\n        result.push(ch);\n    }\n\n    result\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xyzzy\"`,\n right: `\"xyzyx\"`', /tmp/tmpsfzrserv.rs:55:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let rev_string\
    \ = string.chars().rev().collect::<String>();\n    if rev_string == string {\n\
    \        return string;\n    }\n    let kmp = KMP::new(&string);\n    let lps\
    \ = kmp.lps();\n    let l_string = string.len();\n    let l_prefix = l_string\
    \ - lps[l_string - 1];\n    let mut prefix = String::new();\n    for c in string.chars().take(l_prefix)\
    \ {\n        prefix.push(c);\n    }\n    let rev_prefix = prefix.chars().rev().collect::<String>();\n\
    \    format!(\"{}{}{}\", string, rev_prefix, string)\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `KMP`\n  --> /tmp/tmpp7k2zn3j.rs:16:15\n\
    \   |\n16 |     let kmp = KMP::new(&string);\n   |               ^^^ use of undeclared\
    \ type `KMP`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return string;\n    }\n\n    let mut suffix = String::new();\n  \
    \  let mut prefix = String::new();\n    for (i, c) in string.chars().enumerate()\
    \ {\n        let is_odd = i % 2 == 0;\n        if is_odd {\n            suffix.push(c);\n\
    \        } else {\n            prefix.push(c);\n        }\n    }\n\n    let middle\
    \ = string.len() / 2;\n    let palindrome_suffix = longest_palindrome_suffix(&string[middle..]);\n\
    \    prefix.push_str(&string[palindrome_suffix..]);\n    prefix.push_str(&suffix.chars().rev().collect::<String>());\n\
    \    prefix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `longest_palindrome_suffix` in this\
    \ scope\n  --> /tmp/tmplzv_b7yd.rs:28:29\n   |\n28 |     let palindrome_suffix\
    \ = longest_palindrome_suffix(&string[middle..]);\n   |                      \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let prefix_len = longest_palindrome_suffix(&string);\n\
    \    let prefix = &string[..string.len() - prefix_len];\n    result.push_str(prefix.chars().rev().collect::<String>().as_str());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `longest_palindrome_suffix` in this\
    \ scope\n  --> /tmp/tmpjh55v9rc.rs:13:22\n   |\n13 |     let prefix_len = longest_palindrome_suffix(&string);\n\
    \   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut output:\
    \ String = string.clone();\n    let mut size = output.len();\n    while size >\
    \ 0 {\n        if is_palindrome(&output[(output.len() - size)..output.len()])\
    \ {\n            output.push_str(&output[0..(output.len() - size)].chars().rev().collect::<String>());\n\
    \            break;\n        }\n        size -= 1;\n    }\n    output\n}\n\nfn\
    \ main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp86znjpkb.rs:15:12\n   |\n15 |         if is_palindrome(&output[(output.len()\
    \ - size)..output.len()]) {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut suffix\
    \ = longest_palindrome_suffix(string.clone());\n    let prefix = string.chars().take(string.len()\
    \ - suffix.len()).collect::<String>();\n    let mut prefix_rev = prefix.chars().rev().collect::<String>();\n\
    \    suffix.push_str(&prefix_rev);\n    suffix\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `longest_palindrome_suffix` in this\
    \ scope\n  --> /tmp/tmp5_tl499r.rs:12:22\n   |\n12 |     let mut suffix = longest_palindrome_suffix(string.clone());\n\
    \   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    // try to find\
    \ the suffix that is a palindrome.\n    let rx = Regex::new(r\".*?(\\w+)$\").unwrap();\n\
    \    match rx.captures(&string) {\n        None => string,\n        Some(cap)\
    \ => {\n            // it exists - now check if it is a palindrome\n         \
    \   let suffix = cap.get(1).unwrap().as_str();\n            let mut prefix: String\
    \ = string.chars().take(suffix.len()).collect();\n            let is_palindrome\
    \ = suffix == prefix.as_str();\n            if is_palindrome {\n             \
    \   // it is a palindrome - return the original string\n                string\n\
    \            } else {\n                // reverse the prefix and append to the\
    \ original string\n                prefix.reverse();\n                string +\
    \ prefix.as_str()\n            }\n        }\n    }\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmpoitjvkuy.rs:13:14\n   |\n13 |     let rx = Regex::new(r\".*?(\\w+)$\"\
    ).unwrap();\n   |              ^^^^^ use of undeclared type `Regex`\n\nerror[E0599]:\
    \ no method named `reverse` found for struct `String` in the current scope\n \
    \ --> /tmp/tmpoitjvkuy.rs:26:24\n   |\n26 |                 prefix.reverse();\n\
    \   |                        ^^^^^^^ help: there is an associated function with\
    \ a similar name: `reserve`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0433, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    // TODO\n   \
    \ String::new()\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"x\"`', /tmp/tmpf4kp5rtt.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return String::new();\n    }\n\n    let rev_prefix = string.chars().rev().collect::<String>();\n\
    \    let mut longest_palindrome = String::new();\n    let mut prefix_len = string.len()\
    \ - 1;\n    while prefix_len >= 0 {\n        let prefix = &string[0..prefix_len];\n\
    \        let palindrome = format!(\"{}{}\", prefix, rev_prefix[string.len() -\
    \ prefix_len..]);\n        if is_palindrome(&palindrome) {\n            longest_palindrome\
    \ = palindrome;\n            break;\n        }\n        prefix_len -= 1;\n   \
    \ }\n\n    format!(\"{}{}\", string, &rev_prefix[longest_palindrome.len()..])\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpc_s7ebpd.rs:22:12\n   |\n22 |         if is_palindrome(&palindrome)\
    \ {\n   |            ^^^^^^^^^^^^^ help: a local variable with a similar name\
    \ exists: `palindrome`\n\nerror[E0277]: the size for values of type `str` cannot\
    \ be known at compilation time\n   --> /tmp/tmpc_s7ebpd.rs:21:50\n    |\n21  |\
    \         let palindrome = format!(\"{}{}\", prefix, rev_prefix[string.len() -\
    \ prefix_len..]);\n    |                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized`\
    \ is not implemented for `str`\nnote: required by a bound in `ArgumentV1::<'a>::new_display`\n\
    \    = note: this error originates in the macro `$crate::__export::format_args`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0425.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return String::new();\n    }\n\n    let mut suffix = string.clone();\n\
    \    let mut prefix = String::new();\n    loop {\n        if is_palindrome(&suffix)\
    \ {\n            break;\n        }\n        let c = suffix.pop().unwrap();\n \
    \       prefix.push(c);\n    }\n\n    string + &prefix.chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpuh8fqy75.rs:19:12\n   |\n19 |         if is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    if string.is_empty() {\n        return string;\n    }\n    //\
    \ Find longest palindromic suffix.\n    let mut suffix_length = 0;\n    while\
    \ string.chars().nth(suffix_length) == string.chars().rev().nth(suffix_length)\
    \ {\n        suffix_length += 1;\n    }\n    // Append to the end of string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    string.push_str(&string[..string.len()\
    \ - suffix_length].chars().rev().collect::<String>());\n    string\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return string;\n    }\n\n    if string.len() == 1 {\n        return\
    \ format!(\"{}{}\", string, string);\n    }\n\n    let mut end_index = string.len()\
    \ - 1;\n    while end_index > 0 {\n        let (mut begin_index, mut end_index)\
    \ = (0, end_index);\n        while begin_index < end_index {\n            if string.chars().nth(begin_index)\
    \ != string.chars().nth(end_index) {\n                break;\n            }\n\
    \            begin_index += 1;\n            end_index -= 1;\n        }\n     \
    \   if begin_index >= end_index {\n            break;\n        }\n        end_index\
    \ -= 1;\n    }\n\n    let mut prefix = String::from(&string[0..end_index + 1]);\n\
    \    prefix.chars().rev().for_each(|c| string.push(c));\n    string\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "warning: value assigned to `end_index` is never read\n  --> /tmp/tmpxde511p1.rs:33:9\n\
    \   |\n33 |         end_index -= 1;\n   |         ^^^^^^^^^\n   |\n   = note:\
    \ `#[warn(unused_assignments)]` on by default\n   = help: maybe it is overwritten\
    \ before being read?\n\nerror[E0596]: cannot borrow `string` as mutable, as it\
    \ is not declared as mutable\n  --> /tmp/tmpxde511p1.rs:37:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |                    ------ help: consider changing\
    \ this to be mutable: `mut string`\n...\n37 |     prefix.chars().rev().for_each(|c|\
    \ string.push(c));\n   |                                       ^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nwarning: variable does not need to be mutable\n\
    \  --> /tmp/tmpxde511p1.rs:20:9\n   |\n20 |     let mut end_index = string.len()\
    \ - 1;\n   |         ----^^^^^^^^^\n   |         |\n   |         help: remove\
    \ this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\nwarning:\
    \ variable does not need to be mutable\n  --> /tmp/tmpxde511p1.rs:36:9\n   |\n\
    36 |     let mut prefix = String::from(&string[0..end_index + 1]);\n   |     \
    \    ----^^^^^^\n   |         |\n   |         help: remove this `mut`\n\nerror:\
    \ aborting due to previous error; 3 warnings emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let length =\
    \ string.len();\n    let mut reversed_prefix = string.clone();\n    reversed_prefix.reverse();\n\
    \    let mut postfix = string.clone();\n    postfix.push_str(&reversed_prefix);\n\
    \    let mut z_function = z_function(&postfix);\n    for i in 0..length {\n  \
    \      if z_function[i] == length - i {\n            return format!(\"{}{}\",\
    \ &string[i..], &reversed_prefix[..i]);\n        }\n    }\n    String::from(&postfix)\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `z_function` in this scope\n  --> /tmp/tmpx_g94_iv.rs:17:26\n\
    \   |\n17 |     let mut z_function = z_function(&postfix);\n   |             \
    \             ^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named\
    \ `reverse` found for struct `String` in the current scope\n  --> /tmp/tmpx_g94_iv.rs:14:21\n\
    \   |\n14 |     reversed_prefix.reverse();\n   |                     ^^^^^^^ help:\
    \ there is an associated function with a similar name: `reserve`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let (_, mut result)\
    \ = find_longest_palindrome_suffix(string);\n    let prefix = string.chars().take(string.len()\
    \ - result.len()).collect::<String>();\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_longest_palindrome_suffix` in\
    \ this scope\n  --> /tmp/tmpr9stmaq1.rs:12:27\n   |\n12 |     let (_, mut result)\
    \ = find_longest_palindrome_suffix(string);\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    // Find the longest\
    \ postfix that is palindrome.\n    let suffix_length = string.len() - longest_palindrome_suffix(&string);\n\
    \    // Take prefix of the string up to the palindromic suffix, reverse and append\
    \ to the string.\n    string + &string[..suffix_length].chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `longest_palindrome_suffix` in this\
    \ scope\n  --> /tmp/tmpnwsno0ga.rs:13:40\n   |\n13 |     let suffix_length = string.len()\
    \ - longest_palindrome_suffix(&string);\n   |                                \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if is_palindrome(&string)\
    \ {\n        return string;\n    }\n\n    let len = string.len();\n    let mut\
    \ palindrome_len = len - 1;\n    let mut palindrome_suffix = String::new();\n\
    \    let mut palindrome_prefix = String::new();\n\n    for _ in 0..len {\n   \
    \     palindrome_suffix.push(string.chars().nth(palindrome_len).unwrap());\n \
    \       palindrome_prefix.push(string.chars().nth(palindrome_len).unwrap());\n\
    \        palindrome_len -= 1;\n\n        if is_palindrome(&palindrome_suffix)\
    \ {\n            break;\n        }\n    }\n\n    let mut result = string;\n  \
    \  result.push_str(&palindrome_prefix.chars().rev().collect::<String>());\n\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpyk5m_rmu.rs:12:8\n   |\n12 |     if is_palindrome(&string) {\n   | \
    \       ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `is_palindrome` in this scope\n  --> /tmp/tmpyk5m_rmu.rs:26:12\n   |\n26 | \
    \        if is_palindrome(&palindrome_suffix) {\n   |            ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut suffix\
    \ = longest_palindrome(string.clone());\n    let prefix = String::from(&string[..string.len()\
    \ - suffix.len()]);\n    return prefix + &suffix.chars().rev().collect::<String>()\
    \ + &suffix;\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `longest_palindrome` in this scope\n\
    \  --> /tmp/tmp9su1rfhw.rs:12:22\n   |\n12 |     let mut suffix = longest_palindrome(string.clone());\n\
    \   |                      ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let string_ref\
    \ = string.as_str();\n    let reverse = string_ref.chars().rev().collect::<String>();\n\
    \    let mut prefix = String::new();\n    let mut postfix = String::new();\n \
    \   for i in 0..string_ref.len() + 1 {\n        let (prefix_part, postfix_part)\
    \ = string_ref.split_at(i);\n        let (postfix_part, prefix_part) = postfix_part.split_at(postfix_part.len()\
    \ - 1);\n        let is_palindrome =\n            prefix_part == postfix_part\
    \ && prefix_part == postfix_part.chars().rev().collect::<String>();\n        if\
    \ is_palindrome {\n            prefix = prefix_part.to_string();\n           \
    \ postfix = postfix_part.to_string();\n        }\n    }\n    if postfix.is_empty()\
    \ {\n        return string;\n    }\n    let prefix_reverse = prefix.chars().rev().collect::<String>();\n\
    \    String::from(prefix_reverse + string_ref)\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpxv5f9fmi.rs:18:65\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let reversed_string\
    \ = string.chars().rev().collect::<String>();\n    for i in (0..string.len()).rev()\
    \ {\n        if string[..i] == reversed_string[string.len() - i..] {\n       \
    \     return string + &reversed_string[string.len() - i..];\n        }\n    }\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `string`\n  --> /tmp/tmpaws0k9cz.rs:15:46\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \       ------ move occurs because `string` has type `String`, which does not\
    \ implement the `Copy` trait\n...\n15 |             return string + &reversed_string[string.len()\
    \ - i..];\n   |                    ------ value moved here   ^^^^^^^^^^^^ value\
    \ borrowed here after move\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return string;\n    }\n\n    let mut suffix = string.clone();\n \
    \   let mut prefix = suffix.clone();\n    prefix.reverse();\n\n    // Find the\
    \ index of the last letter in the palindromic suffix.\n    let mut last_palindrome_idx\
    \ = 0;\n    for i in 0..suffix.len() {\n        if suffix.starts_with(&prefix[i..])\
    \ {\n            last_palindrome_idx = i;\n            break;\n        }\n   \
    \ }\n\n    // Find the prefix that must be appended to the end.\n    let prefix_to_append\
    \ = &string[..string.len() - last_palindrome_idx];\n    let mut append = prefix_to_append.chars().rev().collect::<String>();\n\
    \n    // Append this prefix to the string.\n    string + &append\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmphhmi2p2w.rs:18:12\n   |\n18 |     prefix.reverse();\n\
    \   |            ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let s = string.as_bytes();\n\
    \    let mut suffix = Vec::new();\n    for i in 0..s.len() {\n        if is_palindrome(&s[i..])\
    \ {\n            suffix = (&s[i..]).to_vec();\n            break;\n        }\n\
    \    }\n    let mut res = string.clone();\n    res.extend_from_slice(&suffix.iter().rev().map(|&x|\
    \ x).collect::<Vec<u8>>());\n    res\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpjjnfayz8.rs:15:12\n   |\n15 |         if is_palindrome(&s[i..]) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `extend_from_slice` found for struct `String` in the current scope\n \
    \ --> /tmp/tmpjjnfayz8.rs:21:9\n   |\n21 |     res.extend_from_slice(&suffix.iter().rev().map(|&x|\
    \ x).collect::<Vec<u8>>());\n   |         ^^^^^^^^^^^^^^^^^ method not found in\
    \ `String`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0425, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut end = string.len();\n    for i in 0..string.len() {\n\
    \        if is_palindrome(&string[i..end]) {\n            string.push_str(&string[0..i].chars().rev().collect::<String>());\n\
    \            return string;\n        }\n    }\n    string\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpmlfrcnk2.rs:15:12\n   |\n15 |         if is_palindrome(&string[i..end])\
    \ {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut prefix_rev\
    \ = Vec::new();\n    let mut suffix = Vec::new();\n    let mut rev_suffix = Vec::new();\n\
    \    let mut rev_prefix = Vec::new();\n    let mut palindrome = Vec::new();\n\
    \    let chars: Vec<char> = string.chars().collect();\n    for i in 0..chars.len()\
    \ {\n        suffix.push(chars[i]);\n        rev_suffix.push(chars[chars.len()\
    \ - 1 - i]);\n        rev_prefix.push(chars[i]);\n        if &suffix == &rev_suffix\
    \ {\n            prefix_rev = rev_prefix.clone();\n        }\n    }\n    palindrome.extend(string.chars());\n\
    \    palindrome.extend(prefix_rev.iter().rev());\n    String::from_iter(palindrome)\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no function or associated item named `from_iter` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpe9wfw6o4.rs:28:13\n   |\n\
    28 |     String::from_iter(palindrome)\n   |             ^^^^^^^^^ function or\
    \ associated item not found in `String`\n   |\n   = help: items from traits can\
    \ only be used if the trait is in scope\nhelp: the following trait is implemented\
    \ but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n\
    \   |\nhelp: there is an associated function with a similar name\n   |\n28 | \
    \    String::from_utf8(palindrome)\n   |             ~~~~~~~~~\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut end_of_palindrome\
    \ = 0;\n    for (i, _) in string.char_indices() {\n        if is_palindrome(&string[0..i])\
    \ {\n            end_of_palindrome = i;\n        }\n    }\n    String::from(&string[0..end_of_palindrome])\
    \ + &string[..string.len() - end_of_palindrome].chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmprhz9c6af.rs:14:12\n   |\n14 |         if is_palindrome(&string[0..i])\
    \ {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let s = string.as_bytes();\n\
    \    let mut len = 0;\n    for i in 0..s.len() {\n        if s[i] == s[s.len()\
    \ - 1 - i] {\n            len += 1;\n        } else {\n            break;\n  \
    \      }\n    }\n    let mut result = String::from(&string[len..]);\n    result.push_str(&reverse(&string[..s.len()\
    \ - len]));\n    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `reverse` in this scope\n  --> /tmp/tmp7c6n92oh.rs:22:22\n\
    \   |\n22 |     result.push_str(&reverse(&string[..s.len() - len]));\n   |   \
    \                   ^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return string;\n    }\n\n    let mut longest_palindrome_idx = 0;\n\
    \    let mut longest_palindrome_len = 0;\n\n    let mut max_idx = string.len()\
    \ * 2 - 1;\n    for i in 0..max_idx {\n        let idx_to_check = i / 2;\n   \
    \     let mut left_idx = idx_to_check;\n        let mut right_idx = left_idx +\
    \ i % 2;\n        let mut palindrome_len = 0;\n\n        while left_idx >= 0 &&\
    \ right_idx < string.len() && string.as_bytes()[left_idx] == string.as_bytes()[right_idx]\
    \ {\n            palindrome_len += 1;\n            left_idx -= 1;\n          \
    \  right_idx += 1;\n        }\n\n        if palindrome_len > longest_palindrome_len\
    \ {\n            longest_palindrome_len = palindrome_len;\n            longest_palindrome_idx\
    \ = idx_to_check;\n        }\n    }\n\n    let mut result = string.chars().take(longest_palindrome_idx).rev().collect::<String>();\n\
    \    result.push_str(&string);\n    result\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmpz6_hwwtp.rs:38:66\n     |\n38   |     let mut result = string.chars().take(longest_palindrome_idx).rev().collect::<String>();\n\
    \     |                                                                  ^^^ the\
    \ trait `ExactSizeIterator` is not implemented for `Chars<'_>`\n     |\n     =\
    \ help: the following other types implement trait `ExactSizeIterator`:\n     \
    \          &mut I\n               Args\n               ArgsOs\n              \
    \ ArrayChunks<'_, T, N>\n               ArrayChunksMut<'_, T, N>\n           \
    \    ArrayWindows<'_, T, N>\n               Box<I, A>\n               Chunks<'_,\
    \ T>\n             and 109 others\n     = note: required because of the requirements\
    \ on the impl of `DoubleEndedIterator` for `std::iter::Take<Chars<'_>>`\nnote:\
    \ required by a bound in `rev`\n\nerror[E0599]: the method `collect` exists for\
    \ struct `Rev<std::iter::Take<Chars<'_>>>`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmpz6_hwwtp.rs:38:72\n   |\n38 |        let mut result = string.chars().take(longest_palindrome_idx).rev().collect::<String>();\n\
    \   |                                                                        \
    \   ^^^^^^^ method cannot be called on `Rev<std::iter::Take<Chars<'_>>>` due to\
    \ unsatisfied trait bounds\n   |\n   = note: the following trait bounds were not\
    \ satisfied:\n           `std::iter::Take<Chars<'_>>: DoubleEndedIterator`\n \
    \          which is required by `Rev<std::iter::Take<Chars<'_>>>: Iterator`\n\
    \           `Rev<std::iter::Take<Chars<'_>>>: Iterator`\n           which is required\
    \ by `&mut Rev<std::iter::Take<Chars<'_>>>: Iterator`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let suffix = longest_palindromic_suffix(&string);\n    let prefix\
    \ = string.split_off(string.len() - suffix.len());\n    prefix.chars().rev().collect::<String>()\
    \ + &string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `longest_palindromic_suffix` in this\
    \ scope\n  --> /tmp/tmpf40m2l52.rs:13:18\n   |\n13 |     let suffix = longest_palindromic_suffix(&string);\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let (prefix,\
    \ _) = find_longest_palindrome_suffix(&string);\n    let mut result = String::new();\n\
    \    result.push_str(&prefix);\n    result.push_str(&string);\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_longest_palindrome_suffix` in\
    \ this scope\n  --> /tmp/tmp1s_mvpcx.rs:12:23\n   |\n12 |     let (prefix, _)\
    \ = find_longest_palindrome_suffix(&string);\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0277]: the size for values of type `str` cannot\
    \ be known at compilation time\n  --> /tmp/tmp1s_mvpcx.rs:12:10\n   |\n12 |  \
    \   let (prefix, _) = find_longest_palindrome_suffix(&string);\n   |         \
    \ ^^^^^^ doesn't have a size known at compile-time\n   |\n   = help: the trait\
    \ `Sized` is not implemented for `str`\n   = note: all local variables must have\
    \ a statically known size\n   = help: unsized locals are gated as an unstable\
    \ feature\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    // Find the longest\
    \ suffix of a string that is a palindrome.\n    let palindrome_suffix = find_palindrome_suffix(&string);\n\
    \    // Generate a reverse of a string prefix.\n    let reversed_prefix = string.chars().take(string.len()\
    \ - palindrome_suffix.len()).rev().collect();\n    // Append the reverse of the\
    \ prefix to the end of the string.\n    format!(\"{}{}\", string, reversed_prefix)\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_palindrome_suffix` in this scope\n\
    \  --> /tmp/tmpkk8ajiqo.rs:13:29\n   |\n13 |     let palindrome_suffix = find_palindrome_suffix(&string);\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmpkk8ajiqo.rs:15:87\n     |\n15   |     let reversed_prefix = string.chars().take(string.len()\
    \ - palindrome_suffix.len()).rev().collect();\n     |                        \
    \                                                               ^^^ the trait\
    \ `ExactSizeIterator` is not implemented for `Chars<'_>`\n     |\n     = help:\
    \ the following other types implement trait `ExactSizeIterator`:\n           \
    \    &mut I\n               Args\n               ArgsOs\n               ArrayChunks<'_,\
    \ T, N>\n               ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_,\
    \ T, N>\n               Box<I, A>\n               Chunks<'_, T>\n            \
    \ and 109 others\n     = note: required because of the requirements on the impl\
    \ of `DoubleEndedIterator` for `std::iter::Take<Chars<'_>>`\nnote: required by\
    \ a bound in `rev`\n\nerror[E0599]: the method `collect` exists for struct `Rev<std::iter::Take<Chars<'_>>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpkk8ajiqo.rs:15:93\n \
    \  |\n15 |        let reversed_prefix = string.chars().take(string.len() - palindrome_suffix.len()).rev().collect();\n\
    \   |                                                                        \
    \                        ^^^^^^^ method cannot be called on `Rev<std::iter::Take<Chars<'_>>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `std::iter::Take<Chars<'_>>: DoubleEndedIterator`\n\
    \           which is required by `Rev<std::iter::Take<Chars<'_>>>: Iterator`\n\
    \           `Rev<std::iter::Take<Chars<'_>>>: Iterator`\n           which is required\
    \ by `&mut Rev<std::iter::Take<Chars<'_>>>: Iterator`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E02"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let palindrome_postfix\
    \ = find_longest_palindrome_postfix(&string);\n    let reverse_prefix = string.chars().take(string.len()\
    \ - palindrome_postfix.len()).rev().collect();\n    string + &reverse_prefix\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_longest_palindrome_postfix` in\
    \ this scope\n  --> /tmp/tmp1_0_bg7r.rs:12:30\n   |\n12 |     let palindrome_postfix\
    \ = find_longest_palindrome_postfix(&string);\n   |                          \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]:\
    \ the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n    --> /tmp/tmp1_0_bg7r.rs:13:87\n\
    \     |\n13   |     let reverse_prefix = string.chars().take(string.len() - palindrome_postfix.len()).rev().collect();\n\
    \     |                                                                      \
    \                 ^^^ the trait `ExactSizeIterator` is not implemented for `Chars<'_>`\n\
    \     |\n     = help: the following other types implement trait `ExactSizeIterator`:\n\
    \               &mut I\n               Args\n               ArgsOs\n         \
    \      ArrayChunks<'_, T, N>\n               ArrayChunksMut<'_, T, N>\n      \
    \         ArrayWindows<'_, T, N>\n               Box<I, A>\n               Chunks<'_,\
    \ T>\n             and 109 others\n     = note: required because of the requirements\
    \ on the impl of `DoubleEndedIterator` for `std::iter::Take<Chars<'_>>`\nnote:\
    \ required by a bound in `rev`\n\nerror[E0599]: the method `collect` exists for\
    \ struct `Rev<std::iter::Take<Chars<'_>>>`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmp1_0_bg7r.rs:13:93\n   |\n13 |        let reverse_prefix = string.chars().take(string.len()\
    \ - palindrome_postfix.len()).rev().collect();\n   |                         \
    \                                                                       ^^^^^^^\
    \ method cannot be called on `Rev<std::iter::Take<Chars<'_>>>` due to unsatisfied\
    \ trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `std::iter::Take<Chars<'_>>: DoubleEndedIterator`\n           which\
    \ is required by `Rev<std::iter::Take<Chars<'_>>>: Iterator`\n           `Rev<std::iter::Take<Chars<'_>>>:\
    \ Iterator`\n           which is required by `&mut Rev<std::iter::Take<Chars<'_>>>:\
    \ Iterator`\n\nerror: aborting due to 3 previous errors\n\nSome errors ha"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let s = string.as_bytes();\n\
    \    let mut preprocessed = vec![0; s.len()];\n    let mut j = 0;\n    for i in\
    \ 1..s.len() {\n        while j > 0 && s[i] != s[j] {\n            j = preprocessed[j\
    \ - 1];\n        }\n        if s[i] == s[j] {\n            j += 1;\n        }\n\
    \        preprocessed[i] = j;\n    }\n    let mut s = string.chars().collect::<Vec<char>>();\n\
    \    let prefix = &s[..s.len() - j];\n    s.extend(prefix.iter().rev());\n   \
    \ s.iter().collect()\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `s` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmpchfg4w_d.rs:26:5\n   |\n25 |     let prefix = &s[..s.len()\
    \ - j];\n   |                   - immutable borrow occurs here\n26 |     s.extend(prefix.iter().rev());\n\
    \   |     ^^------^^^^^^^^^^^^^^^^^^^^^\n   |     | |\n   |     | immutable borrow\
    \ later used by call\n   |     mutable borrow occurs here\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let reverse =\
    \ string.chars().rev().collect::<String>();\n    let mut string = string.clone();\n\
    \    if string == reverse {\n        return string;\n    }\n    let mut longest_palindrome\
    \ = 0;\n    let mut palindrome_from = 0;\n    for i in 0..string.len() {\n   \
    \     let substring = &string[i..];\n        let reversed_substring = &reverse[..string.len()\
    \ - i];\n        if substring == reversed_substring {\n            longest_palindrome\
    \ = i;\n            palindrome_from = string.len() - i;\n        }\n    }\n  \
    \  if longest_palindrome == 0 {\n        return string;\n    }\n    let prefix\
    \ = &string[..palindrome_from];\n    let reverse_prefix = prefix.chars().rev().collect::<String>();\n\
    \    string.push_str(&reverse_prefix);\n    string\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xyzx\"`,\n right: `\"xyzyx\"`', /tmp/tmplod3pea9.rs:40:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return string;\n    }\n\n    let mut rev_string = string.clone();\n\
    \    rev_string.make_ascii_lowercase();\n    rev_string.chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"zyx\"`,\n right: `\"xyzyx\"`', /tmp/tmpv2pr7weo.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return string;\n    }\n\n    let chars: Vec<char> = string.chars().collect();\n\
    \    let mut suffix_chars: Vec<char> = vec![];\n    let mut prefix_chars: Vec<char>\
    \ = vec![];\n\n    // find palindromic suffix\n    let mut is_palindrome = true;\n\
    \    let mut suffix_index = chars.len() - 1;\n    while suffix_index >= 0 {\n\
    \        let current_char = chars[suffix_index];\n        suffix_chars.push(current_char);\n\
    \        if is_palindrome {\n            let mut prefix_index = 0;\n         \
    \   while suffix_chars.len() - 1 - prefix_index >= 0 {\n                if suffix_chars[suffix_chars.len()\
    \ - 1 - prefix_index] != current_char {\n                    is_palindrome = false;\n\
    \                    break;\n                }\n                prefix_index +=\
    \ 1;\n            }\n        }\n        suffix_index -= 1;\n    }\n\n    // trim\
    \ palindromic suffix\n    for _ in 0..suffix_chars.len() {\n        chars.pop();\n\
    \    }\n\n    // collect palindromic prefix\n    for i in 0..chars.len() {\n \
    \       prefix_chars.push(chars[i]);\n    }\n\n    // build result\n    let mut\
    \ result = string;\n    for i in (0..prefix_chars.len()).rev() {\n        result.push(prefix_chars[i]);\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `chars` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpuz3ww04y.rs:41:9\n   |\n16 |     let chars: Vec<char>\
    \ = string.chars().collect();\n   |         ----- help: consider changing this\
    \ to be mutable: `mut chars`\n...\n41 |         chars.pop();\n   |         ^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut postfix\
    \ = suffix_palindrome(string.clone());\n    let mut prefix = postfix.chars().rev().collect::<String>();\n\
    \    postfix.pop();\n    prefix += &postfix;\n    prefix\n}\n\nfn main() {\n \
    \   let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `suffix_palindrome` in this scope\n\
    \  --> /tmp/tmpp_pwa2b4.rs:12:23\n   |\n12 |     let mut postfix = suffix_palindrome(string.clone());\n\
    \   |                       ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return string;\n    }\n\n    let longest_suffix = longest_palindromic_suffix(&string);\n\
    \    let prefix = &string[..string.len() - longest_suffix.len()];\n    let prefix_reversed\
    \ = prefix.chars().rev().collect::<String>();\n    let mut result = string;\n\
    \    result.push_str(&prefix_reversed);\n    result\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `longest_palindromic_suffix` in this\
    \ scope\n  --> /tmp/tmp606n37ug.rs:16:26\n   |\n16 |     let longest_suffix =\
    \ longest_palindromic_suffix(&string);\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    // Find palindromic\
    \ suffix\n    let mut palindromic_suffix = String::new();\n    for (i, c) in string.chars().enumerate()\
    \ {\n        let is_palindrome = string.chars().skip(i).eq(string.chars().take(i).rev());\n\
    \        if is_palindrome {\n            palindromic_suffix = String::from(&string[i..]);\n\
    \        }\n    }\n\n    // Append reverse of prefix\n    let string_prefix =\
    \ String::from(&string[..(string.len() - palindromic_suffix.len())]);\n    let\
    \ string_prefix_reverse = string_prefix.chars().rev().collect::<String>();\n \
    \   let result = format!(\"{}{}{}\", string_prefix, palindromic_suffix, string_prefix_reverse);\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmpfiydk328.rs:15:78\n     |\n15   |         let is_palindrome =\
    \ string.chars().skip(i).eq(string.chars().take(i).rev());\n     |           \
    \                                                                   ^^^ the trait\
    \ `ExactSizeIterator` is not implemented for `Chars<'_>`\n     |\n     = help:\
    \ the following other types implement trait `ExactSizeIterator`:\n           \
    \    &mut I\n               Args\n               ArgsOs\n               ArrayChunks<'_,\
    \ T, N>\n               ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_,\
    \ T, N>\n               Box<I, A>\n               Chunks<'_, T>\n            \
    \ and 109 others\n     = note: required because of the requirements on the impl\
    \ of `DoubleEndedIterator` for `std::iter::Take<Chars<'_>>`\nnote: required by\
    \ a bound in `rev`\n\nerror[E0277]: the trait bound `Chars<'_>: ExactSizeIterator`\
    \ is not satisfied\n  --> /tmp/tmpfiydk328.rs:15:55\n   |\n15 |         let is_palindrome\
    \ = string.chars().skip(i).eq(string.chars().take(i).rev());\n   |           \
    \                                         -- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the\
    \ trait `ExactSizeIterator` is not implemented for `Chars<'_>`\n   |         \
    \                                           |\n   |                          \
    \                          required by a bound introduced by this call\n   |\n\
    \   = help: the following other types implement trait `ExactSizeIterator`:\n \
    \            &mut I\n             Args\n             ArgsOs\n             ArrayChunks<'_,\
    \ T, N>\n             ArrayChunksMut<'_, T, N>\n             ArrayWindows<'_,\
    \ T, N>\n             Box<I, A>\n             Chunks<'_, T>\n           and 109\
    \ others\n   = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `std::iter::Take<Chars<'_>>`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Rev<std::iter::Take<Chars<'_>>>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let reversed\
    \ = string.chars().rev().collect::<String>();\n    let mut final_string = String::new();\n\
    \    let mut start = 0;\n    let mut end = 1;\n    let mut length = 0;\n    let\
    \ mut length_at_center = 1;\n    let len = string.len();\n    let mut match_index\
    \ = 0;\n    let max_length = (len * 2) - 1;\n    let mut ps = vec![0; max_length];\n\
    \    // One by one consider every character as center point of\n    // even and\
    \ length palindromes\n    for i in 0..max_length {\n        // Find the longest\
    \ even length palindrome with center\n        // points as i-1 and i.\n      \
    \  if i > end {\n            length = 0;\n            start = i - 1;\n       \
    \     end = i;\n        }\n        let j = (start * 2) - i;\n        // Check\
    \ whether the i-th character is at the middle\n        // of the given string\n\
    \        if i % 2 == 0 {\n            if i > max_length / 2 {\n              \
    \  break;\n            }\n            ps[i] = if length_at_center >= i / 2 {\n\
    \                length_at_center\n            } else {\n                0\n \
    \           };\n        } else {\n            ps[i] = if (end - i) > (ps[j] as\
    \ isize) {\n                ps[j]\n            } else {\n                end -\
    \ i\n            } as usize;\n        }\n        // Expand palindrome centered\
    \ at i\n        while (start > 0) && (end < max_length) &&\n              (reversed.chars().nth(start\
    \ - 1) == string.chars().nth(end)) {\n            start -= 1;\n            end\
    \ += 1;\n            ps[i] += 1;\n        }\n        // If palindrome centered\
    \ at i expand past R,\n        // adjust center based on expanded palindrome.\n\
    \        if i + ps[i] > end {\n            start = i - ps[i];\n            end\
    \ = i + ps[i];\n            length = ps[i];\n            match_index = i;\n  \
    \      }\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmps0a18y6k.rs:75:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n53 |            \
    \   (reversed.chars().nth(start - 1) == string.chars().nth(end)) {\n   |     \
    \                                                                       - this\
    \ delimiter might not be properly closed...\n...\n57 |         }\n   |       \
    \  - ...as it matches this but it has different indentation\n...\n75 | }\n   |\
    \   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps0a18y6k.rs:45:36\n   |\n\
    45 |             ps[i] = if (end - i) > (ps[j] as isize) {\n   |             \
    \                       ^^^^^^^^^^^^^^^^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n45 |             ps[i] = if (end - i) > ((ps[j] as isize)).try_into().unwrap()\
    \ {\n   |                                    +                +++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmps0a18y6k.rs:11:39\n   |\n11 |\
    \ fn make_palindrome(string: String) -> String {\n   |    ---------------    \
    \                ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    // Palindrome:\
    \ 'abba' or 'aba' or 'a'\n    if is_palindrome(&string) {\n        return string;\n\
    \    }\n\n    let mut suffix_len = 0;\n    for (offset, _) in string.char_indices().rev()\
    \ {\n        if is_palindrome(&string[..offset + 1]) {\n            suffix_len\
    \ = string.len() - offset - 1;\n            break;\n        }\n    }\n\n    //\
    \ String prefix that comes before the palindromic suffix\n    let prefix = &string[..string.len()\
    \ - suffix_len];\n    let prefix_reversed = prefix.chars().rev().collect::<String>();\n\
    \n    string + &prefix_reversed\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp13ebrelt.rs:13:8\n   |\n13 |     if is_palindrome(&string) {\n   | \
    \       ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `is_palindrome` in this scope\n  --> /tmp/tmp13ebrelt.rs:19:12\n   |\n19 | \
    \        if is_palindrome(&string[..offset + 1]) {\n   |            ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return String::new();\n    }\n\n    let n = string.len();\n    let\
    \ (suffix, rest) = string.split_at(n - 1);\n    let suffix = suffix.to_string();\n\
    \    let rest = rest.to_string();\n\n    if is_palindrome(&suffix) {\n       \
    \ return string;\n    }\n\n    let reversed_prefix = reverse(&rest);\n    format!(\"\
    {}{}\", reversed_prefix, string)\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpvt3sv8qv.rs:21:8\n   |\n21 |     if is_palindrome(&suffix) {\n   | \
    \       ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `reverse` in this scope\n  --> /tmp/tmpvt3sv8qv.rs:25:27\n   |\n25 |     let\
    \ reversed_prefix = reverse(&rest);\n   |                           ^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let length =\
    \ string.len();\n    let mut palindrome_length = length;\n    while !is_palindrome(&string[0..palindrome_length])\
    \ {\n        palindrome_length -= 1;\n    }\n    let prefix = &string[0..length\
    \ - palindrome_length];\n    let mut result = string;\n    result.push_str(&reverse_string(prefix));\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp3dnt2kl0.rs:14:12\n   |\n14 |     while !is_palindrome(&string[0..palindrome_length])\
    \ {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `reverse_string` in this scope\n  --> /tmp/tmp3dnt2kl0.rs:19:22\n\
    \   |\n19 |     result.push_str(&reverse_string(prefix));\n   |              \
    \        ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    /// Find the\
    \ longest palindromic suffix of a supplied string.\n    /// Algorithm:\n    ///\
    \ - Compute the longest proper suffix that is also a prefix of a supplied string.\n\
    \    /// - If the suffix is the full string, then the string is already a palindrome.\n\
    \    /// - Otherwise, suffix will be a proper prefix that is also a suffix. In\
    \ this case:\n    ///   - take the reverse of a string prefix,\n    ///   - append\
    \ it to the end of the string.\n    /// >>> find_palindromic_suffix(\"\")\n  \
    \  /// \"\"\n    /// >>> find_palindromic_suffix(\"a\")\n    /// \"a\"\n    ///\
    \ >>> find_palindromic_suffix(\"abc\")\n    /// \"abcba\"\n    /// >>> find_palindromic_suffix(\"\
    abcda\")\n    /// \"abcda\"\n    /// >>> find_palindromic_suffix(\"abcdabcd\"\
    )\n    /// \"abcdabcd\"\n    fn find_palindromic_suffix(string: &str) -> String\
    \ {\n        let n = string.len();\n        if n == 0 {\n            String::new()\n\
    \        } else {\n            let reversed_prefix = &string[..n-1].chars().rev().collect::<String>();\n\
    \            format!(\"{}{}\", string, reversed_prefix)\n        }\n    }\n\n\
    \    find_palindromic_suffix(&string)\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xyxyx\"`,\n right: `\"xyx\"`', /tmp/tmpfh83x4hc.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return String::new();\n    }\n\n    let mut suffix = String::new();\n\
    \    for (idx, ch) in string.chars().enumerate() {\n        if is_palindrome(&string[idx..])\
    \ {\n            suffix = string[idx..].to_string();\n            break;\n   \
    \     }\n    }\n\n    let prefix = suffix.chars().rev().collect::<String>();\n\
    \    format!(\"{}{}\", string, prefix)\n}\n\nfn main() {\n    let candidate =\
    \ make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp4b3s6jdr.rs:18:12\n   |\n18 |         if is_palindrome(&string[idx..])\
    \ {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let (pre, post)\
    \ = find_palindrome_postfix(&string);\n    let pre_rev = pre.chars().rev().collect::<String>();\n\
    \    let mut res = pre_rev + &string;\n    res.push_str(&post);\n    res\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_palindrome_postfix` in this scope\n\
    \  --> /tmp/tmpbr9rzfj6.rs:12:23\n   |\n12 |     let (pre, post) = find_palindrome_postfix(&string);\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let n = string.len();\n\
    \    let mut string = string.into_bytes();\n    for i in 0..n {\n        string.push(string[n\
    \ - i - 1]);\n    }\n    let (mut kmp, _) = KMP::new(&string, n);\n    let mut\
    \ suffix_length = n - kmp[n];\n    for i in 0..n - suffix_length {\n        string.push(string[i]);\n\
    \    }\n    String::from_utf8(string).unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `KMP`\n  --> /tmp/tmpwnubdve8.rs:17:24\n\
    \   |\n17 |     let (mut kmp, _) = KMP::new(&string, n);\n   |               \
    \         ^^^ use of undeclared type `KMP`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let longest_palindrome_suffix = longest_palindrome_suffix(&string);\n\
    \    if string.len() == longest_palindrome_suffix.len() {\n        return string;\n\
    \    }\n    string.push_str(&string[..string.len() - longest_palindrome_suffix.len()].chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `longest_palindrome_suffix` in this\
    \ scope\n  --> /tmp/tmp00cr1d_k.rs:13:37\n   |\n13 |     let longest_palindrome_suffix\
    \ = longest_palindrome_suffix(&string);\n   |                                \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let len = string.len();\n\
    \    let string = string.as_bytes();\n    let mut prefix = Vec::with_capacity(len);\n\
    \    let mut suffix = Vec::with_capacity(len);\n    let mut pi = vec![0; len];\n\
    \    let mut i = 1;\n    let mut j = 0;\n    while i < len {\n        if string[i]\
    \ == string[j] {\n            pi[i] = j + 1;\n            j += 1;\n          \
    \  i += 1;\n        } else {\n            if j == 0 {\n                pi[i] =\
    \ 0;\n                i += 1;\n            } else {\n                j = pi[j\
    \ - 1];\n            }\n        }\n    }\n    for i in pi.iter().rev() {\n   \
    \     if *i == 0 {\n            break;\n        }\n        suffix.push(string[*i]);\n\
    \    }\n    for i in 0..len - pi[len - 1] {\n        prefix.push(string[i]);\n\
    \    }\n    let mut result = String::new();\n    for i in string {\n        result.push(*i\
    \ as char);\n    }\n    for i in prefix.iter().rev() {\n        result.push(*i\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp9v3xk3qi.rs:39:26\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let reverse = string.chars().rev().collect::<String>();\n\
    \    let index = string.find(&reverse);\n    if let Some(i) = index {\n      \
    \  let prefix = string.get(..i).unwrap();\n        result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xyz\"`,\n right: `\"xyzyx\"`', /tmp/tmpz8_0vx9f.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let n = string.len();\n\
    \    if n <= 1 {\n        return string;\n    }\n    let chars: Vec<char> = string.chars().collect();\n\
    \    let mut palindrome_suffix_len = 1;\n    while palindrome_suffix_len <= n\
    \ {\n        let mut good = true;\n        for i in 0..palindrome_suffix_len /\
    \ 2 {\n            if chars[n - palindrome_suffix_len + i] != chars[n - palindrome_suffix_len\
    \ + palindrome_suffix_len - i - 1] {\n                good = false;\n        \
    \        break;\n            }\n        }\n        if good {\n            break;\n\
    \        }\n        palindrome_suffix_len += 1;\n    }\n    let mut result = string;\n\
    \    result.push_str(&string[0..n - palindrome_suffix_len].chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `string`\n  --> /tmp/tmpiupg8uvh.rs:32:22\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \       ------ move occurs because `string` has type `String`, which does not\
    \ implement the `Copy` trait\n...\n31 |     let mut result = string;\n   |   \
    \                   ------ value moved here\n32 |     result.push_str(&string[0..n\
    \ - palindrome_suffix_len].chars().rev().collect::<String>());\n   |         \
    \             ^^^^^^ value borrowed here after move\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let string =\
    \ format!(\"{}$\", string);\n    let length = string.len();\n    let mut suffix_array\
    \ = suffix_array(&string);\n    let mut lcp_array = lcp_array(&string, &suffix_array);\n\
    \    lcp_array.insert(0, 0);\n    lcp_array.insert(length, 0);\n    let suffix_palindrome_lengths\
    \ = lcp_array.windows(3).map(|w| cmp::min(w[0], w[2])).collect::<Vec<_>>();\n\
    \    let longest_suffix_palindrome_length = suffix_palindrome_lengths.iter().cloned().max().unwrap();\n\
    \    let longest_suffix_palindrome_index = suffix_palindrome_lengths.iter().position(|&x|\
    \ x == longest_suffix_palindrome_length).unwrap();\n    let longest_suffix_palindrome_suffix_index\
    \ = suffix_array[longest_suffix_palindrome_index];\n    let longes_suffix_palindrome_suffix\
    \ = &string[longest_suffix_palindrome_suffix_index..(longest_suffix_palindrome_suffix_index\
    \ + longest_suffix_palindrome_length)];\n    let longest_suffix_palindrome_prefix\
    \ = &string[0..(length - longest_suffix_palindrome_suffix_index - longest_suffix_palindrome_length)];\n\
    \    format!(\"{}{}{}\", longest_suffix_palindrome_prefix, longes_suffix_palindrome_suffix,\
    \ longest_suffix_palindrome_prefix.chars().rev().collect::<String>())\n}\n\nfn\
    \ main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmp701q6y0j.rs:18:66\n   |\n18 |     let suffix_palindrome_lengths\
    \ = lcp_array.windows(3).map(|w| cmp::min(w[0], w[2])).collect::<Vec<_>>();\n\
    \   |                                                                  ^^^ use\
    \ of undeclared crate or module `cmp`\n\nerror[E0425]: cannot find function `suffix_array`\
    \ in this scope\n  --> /tmp/tmp701q6y0j.rs:14:28\n   |\n14 |     let mut suffix_array\
    \ = suffix_array(&string);\n   |                            ^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `lcp_array` in this scope\n\
    \  --> /tmp/tmp701q6y0j.rs:15:25\n   |\n15 |     let mut lcp_array = lcp_array(&string,\
    \ &suffix_array);\n   |                         ^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return String::new();\n    }\n\n    let string_bytes = string.into_bytes();\n\
    \    let n = string_bytes.len();\n    let mut longest_palindrome_length = 0;\n\
    \    for i in 0..n {\n        if i % 2 == 0 {\n            // even length palindrome\
    \ length\n            let palindrome_length = palindrome_length_at(&string_bytes,\
    \ i);\n            if palindrome_length > longest_palindrome_length {\n      \
    \          longest_palindrome_length = palindrome_length;\n            }\n   \
    \     } else {\n            // odd length palindrome length\n            let palindrome_length\
    \ = palindrome_length_at(&string_bytes, i) - 1;\n            if palindrome_length\
    \ > longest_palindrome_length {\n                longest_palindrome_length = palindrome_length;\n\
    \            }\n        }\n    }\n\n    let mut result = String::new();\n    result.push_str(&string);\n\
    \    for i in 0..(n - longest_palindrome_length) {\n        result.push(string_bytes[i]\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `palindrome_length_at` in this scope\n\
    \  --> /tmp/tmpkyydhkee.rs:22:37\n   |\n22 |             let palindrome_length\
    \ = palindrome_length_at(&string_bytes, i);\n   |                            \
    \         ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `palindrome_length_at` in this scope\n  --> /tmp/tmpkyydhkee.rs:28:37\n\
    \   |\n28 |             let palindrome_length = palindrome_length_at(&string_bytes,\
    \ i) - 1;\n   |                                     ^^^^^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let end = find_palindrome_postfix(&string);\n    string.push_str(&string[..end].chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_palindrome_postfix` in this scope\n\
    \  --> /tmp/tmp7s9f_bz4.rs:13:15\n   |\n13 |     let end = find_palindrome_postfix(&string);\n\
    \   |               ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        string\n    } else {\n        let mut suffix = string.clone();\n\
    \        let mut prefix = String::new();\n        while !is_palindrome(&suffix)\
    \ {\n            suffix.pop();\n            let new_char = string.chars().last().unwrap();\n\
    \            prefix.push(new_char);\n        }\n        string + &prefix.chars().rev().collect::<String>()\n\
    \    }\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpnx57f6_a.rs:17:16\n   |\n17 |         while !is_palindrome(&suffix)\
    \ {\n   |                ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let reversed_string\
    \ = reverse(string.clone());\n    let palindrome_suffix = longest_common_substring(string,\
    \ reversed_string);\n    let prefix = string.split(&palindrome_suffix).collect::<Vec<&str>>()[0];\n\
    \    let reversed_prefix = reverse(prefix.to_string());\n    format!(\"{}{}{}\"\
    , prefix, palindrome_suffix, reversed_prefix)\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `reverse` in this scope\n  --> /tmp/tmp3gqratid.rs:12:27\n\
    \   |\n12 |     let reversed_string = reverse(string.clone());\n   |         \
    \                  ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `longest_common_substring` in this scope\n  --> /tmp/tmp3gqratid.rs:13:29\n\
    \   |\n13 |     let palindrome_suffix = longest_common_substring(string, reversed_string);\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `reverse` in this scope\n  --> /tmp/tmp3gqratid.rs:15:27\n\
    \   |\n15 |     let reversed_prefix = reverse(prefix.to_string());\n   |     \
    \                      ^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    match string.len()\
    \ {\n        0 => String::new(),\n        1 => string,\n        _ => {\n     \
    \       let palindrome_len = find_longest_palindrome_suffix_len(&string[..]);\n\
    \            let mut result = string;\n            result.reserve(palindrome_len);\n\
    \            let mut suffix = string.as_str()[..palindrome_len].chars().rev();\n\
    \            result.extend(suffix);\n            result\n        }\n    }\n}\n\
    \nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_longest_palindrome_suffix_len`\
    \ in this scope\n  --> /tmp/tmpkbvoekbb.rs:16:34\n   |\n16 |             let palindrome_len\
    \ = find_longest_palindrome_suffix_len(&string[..]);\n   |                   \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut new_string\
    \ = string.clone();\n    let char_list: Vec<char> = string.chars().collect();\n\
    \    let mut palindrome_length = 0;\n    for i in 0..char_list.len() {\n     \
    \   // Check if suffix is a palindrome\n        if is_palindrome(&char_list[i..])\
    \ {\n            palindrome_length = char_list.len() - i;\n            break;\n\
    \        }\n    }\n    let prefix = &char_list[..char_list.len() - palindrome_length];\n\
    \    new_string.push_str(&prefix.iter().rev().collect::<String>());\n    new_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpbqabg4qy.rs:17:12\n   |\n17 |         if is_palindrome(&char_list[i..])\
    \ {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut res =\
    \ string.clone();\n    let s = string.as_bytes();\n    let n = s.len();\n    for\
    \ i in 0..n {\n        let l = n - i;\n        if s[..l] == s[l..][..l].iter().rev()\
    \ {\n            res.push_str(&string[..i].chars().rev().collect::<String>());\n\
    \            break;\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `[u8]` with `Rev<std::slice::Iter<'_, u8>>`\n\
    \  --> /tmp/tmp4vkadzcq.rs:17:19\n   |\n17 |         if s[..l] == s[l..][..l].iter().rev()\
    \ {\n   |                   ^^ no implementation for `[u8] == Rev<std::slice::Iter<'_,\
    \ u8>>`\n   |\n   = help: the trait `PartialEq<Rev<std::slice::Iter<'_, u8>>>`\
    \ is not implemented for `[u8]`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&[B] as PartialEq<[A; N]>>\n        \
    \     <&[T] as PartialEq<Vec<U, A>>>\n             <&mut [B] as PartialEq<[A;\
    \ N]>>\n             <&mut [T] as PartialEq<Vec<U, A>>>\n             <[A; N]\
    \ as PartialEq<&[B]>>\n             <[A; N] as PartialEq<&mut [B]>>\n        \
    \     <[A; N] as PartialEq<[B; N]>>\n             <[A; N] as PartialEq<[B]>>\n\
    \           and 3 others\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut i = result.len();\n    let mut j = 0;\n    let\
    \ mut k = 0;\n    let s = &result;\n    while i > 0 {\n        if is_palindrome(&s[j..i])\
    \ {\n            break;\n        }\n        i -= 1;\n        j += 1;\n    }\n\
    \    k = i;\n    i = result.len();\n    while k > 0 {\n        i -= 1;\n     \
    \   k -= 1;\n        result.insert(i, s.chars().nth(k).unwrap());\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpu9w0q0f1.rs:18:12\n   |\n18 |         if is_palindrome(&s[j..i]) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string_vec:\
    \ Vec<char> = string.chars().collect();\n    let mut n = string_vec.len();\n \
    \   if n == 0 {\n        return string;\n    }\n    let mut i = 0;\n    while\
    \ i < n {\n        if i == 0 || string_vec[i - 1] == string_vec[n - 1] {\n   \
    \         i -= 1;\n            n -= 1;\n        } else {\n            i = 0;\n\
    \        }\n    }\n    string + &string_vec[..n].iter().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmprwpwzi35.rs:20:13\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed\
    \ = string.clone();\n    reversed.reverse();\n    let combined = string + &reversed;\n\
    \    let lps = longest_palindromic_substring(&combined);\n    let prefix = &string[lps.len()..];\n\
    \    prefix.to_string() + &string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `longest_palindromic_substring` in this\
    \ scope\n  --> /tmp/tmpg901e7dq.rs:15:15\n   |\n15 |     let lps = longest_palindromic_substring(&combined);\n\
    \   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0599]: no method named `reverse` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpg901e7dq.rs:13:14\n   |\n13 |     reversed.reverse();\n\
    \   |              ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0425, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reverse_string\
    \ = string.clone();\n    reverse_string.reverse();\n    let postfix = longest_common_suffix(&string,\
    \ &reverse_string);\n    let prefix = string.replace(&postfix, \"\");\n    prefix\
    \ + &string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `longest_common_suffix` in this scope\n\
    \  --> /tmp/tmpgjceyhgq.rs:14:19\n   |\n14 |     let postfix = longest_common_suffix(&string,\
    \ &reverse_string);\n   |                   ^^^^^^^^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0599]: no method named `reverse` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpgjceyhgq.rs:13:20\n   |\n13 |     reverse_string.reverse();\n\
    \   |                    ^^^^^^^ help: there is an associated function with a\
    \ similar name: `reserve`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0425, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut prefix\
    \ = String::new();\n    let mut suffix = String::new();\n    let mut longest_postfix_palindrome\
    \ = String::new();\n    let mut is_palindrome: bool;\n    for i in 0..string.len()\
    \ {\n        prefix.push(string.chars().nth(i).unwrap());\n        suffix.push(string.chars().nth(string.len()\
    \ - i - 1).unwrap());\n        is_palindrome = true;\n        for j in 0..(suffix.len()\
    \ / 2) {\n            if suffix.chars().nth(j).unwrap() != suffix.chars().nth(suffix.len()\
    \ - j - 1).unwrap() {\n                is_palindrome = false;\n              \
    \  break;\n            }\n        }\n        if is_palindrome {\n            longest_postfix_palindrome\
    \ = suffix.clone();\n        }\n    }\n    prefix + &suffix.chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xx\"`,\n right: `\"x\"`', /tmp/tmprrsqnud_.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let n = string.len();\n\
    \    let mut k = 0;\n    let mut buf = string.as_bytes().to_vec();\n    for _\
    \ in 0..n {\n        if buf[k..] == buf[..k].iter().rev() {\n            break;\n\
    \        }\n        k += 1;\n    }\n    buf.extend(buf[..k].iter().rev());\n \
    \   String::from_utf8(buf).unwrap()\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `[u8]` with `Rev<std::slice::Iter<'_, u8>>`\n\
    \  --> /tmp/tmpjju_1vmv.rs:16:21\n   |\n16 |         if buf[k..] == buf[..k].iter().rev()\
    \ {\n   |                     ^^ no implementation for `[u8] == Rev<std::slice::Iter<'_,\
    \ u8>>`\n   |\n   = help: the trait `PartialEq<Rev<std::slice::Iter<'_, u8>>>`\
    \ is not implemented for `[u8]`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&[B] as PartialEq<[A; N]>>\n        \
    \     <&[T] as PartialEq<Vec<U, A>>>\n             <&mut [B] as PartialEq<[A;\
    \ N]>>\n             <&mut [T] as PartialEq<Vec<U, A>>>\n             <[A; N]\
    \ as PartialEq<&[B]>>\n             <[A; N] as PartialEq<&mut [B]>>\n        \
    \     <[A; N] as PartialEq<[B; N]>>\n             <[A; N] as PartialEq<[B]>>\n\
    \           and 3 others\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut output\
    \ = string.clone();\n    let chars: Vec<char> = string.chars().collect();\n  \
    \  let mut prefix_start_pos = 0;\n    let chars_length = chars.len();\n    let\
    \ mut prefix_end_pos = chars_length - 1;\n    while prefix_end_pos > 0 {\n   \
    \     if is_palindrome(prefix_start_pos, prefix_end_pos, &chars) {\n         \
    \   break;\n        }\n        prefix_end_pos -= 1;\n    }\n    let prefix_length\
    \ = prefix_end_pos - prefix_start_pos + 1;\n    for i in 0..prefix_length {\n\
    \        output.push(chars[prefix_end_pos - i]);\n    }\n    output\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpy732p159.rs:18:12\n   |\n18 |         if is_palindrome(prefix_start_pos,\
    \ prefix_end_pos, &chars) {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    // index of the\
    \ first mismatch\n    let first_mismatch = string.iter().zip(string.iter().rev()).position(|(a,\
    \ b)| a != b);\n    // index of the palindromic suffix\n    let suffix_start =\
    \ first_mismatch.unwrap_or(string.len());\n    // append the suffix to the supplied\
    \ string\n    format!(\"{}{}\", string, string[..suffix_start].chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpimux7zez.rs:13:33\n   |\n13 |     let first_mismatch =\
    \ string.iter().zip(string.iter().rev()).position(|(a, b)| a != b);\n   |    \
    \                             ^^^^ method not found in `String`\n   |\nhelp: because\
    \ of the in-memory representation of `&str`, to obtain an `Iterator` over each\
    \ of its codepoint use method `chars`\n   |\n13 |     let first_mismatch = string.chars().zip(string.iter().rev()).position(|(a,\
    \ b)| a != b);\n   |                                 ~~~~~\n\nerror[E0599]: no\
    \ method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpimux7zez.rs:13:51\n\
    \   |\n13 |     let first_mismatch = string.iter().zip(string.iter().rev()).position(|(a,\
    \ b)| a != b);\n   |                                                   ^^^^ method\
    \ not found in `String`\n   |\nhelp: because of the in-memory representation of\
    \ `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n\
    \   |\n13 |     let first_mismatch = string.iter().zip(string.chars().rev()).position(|(a,\
    \ b)| a != b);\n   |                                                   ~~~~~\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    assert!(!string.is_empty());\n\
    \    let mut string = string;\n    let mut suffix = longest_palindrome_suffix(&string);\n\
    \    let remaining = string.len() - suffix.len();\n    string.insert_str(suffix.len(),\
    \ &string[..remaining]);\n    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `longest_palindrome_suffix` in this\
    \ scope\n  --> /tmp/tmp_ahkqdmo.rs:14:22\n   |\n14 |     let mut suffix = longest_palindrome_suffix(&string);\n\
    \   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let reverse =\
    \ string.chars().rev().collect::<String>();\n    let mut prefix = string;\n  \
    \  let mut postfix = \"\".to_string();\n    while !is_palindrome(&prefix) {\n\
    \        postfix.push(prefix.pop().unwrap());\n    }\n    format!(\"{}{}{}\",\
    \ string, postfix, reverse)\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp_6w70zmr.rs:15:12\n   |\n15 |     while !is_palindrome(&prefix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut postfix\
    \ = String::new();\n    let mut prefix = String::new();\n    let mut longest_palindrome_length\
    \ = 0;\n    let mut palindrome_found = false;\n    let mut length = string.len();\n\
    \    let (left, right) = string.split_at(length / 2);\n    if length % 2 == 0\
    \ {\n        for i in 0..length / 2 {\n            let (left_prefix, left_postfix)\
    \ = left.split_at(i);\n            let (right_prefix, right_postfix) = right.split_at(i);\n\
    \            if left_prefix == right_postfix.chars().rev().collect::<String>()\
    \ {\n                longest_palindrome_length = i * 2;\n                palindrome_found\
    \ = true;\n                postfix = left_prefix.to_string();\n              \
    \  prefix = left_postfix.to_string();\n            }\n        }\n    } else {\n\
    \        for i in 0..length / 2 {\n            let (left_prefix, left_postfix)\
    \ = left.split_at(i);\n            let (right_prefix, right_postfix) = right.split_at(i\
    \ + 1);\n            if left_prefix == right_postfix.chars().rev().collect::<String>()\
    \ {\n                longest_palindrome_length = i * 2 + 1;\n                palindrome_found\
    \ = true;\n                postfix = left_prefix.to_string();\n              \
    \  prefix = left_postfix.to_string();\n            }\n        }\n    }\n    if\
    \ palindrome_found {\n        postfix.push_str(&prefix.chars().rev().collect::<String>());\n\
    \        return postfix;\n    }\n    return string;\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xyz\"`,\n right: `\"xyzyx\"`', /tmp/tmpnjjbmmzt.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return string;\n    }\n\n    let mut string = string;\n    let palindrome_suffix\
    \ = find_longest_palindrome_suffix(&string);\n    let palindrome_prefix = &string[..string.len()\
    \ - palindrome_suffix.len()];\n    let palindrome_prefix = palindrome_prefix.chars().rev().collect::<String>();\n\
    \    string.push_str(&palindrome_prefix);\n    string\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_longest_palindrome_suffix` in\
    \ this scope\n  --> /tmp/tmp_i4ckihq.rs:17:29\n   |\n17 |     let palindrome_suffix\
    \ = find_longest_palindrome_suffix(&string);\n   |                           \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut new_string\
    \ = string.clone();\n    let mut longest_palindrome_suffix_len = 0;\n    for i\
    \ in 1..string.len() {\n        if string[i..] == string[i..].chars().rev().collect::<String>()\n\
    \            && string[i..].len() > longest_palindrome_suffix_len\n        {\n\
    \            longest_palindrome_suffix_len = string[i..].len();\n        }\n \
    \   }\n    new_string.push_str(\n        &string[..string.len() - longest_palindrome_suffix_len]\n\
    \            .chars()\n            .rev()\n            .collect::<String>(),\n\
    \    );\n    new_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xx\"`,\n right: `\"x\"`', /tmp/tmpvcgiy9nd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return string;\n    }\n\n    let reversed = string.clone().chars().rev().collect::<String>();\n\
    \    let index = string.find(&reversed).unwrap_or(string.len());\n    let (prefix,\
    \ _) = string.split_at(index);\n    return format!(\"{}{}\", string, prefix.chars().rev().collect::<String>());\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xyzzyx\"`,\n right: `\"xyzyx\"`', /tmp/tmp_z920nh3.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return string;\n    }\n\n    let mut reversed_string = string.clone();\n\
    \    reversed_string.make_ascii_lowercase();\n    reversed_string.chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"zyx\"`,\n right: `\"xyzyx\"`', /tmp/tmp6slns3l8.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut result\
    \ = string.clone();\n    let mut j = 1;\n    let mut i = string.len() - 1;\n \
    \   let half_len = string.len() / 2;\n    let mut k = 0;\n    let mut idx = i;\n\
    \    let mut result_idx = string.len();\n    while j < half_len && i >= half_len\
    \ {\n        k = j;\n        while k < half_len && string.chars().nth(i - k) ==\
    \ string.chars().nth(j + k) {\n            k += 1;\n        }\n        if k ==\
    \ half_len {\n            idx = i;\n            result_idx = j;\n        }\n \
    \       j += 1;\n        i -= 1;\n    }\n    let prefix = string.chars().take(idx\
    \ - result_idx).collect::<String>();\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpxsjp29kl.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string_chars\
    \ = string.chars().collect::<Vec<char>>();\n    let mut reverse_chars = string_chars.clone();\n\
    \    reverse_chars.reverse();\n    let mut longest_palindrome_end = -1;\n    let\
    \ mut longest_palindrome_length = 0;\n    let mut current_palindrome_end = -1;\n\
    \    let mut current_palindrome_length = 0;\n    let mut i = 0;\n    while i <\
    \ string_chars.len() {\n        if string_chars[i] == reverse_chars[i] {\n   \
    \         current_palindrome_end = i;\n            current_palindrome_length +=\
    \ 1;\n        } else {\n            if current_palindrome_length > longest_palindrome_length\
    \ {\n                longest_palindrome_end = current_palindrome_end;\n      \
    \          longest_palindrome_length = current_palindrome_length;\n          \
    \  }\n            current_palindrome_end = -1;\n            current_palindrome_length\
    \ = 0;\n        }\n        i += 1;\n    }\n    if current_palindrome_length >\
    \ longest_palindrome_length {\n        longest_palindrome_end = current_palindrome_end;\n\
    \        longest_palindrome_length = current_palindrome_length;\n    }\n    let\
    \ mut result = string_chars[..longest_palindrome_end + 1].to_vec();\n    result.extend(reverse_chars[longest_palindrome_end\
    \ + 1..].iter().rev());\n    result.iter().collect()\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpgvsow_fl.rs:17:38\n\
    \   |\n17 |     let mut current_palindrome_end = -1;\n   |                   \
    \                   ^^ the trait `Neg` is not implemented for `usize`\n   |\n\
    \   = help: the following other types implement trait `Neg`:\n             &f32\n\
    \             &f64\n             &i128\n             &i16\n             &i32\n\
    \             &i64\n             &i8\n             &isize\n           and 8 others\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpgvsow_fl.rs:15:38\n\
    \   |\n15 |     let mut longest_palindrome_end = -1;\n   |                   \
    \                   ^^ the trait `Neg` is not implemented for `usize`\n   |\n\
    \   = help: the following other types implement trait `Neg`:\n             &f32\n\
    \             &f64\n             &i128\n             &i16\n             &i32\n\
    \             &i64\n             &i8\n             &isize\n           and 8 others\n\
    \nerror[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpgvsow_fl.rs:29:38\n\
    \   |\n29 |             current_palindrome_end = -1;\n   |                   \
    \                   ^^\n   |                                      |\n   |    \
    \                                  cannot apply unary operator `-`\n   |     \
    \                                 help: you may have meant the maximum value of\
    \ `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0600.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let len = string.len();\n\
    \    let mut reverse_string = string.chars().rev().collect::<String>();\n    let\
    \ mut i = 0;\n    let mut max_i = 0;\n    while i < len {\n        if string[i..]\
    \ == reverse_string[len - i..] {\n            max_i = i;\n        }\n        i\
    \ += 1;\n    }\n    reverse_string = reverse_string[..len - max_i].to_string();\n\
    \    string + &reverse_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xx\"`,\n right: `\"x\"`', /tmp/tmp_tzqawib.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return string;\n    }\n\n    let mut current_best_suffix = string.chars().count();\n\
    \    let mut best_suffix_length = 0;\n    let string_chars: Vec<char> = string.chars().collect();\n\
    \n    for i in 0..string.chars().count() {\n        let current_length = i + 1;\n\
    \        let chars_to_check = &string_chars[string.chars().count() - current_length..];\n\
    \        let string_to_check = chars_to_check.iter().collect::<String>();\n  \
    \      if is_palindrome(&string_to_check) {\n            current_best_suffix =\
    \ i;\n            best_suffix_length = current_length;\n        }\n    }\n\n \
    \   // suffix length is zero - whole string is a palindrome.\n    if best_suffix_length\
    \ == 0 {\n        return string;\n    }\n\n    let prefix = &string_chars[0..string.chars().count()\
    \ - best_suffix_length];\n    let reverse_prefix = prefix.iter().rev().collect::<String>();\n\
    \    return string + &reverse_prefix;\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpobd32rqq.rs:24:12\n   |\n24 |         if is_palindrome(&string_to_check)\
    \ {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let str_len =\
    \ string.len();\n    let mut result = string.clone();\n    let longest_common_substring\
    \ = &string[0..make_longest_common_substring(string.as_bytes())];\n    let reversed_prefix\
    \ = longest_common_substring.chars().rev().collect::<String>();\n    result.push_str(&reversed_prefix);\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `make_longest_common_substring` in this\
    \ scope\n  --> /tmp/tmpvy6m5pz8.rs:14:47\n   |\n14 |     let longest_common_substring\
    \ = &string[0..make_longest_common_substring(string.as_bytes())];\n   |      \
    \                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let len = string.len();\n\
    \    if len <= 1 {\n        return string;\n    }\n    let mut last_pali_index\
    \ = len - 1;\n    let string_bytes = string.as_bytes();\n    while last_pali_index\
    \ > 0 {\n        if is_palindrome(&string_bytes[0..last_pali_index]) {\n     \
    \       break;\n        }\n        last_pali_index -= 1;\n    }\n    let mut res\
    \ = string.clone();\n    res.push_str(&string[0..len - last_pali_index].chars().rev().collect::<String>());\n\
    \    res\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp31gqjtud.rs:19:12\n   |\n19 |         if is_palindrome(&string_bytes[0..last_pali_index])\
    \ {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut palindrome\
    \ = String::new();\n    // find the longest postfix that is a palindrome\n   \
    \ for end in (0..string.len()).rev() {\n        let prefix = &string[0..end];\n\
    \        let postfix = &string[end..];\n        let rev_prefix = prefix.chars().rev().collect::<String>();\n\
    \        if postfix == rev_prefix {\n            palindrome.push_str(string.as_str());\n\
    \            palindrome.push_str(prefix);\n            break;\n        }\n   \
    \ }\n    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"x\"`', /tmp/tmpjvmd1bf6.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut s = string.clone();\n\
    \    s.extend(string.chars().rev());\n    let kmp = KMP::new(&s);\n    let mut\
    \ prefix = kmp.lps();\n    prefix.reverse();\n    prefix.extend(string.chars());\n\
    \    prefix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `KMP`\n  --> /tmp/tmpxy39ubal.rs:14:15\n\
    \   |\n14 |     let kmp = KMP::new(&s);\n   |               ^^^ use of undeclared\
    \ type `KMP`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut reversed\
    \ = string.clone();\n    reversed.reverse();\n    for i in 0..string.len() {\n\
    \        if reversed.ends_with(&string[i..]) {\n            return format!(\"\
    {}{}\", string, &reversed[..i]);\n        }\n    }\n    return string;\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp3w0smj6p.rs:13:14\n   |\n13 |     reversed.reverse();\n\
    \   |              ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let chars: Vec<char>\
    \ = string.chars().collect();\n    let mut longest_palindrome_length = 0;\n  \
    \  let mut palindrome_start = 0;\n    for i in 0..chars.len() {\n        let palindrome_length\
    \ = num_chars_until_first_different(&chars, i);\n        if palindrome_length\
    \ > longest_palindrome_length {\n            longest_palindrome_length = palindrome_length;\n\
    \            palindrome_start = i;\n        }\n    }\n    let mut prefix = String::new();\n\
    \    let mut suffix = String::new();\n    for i in 0..(chars.len() - palindrome_start\
    \ - longest_palindrome_length) {\n        prefix.push(chars[i]);\n    }\n    for\
    \ i in (palindrome_start + longest_palindrome_length)..chars.len() {\n       \
    \ suffix.push(chars[i]);\n    }\n    format!(\"{}{}{}\", prefix, string, prefix.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `num_chars_until_first_different` in\
    \ this scope\n  --> /tmp/tmprdpw_ygo.rs:16:33\n   |\n16 |         let palindrome_length\
    \ = num_chars_until_first_different(&chars, i);\n   |                        \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let postfix =\
    \ get_longest_palindromic_postfix(&string);\n    format!(\"{}{}\", string, string[..string.len()\
    \ - postfix.len()].chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `get_longest_palindromic_postfix` in\
    \ this scope\n  --> /tmp/tmp2xt3fd_w.rs:12:19\n   |\n12 |     let postfix = get_longest_palindromic_postfix(&string);\n\
    \   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    // Write your code here\n    let (mut right, mut left) = (string.len()\
    \ - 1, 0);\n    // Find the longest palindromic suffix.\n    while left < right\
    \ {\n        if string.chars().nth(left) != string.chars().nth(right) {\n    \
    \        left = 0;\n            right -= 1;\n        } else {\n            left\
    \ += 1;\n        }\n    }\n    // Find the longest prefix that comes before the\
    \ palindromic suffix.\n    let prefix = &string[..string.len() - right - 1];\n\
    \    // Reverse the prefix.\n    let reversed_prefix: String = prefix.chars().rev().collect();\n\
    \    // Append the prefix to the end of the string.\n    string.push_str(&reversed_prefix);\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp1hb8tak1.rs:14:34\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let s = string.as_bytes();\n\
    \    let max_length = palindrome_length(s);\n    let n = s.len();\n    let mut\
    \ result = string;\n    for i in 0..n - max_length {\n        result.push(s[n\
    \ - 1 - i] as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `palindrome_length` in this scope\n\
    \  --> /tmp/tmp1cj6oh28.rs:13:22\n   |\n13 |     let max_length = palindrome_length(s);\n\
    \   |                      ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut res =\
    \ String::new();\n    let mut prefix = String::new();\n    let mut suffix = String::new();\n\
    \    let mut next_char = None;\n    for (i, ch) in string.chars().enumerate()\
    \ {\n        if let Some(c) = next_char {\n            if ch == c {\n        \
    \        prefix.push(ch);\n                suffix.push(ch);\n                next_char\
    \ = None;\n            } else {\n                next_char = Some(ch);\n     \
    \       }\n        } else {\n            next_char = Some(ch);\n        }\n  \
    \      if i == string.len() - 1 {\n            prefix.push(ch);\n        }\n \
    \   }\n    res.push_str(&prefix);\n    res.push_str(&suffix.chars().rev().collect::<String>());\n\
    \    res\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"z\"`,\n right: `\"xyzyx\"`', /tmp/tmppky1od4w.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut reverse = string.clone();\n    reverse.reverse();\n \
    \   let lcs = longest_common_substring(string.clone(), reverse);\n    let palindrome_suffix\
    \ = String::from(&string[string.len() - lcs.len()..]);\n    let new_prefix = String::from(&string[..string.len()\
    \ - lcs.len()]);\n    let reverse_prefix = new_prefix.clone();\n    reverse_prefix.reverse();\n\
    \    return new_prefix + &reverse_prefix + &palindrome_suffix;\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `longest_common_substring` in this scope\n\
    \  --> /tmp/tmp766i7qdj.rs:15:15\n   |\n15 |     let lcs = longest_common_substring(string.clone(),\
    \ reverse);\n   |               ^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0599]: no method named `reverse` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp766i7qdj.rs:14:13\n   |\n14 |     reverse.reverse();\n\
    \   |             ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror[E0599]: no method named `reverse` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmp766i7qdj.rs:19:20\n   |\n19 | \
    \    reverse_prefix.reverse();\n   |                    ^^^^^^^ help: there is\
    \ an associated function with a similar name: `reserve`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    // Find longest\
    \ palindromic suffix.\n    let chars: Vec<char> = string.chars().collect();\n\
    \    let string_length = chars.len();\n    let mut is_palindrome = vec![false;\
    \ string_length];\n    let mut palindrome_length = 0;\n    let mut palindrome_start\
    \ = 0;\n    let mut palindrome_end = 0;\n    for index in 0..string_length {\n\
    \        let offset = 2 * index;\n        let offset_position = offset / 2;\n\
    \        let offset_mirror = (offset - 1) / 2;\n        let mirror_index = string_length\
    \ - 1 - offset_mirror;\n        let mut current_palindrome_length = 0;\n     \
    \   if offset_position > 0 {\n            if mirror_index + 1 < offset_position\
    \ {\n                continue;\n            }\n            let length_from_edge\
    \ = mirror_index - offset_position + 1;\n            if is_palindrome[length_from_edge]\
    \ {\n                current_palindrome_length = offset_position;\n          \
    \  } else {\n                continue;\n            }\n        }\n        while\
    \ offset_position + current_palindrome_length < string_length &&\n           \
    \   mirror_index - current_palindrome_length >= 0 &&\n              chars[offset_position\
    \ + current_palindrome_length] == chars[mirror_index - current_palindrome_length]\
    \ {\n            current_palindrome_length += 1;\n        }\n        if current_palindrome_length\
    \ > palindrome_length {\n            palindrome_length = current_palindrome_length;\n\
    \            palindrome_start = offset_position;\n            palindrome_end =\
    \ mirror_index;\n        }\n        is_palindrome[mirror_index] = true;\n    }\n\
    \    // Append the prefix (reverse of a part before the palindromic suffix) to\
    \ the end of the string.\n    let mut result = String::with_capacity(string_length\
    \ + (string_length - palindrome_end - 1));\n    result.push_str(&string);\n  \
    \  for index in palindrome_end + 1..string_length {\n\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpvr4tifnr.rs:62:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n38 |            \
    \   chars[offset_position + current_palindrome_length] == chars[mirror_index -\
    \ current_palindrome_length] {\n   |                                         \
    \                                                                            -\
    \ this delimiter might not be properly closed...\n39 |             current_palindrome_length\
    \ += 1;\n40 |         }\n   |         - ...as it matches this but it has different\
    \ indentation\n...\n62 | }\n   |   ^\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpvr4tifnr.rs:11:39\n   |\n11 | fn make_palindrome(string: String) ->\
    \ String {\n   |    ---------------                    ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return string;\n    }\n\n    let mut postfix = String::new();\n \
    \   let mut palindrome = string.clone();\n    while !palindrome.is_empty() {\n\
    \        if palindrome.len() > 1 && is_palindrome(&palindrome) {\n           \
    \ break;\n        }\n        postfix.push(palindrome.pop().unwrap());\n    }\n\
    \n    palindrome.push_str(&postfix);\n    palindrome.push_str(&postfix.chars().rev().collect::<String>());\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpmj5kfw_v.rs:19:36\n   |\n19 |         if palindrome.len() > 1 && is_palindrome(&palindrome)\
    \ {\n   |                                    ^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `palindrome`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let reverse =\
    \ string.chars().rev().collect::<String>();\n    let mut result = string;\n  \
    \  for i in 0..string.len() {\n        let prefix = string.get(0..i).unwrap();\n\
    \        let postfix = reverse.get(0..i).unwrap();\n        if prefix == postfix\
    \ {\n            result = format!(\"{}{}\", string, string.get(i..).unwrap().chars().rev().collect::<String>());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `string`\n  --> /tmp/tmpzgu3v87p.rs:14:17\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \       ------ move occurs because `string` has type `String`, which does not\
    \ implement the `Copy` trait\n12 |     let reverse = string.chars().rev().collect::<String>();\n\
    13 |     let mut result = string;\n   |                      ------ value moved\
    \ here\n14 |     for i in 0..string.len() {\n   |                 ^^^^^^^^^^^^\
    \ value borrowed here after move\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    // let substr\
    \ = longest_postfix_palindrome(&string);\n    let substr = longest_prefix_palindrome(&string);\n\
    \    let mut new_string = string.clone();\n    new_string.extend(substr.chars().rev());\n\
    \    new_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `longest_prefix_palindrome` in this\
    \ scope\n  --> /tmp/tmpyazkzqlm.rs:13:18\n   |\n13 |     let substr = longest_prefix_palindrome(&string);\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return String::new();\n    }\n\n    let mut palindrome = String::from(&string);\n\
    \    let reversed_prefix = string.chars().rev().collect::<String>();\n    let\
    \ prefix_end = palindrome.len() - 1;\n    let prefix_start = 0;\n    let mut longest_palindrome_start\
    \ = prefix_end;\n    let mut longest_palindrome_end = prefix_end;\n\n    for end\
    \ in prefix_end..=prefix_end + 1 {\n        for start in (prefix_start..=prefix_end).rev()\
    \ {\n            let substring = &palindrome[start..=end];\n            if is_palindrome(substring)\
    \ {\n                if end - start > longest_palindrome_end - longest_palindrome_start\
    \ {\n                    longest_palindrome_start = start;\n                 \
    \   longest_palindrome_end = end;\n                }\n            }\n        }\n\
    \    }\n\n    palindrome.push_str(&reversed_prefix[..longest_palindrome_start]);\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp7lmxu3x7.rs:26:16\n   |\n26 |             if is_palindrome(substring)\
    \ {\n   |                ^^^^^^^^^^^^^ help: a local variable with a similar name\
    \ exists: `palindrome`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut suffix\
    \ = suffix_longest_palindrome(string.clone());\n    let reverse_prefix = reverse_string(prefix_string(string,\
    \ suffix.len()));\n    suffix.push_str(&reverse_prefix);\n    suffix\n}\n\nfn\
    \ main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `suffix_longest_palindrome` in this\
    \ scope\n  --> /tmp/tmpicuvzj1n.rs:12:22\n   |\n12 |     let mut suffix = suffix_longest_palindrome(string.clone());\n\
    \   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `reverse_string` in this scope\n  --> /tmp/tmpicuvzj1n.rs:13:26\n\
    \   |\n13 |     let reverse_prefix = reverse_string(prefix_string(string, suffix.len()));\n\
    \   |                          ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `prefix_string` in this scope\n  --> /tmp/tmpicuvzj1n.rs:13:41\n\
    \   |\n13 |     let reverse_prefix = reverse_string(prefix_string(string, suffix.len()));\n\
    \   |                                         ^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut string\
    \ = string;\n    let mut i = string.len();\n    while i > 0 {\n        if is_palindrome(&string[(string.len()\
    \ - i)..]) {\n            string.push_str(&string[..(string.len() - i)].chars().rev().collect::<String>());\n\
    \            return string;\n        }\n        i -= 1;\n    }\n    string\n}\n\
    \nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpfi_nece3.rs:15:12\n   |\n15 |         if is_palindrome(&string[(string.len()\
    \ - i)..]) {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    // Find the longest\
    \ palindromic suffix of supplied string.\n    // We assume that supplied string\
    \ is not empty.\n    let mut rev_string = string.chars().rev().collect::<String>();\n\
    \    let mut suffix = longest_common_substring(string.clone(), rev_string);\n\
    \    let prefix = string[..string.len() - suffix.len()].to_string();\n    rev_string\
    \ = prefix.chars().rev().collect::<String>();\n    string + &rev_string\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `longest_common_substring` in this scope\n\
    \  --> /tmp/tmpk6dclzqf.rs:15:22\n   |\n15 |     let mut suffix = longest_common_substring(string.clone(),\
    \ rev_string);\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut rev_string\
    \ = string.clone();\n    rev_string.reverse();\n    let concat = format!(\"{}{}\"\
    , string, rev_string);\n    let sa = suffix_array::build_suffix_array(&concat);\n\
    \    let mut longest_len = 0;\n    let mut longest_pos = 0;\n    for i in 0..sa.len()\
    \ {\n        if concat[sa[i]..].starts_with(&string) {\n            let suffix_len\
    \ = concat.len() - sa[i];\n            if suffix_len > longest_len {\n       \
    \         longest_len = suffix_len;\n                longest_pos = sa[i];\n  \
    \          }\n        }\n    }\n    let prefix = &concat[0..longest_pos];\n  \
    \  format!(\"{}{}\", string, prefix.chars().rev().collect::<String>())\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `suffix_array`\n\
    \  --> /tmp/tmpljeknoom.rs:15:14\n   |\n15 |     let sa = suffix_array::build_suffix_array(&concat);\n\
    \   |              ^^^^^^^^^^^^ use of undeclared crate or module `suffix_array`\n\
    \nerror[E0599]: no method named `reverse` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpljeknoom.rs:13:16\n   |\n13 |     rev_string.reverse();\n\
    \   |                ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0433, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let chars: Vec<char>\
    \ = string.chars().collect();\n    let len = chars.len();\n    if len == 0 {\n\
    \        return string;\n    }\n    let mut longest_palindrome = String::new();\n\
    \    // iterate from tail of the string.\n    for i in 0..len {\n        // check\
    \ if the current tail is a part of the palindrome suffix\n        if is_palindrome(&chars[i..len])\
    \ {\n            longest_palindrome = chars[i..len].iter().collect();\n      \
    \      break;\n        }\n    }\n    let mut s = string;\n    s.push_str(&longest_palindrome.chars().rev().collect::<String>());\n\
    \    s\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmprea3c6rk.rs:21:12\n   |\n21 |         if is_palindrome(&chars[i..len])\
    \ {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let n = string.len();\n\
    \    let mut preffix_table = kmp_preffix_table(&string);\n    let mut palindrome_end\
    \ = n - preffix_table[n];\n    let mut rev_string = string.chars().rev().collect::<String>();\n\
    \    return string + &rev_string[..rev_string.len() - palindrome_end];\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `kmp_preffix_table` in this scope\n\
    \  --> /tmp/tmpztq8khr4.rs:13:29\n   |\n13 |     let mut preffix_table = kmp_preffix_table(&string);\n\
    \   |                             ^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return String::new();\n    }\n\n    // Find the longest postfix which\
    \ is a palindrome.\n    let mut postfix = 0;\n    while !is_palindrome(&string[postfix..])\
    \ {\n        postfix += 1;\n    }\n\n    // Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    let mut prefix\
    \ = string.chars().take(string.len() - postfix).collect::<Vec<_>>();\n    prefix.reverse();\n\
    \    let prefix = prefix.into_iter().collect::<String>();\n    string + &prefix\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp1kfb_9ps.rs:18:12\n   |\n18 |     while !is_palindrome(&string[postfix..])\
    \ {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let lps = longest_palindromic_suffix(&string);\n\
    \    let len = string.len();\n    let prefix = string[0..len - lps].chars().rev().collect::<String>();\n\
    \    string + &prefix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `longest_palindromic_suffix` in this\
    \ scope\n  --> /tmp/tmpzx6znyj5.rs:12:15\n   |\n12 |     let lps = longest_palindromic_suffix(&string);\n\
    \   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let (s1, s2)\
    \ = string.split_at(find_palindrome_end(string.as_bytes()));\n    let reversed_prefix\
    \ = s1.chars().rev().collect::<String>();\n    format!(\"{}{}{}\", string, reversed_prefix,\
    \ s2)\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_palindrome_end` in this scope\n\
    \  --> /tmp/tmpbmqobq8g.rs:12:36\n   |\n12 |     let (s1, s2) = string.split_at(find_palindrome_end(string.as_bytes()));\n\
    \   |                                    ^^^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    if string.is_empty()\
    \ {\n        return String::new();\n    }\n\n    let (mut prefix, suffix) = longest_prefix_suffix(string.clone());\n\
    \    if prefix.is_empty() {\n        return string;\n    }\n\n    let mut chars\
    \ = string.chars().rev();\n    let mut reverse_prefix = String::new();\n    while\
    \ let Some(c) = chars.next() {\n        reverse_prefix.push(c);\n        if &reverse_prefix\
    \ == prefix {\n            break;\n        }\n    }\n\n    reverse_prefix + &suffix\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `longest_prefix_suffix` in this scope\n\
    \  --> /tmp/tmpp3vsm8qd.rs:16:32\n   |\n16 |     let (mut prefix, suffix) = longest_prefix_suffix(string.clone());\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmpp3vsm8qd.rs:16:22\n   |\n16 |     let (mut prefix, suffix)\
    \ = longest_prefix_suffix(string.clone());\n   |                      ^^^^^^ doesn't\
    \ have a size known at compile-time\n   |\n   = help: the trait `Sized` is not\
    \ implemented for `str`\n   = note: all local variables must have a statically\
    \ known size\n   = help: unsized locals are gated as an unstable feature\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let mut prefix\
    \ = String::from(\"\");\n    let mut postfix = String::from(\"\");\n    for (i,\
    \ _) in string.chars().enumerate() {\n        let sub_string = string.chars().skip(i).collect::<String>();\n\
    \        if is_palindrome(&sub_string) {\n            postfix = sub_string;\n\
    \            break;\n        }\n    }\n    let prefix_begin = string.len() - postfix.len();\n\
    \    prefix = string.chars().take(prefix_begin).collect::<String>();\n    let\
    \ reversed_prefix = prefix.chars().rev().collect::<String>();\n    prefix + &reversed_prefix\
    \ + &postfix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpt8tm203d.rs:16:12\n   |\n16 |         if is_palindrome(&sub_string)\
    \ {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfn make_palindrome(string: String) -> String {\n    let n = string.len();\n\
    \    if n == 0 {\n        return String::new();\n    }\n    let mut z_array =\
    \ z_array(string.clone());\n    let mut max_z = 0;\n    let mut max_z_index =\
    \ 0;\n    for i in 1..n {\n        if z_array[i] == n - i && z_array[i] > max_z\
    \ {\n            max_z = z_array[i];\n            max_z_index = i;\n        }\n\
    \    }\n    let mut prefix = String::new();\n    for i in max_z_index..n {\n \
    \       prefix.push(string.chars().nth(i).unwrap());\n    }\n    let reversed\
    \ = prefix.chars().rev().collect::<String>();\n    string + &reversed\n}\n\nfn\
    \ main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `z_array` in this scope\n  --> /tmp/tmpy8id2x0d.rs:16:23\n\
    \   |\n16 |     let mut z_array = z_array(string.clone());\n   |             \
    \          ^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
