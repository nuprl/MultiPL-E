name: HumanEval_37_sort_even
language: rust
results:
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n  let mut odd_idx = Vec::new();\n\
    \  let mut even_idx = Vec::new();\n  for (idx, num) in l.iter().enumerate() {\n\
    \    if idx % 2 == 0 {\n      odd_idx.push(*num);\n    } else {\n      even_idx.push(*num);\n\
    \    }\n  }\n  even_idx.sort();\n  let mut new_l = Vec::new();\n  for idx in 0..l.len()\
    \ {\n    if idx % 2 == 0 {\n      new_l.push(odd_idx[idx / 2]);\n    } else {\n\
    \      new_l.push(even_idx[idx / 2]);\n    }\n  }\n  new_l\n}\n\nfn main() {\n\
    \    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 0, -5, 1, -3, 2, 9, 3, 123, 3, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmplamenrvy.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    fn sort_odd(l: Vec<isize>)\
    \ -> Vec<isize> {\n        match l {\n            [] => [],\n            [x] =>\
    \ [x],\n            [x, y] => [y, x],\n            [x, y, z] => [y, x, z],\n \
    \           [x, y, z, w] => [y, w, x, z],\n            x => {\n              \
    \  if x[0] > x[1] {\n                    [x[1]] + sort_odd(x[2..])\n         \
    \       } else {\n                    [x[0]] + sort_odd(x[2..])\n            \
    \    }\n            }\n        }\n    }\n    sort_odd(l)\n}\n\nfn main() {\n \
    \   let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0529]: expected an array or slice, found `Vec<isize>`\n  --> /tmp/tmpy0n29oxd.rs:11:13\n\
    \   |\n10 |         match l {\n   |               - help: consider slicing here:\
    \ `l[..]`\n11 |             [] => [],\n   |             ^^ pattern cannot match\
    \ with input type `Vec<isize>`\n\nerror[E0529]: expected an array or slice, found\
    \ `Vec<isize>`\n  --> /tmp/tmpy0n29oxd.rs:12:13\n   |\n10 |         match l {\n\
    \   |               - help: consider slicing here: `l[..]`\n11 |             []\
    \ => [],\n12 |             [x] => [x],\n   |             ^^^ pattern cannot match\
    \ with input type `Vec<isize>`\n\nerror[E0529]: expected an array or slice, found\
    \ `Vec<isize>`\n  --> /tmp/tmpy0n29oxd.rs:13:13\n   |\n10 |         match l {\n\
    \   |               - help: consider slicing here: `l[..]`\n...\n13 |        \
    \     [x, y] => [y, x],\n   |             ^^^^^^ pattern cannot match with input\
    \ type `Vec<isize>`\n\nerror[E0529]: expected an array or slice, found `Vec<isize>`\n\
    \  --> /tmp/tmpy0n29oxd.rs:14:13\n   |\n10 |         match l {\n   |         \
    \      - help: consider slicing here: `l[..]`\n...\n14 |             [x, y, z]\
    \ => [y, x, z],\n   |             ^^^^^^^^^ pattern cannot match with input type\
    \ `Vec<isize>`\n\nerror[E0529]: expected an array or slice, found `Vec<isize>`\n\
    \  --> /tmp/tmpy0n29oxd.rs:15:13\n   |\n10 |         match l {\n   |         \
    \      - help: consider slicing here: `l[..]`\n...\n15 |             [x, y, z,\
    \ w] => [y, w, x, z],\n   |             ^^^^^^^^^^^^ pattern cannot match with\
    \ input type `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy0n29oxd.rs:11:19\n\
    \   |\n9  |     fn sort_odd(l: Vec<isize>) -> Vec<isize> {\n   |             \
    \                      ---------- expected `Vec<isize>` because of return type\n\
    10 |         match l {\n11 |             [] => [],\n   |                   ^^-\
    \ help: try using a conversion method: `.to_vec()`\n   |                   |\n\
    \   |                   expected struct `Vec`, found array of 0 elements\n   |\n\
    \   = note: expected struct `Vec<isize>`\n               found array `[_; 0]`\n\
    \nerror[E0308]: mismatched types\n  --> /"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut vec = l.clone();\n\
    \    let mut s = 0;\n    for i in (0..vec.len()).filter(|&x| x % 2 == 0) {\n \
    \       for j in (i..vec.len()).filter(|&x| x % 2 == 0) {\n            if vec[i]\
    \ > vec[j] {\n                s = vec[i];\n                vec[i] = vec[j];\n\
    \                vec[j] = s;\n            }\n        }\n    }\n    vec\n}\n\n\
    fn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut is_even =\
    \ true;\n    let mut new_list = Vec::new();\n    for e in l {\n        if is_even\
    \ {\n            new_list.push(e);\n        } else {\n            let mut new_vec\
    \ = new_list.clone();\n            new_vec.push(e);\n            new_vec.sort();\n\
    \            new_list.push(new_vec[1]);\n        }\n        is_even = !is_even;\n\
    \    }\n    new_list\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 5, -5, 2, -3, -3, 9, -3, 123, -3, -10]`,\n right: `[-10, 3, -5, 2, -3,\
    \ 3, 5, 0, 9, 1, 123]`', /tmp/tmpxga6d0fk.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    fn sorted(l: Vec<isize>)\
    \ -> Vec<isize> {\n        fn helper(l: Vec<isize>, acc: Vec<isize>) -> Vec<isize>\
    \ {\n            if l.len() == 0 {\n                acc\n            } else {\n\
    \                let curr = l[0];\n                let mut curr_index = 0;\n \
    \               let mut i = 0;\n                for (index, value) in acc.iter().enumerate()\
    \ {\n                    if curr < *value {\n                        curr_index\
    \ = index;\n                        break;\n                    }\n          \
    \          i += 1;\n                }\n                let mut next_acc = acc.clone();\n\
    \                if i == acc.len() {\n                    next_acc.push(curr);\n\
    \                } else {\n                    next_acc.insert(curr_index, curr);\n\
    \                }\n                helper(l[1..].to_vec(), next_acc)\n      \
    \      }\n        }\n        helper(l, vec![])\n    }\n    let mut r = vec![];\n\
    \    for (index, value) in l.iter().enumerate() {\n        if index % 2 == 0 {\n\
    \            r.push(*value);\n        } else {\n            let sorted_vec = sorted(l[index..].to_vec());\n\
    \            r.extend(sorted_vec);\n            break;\n        }\n    }\n   \
    \ r\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, -10, -5, -3, 0, 1, 2, 3, 3, 9, 123]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp9ia_inpn.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    if l.len() < 2 {\n\
    \        return l;\n    }\n    let mut l = l;\n    let (v0, v1) = l.split_at_mut(2);\n\
    \    if v0[0] > v0[1] {\n        let tmp = v0[0];\n        v0[0] = v0[1];\n  \
    \      v0[1] = tmp;\n    }\n    let mut ret = vec![v0[0], v0[1]];\n    ret.append(&mut\
    \ sort_even(v1.to_vec()));\n    ret\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 5, -5, 2, -3, 3, 0, 9, 1, 123, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpo4ucbfof.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut new_list\
    \ = l.clone();\n    let mut even_list = Vec::new();\n    let mut counter = 0;\n\
    \    for num in l {\n        if counter % 2 == 0 {\n            even_list.push(num);\n\
    \        }\n        counter += 1;\n    }\n    even_list.sort();\n    counter =\
    \ 0;\n    for num in even_list {\n        new_list[counter] = num;\n        counter\
    \ += 2;\n    }\n    new_list\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut new_l = l.clone();\n\
    \    let mut even_nums = Vec::new();\n    let mut first_i = 0;\n    let mut last_i\
    \ = 0;\n    for i in 0..new_l.len() {\n        if i % 2 == 0 {\n            even_nums.push(new_l[i]);\n\
    \            last_i = i;\n        }\n    }\n    even_nums.sort();\n    for i in\
    \ first_i..last_i + 1 {\n        if i % 2 == 0 {\n            new_l[i] = even_nums[(i\
    \ - first_i) / 2];\n        }\n    }\n    new_l\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    // YOUR CODE HERE\n\
    \    let mut list: Vec<isize> = Vec::new();\n    let mut even_list: Vec<isize>\
    \ = Vec::new();\n    let mut odd_list: Vec<isize> = Vec::new();\n    let mut sort_list:\
    \ Vec<isize> = Vec::new();\n    for (index, val) in l.iter().enumerate() {\n \
    \       if index % 2 == 0 {\n            even_list.push(*val);\n        } else\
    \ {\n            odd_list.push(*val);\n        }\n    }\n    sort_list = even_list.clone();\n\
    \    sort_list.sort();\n    for (index, val) in even_list.iter().enumerate() {\n\
    \        list.push(*val);\n        list.push(odd_list[index]);\n    }\n    list\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 1 but the index\
    \ is 1', /tmp/tmpu5jw6e8j.rs:25:19\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    if l.len() <= 1 {\n\
    \        return l;\n    }\n\n    let mut left = vec![];\n    let mut right = vec![];\n\
    \    let mut even = vec![];\n    let mut odd = vec![];\n\n    for (index, num)\
    \ in l.iter().enumerate() {\n        if index % 2 == 0 {\n            even.push(*num);\n\
    \        } else {\n            odd.push(*num);\n        }\n    }\n\n    let mid\
    \ = even.len() / 2;\n    left = even[..mid].to_vec();\n    right = even[mid..].to_vec();\n\
    \n    let left = sort_even(left);\n    let right = sort_even(right);\n\n    let\
    \ mut l = vec![];\n    l.append(&mut left);\n    l.append(&mut right);\n    l.append(&mut\
    \ odd);\n\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "warning: value assigned to `left` is never read\n  --> /tmp/tmpc3hcw1op.rs:13:13\n\
    \   |\n13 |     let mut left = vec![];\n   |             ^^^^\n   |\n   = note:\
    \ `#[warn(unused_assignments)]` on by default\n   = help: maybe it is overwritten\
    \ before being read?\n\nwarning: value assigned to `right` is never read\n  -->\
    \ /tmp/tmpc3hcw1op.rs:14:13\n   |\n14 |     let mut right = vec![];\n   |    \
    \         ^^^^^\n   |\n   = help: maybe it is overwritten before being read?\n\
    \nerror[E0596]: cannot borrow `left` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmpc3hcw1op.rs:34:14\n   |\n30 |     let left = sort_even(left);\n\
    \   |         ---- help: consider changing this to be mutable: `mut left`\n...\n\
    34 |     l.append(&mut left);\n   |              ^^^^^^^^^ cannot borrow as mutable\n\
    \nerror[E0596]: cannot borrow `right` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmpc3hcw1op.rs:35:14\n   |\n31 |     let right = sort_even(right);\n\
    \   |         ----- help: consider changing this to be mutable: `mut right`\n\
    ...\n35 |     l.append(&mut right);\n   |              ^^^^^^^^^^ cannot borrow\
    \ as mutable\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\
    \nFor more information about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize>\
    \ = Vec::new();\n    let mut sorted: Vec<isize> = Vec::new();\n    let mut odd:\
    \ Vec<isize> = Vec::new();\n    let mut index = 0;\n    let mut even_index = 0;\n\
    \    for n in l {\n        if index % 2 == 0 {\n            sorted.push(n);\n\
    \            evens.push(n);\n        } else {\n            odd.push(n);\n    \
    \    }\n        index += 1;\n    }\n    sorted.sort();\n    for n in sorted {\n\
    \        if even_index < evens.len() && evens[even_index] == n {\n           \
    \ even_index += 1;\n        } else {\n            odd.push(n);\n        }\n  \
    \  }\n    odd\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2]`,\n right: `[1, 2, 3]`', /tmp/tmphlha8g9q.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut new_l = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            new_l.push(l[i]);\n\
    \        } else {\n            let mut temp = l[i];\n            for j in 0..i\
    \ {\n                if new_l[j] > temp {\n                    let temp_i = new_l[j];\n\
    \                    new_l[j] = temp;\n                    temp = temp_i;\n  \
    \              }\n            }\n            new_l.push(temp);\n        }\n  \
    \  }\n    new_l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, -5, 2, -3, 3, 3, 5, 9, 123, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpvd6kqifd.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    // TODO: Fill in\
    \ this function.\n    let mut new_vec: Vec<isize> = Vec::new();\n    for i in\
    \ 0..l.len() {\n        if i % 2 == 0 {\n            new_vec.push(l[i]);\n   \
    \     } else {\n            let mut inner_vec: Vec<isize> = Vec::new();\n    \
    \        inner_vec.push(l[i]);\n            new_vec.push(inner_vec.pop().unwrap());\n\
    \        }\n    }\n    new_vec\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpj9ndglxk.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpssc5vxv7.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    return l.into_iter().enumerate().map(|(i,\
    \ x)| {\n        if i % 2 == 0 {\n            return x;\n        } else {\n  \
    \          let mut temp = vec![x];\n            temp.extend(l.iter().enumerate().filter(|(j,\
    \ _)| *j % 2 == 1 && *j != i).map(|(_, y)| *y));\n            temp.sort();\n \
    \           return temp[0];\n        }\n    }).collect();\n}\n\nfn main() {\n\
    \    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmplqky8cau.rs:9:42\n\
    \    |\n8   | fn sort_even(l: Vec<isize>) -> Vec<isize> {\n    |             \
    \ - move occurs because `l` has type `Vec<isize>`, which does not implement the\
    \ `Copy` trait\n9   |     return l.into_iter().enumerate().map(|(i, x)| {\n  \
    \  |              -----------                 ^^^^^^^^ value borrowed here after\
    \ move\n    |              |\n    |              `l` moved due to this method\
    \ call\n...\n14  |             temp.extend(l.iter().enumerate().filter(|(j, _)|\
    \ *j % 2 == 1 && *j != i).map(|(_, y)| *y));\n    |                         -\
    \ borrow occurs due to use in closure\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `l`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut sorted_l:\
    \ Vec<isize> = l.clone();\n    let mut even_indicies: Vec<usize> = vec![];\n \
    \   let mut even_values: Vec<isize> = vec![];\n    for i in 0..l.len() {\n   \
    \     if i % 2 == 0 {\n            even_indicies.push(i);\n            even_values.push(l[i]);\n\
    \        }\n    }\n    even_values.sort();\n    for i in 0..even_indicies.len()\
    \ {\n        sorted_l[even_indicies[i]] = even_values[i];\n    }\n    sorted_l\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    // TODO: implement!\n    for i in 0..l.len() {\n        if i % 2 == 0 {\n\
    \            for j in 0..l.len() {\n                if l[j] < l[i] {\n       \
    \             let temp = l[i];\n                    l[i] = l[j];\n           \
    \         l[j] = temp;\n                }\n            }\n        }\n    }\n \
    \   l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 2, 1]`,\n right: `[1, 2, 3]`', /tmp/tmpea00onb0.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    fn sort_even_helper(l:\
    \ Vec<isize>, ret: Vec<isize>, index: usize) -> Vec<isize> {\n        if index\
    \ == l.len() {\n            ret\n        } else if index % 2 == 0 {\n        \
    \    let insert = if index < l.len() - 1 {\n                vec![l[index], l[index\
    \ + 1]].sort();\n                insert[0]\n            } else {\n           \
    \     l[index]\n            };\n            sort_even_helper(l, ret.append(&mut\
    \ vec![insert]), index + 1)\n        } else {\n            sort_even_helper(l,\
    \ ret.append(&mut vec![l[index]]), index + 1)\n        }\n    }\n    sort_even_helper(l,\
    \ vec![], 0)\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `insert` in this scope\n  --> /tmp/tmpijiu9m1u.rs:15:17\n\
    \   |\n15 |                 insert[0]\n   |                 ^^^^^^ not found in\
    \ this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpijiu9m1u.rs:19:33\n\
    \   |\n19 |             sort_even_helper(l, ret.append(&mut vec![insert]), index\
    \ + 1)\n   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n  \
    \         found unit type `()`\nnote: method `append` modifies its receiver in-place\n\
    \  --> /tmp/tmpijiu9m1u.rs:19:37\n   |\n19 |             sort_even_helper(l, ret.append(&mut\
    \ vec![insert]), index + 1)\n   |                                 --- ^^^^^^ this\
    \ call modifies `ret` in-place\n   |                                 |\n   | \
    \                                you probably want to use this value after calling\
    \ the method...\n   = note: ...instead of the `()` output of method `append`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpijiu9m1u.rs:21:33\n   |\n21 |\
    \             sort_even_helper(l, ret.append(&mut vec![l[index]]), index + 1)\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n  \
    \         found unit type `()`\nnote: method `append` modifies its receiver in-place\n\
    \  --> /tmp/tmpijiu9m1u.rs:21:37\n   |\n21 |             sort_even_helper(l, ret.append(&mut\
    \ vec![l[index]]), index + 1)\n   |                                 --- ^^^^^^\
    \ this call modifies `ret` in-place\n   |                                 |\n\
    \   |                                 you probably want to use this value after\
    \ calling the method...\n   = note: ...instead of the `()` output of method `append`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut sorted_even\
    \ = vec![];\n    for (i, element) in l.iter().enumerate() {\n        if i % 2\
    \ == 0 {\n            sorted_even.push(*element);\n        }\n    }\n    sorted_even.sort();\n\
    \    let mut new_list = vec![];\n    for (i, element) in l.iter().enumerate()\
    \ {\n        if i % 2 == 0 {\n            new_list.push(sorted_even.remove(0));\n\
    \        } else {\n            new_list.push(*element);\n        }\n    }\n  \
    \  new_list\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut res = l.clone();\n\
    \    let mut new = Vec::new();\n    for (i, x) in l.iter().enumerate() {\n   \
    \     if i % 2 == 0 {\n            new.push(*x);\n        }\n    }\n    new.sort();\n\
    \    for (i, x) in new.iter().enumerate() {\n        res[i * 2] = *x;\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut tmp = Vec::<isize>::new();\n\
    \    let mut vec = Vec::<isize>::new();\n    let mut count = 0;\n    let mut x\
    \ = 0;\n    while count < l.len() {\n        if count % 2 == 0 {\n           \
    \ vec.push(l[count]);\n        } else {\n            tmp.push(l[count]);\n   \
    \     }\n        count += 1;\n    }\n    tmp.sort();\n    for i in tmp {\n   \
    \     vec.insert(x + 1, i);\n        x += 2;\n    }\n    vec\n}\n\nfn main() {\n\
    \    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 0, -5, 1, -3, 2, 9, 3, 123, 3, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmppki654kr.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_list = Vec::new();\n    for i in 0..l.len() {\n        if i\
    \ % 2 == 0 {\n            let mut even_num = l[i];\n            even_list.push(even_num);\n\
    \        }\n    }\n    even_list.sort();\n    for i in 0..l.len() {\n        if\
    \ i % 2 == 0 {\n            l[i] = even_list[i / 2];\n        }\n    }\n    l\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    // TODO: replace\
    \ this with your code.\n    vec![]\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 2, 3]`', /tmp/tmppohlbq10.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let n = l.len();\n\
    \    // Create an empty list with n elements.\n    let mut l2 = Vec::with_capacity(n);\n\
    \    for _ in 0..n {\n        l2.push(0);\n    }\n    let mut e = 0;\n    let\
    \ mut o = 1;\n    for i in 0..n {\n        if i % 2 == 0 {\n            l2[e]\
    \ = l[i];\n            e += 2;\n        } else {\n            l2[o] = l[i];\n\
    \            o += 2;\n        }\n    }\n    let mut t = 0;\n    for j in 0..n\
    \ {\n        if j % 2 == 0 {\n            let mut min = l2[j];\n            let\
    \ mut min_index = j;\n            for k in j..n {\n                if k % 2 ==\
    \ 0 {\n                    if l2[k] < min {\n                        min = l2[k];\n\
    \                        min_index = k;\n                    }\n             \
    \   }\n            }\n            let temp = l2[j];\n            l2[j] = min;\n\
    \            l2[min_index] = temp;\n            t += 1;\n        }\n    }\n  \
    \  l2\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut new_list\
    \ = Vec::new();\n    let mut even_list = Vec::new();\n    let mut odd_list = Vec::new();\n\
    \    let mut idx = 0;\n    for i in l {\n        if idx % 2 == 0 {\n         \
    \   even_list.push(i);\n        } else {\n            odd_list.push(i);\n    \
    \    }\n        idx += 1;\n    }\n    even_list.sort();\n    idx = 0;\n    for\
    \ i in even_list {\n        new_list.push(i);\n        if idx < odd_list.len()\
    \ {\n            new_list.push(odd_list[idx]);\n        }\n        idx += 1;\n\
    \    }\n    new_list\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    if l.len() < 2 {\n\
    \        return l;\n    }\n    let mut ret = Vec::with_capacity(l.len());\n  \
    \  let mut odd = Vec::with_capacity(l.len() / 2);\n    let mut even = Vec::with_capacity(l.len()\
    \ / 2);\n    for i in l.iter() {\n        if even.len() < odd.len() {\n      \
    \      even.push(*i);\n        } else {\n            odd.push(*i);\n        }\n\
    \    }\n    let mut even = even.sort();\n    while even.len() > 0 {\n        ret.push(odd.pop().unwrap());\n\
    \        ret.push(even.pop().unwrap());\n    }\n    ret\n}\n\nfn main() {\n  \
    \  let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for unit type `()` in the current\
    \ scope\n  --> /tmp/tmpv6cdmvv3.rs:23:16\n   |\n23 |     while even.len() > 0\
    \ {\n   |                ^^^ method not found in `()`\n\nerror[E0599]: no method\
    \ named `pop` found for unit type `()` in the current scope\n  --> /tmp/tmpv6cdmvv3.rs:25:23\n\
    \   |\n25 |         ret.push(even.pop().unwrap());\n   |                     \
    \  ^^^ method not found in `()`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l1: Vec<isize>\
    \ = Vec::new();\n    let mut l2: Vec<isize> = Vec::new();\n    let mut l3: Vec<isize>\
    \ = Vec::new();\n    let mut i = 0;\n    while i < l.len() {\n        if i % 2\
    \ == 0 {\n            l1.push(l[i]);\n        } else {\n            l2.push(l[i]);\n\
    \        }\n        i += 1;\n    }\n    l2.sort();\n    let mut i1 = 0;\n    let\
    \ mut i2 = 0;\n    while i1 < l1.len() {\n        l3.push(l1[i1]);\n        l3.push(l2[i2]);\n\
    \        i1 += 1;\n        i2 += 1;\n    }\n    l3\n}\n\nfn main() {\n    let\
    \ candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 1 but the index\
    \ is 1', /tmp/tmplkczs5r4.rs:26:17\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut vec = Vec::new();\n\
    \    let mut iter = l.into_iter();\n    while let Some(a) = iter.next() {\n  \
    \      vec.push(a);\n        if let Some(b) = iter.next() {\n            vec.push(sort(&vec![a,\
    \ b])[1]);\n        }\n    }\n    vec\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sort` in this scope\n  --> /tmp/tmp2qhntyxu.rs:14:22\n\
    \   |\n14 |             vec.push(sort(&vec![a, b])[1]);\n   |                \
    \      ^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    if l.len() <= 1 {\n\
    \        return l;\n    }\n    let mut v = Vec::new();\n    let mut i = 0;\n \
    \   while i < l.len() {\n        let mut e = l[i].clone();\n        if i % 2 ==\
    \ 0 {\n            e = get_smallest(l[i + 1].clone(), l[i].clone());\n       \
    \ }\n        v.push(e);\n        i += 1;\n    }\n    v\n}\n\nfn main() {\n   \
    \ let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `get_smallest` in this scope\n  -->\
    \ /tmp/tmp21vkhou6.rs:17:17\n   |\n17 |             e = get_smallest(l[i + 1].clone(),\
    \ l[i].clone());\n   |                 ^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut new_list\
    \ = l.clone();\n    for i in 0..new_list.len() {\n        // new_list[i] = new_list[i]\n\
    \        // println!(\"{:?}\", new_list[i]);\n        if i % 2 == 0 {\n      \
    \      new_list[i] = new_list[i]\n        } else {\n            new_list[i] =\
    \ new_list[i]\n        }\n    }\n    new_list\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpl04309f3.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut cloned =\
    \ l.clone();\n    for i in 1..l.len() {\n        if i % 2 == 0 {\n           \
    \ for j in i..l.len() {\n                if l[j] < l[i] {\n                  \
    \  cloned.swap(i, j);\n                }\n            }\n        }\n    }\n  \
    \  cloned\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -10, 2, -5, 3, -3, 9, 1, 123, 0]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmplw4s_0t6.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let l: Vec<isize>\
    \ = l;\n    let mut ls: Vec<isize> = Vec::new();\n    let mut i: isize = 0;\n\
    \    while i < l.len() as isize {\n        if i % 2 == 0 {\n            ls.push(l[i\
    \ as usize]);\n        } else {\n            let mut ls2: Vec<isize> = Vec::new();\n\
    \            let mut j: isize = 0;\n            while j < i {\n              \
    \  if j % 2 == 0 {\n                    ls2.push(l[j as usize]);\n           \
    \     }\n                j = j + 1;\n            }\n            ls2.sort();\n\
    \            let mut k: isize = 0;\n            while k < ls2.len() as isize {\n\
    \                ls.push(ls2[k as usize]);\n                k = k + 1;\n     \
    \       }\n        }\n        i = i + 1;\n    }\n    return ls;\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 3]`,\n right: `[1, 2, 3]`', /tmp/tmp1bxuev53.rs:38:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let (even, odd) =\
    \ l.split_at(l.len() / 2);\n    let mut even = even.to_vec();\n    even.sort();\n\
    \    even.into_iter().zip(odd.into_iter()).flatten().collect()\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `(isize, &isize)` is not an iterator\n    --> /tmp/tmp_60xpfn4.rs:12:43\n\
    \     |\n12   |     even.into_iter().zip(odd.into_iter()).flatten().collect()\n\
    \     |                                           ^^^^^^^ `(isize, &isize)` is\
    \ not an iterator\n     |\n     = help: the trait `Iterator` is not implemented\
    \ for `(isize, &isize)`\n     = note: required because of the requirements on\
    \ the impl of `IntoIterator` for `(isize, &isize)`\nnote: required by a bound\
    \ in `flatten`\n\nerror[E0599]: the method `collect` exists for struct `Flatten<Zip<std::vec::IntoIter<isize>,\
    \ std::slice::Iter<'_, isize>>>`, but its trait bounds were not satisfied\n  \
    \ --> /tmp/tmp_60xpfn4.rs:12:53\n    |\n12  |       even.into_iter().zip(odd.into_iter()).flatten().collect()\n\
    \    |                                                       ^^^^^^^ method cannot\
    \ be called on `Flatten<Zip<std::vec::IntoIter<isize>, std::slice::Iter<'_, isize>>>`\
    \ due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds\
    \ were not satisfied:\n            `<(isize, &isize) as IntoIterator>::IntoIter\
    \ = _`\n            which is required by `Flatten<Zip<std::vec::IntoIter<isize>,\
    \ std::slice::Iter<'_, isize>>>: Iterator`\n            `<(isize, &isize) as IntoIterator>::Item\
    \ = _`\n            which is required by `Flatten<Zip<std::vec::IntoIter<isize>,\
    \ std::slice::Iter<'_, isize>>>: Iterator`\n            `(isize, &isize): IntoIterator`\n\
    \            which is required by `Flatten<Zip<std::vec::IntoIter<isize>, std::slice::Iter<'_,\
    \ isize>>>: Iterator`\n            `Flatten<Zip<std::vec::IntoIter<isize>, std::slice::Iter<'_,\
    \ isize>>>: Iterator`\n            which is required by `&mut Flatten<Zip<std::vec::IntoIter<isize>,\
    \ std::slice::Iter<'_, isize>>>: Iterator`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut odd_indicies_l\
    \ = Vec::<isize>::new();\n    let mut even_indicies_l = Vec::<isize>::new();\n\
    \    let mut l_sort = Vec::<isize>::new();\n    // Make the two lists\n    for\
    \ (index, &value) in l.iter().enumerate() {\n        if index % 2 == 0 {\n   \
    \         odd_indicies_l.push(value);\n        } else {\n            even_indicies_l.push(value);\n\
    \        }\n    }\n    // Sort the list\n    even_indicies_l.sort();\n    // Make\
    \ the new list\n    for (index, &value) in l.iter().enumerate() {\n        if\
    \ index % 2 == 0 {\n            l_sort.push(value);\n        } else {\n      \
    \      l_sort.push(even_indicies_l.pop().unwrap());\n        }\n    }\n    l_sort\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 3, -3, 2, 9, 1, 123, 0, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmps8w8_0hm.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    l.into_iter().enumerate().map(|(i,\
    \ x)| if i % 2 == 0 { x } else { x }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpn5rrx0j9.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let (mut left, mut\
    \ right) = l.split_at(2);\n    left.sort();\n    let mut sorted = left.to_vec();\n\
    \    sorted.extend(right);\n    sorted\n}\n\nfn main() {\n    let candidate =\
    \ sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n --> /tmp/tmpty3tr9vs.rs:9:10\n\
    \  |\n9 |     let (mut left, mut right) = l.split_at(2);\n  |          ----^^^^\n\
    \  |          |\n  |          help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]`\
    \ on by default\n\nwarning: variable does not need to be mutable\n --> /tmp/tmpty3tr9vs.rs:9:20\n\
    \  |\n9 |     let (mut left, mut right) = l.split_at(2);\n  |                \
    \    ----^^^^^\n  |                    |\n  |                    help: remove\
    \ this `mut`\n\nerror[E0596]: cannot borrow `*left` as mutable, as it is behind\
    \ a `&` reference\n  --> /tmp/tmpty3tr9vs.rs:10:5\n   |\n9  |     let (mut left,\
    \ mut right) = l.split_at(2);\n   |          -------- help: consider changing\
    \ this to be a mutable reference: `&mut [isize]`\n10 |     left.sort();\n   |\
    \     ^^^^^^^^^^^ `left` is a `&` reference, so the data it refers to cannot be\
    \ borrowed as mutable\n\nerror: aborting due to previous error; 2 warnings emitted\n\
    \nFor more information about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    // TODO\n    vec![]\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 2, 3]`', /tmp/tmpfzv9_sza.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut i = 1;\n\
    \    let mut l1 = l.clone();\n    while i < l.len() {\n        let mut j = i;\n\
    \        while j > 0 && l1[j - 1] > l1[j] {\n            l1.swap(j - 1, j);\n\
    \            j -= 1;\n        }\n        i += 2;\n    }\n    l1\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 5, -5, 2, -3, 0, 1, 3, 9, 123, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpa7_i8mof.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            l[i] = l[i];\n\
    \        } else {\n            l[i] = swap(l[i], l[i - 1]);\n        }\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmp6mbr1dcl.rs:14:20\n\
    \   |\n14 |             l[i] = swap(l[i], l[i - 1]);\n   |                   \
    \ ^^^^ not found in this scope\n   |\nhelp: consider importing one of these items\n\
    \   |\n1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut new_list\
    \ = l.clone();\n    let mut even_index = 0;\n    for (index, i) in l.iter().enumerate()\
    \ {\n        if index % 2 == 0 {\n            new_list[even_index] = *i;\n   \
    \         even_index += 1;\n        }\n    }\n    new_list[0..even_index].sort();\n\
    \    return new_list;\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 3, 3]`,\n right: `[1, 2, 3]`', /tmp/tmpyh58h3cb.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let evens = l.iter().enumerate().filter(|&(i,\
    \ _)| i % 2 == 0).map(|(_, a)| *a).collect::<Vec<isize>>();\n    let mut odds\
    \ = l.iter().enumerate().filter(|&(i, _)| i % 2 == 1).map(|(_, a)| *a).collect::<Vec<isize>>();\n\
    \    evens.iter().enumerate().map(|(i, n)| {\n        if i % 2 == 0 {\n      \
    \      n.clone()\n        } else {\n            odds.sort();\n            odds.remove(0)\n\
    \        }\n    }).collect::<Vec<isize>>()\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2]`,\n right: `[1, 2, 3]`', /tmp/tmp4zf7kiyq.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut result: Vec<isize> = Vec::new();\n    for i in 0..l.len() {\n   \
    \     if i % 2 == 0 {\n            result.push(l[i]);\n        } else {\n    \
    \        let mut temp: Vec<isize> = Vec::new();\n            temp.push(l[i]);\n\
    \            for j in i+1..l.len() {\n                if j % 2 == 1 {\n      \
    \              temp.push(l[j]);\n                }\n            }\n          \
    \  temp.sort();\n            for elem in temp {\n                result.push(elem);\n\
    \            }\n            break;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2]`,\n right: `[1, 2, 3]`', /tmp/tmp2_oe70o3.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let l_len = l.len();\n    let mut i = 1;\n    while i < l_len {\n       \
    \ let mut j = i - 1;\n        while j >= 0 && l[j] > l[j + 1] {\n            let\
    \ temp = l[j];\n            l[j] = l[j + 1];\n            l[j + 1] = temp;\n \
    \           j -= 1;\n        }\n        i += 2;\n    }\n    l\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp73fcrlv5.rs:18:13\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let even = l.iter().enumerate().filter(|(i,\
    \ _)| i % 2 == 0).map(|(_, x)| *x).collect::<Vec<isize>>();\n    let odd = l.iter().enumerate().filter(|(i,\
    \ _)| i % 2 == 1).map(|(_, x)| *x).collect::<Vec<isize>>();\n    let mut even\
    \ = even.clone();\n    even.sort();\n    let mut odd = odd.clone();\n    odd.sort();\n\
    \    let mut v = Vec::new();\n    for i in 0..(even.len() + odd.len()) {\n   \
    \     if i % 2 == 0 {\n            v.push(even[i / 2]);\n        } else {\n  \
    \          v.push(odd[i / 2]);\n        }\n    }\n    v\n}\n\nfn main() {\n  \
    \  let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 0, -5, 1, -3, 2, 5, 3, 9, 3, 123]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp5tn59ksg.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut vec_of_even = vec![];\n    let mut vec_of_odd = vec![];\n    let\
    \ mut vec_of_sorted_even = vec![];\n    let mut vec_of_sorted_odd = vec![];\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      vec_of_even.push(l[i]);\n        } else {\n            vec_of_odd.push(l[i]);\n\
    \        }\n        i += 1;\n    }\n    vec_of_sorted_even = vec_of_even.clone();\n\
    \    vec_of_sorted_even.sort();\n    i = 0;\n    while i < l.len() {\n       \
    \ if i % 2 == 0 {\n            l[i] = vec_of_sorted_even[0];\n            vec_of_sorted_even.remove(0);\n\
    \        } else {\n            l[i] = vec_of_odd[0];\n            vec_of_odd.remove(0);\n\
    \        }\n        i += 1;\n    }\n    l\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmpsyyfs74w.rs:13:33\n\
    \   |\n13 |     let mut vec_of_sorted_odd = vec![];\n   |         ---------------------\
    \   ^^^^^^ cannot infer type for type parameter `T`\n   |         |\n   |    \
    \     consider giving `vec_of_sorted_odd` the explicit type `Vec<T>`, where the\
    \ type parameter `T` is specified\n   |\n   = note: this error originates in the\
    \ macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut odd_elements:\
    \ Vec<isize> = Vec::new();\n    let mut even_elements: Vec<isize> = Vec::new();\n\
    \    let mut sorted_elements: Vec<isize> = Vec::new();\n    let mut l_mut: Vec<isize>\
    \ = l;\n    let mut index: usize = 0;\n    let mut list_size: usize = l_mut.len();\n\
    \    for i in 0..list_size {\n        if (i+1) % 2 == 0 {\n            odd_elements.push(l_mut[i]);\n\
    \        } else {\n            even_elements.push(l_mut[i]);\n        }\n    }\n\
    \    odd_elements.sort();\n    odd_elements.reverse();\n    even_elements.sort();\n\
    \    even_elements.reverse();\n    while index < list_size {\n        if (index+1)\
    \ % 2 == 0 {\n            sorted_elements.push(odd_elements.pop().unwrap());\n\
    \        } else {\n            sorted_elements.push(even_elements.pop().unwrap());\n\
    \        }\n        index += 1;\n    }\n    sorted_elements.reverse();\n    sorted_elements\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 2, 1]`,\n right: `[1, 2, 3]`', /tmp/tmp0xr05sxt.rs:40:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            l[i] = l[i] -\
    \ 1;\n        }\n    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 2, 2]`,\n right: `[1, 2, 3]`', /tmp/tmpz4o1qn33.rs:20:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut ret = Vec::new();\n\
    \    let mut even = Vec::new();\n    for (i, x) in l.iter().enumerate() {\n  \
    \      if i % 2 == 0 {\n            ret.push(*x);\n        } else {\n        \
    \    even.push(*x);\n        }\n    }\n    even.sort();\n    for (i, x) in even.iter().enumerate()\
    \ {\n        ret.insert(i * 2 + 1, *x);\n    }\n    ret\n}\n\nfn main() {\n  \
    \  let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 0, -5, 1, -3, 2, 9, 3, 123, 3, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmps6t33d54.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut sorted_vec\
    \ = Vec::new();\n    // you can use this to add elements to the vector\n    for\
    \ (i, n) in l.iter().enumerate() {\n        if i % 2 == 0 {\n            sorted_vec.push(*n);\n\
    \        } else {\n            let mut temp_vec = l[i..].to_vec();\n         \
    \   temp_vec.sort();\n            sorted_vec.push(temp_vec[0]);\n        }\n \
    \   }\n    sorted_vec\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, -10, -5, -10, -3, -10, 9, -10, 123, -10, -10]`,\n right: `[-10, 3, -5,\
    \ 2, -3, 3, 5, 0, 9, 1, 123]`', /tmp/tmp0ykk1x6q.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut temp = l.clone();\n\
    \    let mut idx: usize = 0;\n    while idx < temp.len() {\n        if idx % 2\
    \ == 0 {\n            idx += 1;\n            continue;\n        }\n        let\
    \ mut odd_vec = Vec::new();\n        let mut i = idx;\n        while i < temp.len()\
    \ {\n            if i % 2 == 0 {\n                break;\n            }\n    \
    \        odd_vec.push(temp[i]);\n            i += 1;\n        }\n        odd_vec.sort();\n\
    \        i = idx;\n        let mut j = 0;\n        while i < temp.len() {\n  \
    \          if i % 2 == 0 {\n                break;\n            }\n          \
    \  temp[i] = odd_vec[j];\n            i += 1;\n            j += 1;\n        }\n\
    \        idx += 1;\n    }\n    temp\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp8p9jyjvc.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut new_l = l.clone();\n\
    \    let mut counter = 0;\n    while counter < new_l.len() {\n        if counter\
    \ % 2 == 0 {\n            let mut remaining_list = Vec::new();\n            for\
    \ i in counter..new_l.len() {\n                if i % 2 == 0 {\n             \
    \       remaining_list.push(new_l[i]);\n                }\n            }\n   \
    \         remaining_list.sort();\n            for i in counter..new_l.len() {\n\
    \                if i % 2 == 0 {\n                    new_l[i] = remaining_list.remove(0);\n\
    \                }\n            }\n        }\n        counter += 1;\n    }\n \
    \   new_l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let even = l.iter().enumerate().filter(|(i,\
    \ _)| i % 2 == 0).map(|(_, x)| *x).collect::<Vec<isize>>();\n    let mut even\
    \ = even.clone();\n    even.sort();\n    let mut result = Vec::new();\n    for\
    \ (i, x) in l.iter().enumerate() {\n        result.push(if i % 2 == 0 { even[i\
    \ / 2] } else { *x });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    if l.len() < 3 {\n\
    \        return l;\n    }\n    let mut odds = vec![];\n    let mut evens = vec![];\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            odds.push(l[i]);\n\
    \        } else {\n            evens.push(l[i]);\n        }\n    }\n    evens.sort();\n\
    \    let mut result = vec![];\n    for i in 0..odds.len() {\n        result.push(odds[i]);\n\
    \        result.push(evens[i]);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 1 but the index\
    \ is 1', /tmp/tmpe8722xyg.rs:25:21\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    //let mut new_l:\
    \ Vec<isize> = Vec::new();\n    //println!(\"{:?}\",l);\n    let mut len = l.len();\n\
    \    len = len -1;\n    if (len <= 0) {\n        return l;\n    }\n    let mut\
    \ evens = Vec::new();\n    for i in 0..len {\n        if (i % 2 == 0) {\n    \
    \        evens.push(l[i]);\n        }\n    }\n    //println!(\"{:?}\",evens);\n\
    \    evens.sort();\n    //println!(\"{:?}\",evens);\n    let mut new_l = Vec::new();\n\
    \    let mut j = 0;\n    for i in 0..len {\n        if (i % 2 == 0) {\n      \
    \      new_l.push(evens[j]);\n            j = j + 1;\n        } else {\n     \
    \       new_l.push(l[i]);\n        }\n    }\n    return new_l;\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2]`,\n right: `[1, 2, 3]`', /tmp/tmp1tp9n6od.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    // define even and\
    \ odd as in previous problem\n    let mut even = Vec::new();\n    let mut odd\
    \ = Vec::new();\n    for (index, element) in l.iter().enumerate() {\n        if\
    \ index % 2 == 0 {\n            even.push(*element);\n        } else {\n     \
    \       odd.push(*element);\n        }\n    }\n    // sort even\n    even.sort();\n\
    \    // zip even and odd together and return a flat_map\n    even.iter().zip(odd.iter()).flat_map(|(&a,\
    \ &b)| vec![a, b]).collect()\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2]`,\n right: `[1, 2, 3]`', /tmp/tmpgyl_tg0c.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_copy =\
    \ l.clone();\n    let n = l.len();\n    let mut i = 0;\n    while i < n {\n  \
    \      if i % 2 == 0 {\n            let mut j = i + 2;\n            while j <\
    \ n {\n                if l[j] < l[i] {\n                    l_copy[i] = l[j];\n\
    \                    l_copy[j] = l[i];\n                }\n                j +=\
    \ 2;\n            }\n        }\n        i += 1;\n    }\n    l_copy\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, 3, -10, 2, -10, 3, -10, 0, -10, 1, 123]`,\n right: `[-10, 3, -5, 2, -3,\
    \ 3, 5, 0, 9, 1, 123]`', /tmp/tmpl4za5aw2.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut evens = l.iter().enumerate().filter(|&(i,\
    \ _)| i % 2 == 0).map(|(_, &x)| x).collect::<Vec<isize>>();\n    evens.sort();\n\
    \    l.iter().enumerate().map(|(i, &x)| if i % 2 == 0 { evens.remove(0) } else\
    \ { x }).collect()\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut ret = l.clone();\n\
    \    let mut even = l.iter().enumerate().filter(|&(i, _)| i % 2 == 0).map(|(_,\
    \ &x)| x).collect::<Vec<isize>>();\n    even.sort();\n    for (i, &x) in even.iter().enumerate()\
    \ {\n        ret[i * 2] = x;\n    }\n    ret\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l1 = Vec::new();\n\
    \    let mut r = l.clone();\n    for i in 0..l.len() {\n        if i % 2 == 0\
    \ {\n            l1.push(l[i]);\n        }\n    }\n    l1.sort();\n    for i in\
    \ 0..l.len() {\n        if i % 2 == 0 {\n            r[i] = l1[i/2];\n       \
    \ }\n    }\n    r\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut sorted_vec\
    \ = l.clone();\n    let mut index = 1;\n    while index < sorted_vec.len() {\n\
    \        sorted_vec[index] = l[index];\n        index += 2;\n    }\n    index\
    \ = 2;\n    while index < sorted_vec.len() {\n        sorted_vec[index] = l[index].max(l[index\
    \ - 1]);\n        index += 2;\n    }\n    sorted_vec\n}\n\nfn main() {\n    let\
    \ candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, 3, 2, 2, 3, 9, 0, 123, 1, 1]`,\n right: `[-10, 3, -5, 2, -3, 3, 5, 0,\
    \ 9, 1, 123]`', /tmp/tmp6oxjx1y1.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    if l.len() <= 1 {\n\
    \        return l;\n    }\n    let mut new_l = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            new_l.push(l[i]);\n        } else {\n\
    \            new_l.push(max(l[i], l[i - 1]));\n            new_l.push(min(l[i],\
    \ l[i - 1]));\n        }\n    }\n    return new_l;\n}\n\nfn main() {\n    let\
    \ candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpnaag7jvk.rs:17:24\n\
    \   |\n17 |             new_l.push(max(l[i], l[i - 1]));\n   |               \
    \         ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]: cannot find function `min`\
    \ in this scope\n  --> /tmp/tmpnaag7jvk.rs:18:24\n   |\n18 |             new_l.push(min(l[i],\
    \ l[i - 1]));\n   |                        ^^^\n...\n24 | fn main() {\n   | ---------\
    \ similarly named function `main` defined here\n   |\nhelp: a function with a\
    \ similar name exists\n   |\n18 |             new_l.push(main(l[i], l[i - 1]));\n\
    \   |                        ~~~~\nhelp: consider importing this function\n  \
    \ |\n1  | use std::cmp::min;\n   |\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    // This is a good\
    \ opportunity to use your 'range' function, which will be particularly\n    //\
    \ useful here. You may wish to take a look at the 'sort' function defined in the\
    \ standard\n    // library.\n\n    let mut sorted_evens = Vec::new();\n    let\
    \ mut odds = Vec::new();\n    for i in range(0, l.len()) {\n        if i % 2 ==\
    \ 0 {\n            sorted_evens.push(l[i]);\n        } else {\n            odds.push(l[i]);\n\
    \        }\n    }\n    sorted_evens.sort();\n    let mut j = 0;\n    for i in\
    \ range(0, l.len()) {\n        if i % 2 == 0 {\n            l[i] = sorted_evens[j];\n\
    \            j += 1;\n        } else {\n            l[i] = odds[i - j];\n    \
    \    }\n    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `range` in this scope\n  --> /tmp/tmpb8s24u88.rs:15:14\n\
    \   |\n15 |     for i in range(0, l.len()) {\n   |              ^^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use\
    \ std::slice::range;\n   |\n\nerror[E0425]: cannot find function `range` in this\
    \ scope\n  --> /tmp/tmpb8s24u88.rs:24:14\n   |\n24 |     for i in range(0, l.len())\
    \ {\n   |              ^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this function\n   |\n1  | use std::slice::range;\n   |\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut sorted_even\
    \ = l.clone();\n    sorted_even.sort();\n    let mut l: Vec<isize> = Vec::new();\n\
    \    for (i, e) in l.iter().enumerate() {\n        if i % 2 == 0 {\n         \
    \   l.push(*e);\n        } else {\n            l.push(sorted_even[i]);\n     \
    \   }\n    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `l` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmpdxnlqmcd.rs:14:13\n   |\n12 |     for (i, e) in\
    \ l.iter().enumerate() {\n   |                   --------------------\n   |  \
    \                 |\n   |                   immutable borrow occurs here\n   |\
    \                   immutable borrow later used here\n13 |         if i % 2 ==\
    \ 0 {\n14 |             l.push(*e);\n   |             ^^^^^^^^^^ mutable borrow\
    \ occurs here\n\nerror[E0502]: cannot borrow `l` as mutable because it is also\
    \ borrowed as immutable\n  --> /tmp/tmpdxnlqmcd.rs:16:13\n   |\n12 |     for (i,\
    \ e) in l.iter().enumerate() {\n   |                   --------------------\n\
    \   |                   |\n   |                   immutable borrow occurs here\n\
    \   |                   immutable borrow later used here\n...\n16 |          \
    \   l.push(sorted_even[i]);\n   |             ^^^^^^^^^^^^^^^^^^^^^^ mutable borrow\
    \ occurs here\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    if l.len() <= 1 {\n\
    \        return l;\n    }\n\n    let mut l_even = l.clone();\n    let mut l_odd\
    \ = l.clone();\n\n    l_even.retain(|&i| i % 2 == 0);\n    l_odd.retain(|&i| i\
    \ % 2 != 0);\n\n    l_even.sort();\n\n    let mut sorted = Vec::new();\n\n   \
    \ for (i, j) in l_odd.iter().zip(l_even.iter()) {\n        sorted.push(*i);\n\
    \        sorted.push(*j);\n    }\n\n    sorted\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2]`,\n right: `[1, 2, 3]`', /tmp/tmpd27rrh_0.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut x = 0;\n\
    \    let mut z = vec![];\n    for i in l {\n        if x % 2 == 0 {\n        \
    \    let mut y = vec![i];\n            let mut m = l.clone();\n            m.remove(x);\n\
    \            let mut m1 = m.clone();\n            m1.dedup();\n            m1.sort();\n\
    \            for j in m1 {\n                let mut count = 0;\n             \
    \   for k in m {\n                    if j == k {\n                        count\
    \ += 1;\n                    }\n                }\n                for _ in 0..count\
    \ {\n                    y.push(j);\n                }\n            }\n      \
    \      z.append(&mut y);\n        } else {\n            z.push(i);\n        }\n\
    \        x += 1;\n    }\n    z\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmpukigoy68.rs:14:25\n\
    \    |\n8   | fn sort_even(l: Vec<isize>) -> Vec<isize> {\n    |             \
    \ - move occurs because `l` has type `Vec<isize>`, which does not implement the\
    \ `Copy` trait\n...\n11  |     for i in l {\n    |              - `l` moved due\
    \ to this implicit call to `.into_iter()`\n...\n14  |             let mut m =\
    \ l.clone();\n    |                         ^^^^^^^^^ value borrowed here after\
    \ move\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content\
    \ to avoid moving into the `for` loop\n    |\n11  |     for i in &l {\n    | \
    \             +\n\nerror[E0382]: use of moved value: `m`\n  --> /tmp/tmpukigoy68.rs:21:26\n\
    \   |\n14 |             let mut m = l.clone();\n   |                 -----   ---------\
    \ this reinitialization might get skipped\n   |                 |\n   |      \
    \           move occurs because `m` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n21 |                 for k in m {\n   |             \
    \             ^ `m` moved due to this implicit call to `.into_iter()`, in previous\
    \ iteration of loop\n   |\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n   |\n21 |                 for\
    \ k in &m {\n   |                          +\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut res = l.clone();\n\
    \    let mut iter = res.iter_mut();\n    loop {\n        if let Some(x) = iter.next()\
    \ {\n            iter.next();\n        } else {\n            break;\n        }\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp8g58rjfj.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    for i in (0..l.len()).step_by(2) {\n        let mut head = l[i..].to_vec();\n\
    \        head.sort();\n        l[i..].clone_from_slice(&head);\n    }\n    l\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, -5, -3, 0, 1, 2, 3, 3, 5, 9, 123]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpkdmqafqn.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut out = l.clone();\n\
    \    let mut odd = true;\n    let mut i = 0;\n    while i < out.len() {\n    \
    \    if odd {\n            out[i] = l[i];\n        } else {\n            out[i]\
    \ = sort_even_iter(l[i]);\n        }\n        odd = !odd;\n        i += 1;\n \
    \   }\n    out\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sort_even_iter` in this scope\n  -->\
    \ /tmp/tmpkgjzd5i3.rs:16:22\n   |\n16 |             out[i] = sort_even_iter(l[i]);\n\
    \   |                      ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    // BEGIN TASK 5.2\n\
    \    let mut v: Vec<isize> = Vec::new();\n    let mut i = 0;\n    for x in l {\n\
    \        if i % 2 == 0 {\n            v.push(x);\n        } else {\n         \
    \   v.insert(i - 1, x);\n        }\n        i += 1;\n    }\n    v.sort();\n  \
    \  v\n    // END TASK 5.2\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-10, -5, -3, 0, 1, 2, 3, 3, 5, 9, 123]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmplgrne0c7.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut res: Vec<isize>\
    \ = vec![];\n    let mut evens: Vec<isize> = vec![];\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            res.push(l[i]);\n        } else {\n\
    \            evens.push(l[i]);\n        }\n    }\n    evens.sort();\n    for i\
    \ in 0..evens.len() {\n        res.insert(2 * i + 1, evens[i]);\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 0, -5, 1, -3, 2, 9, 3, 123, 3, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpq4oenwca.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut sorted_evens\
    \ = l.clone();\n    sorted_evens.sort();\n    let mut evens = Vec::new();\n  \
    \  let mut odds = Vec::new();\n    let mut i = 0;\n    while i < l.len() {\n \
    \       if i % 2 == 0 {\n            evens.push(l[i]);\n        } else {\n   \
    \         odds.push(l[i]);\n        }\n        i += 1;\n    }\n    let mut sorted_list\
    \ = Vec::new();\n    for i in 0..evens.len() {\n        sorted_list.push(evens[i]);\n\
    \        sorted_list.push(odds[i]);\n    }\n    sorted_list\n}\n\nfn main() {\n\
    \    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 1 but the index\
    \ is 1', /tmp/tmplr2nyq8l.rs:25:26\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    l.iter().enumerate().fold(Vec::new(),\
    \ |mut acc, (i, x)| {\n        if i % 2 == 0 {\n            acc.push(*x);\n  \
    \      } else {\n            acc.push(*l.iter().skip(i).take(2).min().unwrap());\n\
    \            acc.push(*l.iter().skip(i).take(2).max().unwrap());\n        }\n\
    \        acc\n    })\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 3]`,\n right: `[1, 2, 3]`', /tmp/tmpmt777l74.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    l.iter().step_by(2).cloned().collect::<Vec<isize>>().sort();\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpnimzvpr7.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut returnlist\
    \ = l.clone();\n    for (i, e) in l.iter().enumerate() {\n        if i % 2 ==\
    \ 0 {\n            returnlist[i] = l[i + 1];\n        }\n    }\n    returnlist\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 3 but the index\
    \ is 3', /tmp/tmpnj53ba56.rs:12:29\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    fn sort_even_h(l:\
    \ Vec<isize>, even_l: Vec<isize>, acc: Vec<isize>) -> Vec<isize> {\n        if\
    \ l.len() == 0 {\n            return acc;\n        } else {\n            let even_l_len\
    \ = even_l.len();\n            let mut even_l_front = Vec::new();\n          \
    \  let mut even_l_back = Vec::new();\n            let mut even_l_mid = Vec::new();\n\
    \            let even_l_first = even_l[0];\n            for i in 0..even_l_len\
    \ {\n                if even_l[i] <= even_l_first {\n                    even_l_front.push(even_l[i]);\n\
    \                } else if even_l[i] >= even_l_first {\n                    even_l_back.push(even_l[i]);\n\
    \                } else {\n                    even_l_mid.push(even_l[i]);\n \
    \               }\n            }\n            let mut new_acc = acc;\n       \
    \     new_acc.push(even_l_first);\n            sort_even_h(l.iter().skip(2).cloned().collect(),\n\
    \                        even_l_front.iter().skip(1).cloned().collect(),\n   \
    \                     new_acc);\n            sort_even_h(l.iter().skip(2).cloned().collect(),\n\
    \                        even_l_back.iter().skip(1).cloned().collect(),\n    \
    \                    new_acc);\n            sort_even_h(l.iter().skip(2).cloned().collect(),\n\
    \                        even_l_mid.iter().skip(1).cloned().collect(),\n     \
    \                   new_acc);\n        }\n    }\n    let mut even_l = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_l.push(l[i]);\n\
    \        }\n    }\n    return sort_even_h(l, even_l, Vec::new());\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv_ee5kgk.rs:12:16\n   |\n\
    12 |           } else {\n   |  ________________^\n13 | |             let even_l_len\
    \ = even_l.len();\n14 | |             let mut even_l_front = Vec::new();\n15 |\
    \ |             let mut even_l_back = Vec::new();\n...  |\n37 | |            \
    \             new_acc);\n   | |                                 - help: remove\
    \ this semicolon\n38 | |         }\n   | |_________^ expected struct `Vec`, found\
    \ `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type\
    \ `()`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut v = l.clone();\n\
    \    let mut i = 0;\n    while i < v.len() {\n        let mut l = Vec::new();\n\
    \        l.push(v[i]);\n        let mut j = i + 2;\n        while j < v.len()\
    \ {\n            l.push(v[j]);\n            j += 2;\n        }\n        l.sort();\n\
    \        for (x, y) in l.iter().zip(v.iter_mut().skip(i+1).step_by(2)) {\n   \
    \         *y = *x;\n        }\n        i += 2;\n    }\n    v\n}\n\nfn main() {\n\
    \    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 3]`,\n right: `[1, 2, 3]`', /tmp/tmp2ztrxk7f.rs:30:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut r = l.clone();\n\
    \    let evens = r.iter().enumerate().filter(|&(i, _)| i % 2 == 0).map(|(_, x)|\
    \ x).collect::<Vec<_>>();\n    let mut evens = evens.clone();\n    evens.sort();\n\
    \    for (i, x) in evens.iter().enumerate() {\n        r[i * 2] = *x;\n    }\n\
    \    r\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7didjhpd.rs:14:20\n   |\n\
    14 |         r[i * 2] = *x;\n   |         --------   ^^ expected `isize`, found\
    \ `&isize`\n   |         |\n   |         expected due to the type of this binding\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n14 |         r[i * 2] =\
    \ **x;\n   |                    +\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut result =\
    \ l.clone();\n    let mut even = Vec::new();\n    for i in 0..l.len() {\n    \
    \    if i % 2 == 0 {\n            even.push(l[i]);\n        }\n    }\n    even.sort();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            result[i] = even[i\
    \ / 2];\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut v = Vec::new();\n\
    \    let mut e = 0;\n    let mut o = 0;\n    for i in l {\n        if e == 0 {\n\
    \            v.push(i);\n            e = 1;\n        } else {\n            v.push(v[o]);\n\
    \            v[o] = i;\n            e = 0;\n            o += 1;\n        }\n \
    \   }\n    v\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1, 3]`,\n right: `[1, 2, 3]`', /tmp/tmpg4rva66c.rs:28:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    return vec![];\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 2, 3]`', /tmp/tmpvz73a3d4.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let evens: Vec<isize>\
    \ = l.iter().enumerate().filter(|&(i, _)| i % 2 == 0).map(|(_, &x)| x).collect();\n\
    \    let mut odds: Vec<isize> = l.iter().enumerate().filter(|&(i, _)| i % 2 ==\
    \ 1).map(|(_, &x)| x).collect();\n    odds.sort();\n    let mut result: Vec<isize>\
    \ = Vec::new();\n    for (i, elt) in l.iter().enumerate() {\n        result.push(if\
    \ i % 2 == 0 {evens[i / 2]} else {odds[i / 2]});\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 0, -5, 1, -3, 2, 9, 3, 123, 3, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp3xckf8ib.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    // We'll use mutability\
    \ to create the new list.\n    let mut new_list = Vec::with_capacity(l.len());\n\
    \n    // Split the list into two parts: odd and even indicies.\n    let odd =\
    \ l.into_iter().enumerate().filter(|&(i, _)| i % 2 == 1).map(|(_, v)| v);\n  \
    \  let even = l.into_iter().enumerate().filter(|&(i, _)| i % 2 == 0).map(|(_,\
    \ v)| v);\n\n    // Merge the lists.\n    for (o, e) in odd.zip(even) {\n    \
    \    new_list.push(o);\n        new_list.push(e);\n    }\n\n    // Sort the even\
    \ elements and push them into the list.\n    let even_sorted = even.collect::<Vec<_>>();\n\
    \    even_sorted.sort();\n    new_list.extend(even_sorted);\n\n    new_list\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `l`\n   --> /tmp/tmp677bijef.rs:14:16\n\
    \    |\n8   | fn sort_even(l: Vec<isize>) -> Vec<isize> {\n    |             \
    \ - move occurs because `l` has type `Vec<isize>`, which does not implement the\
    \ `Copy` trait\n...\n13  |     let odd = l.into_iter().enumerate().filter(|&(i,\
    \ _)| i % 2 == 1).map(|(_, v)| v);\n    |                 ----------- `l` moved\
    \ due to this method call\n14  |     let even = l.into_iter().enumerate().filter(|&(i,\
    \ _)| i % 2 == 0).map(|(_, v)| v);\n    |                ^ value used here after\
    \ move\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `l`\n\nerror[E0382]: use of moved value: `even`\n  --> /tmp/tmp677bijef.rs:23:23\n\
    \   |\n14 |     let even = l.into_iter().enumerate().filter(|&(i, _)| i % 2 ==\
    \ 0).map(|(_, v)| v);\n   |         ---- move occurs because `even` has type `Map<Filter<Enumerate<std::vec::IntoIter<isize>>,\
    \ [closure@/tmp/tmp677bijef.rs:14:49: 14:69]>, [closure@/tmp/tmp677bijef.rs:14:75:\
    \ 14:85]>`, which does not implement the `Copy` trait\n...\n17 |     for (o, e)\
    \ in odd.zip(even) {\n   |                           ---- value moved here\n...\n\
    23 |     let even_sorted = even.collect::<Vec<_>>();\n   |                   \
    \    ^^^^ value used here after move\n\nerror[E0596]: cannot borrow `even_sorted`\
    \ as mutable, as it is not declared as mutable\n  --> /tmp/tmp677bijef.rs:24:5\n\
    \   |\n23 |     let even_sorted = even.collect::<Vec<_>>();\n   |         -----------\
    \ help: consider changing this to be mutable: `mut even_sorted`\n24 |     even_sorted.sort();\n\
    \   |     ^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0382, E0596.\n\
    For more information about an error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut result =\
    \ Vec::new();\n    let mut even = Vec::new();\n    for i in l {\n        if i\
    \ % 2 == 0 {\n            even.push(i);\n        }\n    }\n    even.sort();\n\
    \    for i in l {\n        if i % 2 == 0 {\n            result.push(even.pop().unwrap());\n\
    \        } else {\n            result.push(i);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `l`\n   --> /tmp/tmpql1cjxga.rs:17:14\n\
    \    |\n8   | fn sort_even(l: Vec<isize>) -> Vec<isize> {\n    |             \
    \ - move occurs because `l` has type `Vec<isize>`, which does not implement the\
    \ `Copy` trait\n...\n11  |     for i in l {\n    |              - `l` moved due\
    \ to this implicit call to `.into_iter()`\n...\n17  |     for i in l {\n    |\
    \              ^ value used here after move\n    |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `l`\nhelp: consider iterating\
    \ over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n\
    \    |\n11  |     for i in &l {\n    |              +\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut ret: Vec<isize>\
    \ = Vec::new();\n    let mut even_elems: Vec<isize> = Vec::new();\n    let mut\
    \ odd_elems: Vec<isize> = Vec::new();\n    let mut even_ind = false;\n    for\
    \ i in l {\n        if even_ind {\n            even_elems.push(i);\n        }\
    \ else {\n            odd_elems.push(i);\n        }\n        even_ind = !even_ind;\n\
    \    }\n    even_elems.sort();\n    for x in 0..odd_elems.len() {\n        ret.push(odd_elems[x]);\n\
    \        ret.push(even_elems[x]);\n    }\n    return ret;\n}\n\nfn main() {\n\
    \    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 1 but the index\
    \ is 1', /tmp/tmphvpzpvws.rs:24:18\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    match l.len() {\n\
    \        0 => l,\n        1 => l,\n        _ => {\n            let mut ret = Vec::new();\n\
    \            let mut evens = Vec::new();\n            for i in 0..l.len() {\n\
    \                if i % 2 == 0 {\n                    ret.push(l[i]);\n      \
    \          } else {\n                    evens.push(l[i]);\n                }\n\
    \            }\n            evens.sort();\n            for i in 0..evens.len()\
    \ {\n                ret.insert(i * 2 + 1, evens[i]);\n            }\n       \
    \     ret\n        }\n    }\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 0, -5, 1, -3, 2, 9, 3, 123, 3, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpx00pvqgq.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let even_indicies:\
    \ Vec<isize> = (0..l.len()).filter(|x| x % 2 == 0).map(|x| l[x]).collect();\n\
    \    let mut even_indicies = even_indicies.clone();\n    even_indicies.sort();\n\
    \    let mut l_prime = l.clone();\n    for i in 0..even_indicies.len() {\n   \
    \     l_prime[i * 2] = even_indicies[i];\n    }\n    l_prime\n}\n\nfn main() {\n\
    \    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let evens = extract_even(l);\n\
    \    let mut answer = Vec::new();\n    for i in 0..l.len() {\n        if i % 2\
    \ == 0 {\n            answer.push(l[i]);\n        } else {\n            answer.push(evens[i/2]);\n\
    \        }\n    }\n    answer\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `extract_even` in this scope\n --> /tmp/tmpcgdsq551.rs:9:17\n\
    \  |\n9 |     let evens = extract_even(l);\n  |                 ^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    // This function\
    \ recieves a list of values, and returns a list of values with the even indicies\n\
    \    // sorted.\n    // >>> sort_even([1, 3, 2])\n    // [1, 2, 3]\n    // >>>\
    \ sort_even([1, 2, 2, 4])\n    // [1, 2, 2, 4]\n    fn sort_even_helper(l: Vec<isize>)\
    \ -> Vec<isize> {\n        if l.len() == 0 {\n            return l;\n        }\n\
    \        if l.len() == 1 {\n            return l;\n        }\n        let left_list\
    \ = l[1..].to_vec();\n        let left_list_sorted = sort_even_helper(left_list);\n\
    \        let mut sorted_list = vec![l[0]];\n        for x in left_list_sorted\
    \ {\n            let mut index = 0;\n            for y in sorted_list.clone()\
    \ {\n                if x < y {\n                    break;\n                }\n\
    \                index += 1;\n            }\n            sorted_list.insert(index,\
    \ x);\n        }\n        sorted_list\n    }\n    // This function takes a list\
    \ l and returns a list l' such that\n    // l' is identical to l in the odd indicies,\
    \ while its values at the even indicies are equal\n    // to the values of the\
    \ even indicies of l, but sorted.\n    // >>> sort_even([1, 2, 3])\n    // [1,\
    \ 2, 3]\n    // >>> sort_even([5, 6, 3, 4])\n    // [3, 6, 5, 4]\n    fn sort_even_helper_2(l:\
    \ Vec<isize>) -> Vec<isize> {\n        if l.len() == 0 {\n            return l;\n\
    \        }\n        if l.len() == 1 {\n            return l;\n        }\n    \
    \    let mut sorted_list = vec![l[0]];\n        let mut index = 0;\n        for\
    \ x in sort_even_helper(l[1..].to_vec()) {\n            sorted_list.insert(index,\
    \ x);\n            index += 2;\n        }\n\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpihb_op84.rs:65:3\n\
    \   |\n8  | fn sort_even(l: Vec<isize>) -> Vec<isize> {\n   |                \
    \                           - unclosed delimiter\n...\n44 |     fn sort_even_helper_2(l:\
    \ Vec<isize>) -> Vec<isize> {\n   |                                          \
    \              - this delimiter might not be properly closed...\n...\n58 | }\n\
    \   | - ...as it matches this but it has different indentation\n...\n65 | }\n\
    \   |   ^\n\nerror[E0308]: mismatched types\n --> /tmp/tmpihb_op84.rs:8:32\n \
    \ |\n8 | fn sort_even(l: Vec<isize>) -> Vec<isize> {\n  |    ---------       \
    \            ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n  |\n  = note:\
    \ expected struct `Vec<isize>`\n          found unit type `()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpihb_op84.rs:53:9\n   |\n44 |       fn sort_even_helper_2(l:\
    \ Vec<isize>) -> Vec<isize> {\n   |                                          \
    \     ---------- expected `Vec<isize>` because of return type\n...\n53 | /   \
    \      for x in sort_even_helper(l[1..].to_vec()) {\n54 | |             sorted_list.insert(index,\
    \ x);\n55 | |             index += 2;\n56 | |         }\n   | |_________^ expected\
    \ struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n  \
    \         found unit type `()`\n\nerror: aborting due to 3 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l: Vec<isize>\
    \ = l;\n    for i in (0..l.len()).filter(|&x| x % 2 == 0) {\n        let mut l_odds:\
    \ Vec<isize> = l[i+1..].iter().filter(|&x| x % 2 == 1).cloned().collect();\n \
    \       l_odds.sort();\n        let mut l_evens: Vec<isize> = l[i+1..].iter().filter(|&x|\
    \ x % 2 == 0).cloned().collect();\n        l_evens.sort();\n        let mut l_odds_and_evens:\
    \ Vec<isize> = l_odds;\n        l_odds_and_evens.extend(l_evens);\n        l[i+1..].clone_from_slice(&l_odds_and_evens);\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 3, 2]`,\n right: `[1, 2, 3]`', /tmp/tmpl6taaprk.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut new_l = l.clone();\n\
    \    // split the vector into its even and odd indicies\n    let even_indices\
    \ = &new_l[1..(new_l.len() / 2) * 2];\n    let odd_indices = &new_l[(new_l.len()\
    \ / 2) * 2..];\n    // sort the even indicies\n    // note: must use .as_mut_slice()\
    \ to sort a vector\n    even_indices.as_mut_slice().sort();\n    // append the\
    \ two vectors\n    let new_l = even_indices.iter().chain(odd_indices.iter()).cloned().collect();\n\
    \    new_l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `as_mut_slice` found for reference `&[isize]`\
    \ in the current scope\n  --> /tmp/tmpipnj1t51.rs:15:18\n   |\n15 |     even_indices.as_mut_slice().sort();\n\
    \   |                  ^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `as_mut_ptr`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    // TODO: complete\
    \ this function so that it passes all tests below.\n    // You should remove the\
    \ \"unimplemented!\" call.\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpikhjy7nn.rs:11:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    if l.len() <= 1 {\n\
    \        return l;\n    }\n    let mut temp_l = l.clone();\n    let mut temp_l_len\
    \ = temp_l.len();\n    let mut temp_l_head = temp_l.remove(0);\n    let mut new_vec\
    \ = Vec::new();\n    if temp_l_len % 2 == 0 {\n        new_vec.push(temp_l_head);\n\
    \        new_vec.push(temp_l.remove(0));\n        temp_l_len -= 2;\n    } else\
    \ {\n        new_vec.push(temp_l_head);\n        temp_l_len -= 1;\n    }\n   \
    \ new_vec.append(&mut temp_l);\n    for i in 0..temp_l_len {\n        if i % 2\
    \ == 0 {\n            let temp_val = new_vec.remove(i);\n            new_vec.insert(new_vec.len()\
    \ - 1, temp_val);\n        }\n    }\n    let mut ret_vec = Vec::new();\n    if\
    \ l.len() % 2 == 0 {\n        ret_vec.push(new_vec.remove(0));\n        ret_vec.push(new_vec.remove(0));\n\
    \    } else {\n        ret_vec.push(new_vec.remove(0));\n    }\n    ret_vec.append(&mut\
    \ new_vec);\n    ret_vec\n}\n\nfn main() {\n    let candidate = sort_even;\n \
    \   assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1, 3]`,\n right: `[1, 2, 3]`', /tmp/tmp1yrm6mwm.rs:44:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut l_even = Vec::new();\n    let mut l_odd = Vec::new();\n    for i\
    \ in 0..l.len() {\n        if i % 2 == 0 {\n            l_even.push(l[i]);\n \
    \       } else {\n            l_odd.push(l[i]);\n        }\n    }\n    l_even.sort();\n\
    \    for i in 0..l_even.len() {\n        l[2 * i] = l_even[i];\n    }\n    for\
    \ i in 0..l_odd.len() {\n        l[2 * i + 1] = l_odd[i];\n    }\n    l\n}\n\n\
    fn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut result =\
    \ Vec::new();\n    for i in 0..l.len() {\n        if i % 2 == 0 {\n          \
    \  result.push(l[i]);\n        } else {\n            result.push(l[i]);\n    \
    \        result.sort();\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-5, -3, 0, 1, 2, 3, 3, 5, 9, 123, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpyn7zys35.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_new = l.clone();\n\
    \    let mut even_vec = Vec::new();\n    let mut odd_vec = Vec::new();\n    let\
    \ mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n            even_vec.push(l[i]);\n\
    \        } else {\n            odd_vec.push(l[i]);\n        }\n        i += 1;\n\
    \    }\n    even_vec.sort();\n    let mut l_new_even = even_vec.clone();\n   \
    \ let mut l_new_odd = odd_vec.clone();\n    l_new_even.append(&mut l_new_odd);\n\
    \    return l_new_even;\n}\n\nfn main() {\n    let candidate = sort_even;\n  \
    \  assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 3, 2]`,\n right: `[1, 2, 3]`', /tmp/tmpjxeexxx8.rs:30:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    // this could be\
    \ done a ton of ways:\n    // * if we start with l and make a new vector, we could\
    \ use a nested for loop and push the values in order\n    // * if we start with\
    \ l, we could use a nested for loop to find the smallest odd value and swap it\
    \ with the first even one, then continue to the second smallest odd value, and\
    \ swap it with the second even one, and so on\n    // * if we start with l, we\
    \ could use a nested for loop to find the smallest odd value and swap it with\
    \ the first even one, then continue to the second smallest odd value, and swap\
    \ it with the second even one, and so on\n    // * if we start with l, we could\
    \ just sort the even values and then swap the odd and even values\n    // * if\
    \ we start with l, we could use a nested for loop to find the smallest odd value\
    \ and swap it with the first even one, then continue to the second smallest odd\
    \ value, and swap it with the second even one, and so on\n    let mut evens =\
    \ Vec::new();\n    let mut odds = Vec::new();\n    let mut l_prime = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            odds.push(l[i]);\n\
    \        } else {\n            evens.push(l[i]);\n        }\n    }\n    evens.sort();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            l_prime.push(odds[i\
    \ / 2]);\n        } else {\n            l_prime.push(evens[i / 2]);\n        }\n\
    \    }\n    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 0, -5, 1, -3, 2, 9, 3, 123, 3, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpb6s592fb.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    if l.len() % 2 ==\
    \ 0 {\n        let mut v = l.clone();\n        let mut i = 0;\n        while i\
    \ < v.len() {\n            if i % 2 == 0 {\n                let t = v[i];\n  \
    \              v.remove(i);\n                v.insert(i, v[i + 1]);\n        \
    \        v.remove(i + 1);\n                v.insert(i + 1, t);\n            }\n\
    \            i += 1;\n        }\n        v\n    } else {\n        l\n    }\n}\n\
    \nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpveegmv86.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n  let even = l.iter().enumerate().filter(|(i,\
    \ _)| i % 2 == 0).map(|(_, i)| *i).collect::<Vec<isize>>();\n  let mut odd = l.iter().enumerate().filter(|(i,\
    \ _)| i % 2 == 1).map(|(_, i)| *i).collect::<Vec<isize>>();\n  odd.sort();\n \
    \ even.iter().enumerate().map(|(i, e)| {\n    if i < odd.len() {\n      vec![*e,\
    \ odd[i]]\n    } else {\n      vec![*e]\n    }\n  }).flatten().collect()\n}\n\n\
    fn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 0, -5, 1, -3, 2, 9, 3, 123, 3, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmprwhx8mmp.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut r = Vec::new();\n\
    \    let mut evens = l.iter().step_by(2).cloned().collect::<Vec<isize>>();\n \
    \   evens.sort();\n    r.extend(l.iter().step_by(2).cloned());\n    r.extend(evens);\n\
    \    r\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 3, 1, 3]`,\n right: `[1, 2, 3]`', /tmp/tmpol0vqib6.rs:19:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut v = l.clone();\n\
    \    for i in (1..v.len()).step_by(2) {\n        for j in i+1..v.len() {\n   \
    \         if v[j] < v[i] {\n                let t = v[i];\n                v[i]\
    \ = v[j];\n                v[j] = t;\n            }\n        }\n    }\n    v\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, -10, 3, -5, 2, -3, 9, 0, 123, 1, 3]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp3h6qwzbc.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut new_l = Vec::new();\n\
    \    let mut even_nums = Vec::new();\n    let mut odd_nums = Vec::new();\n   \
    \ for (index, element) in l.iter().enumerate() {\n        if index % 2 == 0 {\n\
    \            odd_nums.push(*element);\n        } else {\n            even_nums.push(*element);\n\
    \        }\n    }\n    even_nums.sort();\n    for (index, element) in l.iter().enumerate()\
    \ {\n        if index % 2 == 0 {\n            new_l.push(*element);\n        }\
    \ else {\n            new_l.push(even_nums.pop().unwrap());\n        }\n    }\n\
    \    new_l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 3, -3, 2, 9, 1, 123, 0, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmppnkxlbbi.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    // type annotations\
    \ should be avoided if you can infer types instead\n    let mut result: Vec<isize>\
    \ = vec![];\n    let mut evens: Vec<isize> = vec![];\n    let mut odds: Vec<isize>\
    \ = vec![];\n    let mut sort_list: Vec<isize> = vec![];\n    let mut odd_index:\
    \ usize = 0;\n    let mut even_index: usize = 0;\n    let mut sort_index: usize\
    \ = 0;\n    let mut i: usize = 0;\n    // It's considered good practice to use\
    \ `if let` instead of `match` when you're only\n    // checking for one match\
    \ or you don't need `_` for a catch-all case\n    for j in l {\n        if i %\
    \ 2 == 0 {\n            evens.push(j);\n        } else {\n            odds.push(j);\n\
    \        }\n        i += 1;\n    }\n    evens.sort();\n    while odd_index < odds.len()\
    \ && even_index < evens.len() {\n        if odd_index % 2 == 0 {\n           \
    \ sort_list.push(evens[even_index]);\n            even_index += 1;\n        }\
    \ else {\n            sort_list.push(odds[odd_index]);\n            odd_index\
    \ += 1;\n        }\n        sort_index += 1;\n    }\n    while odd_index < odds.len()\
    \ {\n        sort_list.push(odds[odd_index]);\n        odd_index += 1;\n    }\n\
    \    while even_index < evens.len() {\n        sort_list.push(evens[even_index]);\n\
    \        even_index += 1;\n    }\n    result = sort_list;\n    result\n}\n\nfn\
    \ main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2,\
    \ 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0,\
    \ 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 3, 2]`,\n right: `[1, 2, 3]`', /tmp/tmpdhom5hah.rs:53:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    assert!(l.len() >=\
    \ 1);\n    let mut mut_l = l.clone();\n    if l.len() == 1 {\n        return mut_l;\n\
    \    }\n    mut_l[1] = ord_two(mut_l[0], mut_l[1]);\n    mut_l = sort_even(mut_l);\n\
    \    let mut count = 2;\n    while count < l.len() {\n        if count % 2 ==\
    \ 0 {\n            mut_l[count] = ord_two(mut_l[count - 1], mut_l[count]);\n \
    \       }\n        count += 1;\n    }\n    mut_l\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `ord_two` in this scope\n  --> /tmp/tmpedw_h3qs.rs:14:16\n\
    \   |\n14 |     mut_l[1] = ord_two(mut_l[0], mut_l[1]);\n   |                ^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `ord_two` in this\
    \ scope\n  --> /tmp/tmpedw_h3qs.rs:19:28\n   |\n19 |             mut_l[count]\
    \ = ord_two(mut_l[count - 1], mut_l[count]);\n   |                           \
    \ ^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let len = l.len();\n\
    \    if len <= 1 {\n        return l;\n    }\n\n    let mut res = Vec::with_capacity(len);\n\
    \    for i in 0..len {\n        if i % 2 == 0 {\n            res.push(l[i]);\n\
    \        } else {\n            let mut copy = l[i..].to_vec();\n            copy.sort();\n\
    \            res.append(&mut copy);\n            break;\n        }\n    }\n  \
    \  res\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, -10, -5, -3, 0, 1, 2, 3, 3, 9, 123]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpo6mvfduv.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    if l.len() == 0 {\n\
    \        return l;\n    }\n    else {\n        let mut a = Vec::new();\n     \
    \   let mut b = Vec::new();\n        let mut l_even = Vec::new();\n        let\
    \ mut l_odd = Vec::new();\n        // a is even indicies, b is odd\n        for\
    \ i in 0..l.len() {\n            if i % 2 == 0 {\n                a.push(l[i]);\n\
    \            }\n            else {\n                b.push(l[i]);\n          \
    \  }\n        }\n        a.sort();\n        // combine a and b\n        for i\
    \ in 0..a.len() {\n            l_even.push(a[i]);\n            l_even.push(b[i]);\n\
    \        }\n        return l_even;\n    }\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmpisora1ch.rs:16:25\n\
    \   |\n16 |         let mut l_odd = Vec::new();\n   |             ---------  \
    \ ^^^^^^^^ cannot infer type for type parameter `T`\n   |             |\n   |\
    \             consider giving `l_odd` the explicit type `Vec<T>`, where the type\
    \ parameter `T` is specified\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l: Vec<isize>\
    \ = l;\n    let mut even_sorted = Vec::new();\n    for x in 0..l.len() {\n   \
    \     if x % 2 == 0 {\n            even_sorted.push(l[x]);\n        }\n    }\n\
    \    even_sorted.sort();\n    for x in 0..l.len() {\n        if x % 2 == 0 {\n\
    \            l[x] = even_sorted[x / 2];\n        }\n    }\n    l\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut vec = l.clone();\n\
    \    let mut sorted = true;\n    for x in 0..vec.len()-1 {\n        if vec[x]\
    \ > vec[x+1] {\n            sorted = false;\n        }\n    }\n    if sorted {\n\
    \        return vec;\n    }\n    for x in 0..vec.len()-1 {\n        if vec[x]\
    \ > vec[x+1] {\n            vec[x] += vec[x+1];\n            vec[x+1] = vec[x]\
    \ - vec[x+1];\n            vec[x] -= vec[x+1];\n        }\n    }\n    vec\n}\n\
    \nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, -5, 2, -3, 3, 5, 0, 9, 1, -10, 123]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpc4nrhykg.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    if l.len() < 2 {\n\
    \        return l;\n    }\n    let mut evens = Vec::new();\n    let mut odds =\
    \ Vec::new();\n    for i in 0..l.len() {\n        if i % 2 == 0 {\n          \
    \  odds.push(l[i]);\n        } else {\n            evens.push(l[i]);\n       \
    \ }\n    }\n    evens.sort();\n    let mut new_list = Vec::new();\n    for i in\
    \ 0..odds.len() {\n        new_list.push(odds[i]);\n        new_list.push(evens[i]);\n\
    \    }\n    new_list\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 1 but the index\
    \ is 1', /tmp/tmptn4g404h.rs:25:23\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    if l.len() < 2 {\n\
    \        return l;\n    }\n    let mut odds = Vec::new();\n    let mut evens =\
    \ Vec::new();\n    for (i, val) in l.iter().enumerate() {\n        if i % 2 ==\
    \ 0 {\n            odds.push(*val);\n        } else {\n            evens.push(*val);\n\
    \        }\n    }\n    let mut sorted_evens = evens.clone();\n    sorted_evens.sort();\n\
    \    let mut sorted_list = Vec::new();\n    for (i, val) in odds.iter().enumerate()\
    \ {\n        sorted_list.push(*val);\n        sorted_list.push(sorted_evens[i]);\n\
    \    }\n    return sorted_list;\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 1 but the index\
    \ is 1', /tmp/tmp_xgo1scg.rs:26:26\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut result =\
    \ l.clone();\n    let len = l.len();\n    let mut i = 1;\n    while i < len {\n\
    \        let mut j = i;\n        while j > 0 && result[j - 1] > result[j] {\n\
    \            result.swap(j - 1, j);\n            j -= 1;\n        }\n        i\
    \ += 2;\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 5, -5, 2, -3, 0, 1, 3, 9, 123, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp_urrjxnh.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut vec = l.clone();\n\
    \    let len = vec.len();\n    let mut i = 1;\n    while i < len {\n        if\
    \ len % 2 == 0 {\n            if i == len - 1 {\n                break;\n    \
    \        }\n        }\n        let num = vec[i];\n        if num < vec[i - 1]\
    \ {\n            vec[i] = vec[i - 1];\n            vec[i - 1] = num;\n       \
    \     i -= 2;\n            if i < 0 {\n                i = 1;\n            }\n\
    \        } else {\n            i += 2;\n        }\n    }\n    vec\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpp9vd62gb.rs:22:13\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_new = Vec::new();\n\
    \    for index in 0..l.len() {\n        if index % 2 == 0 {\n            l_new.push(l[index]);\n\
    \        } else {\n            let mut slice = l[index-1..index+1].to_vec();\n\
    \            slice.sort();\n            l_new.push(slice[0]);\n            l_new.push(slice[1]);\n\
    \        }\n    }\n    l_new\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 2, 3]`,\n right: `[1, 2, 3]`', /tmp/tmp31mxfhvx.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut last_even\
    \ = false;\n    let mut l_even_sorted = vec![];\n    let mut l_odd = vec![];\n\
    \    for item in l {\n        if last_even {\n            l_even_sorted.push(item);\n\
    \        } else {\n            l_odd.push(item);\n        }\n        last_even\
    \ = !last_even;\n    }\n    l_even_sorted.sort();\n    l_even_sorted.into_iter().chain(l_odd.into_iter()).collect()\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1, 3]`,\n right: `[1, 2, 3]`', /tmp/tmpl6sfw6s1.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut res: Vec<isize>\
    \ = vec![];\n    for i in 0..l.len() {\n        if i % 2 == 0 {\n            res.push(l[i]);\n\
    \        } else {\n            res.push(\n                l[i]\n             \
    \       .clone()\n                    .to_string()\n                    .chars()\n\
    \                    .map(|x| x.to_digit(10).unwrap() as isize)\n            \
    \        .collect::<Vec<isize>>()\n                    .sort_by(|a, b| b.cmp(a))\n\
    \                    .iter()\n                    .map(|x| x.to_string())\n  \
    \                  .collect::<String>()\n                    .parse::<isize>()\n\
    \                    .unwrap(),\n            );\n        }\n    }\n    res\n}\n\
    \nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for unit type `()` in the current\
    \ scope\n  --> /tmp/tmpjeras_pw.rs:22:22\n   |\n22 |                     .iter()\n\
    \   |                      ^^^^ method not found in `()`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    l.iter().zip(0..).map(|(val,\
    \ i)| {\n        if i % 2 == 0 {\n            *val\n        } else {\n       \
    \     let mut copied = l.clone();\n            copied.sort();\n            copied[i\
    \ / 2]\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 3]`,\n right: `[1, 2, 3]`', /tmp/tmp4cd_8gfo.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_prime =\
    \ Vec::new();\n    let mut even_indicies = Vec::new();\n    let mut odd_indicies\
    \ = Vec::new();\n    for i in 0..l.len() {\n        if i % 2 == 0 {\n        \
    \    odd_indicies.push(l[i]);\n        } else {\n            even_indicies.push(l[i]);\n\
    \        }\n    }\n    even_indicies.sort();\n    for i in 0..l.len() {\n    \
    \    if i % 2 == 0 {\n            l_prime.push(odd_indicies[i/2]);\n        }\
    \ else {\n            l_prime.push(even_indicies[i/2]);\n        }\n    }\n  \
    \  l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 0, -5, 1, -3, 2, 9, 3, 123, 3, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp9aw3qumu.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_even: Vec<isize>\
    \ = Vec::new();\n    let mut l_odd: Vec<isize> = Vec::new();\n    for (i, elem)\
    \ in l.iter().enumerate() {\n        if i % 2 == 0 {\n            l_even.push(*elem);\n\
    \        } else {\n            l_odd.push(*elem);\n        }\n    }\n    l_even.sort();\n\
    \    let mut l_new: Vec<isize> = Vec::new();\n    for (elem_even, elem_odd) in\
    \ l_even.iter().zip(l_odd.iter()) {\n        l_new.push(*elem_even);\n       \
    \ l_new.push(*elem_odd);\n    }\n    l_new\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2]`,\n right: `[1, 2, 3]`', /tmp/tmp0_boudu0.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut evens = Vec::new();\n\
    \    let mut odds = Vec::new();\n    for (i, v) in l.iter().enumerate() {\n  \
    \      if i % 2 == 0 {\n            odds.push(*v);\n        } else {\n       \
    \     evens.push(*v);\n        }\n    }\n    evens.sort();\n    let mut l = Vec::new();\n\
    \    for (i, v) in odds.iter().enumerate() {\n        l.push(*v);\n        l.push(evens[i]);\n\
    \    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 1 but the index\
    \ is 1', /tmp/tmpd_x4rz91.rs:22:16\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut new_l = Vec::new();\n\
    \    for (index, value) in l.iter().enumerate() {\n        if index % 2 == 0 {\n\
    \            new_l.push(*value);\n        } else {\n            new_l.push(*value);\n\
    \            new_l.sort();\n        }\n    }\n    new_l\n}\n\nfn main() {\n  \
    \  let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-5, -3, 0, 1, 2, 3, 3, 5, 9, 123, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpncnwlwoz.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    if l.len() <= 1 {\n\
    \        return l;\n    }\n    let mut ret = Vec::new();\n    let mut evens =\
    \ Vec::new();\n    for i in 0..l.len() {\n        if i % 2 == 0 {\n          \
    \  ret.push(l[i]);\n        } else {\n            evens.push(l[i]);\n        }\n\
    \    }\n    evens.sort();\n    for i in 0..evens.len() {\n        ret.insert(i\
    \ * 2 + 1, evens[i]);\n    }\n    ret\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 0, -5, 1, -3, 2, 9, 3, 123, 3, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp1yz_v06i.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    l.into_iter().enumerate().map(|(i,\
    \ x)| if i % 2 == 0 { x } else { sorted_even(l.clone(), i) }).collect()\n}\n\n\
    fn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sorted_even` in this scope\n --> /tmp/tmpwtzcq68b.rs:9:71\n\
    \  |\n9 |     l.into_iter().enumerate().map(|(i, x)| if i % 2 == 0 { x } else\
    \ { sorted_even(l.clone(), i) }).collect()\n  |                              \
    \                                         ^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let evens = l.iter().enumerate().filter(|&(i,\
    \ _)| i % 2 == 0).map(|(_, &x)| x).collect::<Vec<isize>>();\n    let odds = l.iter().enumerate().filter(|&(i,\
    \ _)| i % 2 == 1).map(|(_, &x)| x).collect::<Vec<isize>>();\n    let mut evens\
    \ = evens.clone();\n    evens.sort();\n    let mut result = Vec::with_capacity(l.len());\n\
    \    for ((&x, &y), &z) in odds.iter().zip(evens.iter()).zip(evens.iter()) {\n\
    \        result.push(x);\n        result.push(y);\n        result.push(z);\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1, 1]`,\n right: `[1, 2, 3]`', /tmp/tmpep2vqpah.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut veclist =\
    \ l.clone();\n    let mut slicelist: &mut [isize] = &mut veclist[..];\n    slicelist[1..].sort();\n\
    \    veclist\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, -10, -5, -3, 0, 1, 2, 3, 3, 9, 123]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp21mr0ohw.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut a: Vec<isize>\
    \ = Vec::new();\n    let mut b: Vec<isize> = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            a.push(l[i]);\n        } else {\n  \
    \          b.push(l[i]);\n        }\n    }\n    b.sort();\n    let mut c: Vec<isize>\
    \ = Vec::new();\n    for i in 0..a.len() {\n        c.push(a[i]);\n        c.push(b[i]);\n\
    \    }\n    c\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 1 but the index\
    \ is 1', /tmp/tmpbsqr3zgj.rs:22:16\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut even_list\
    \ = Vec::new();\n    let mut odd_list = Vec::new();\n    let mut result = Vec::new();\n\
    \    for (i, item) in l.iter().enumerate() {\n        if i % 2 == 0 {\n      \
    \      odd_list.push(*item);\n        } else {\n            even_list.push(*item);\n\
    \        }\n    }\n    even_list.sort();\n    for (i, item) in l.iter().enumerate()\
    \ {\n        if i % 2 == 0 {\n            result.push(*item);\n        } else\
    \ {\n            result.push(even_list.remove(0));\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 0, -5, 1, -3, 2, 9, 3, 123, 3, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpwprp2wbj.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut result =\
    \ Vec::new();\n    let len = l.len();\n    for i in 0..len {\n        if i % 2\
    \ == 0 {\n            result.push(l[i]);\n        } else {\n            result.push(l[i]);\n\
    \            result.sort();\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-5, -3, 0, 1, 2, 3, 3, 5, 9, 123, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp5saopq0r.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut even_sorted:\
    \ Vec<isize> = Vec::new();\n    for i in 1..l.len() {\n        even_sorted.push(l[i]);\n\
    \    }\n    even_sorted.sort();\n    let mut res: Vec<isize> = Vec::new();\n \
    \   for i in 0..l.len() {\n        if i % 2 == 0 {\n            res.push(l[i]);\n\
    \        } else {\n            res.push(even_sorted[i / 2]);\n        }\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, -10, -5, -5, -3, -3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3,\
    \ 3, 5, 0, 9, 1, 123]`', /tmp/tmpwagdz6t0.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpddychyts.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut sorted = false;\n    let mut count = 0;\n    while !sorted {\n  \
    \      sorted = true;\n        let mut i = 0;\n        while i < l.len() - 1 {\n\
    \            if i % 2 == 0 && l[i] > l[i + 1] {\n                l.swap(i, i +\
    \ 1);\n                sorted = false;\n            }\n            i += 1;\n \
    \       }\n        count += 1;\n    }\n    l\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 5, -5, 2, -3, 3, 0, 9, 1, 123, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpk4zzkz0i.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut result: Vec<isize>\
    \ = Vec::new();\n    let mut i = 0;\n    while i < l.len() {\n        if i % 2\
    \ == 0 {\n            result.push(l[i]);\n        } else {\n            result.push(sublist(&l,\
    \ i).sort().nth(i / 2).unwrap());\n        }\n        i += 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sublist` in this scope\n  --> /tmp/tmpa0hyharl.rs:15:25\n\
    \   |\n15 |             result.push(sublist(&l, i).sort().nth(i / 2).unwrap());\n\
    \   |                         ^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even = Vec::new();\n    let mut odd = Vec::new();\n    for (i, n)\
    \ in l.iter().enumerate() {\n        if i % 2 == 0 {\n            even.push(*n);\n\
    \        } else {\n            odd.push(*n);\n        }\n    }\n    even.sort();\n\
    \    for (i, n) in even.iter().enumerate() {\n        l[i * 2] = *n;\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even_indicies = Vec::new();\n    let mut odd_indicies = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            even_indicies.push(l[i]);\n\
    \        } else {\n            odd_indicies.push(l[i]);\n        }\n    }\n  \
    \  even_indicies.sort();\n    let mut result = Vec::new();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            result.push(even_indicies[i / 2]);\n\
    \        } else {\n            result.push(odd_indicies[i / 2]);\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut ret = Vec::new();\n\
    \    let mut even = l.iter().enumerate().filter(|(i, _)| i % 2 == 0).map(|(_,\
    \ x)| *x).collect::<Vec<isize>>();\n    even.sort();\n    for (index, x) in l.iter().enumerate()\
    \ {\n        ret.push(if index % 2 == 0 { even.remove(0) } else { *x });\n   \
    \ }\n    ret\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpu2uh3a46.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut list = l;\n\
    \    let (even, odd) = split_odd_even(&mut list);\n    merge_sort(&mut even);\n\
    \    let mut ret: Vec<isize> = Vec::new();\n    ret.push(odd[0]);\n    for i in\
    \ 0..even.len() {\n        ret.push(even[i]);\n        ret.push(odd[i + 1]);\n\
    \    }\n    ret\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `split_odd_even` in this scope\n  -->\
    \ /tmp/tmpdlim5wms.rs:10:23\n   |\n10 |     let (even, odd) = split_odd_even(&mut\
    \ list);\n   |                       ^^^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `merge_sort` in this scope\n  --> /tmp/tmpdlim5wms.rs:11:5\n\
    \   |\n11 |     merge_sort(&mut even);\n   |     ^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut newl = Vec::new();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            newl.push(l[i]);\n\
    \        } else {\n            let mut temp = l[i];\n            for j in (0..i).rev()\
    \ {\n                if l[j] < temp {\n                    break;\n          \
    \      }\n                newl.push(l[j]);\n                newl.swap_remove(j);\n\
    \            }\n            newl.push(temp);\n        }\n    }\n    newl\n}\n\n\
    fn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp5e8gs5xh.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut vec: Vec<isize>\
    \ = Vec::new();\n    for item in l.into_iter() {\n        vec.push(item);\n  \
    \  }\n    for i in 1..vec.len() {\n        if i % 2 == 0 {\n            vec[i]\
    \ = vec[i - 1];\n        }\n    }\n    vec\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 2]`,\n right: `[1, 2, 3]`', /tmp/tmp_9xrqgm7.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    // Start by sorting\
    \ the even indicies\n    let mut sorted_l = Vec::new();\n    for (i, elem) in\
    \ l.iter().enumerate() {\n        if i % 2 == 0 {\n            sorted_l.push(*elem);\n\
    \        }\n    }\n    sorted_l.sort();\n\n    // Now insert the unsorted odd\
    \ indicies\n    let mut ret = Vec::new();\n    for (i, elem) in l.iter().enumerate()\
    \ {\n        if i % 2 == 0 {\n            ret.push(sorted_l.remove(0));\n    \
    \    } else {\n            ret.push(*elem);\n        }\n    }\n    ret\n}\n\n\
    fn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut xs = Vec::new();\n\
    \    for (i, y) in l.iter().enumerate() {\n        if i % 2 == 0 {\n         \
    \   xs.push(*y);\n        }\n    }\n    xs.sort();\n    let mut ret = Vec::new();\n\
    \    for (i, y) in l.iter().enumerate() {\n        if i % 2 == 0 {\n         \
    \   ret.push(xs.pop().unwrap());\n        } else {\n            ret.push(*y);\n\
    \        }\n    }\n    ret\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 2, 1]`,\n right: `[1, 2, 3]`', /tmp/tmpeu3phs2a.rs:29:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut ret = Vec::new();\n\
    \    let mut copy = l.clone();\n    copy.sort();\n    let mut i = 0;\n    while\
    \ i < l.len() {\n        if i % 2 == 0 {\n            ret.push(l[i]);\n      \
    \  } else {\n            ret.push(copy[i]);\n        }\n        i += 1;\n    }\n\
    \    ret\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, -5, -5, 0, -3, 2, 9, 3, 123, 9, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpwz6bw9gl.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut result: Vec<isize>\
    \ = Vec::new();\n    let mut i = 0;\n    while i < l.len() {\n        if i % 2\
    \ == 0 {\n            result.push(l[i]);\n        } else {\n            let mut\
    \ tmp: Vec<isize> = Vec::new();\n            for index in i..l.len() {\n     \
    \           tmp.push(l[index]);\n            }\n            tmp.sort();\n    \
    \        for value in tmp {\n                result.push(value);\n           \
    \ }\n            break;\n        }\n        i += 1;\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, -10, -5, -3, 0, 1, 2, 3, 3, 9, 123]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpzjlo7fmb.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    for i in (0..l.len()).step_by(2) {\n        l[i..i+2].sort();\n    }\n  \
    \  l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 4 out of range for slice of\
    \ length 3', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut a = vec![];\n\
    \    let mut b = vec![];\n    for i in 0..l.len() {\n        if i % 2 == 0 {\n\
    \            a.push(l[i]);\n        } else {\n            b.push(l[i]);\n    \
    \    }\n    }\n    let mut c = a.clone();\n    c.append(&mut b);\n    c\n}\n\n\
    fn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 3, 2]`,\n right: `[1, 2, 3]`', /tmp/tmpgdahg_4k.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut even_nums\
    \ = Vec::new();\n    let mut i = 0;\n    while i < l.len() {\n        even_nums.push(l[i]);\n\
    \        i += 2;\n    }\n    even_nums.sort();\n    let mut l_prime = Vec::new();\n\
    \    i = 0;\n    let mut j = 0;\n    while i < l.len() {\n        l_prime.push(l[i]);\n\
    \        i += 1;\n        if i < l.len() {\n            l_prime.push(even_nums[j]);\n\
    \            j += 1;\n            i += 1;\n        }\n    }\n    l_prime\n}\n\n\
    fn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 3]`,\n right: `[1, 2, 3]`', /tmp/tmps5ww_myg.rs:33:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut even_list\
    \ = Vec::new();\n    let mut odd_list = Vec::new();\n    let mut final_list =\
    \ Vec::new();\n    for index in 0..l.len() {\n        if index % 2 == 0 {\n  \
    \          even_list.push(l[index]);\n        } else {\n            odd_list.push(l[index]);\n\
    \        }\n    }\n    even_list.sort();\n    for index in 0..l.len() {\n    \
    \    if index % 2 == 0 {\n            final_list.push(even_list[index / 2]);\n\
    \        } else {\n            final_list.push(odd_list[index / 2]);\n       \
    \ }\n    }\n    final_list\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut l_sorted = l.clone();\n    l_sorted.sort();\n    let mut result =\
    \ Vec::new();\n    for i in 0..l.len() {\n        if i % 2 == 0 {\n          \
    \  result.push(l[i]);\n        } else {\n            result.push(l_sorted[i]);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, -5, -5, 0, -3, 2, 9, 3, 123, 9, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp0hr5gxn3.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut new_l: Vec<isize>\
    \ = Vec::new();\n    let mut even_indices: Vec<isize> = Vec::new();\n    let mut\
    \ odd_indices: Vec<isize> = Vec::new();\n    let mut i = 0;\n    while i < l.len()\
    \ {\n        if i % 2 == 0 {\n            even_indices.push(l[i]);\n        }\
    \ else {\n            odd_indices.push(l[i]);\n        }\n        i += 1;\n  \
    \  }\n    even_indices.sort();\n    let mut j = 0;\n    let mut k = 0;\n    while\
    \ j < odd_indices.len() && k < even_indices.len() {\n        new_l.push(odd_indices[j]);\n\
    \        new_l.push(even_indices[k]);\n        j += 1;\n        k += 1;\n    }\n\
    \    new_l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1]`,\n right: `[1, 2, 3]`', /tmp/tmpt7y361qo.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_vec: Vec<isize>\
    \ = Vec::new();\n    for x in 0..l.len() {\n        if x % 2 == 0 {\n        \
    \    l_vec.push(l[x]);\n        } else {\n            let mut l_sub_vec: Vec<isize>\
    \ = Vec::new();\n            for y in 0..x {\n                if y % 2 == 0 {\n\
    \                    l_sub_vec.push(l[y]);\n                }\n            }\n\
    \            l_sub_vec.sort();\n            for z in 0..l_sub_vec.len() {\n  \
    \              l_vec.push(l_sub_vec[z]);\n            }\n            l_vec.push(l[x]);\n\
    \        }\n    }\n    l_vec\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 2, 3]`,\n right: `[1, 2, 3]`', /tmp/tmpv5902d9e.rs:32:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    // TODO: replace\
    \ 0 with your implementation\n\n    return vec![];\n}\n\nfn main() {\n    let\
    \ candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 2, 3]`', /tmp/tmp7ln9mc8t.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_prime =\
    \ l.clone();\n    for i in 1..l.len() {\n        if i % 2 == 0 {\n           \
    \ let v: Vec<_> = l_prime.iter().enumerate().filter(|&(j, _)| j % 2 == 0).map(|(_,\
    \ v)| *v).collect();\n            let mut v_prime: Vec<_> = v.clone();\n     \
    \       v_prime.sort();\n            for j in 0..v.len() {\n                l_prime[2\
    \ * j] = v_prime[j];\n            }\n        }\n    }\n    l_prime\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    let mut x = 0;\n    let mut y = 0;\n    while i < l.len()\
    \ {\n        if i % 2 == 0 {\n            x = l[i];\n            y = l[i + 1];\n\
    \            if x > y {\n                l[i] = y;\n                l[i + 1] =\
    \ x;\n            }\n        }\n        i += 1;\n    }\n    l\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 3 but the index\
    \ is 3', /tmp/tmphxibcpbd.rs:16:17\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    return map_each_even(l,\
    \ |l| l.sort());\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `map_each_even` in this scope\n -->\
    \ /tmp/tmpbknlz3yz.rs:9:12\n  |\n9 |     return map_each_even(l, |l| l.sort());\n\
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut even = Vec::new();\n\
    \    let mut odd = Vec::new();\n    for i in l {\n        if i % 2 == 0 {\n  \
    \          even.push(i);\n        } else {\n            odd.push(i);\n       \
    \ }\n    }\n    let mut res = Vec::new();\n    even.sort();\n    for i in 0..l.len()\
    \ {\n        if i % 2 == 0 {\n            res.push(odd[i / 2]);\n        } else\
    \ {\n            res.push(even[i / 2]);\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmpcae21uwn.rs:20:17\n\
    \    |\n8   | fn sort_even(l: Vec<isize>) -> Vec<isize> {\n    |             \
    \ - move occurs because `l` has type `Vec<isize>`, which does not implement the\
    \ `Copy` trait\n...\n11  |     for i in l {\n    |              - `l` moved due\
    \ to this implicit call to `.into_iter()`\n...\n20  |     for i in 0..l.len()\
    \ {\n    |                 ^^^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `l`\nhelp:\
    \ consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n11  |     for i in &l {\n    |              +\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut s = l.clone();\n\
    \    let (l, r) = s.split_at_mut(2);\n    l.reverse();\n    r.reverse();\n   \
    \ l.append(r);\n    l.reverse();\n    l.to_vec()\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `append` found for mutable reference `&mut\
    \ [isize]` in the current scope\n  --> /tmp/tmp6w15zwya.rs:13:7\n   |\n13 |  \
    \   l.append(r);\n   |       ^^^^^^ method not found in `&mut [isize]`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    // YOUR CODE HERE\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpp90xgd9o.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let odds: Vec<isize>\
    \ = l.iter().enumerate().filter(|&(i, _)| i % 2 == 1).map(|(_, x)| *x).collect();\n\
    \    let evens: Vec<isize> = l.iter().enumerate().filter(|&(i, _)| i % 2 == 0).map(|(_,\
    \ x)| *x).collect();\n    let mut evens_sorted = evens.clone();\n    evens_sorted.sort();\n\
    \    let mut l_prime: Vec<isize> = vec![];\n    for i in 0..odds.len() {\n   \
    \     l_prime.push(odds[i]);\n        l_prime.push(evens_sorted[i]);\n    }\n\
    \    l_prime\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1]`,\n right: `[1, 2, 3]`', /tmp/tmpm2mn5sbc.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_cpy = l.clone();\n\
    \    // Even indicies\n    let even_indicies: Vec<usize> = (0..l.len()).step_by(2).collect();\n\
    \    // Sorted values in even indicies\n    let even_indicies_sorted: Vec<isize>\
    \ = even_indicies.iter().map(|&idx| l[idx]).sorted().collect();\n    // Replace\
    \ the values in the even indicies with the sorted values\n    for (i, &idx) in\
    \ even_indicies.iter().enumerate() {\n        l_cpy[idx] = even_indicies_sorted[i];\n\
    \    }\n    l_cpy\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sorted` found for struct `Map` in the current\
    \ scope\n  --> /tmp/tmpg22v9xhj.rs:13:84\n   |\n13 |     let even_indicies_sorted:\
    \ Vec<isize> = even_indicies.iter().map(|&idx| l[idx]).sorted().collect();\n \
    \  |                                                                         \
    \           ^^^^^^ method not found in `Map<std::slice::Iter<'_, usize>, [closure@/tmp/tmpg22v9xhj.rs:13:69:\
    \ 13:82]>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut v = l.clone();\n\
    \    let mut k: usize = 1;\n    while k < v.len() {\n        if v[k] < v[k - 1]\
    \ {\n            v.swap(k, k - 1);\n            k = 1;\n        } else {\n   \
    \         k += 2;\n        }\n    }\n    v\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[3, 5, -5, 2, -3, 3, 0, 9, 1, 123, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp3254i3a5.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l2 = Vec::new();\n\
    \    let mut l_even = Vec::new();\n    let mut l_odd = Vec::new();\n    for i\
    \ in 0..l.len() {\n        if i % 2 == 0 {\n            l_even.push(l[i]);\n \
    \       } else {\n            l_odd.push(l[i]);\n        }\n    }\n    l_even.sort();\n\
    \    for i in 0..l.len() {\n        if i % 2 == 0 {\n            l2.push(l_even[i\
    \ / 2]);\n        } else {\n            l2.push(l_odd[i / 2]);\n        }\n  \
    \  }\n    l2\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmps70si9on.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    if l.len() == 0 {\n\
    \        return vec![];\n    }\n    let even_sorted = {\n        let mut even\
    \ = l.clone();\n        even.retain(|x| x % 2 == 0);\n        even.sort();\n \
    \       even\n    };\n    let mut l = l;\n    let mut i = 0;\n    let mut j =\
    \ 0;\n    while i < l.len() {\n        if l[i] % 2 == 0 {\n            l[i] =\
    \ even_sorted[j];\n            j += 1;\n        }\n        i += 1;\n    }\n  \
    \  l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, -10, -3, 3, 9, 0, 123, 1, 2]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp6qsd8aom.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let (mut even, mut\
    \ odd) = split_even_odd(&l);\n    even.sort();\n    merge_even_odd(&even, &odd)\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `split_even_odd` in this scope\n -->\
    \ /tmp/tmppimswgx0.rs:9:31\n  |\n9 |     let (mut even, mut odd) = split_even_odd(&l);\n\
    \  |                               ^^^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `merge_even_odd` in this scope\n  --> /tmp/tmppimswgx0.rs:11:5\n\
    \   |\n11 |     merge_even_odd(&even, &odd)\n   |     ^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut evens = Vec::new();\n\
    \    let mut odds = Vec::new();\n    for (i, n) in l.iter().enumerate() {\n  \
    \      if i % 2 == 0 {\n            odds.push(*n);\n        } else {\n       \
    \     evens.push(*n);\n        }\n    }\n    evens.sort();\n    for (i, n) in\
    \ odds.iter().enumerate() {\n        evens.insert(i * 2, *n);\n    }\n    evens\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 0, -5, 1, -3, 2, 9, 3, 123, 3, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmp8j4myw0v.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut v = l.clone();\n\
    \    let mut i = 0;\n    while i < v.len() {\n        if i % 2 == 0 {\n      \
    \      let mut c = 0;\n            while c < v.len() {\n                if v[c]\
    \ > v[i] {\n                    v.swap(c, i);\n                }\n           \
    \     c += 1;\n            }\n        }\n        i += 1;\n    }\n    v\n}\n\n\
    fn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1, 3]`,\n right: `[1, 2, 3]`', /tmp/tmp8d4t201b.rs:28:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n  let n = l.len();\n\
    \  let mut r = Vec::new();\n  for i in 0..n {\n    let i_is_even = i % 2 == 0;\n\
    \    let i_is_odd = i % 2 == 1;\n    if i_is_even {\n      r.push(l[i]);\n   \
    \ } else if i_is_odd {\n      r.push(l[i]);\n    }\n  }\n  r\n}\n\nfn main() {\n\
    \    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpvo5u2qjg.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let odd_indicies\
    \ = l.iter().enumerate().filter(|&(i, _)| i % 2 == 1).map(|(_, x)| x);\n    let\
    \ even_indicies = l.iter().enumerate().filter(|&(i, _)| i % 2 == 0).map(|(_, x)|\
    \ x);\n    let sorted_even_indicies = even_indicies.clone().collect::<Vec<_>>().sort();\n\
    \    let sorted_even_indicies = sorted_even_indicies.iter().map(|&x| x);\n   \
    \ let result: Vec<isize> = odd_indicies.zip(sorted_even_indicies).flat_map(|(x,\
    \ y)| vec![x, y]).collect();\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for unit type `()` in the current\
    \ scope\n  --> /tmp/tmp5fcrlr83.rs:12:53\n   |\n12 |     let sorted_even_indicies\
    \ = sorted_even_indicies.iter().map(|&x| x);\n   |                           \
    \                          ^^^^ method not found in `()`\n\nerror[E0277]: a value\
    \ of type `Vec<isize>` cannot be built from an iterator over elements of type\
    \ `&isize`\n    --> /tmp/tmp5fcrlr83.rs:13:99\n     |\n13   |     let result:\
    \ Vec<isize> = odd_indicies.zip(sorted_even_indicies).flat_map(|(x, y)| vec![x,\
    \ y]).collect();\n     |                                                     \
    \                                              ^^^^^^^ value of type `Vec<isize>`\
    \ cannot be built from `std::iter::Iterator<Item=&isize>`\n     |\n     = help:\
    \ the trait `FromIterator<&isize>` is not implemented for `Vec<isize>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut r = Vec::new();\n\
    \    let mut l = l;\n    let mut i = 0;\n    while i < l.len() {\n        let\
    \ o = l.split_off(i);\n        let mut o = o;\n        let n = l.pop().unwrap();\n\
    \        let mut even = l.clone();\n        even.sort();\n        l.push(n);\n\
    \        l.append(&mut even);\n        l.append(&mut o);\n        i += 2;\n  \
    \  }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n --> /tmp/tmp2cg3gzer.rs:9:17\n\
    \  |\n9 |     let mut r = Vec::new();\n  |         -----   ^^^^^^^^ cannot infer\
    \ type for type parameter `T`\n  |         |\n  |         consider giving `r`\
    \ the explicit type `Vec<T>`, where the type parameter `T` is specified\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut evens = Vec::new();\n\
    \    let mut odds = Vec::new();\n    for (i, x) in l.iter().enumerate() {\n  \
    \      if i % 2 == 0 {\n            odds.push(*x);\n        } else {\n       \
    \     evens.push(*x);\n        }\n    }\n    evens.sort();\n    let mut res =\
    \ Vec::new();\n    for (even, odd) in evens.iter().zip(odds.iter()) {\n      \
    \  res.push(*odd);\n        res.push(*even);\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2]`,\n right: `[1, 2, 3]`', /tmp/tmp4hrr1866.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    for i in 1..l.len() {\n        if i % 2 == 0 {\n            for j in 0..i\
    \ {\n                if l[j] < l[i] {\n                    swap(&mut l[j], &mut\
    \ l[i]);\n                }\n            }\n        }\n    }\n    l\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmp8p6n8i6w.rs:14:21\n\
    \   |\n14 |                     swap(&mut l[j], &mut l[i]);\n   |            \
    \         ^^^^ not found in this scope\n   |\nhelp: consider importing one of\
    \ these items\n   |\n1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut ret: Vec<isize>\
    \ = Vec::new();\n    let mut even: Vec<isize> = Vec::new();\n    let mut odd:\
    \ Vec<isize> = Vec::new();\n    for i in 0..l.len() {\n        if i % 2 == 0 {\n\
    \            even.push(l[i]);\n        } else {\n            odd.push(l[i]);\n\
    \        }\n    }\n    even.sort();\n    for i in 0..l.len() {\n        if i %\
    \ 2 == 0 {\n            ret.push(even[i / 2]);\n        } else {\n           \
    \ ret.push(odd[i / 2]);\n        }\n    }\n    ret\n}\n\nfn main() {\n    let\
    \ candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut i = 0;\n    while i < l.len() {\n        if i % 2 == 0 {\n      \
    \      let mut j = i;\n            while j < l.len() {\n                if j %\
    \ 2 == 0 {\n                    if l[j] < l[i] {\n                        let\
    \ s = l[i];\n                        l[i] = l[j];\n                        l[j]\
    \ = s;\n                    }\n                }\n                j += 1;\n  \
    \          }\n        }\n        i += 1;\n    }\n    l\n}\n\nfn main() {\n   \
    \ let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut result =\
    \ Vec::new();\n    let mut even = Vec::new();\n    for (i, x) in l.iter().enumerate()\
    \ {\n        if i % 2 == 0 {\n            result.push(*x);\n        } else {\n\
    \            even.push(*x);\n        }\n    }\n    even.sort();\n    for (i, x)\
    \ in even.iter().enumerate() {\n        result.insert(i * 2 + 1, *x);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 0, -5, 1, -3, 2, 9, 3, 123, 3, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpy2z1tzwa.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut even_indicies:\
    \ Vec<isize> = Vec::new();\n    let mut odd_indicies: Vec<isize> = Vec::new();\n\
    \    for (i, elem) in l.iter().enumerate() {\n        if i % 2 == 0 {\n      \
    \      even_indicies.push(*elem);\n        } else {\n            odd_indicies.push(*elem);\n\
    \        }\n    }\n    even_indicies.sort();\n    let mut new_vec: Vec<isize>\
    \ = Vec::new();\n    for (i, elem) in even_indicies.iter().enumerate() {\n   \
    \     new_vec.push(*elem);\n        new_vec.push(odd_indicies[i]);\n    }\n  \
    \  new_vec\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 1 but the index\
    \ is 1', /tmp/tmp8k2dnsfz.rs:22:22\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut lp = l.clone();\n\
    \    for n in 0..lp.len() {\n        if n % 2 == 0 {\n            let mut s =\
    \ vec![];\n            for m in (n + 1)..lp.len() {\n                if m % 2\
    \ == 0 {\n                    s.push(lp[m]);\n                }\n            }\n\
    \            s.sort();\n            let mut ind = n + 1;\n            for x in\
    \ s {\n                lp[ind] = x;\n                ind += 2;\n            }\n\
    \        }\n    }\n    lp\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 3, 3]`,\n right: `[1, 2, 3]`', /tmp/tmptpb9bgb1.rs:31:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n  // TODO\n  unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpcs5rqv34.rs:10:3\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    l.iter().enumerate().map(|(i,\
    \ v)| {\n        if i % 2 == 0 {\n            *v\n        } else {\n         \
    \   let mut v2 = v.clone();\n            v2.sort();\n            v2\n        }\n\
    \    }).collect()\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sort` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp9nsa071c.rs:14:16\n   |\n14 |             v2.sort();\n\
    \   |                ^^^^ method not found in `isize`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    // Local helper function\
    \ to return a sorted vector.\n    fn helper(l: Vec<isize>) -> Vec<isize> {\n \
    \       let mut result = l.clone();\n        result.sort();\n        result\n\
    \    }\n\n    // Implement this function.  Hint: use for_each_pair.\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpd7t5iget.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    for (i, v) in l.iter_mut().enumerate() {\n        if i % 2 == 0 {\n     \
    \       *v = i;\n        }\n    }\n    l\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc_crl603.rs:12:18\n   |\n\
    12 |             *v = i;\n   |             --   ^ expected `isize`, found `usize`\n\
    \   |             |\n   |             expected due to the type of this binding\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l: Vec<isize>\
    \ = l;\n    let l_len = l.len();\n    if l_len <= 1 {\n        return l;\n   \
    \ }\n    let mut even_l = Vec::new();\n    let mut odd_l = Vec::new();\n    for\
    \ i in 0..l_len {\n        if i % 2 == 0 {\n            even_l.push(l[i]);\n \
    \       } else {\n            odd_l.push(l[i]);\n        }\n    }\n    even_l.sort();\n\
    \    for i in 0..l_len {\n        if i % 2 == 0 {\n            l[i] = even_l[i\
    \ / 2];\n        } else {\n            l[i] = odd_l[i / 2];\n        }\n    }\n\
    \    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    // Split the list\
    \ into odd and even lists\n    let (odd, even) = l.into_iter().enumerate().partition(|x|\
    \ x.0 % 2 == 0);\n    // Sort the even list and transform it back into a Vec<isize>\n\
    \    let even: Vec<isize> = even.map(|(_, val)| val).collect();\n    // Sort the\
    \ even list\n    let even = bubble_sort(even);\n    // Get the odd elements from\
    \ the odd list\n    let odd: Vec<isize> = odd.map(|(_, val)| val).collect();\n\
    \    // Use zip_eq to pair the odd and even lists together, then transform them\
    \ into a Vec<isize>\n    even.iter().zip_eq(odd.iter()).map(|(a, b)| [a, b]).flatten().collect()\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `bubble_sort` in this scope\n  --> /tmp/tmp29zkhmc8.rs:14:16\n\
    \   |\n14 |     let even = bubble_sort(even);\n   |                ^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0282]: type annotations needed for `(B, B)`\n\
    \  --> /tmp/tmp29zkhmc8.rs:12:28\n   |\n10 |     let (odd, even) = l.into_iter().enumerate().partition(|x|\
    \ x.0 % 2 == 0);\n   |         ----------- consider giving this pattern the explicit\
    \ type `(B, B)`, with the type parameters specified\n11 |     // Sort the even\
    \ list and transform it back into a Vec<isize>\n12 |     let even: Vec<isize>\
    \ = even.map(|(_, val)| val).collect();\n   |                            ^^^^\
    \ cannot infer type\n   |\n   = note: type must be known at this point\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0282, E0425.\nFor more information about an error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut even_indices:\
    \ Vec<isize> = vec![];\n    let mut new_l: Vec<isize> = vec![];\n    for (index,\
    \ value) in l.iter().enumerate() {\n        if index % 2 == 0 {\n            new_l.push(*value);\n\
    \        } else {\n            even_indices.push(*value);\n        }\n    }\n\
    \    even_indices.sort();\n    for value in even_indices {\n        new_l.push(value);\n\
    \    }\n    new_l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 3, 2]`,\n right: `[1, 2, 3]`', /tmp/tmp9jcwcobh.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_orig =\
    \ l.clone();\n    let mut l_even = l.clone();\n    l_even.retain(|x| x%2 == 0);\n\
    \    l_even.sort();\n    let mut l_odd = l.clone();\n    l_odd.retain(|x| x%2\
    \ != 0);\n    let mut res = Vec::new();\n    for (x, y) in l_orig.iter().zip(l_even.iter())\
    \ {\n        if x%2 == 0 {\n            res.push(*y);\n        } else {\n    \
    \        res.push(*x);\n        }\n    }\n    for x in l_odd {\n        res.push(x);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 3]`,\n right: `[1, 2, 3]`', /tmp/tmprfadn8d8.rs:31:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    if l.len() < 2 {\n\
    \        return l;\n    }\n    let mut even = vec![];\n    let mut odd = vec![];\n\
    \    for (i, x) in l.iter().enumerate() {\n        if i % 2 == 0 {\n         \
    \   even.push(*x);\n        } else {\n            odd.push(*x);\n        }\n \
    \   }\n    even.sort();\n    let mut output = vec![];\n    for (i, x) in even.iter().enumerate()\
    \ {\n        output.push(*x);\n        if odd.len() > i {\n            output.push(odd[i]);\n\
    \        }\n    }\n    output\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp45l8oi6t.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut sorted =\
    \ l.clone();\n    sorted.sort();\n    let mut new_vec = Vec::new();\n    for i\
    \ in 0..l.len() {\n        if i % 2 == 0 {\n            new_vec.push(l[i]);\n\
    \        } else {\n            new_vec.push(sorted[i]);\n        }\n    }\n  \
    \  new_vec\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, -5, -5, 0, -3, 2, 9, 3, 123, 9, -10]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpbhni3ptu.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut xs = l.clone();\n\
    \    let mut i = 0;\n    while i < xs.len() {\n        if i % 2 == 0 {\n     \
    \       xs[i] = xs[i];\n        } else {\n            xs[i] = xs[i - 1];\n   \
    \     }\n        i += 1;\n    }\n    return xs;\n}\n\nfn main() {\n    let candidate\
    \ = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n   \
    \ assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10,\
    \ 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5, 8, -12,\
    \ 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 3]`,\n right: `[1, 2, 3]`', /tmp/tmpl9jz5r_w.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_vec = l.clone();\n\
    \    let mut l_even_vec = Vec::new();\n    for (i, e) in l_vec.iter().enumerate()\
    \ {\n        if i % 2 == 0 {\n            l_even_vec.push(*e);\n        }\n  \
    \  }\n    l_even_vec.sort();\n    for (i, e) in l_vec.iter_mut().enumerate() {\n\
    \        if i % 2 == 0 {\n            *e = l_even_vec[i / 2];\n        }\n   \
    \ }\n    l_vec\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let mut even = Vec::new();\n    for i in 0..l.len() {\n        if i % 2 ==\
    \ 0 {\n            even.push(l[i]);\n        }\n    }\n    even.sort();\n    for\
    \ i in 0..l.len() {\n        if i % 2 == 0 {\n            l[i] = even[i / 2];\n\
    \        }\n    }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n \
    \   assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    // TODO: write code\
    \ for sort_even here\n    let mut cl = l.clone();\n    let mut even = Vec::new();\n\
    \    for (i, n) in cl.iter().enumerate() {\n        if i % 2 == 0 {\n        \
    \    even.push(*n);\n        }\n    }\n    even.sort();\n    for (i, n) in cl.iter_mut().enumerate()\
    \ {\n        if i % 2 == 0 {\n            *n = even[i/2];\n        }\n    }\n\
    \    cl\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut new_list\
    \ = Vec::new();\n    if l.len() > 0 {\n        new_list.push(l[0]);\n    }\n \
    \   if l.len() > 1 {\n        let mut evens: Vec<isize> = Vec::new();\n      \
    \  for i in 1..l.len() {\n            if i % 2 == 0 {\n                evens.push(l[i]);\n\
    \            } else {\n                new_list.push(l[i]);\n            }\n \
    \       }\n        evens.sort();\n        for i in 0..evens.len() {\n        \
    \    new_list.push(evens[i]);\n        }\n    }\n    new_list\n}\n\nfn main()\
    \ {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]),\
    \ vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123,\
    \ 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 3, 2, 3, 0, 1, -10, -5, -3, 9, 123]`,\n right: `[-10, 3, -5, 2, -3, 3,\
    \ 5, 0, 9, 1, 123]`', /tmp/tmpcrny_iu9.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut ret: Vec<isize>\
    \ = Vec::new();\n    let mut even_indicies: Vec<isize> = Vec::new();\n    let\
    \ mut odd_indicies: Vec<isize> = Vec::new();\n    for index in 0..l.len() {\n\
    \        if index % 2 == 0 {\n            even_indicies.push(l[index]);\n    \
    \    } else {\n            odd_indicies.push(l[index]);\n        }\n    }\n  \
    \  even_indicies.sort();\n    ret.append(&mut even_indicies);\n    ret.append(&mut\
    \ odd_indicies);\n    ret\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 3, 2]`,\n right: `[1, 2, 3]`', /tmp/tmprf4r_0js.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_sorted:\
    \ Vec<isize> = l.clone();\n    l_sorted.sort();\n    let mut answer: Vec<isize>\
    \ = Vec::new();\n    let mut i = 0;\n    let mut j = 0;\n    while i < l.len()\
    \ {\n        if i % 2 == 0 {\n            answer.push(l[i]);\n        } else {\n\
    \            answer.push(l_sorted[j]);\n            j += 1;\n        }\n     \
    \   i += 1;\n    }\n    answer\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 3]`,\n right: `[1, 2, 3]`', /tmp/tmpo1lt0xgl.rs:28:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut new_list\
    \ = Vec::with_capacity(l.len());\n    let half_length = l.len() / 2;\n    let\
    \ mut even_list = Vec::with_capacity(half_length);\n    for i in 0..l.len() {\n\
    \        if i % 2 == 0 {\n            even_list.push(l[i]);\n        }\n    }\n\
    \    even_list.sort();\n    for i in 0..l.len() {\n        if i % 2 == 0 {\n \
    \           new_list.push(even_list[i / 2]);\n        } else {\n            new_list.push(l[i]);\n\
    \        }\n    }\n    new_list\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut evens = Vec::new();\n\
    \    let mut odds = Vec::new();\n    for (i, n) in l.iter().enumerate() {\n  \
    \      if i % 2 == 0 {\n            odds.push(*n);\n        } else {\n       \
    \     evens.push(*n);\n        }\n    }\n    evens.sort();\n    odds.into_iter().zip(evens.into_iter()).flatten().collect()\n\
    }\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: `(isize, isize)` is not an iterator\n    --> /tmp/tmpl4ym525a.rs:19:45\n\
    \     |\n19   |     odds.into_iter().zip(evens.into_iter()).flatten().collect()\n\
    \     |                                             ^^^^^^^ `(isize, isize)` is\
    \ not an iterator\n     |\n     = help: the trait `Iterator` is not implemented\
    \ for `(isize, isize)`\n     = note: required because of the requirements on the\
    \ impl of `IntoIterator` for `(isize, isize)`\nnote: required by a bound in `flatten`\n\
    \nerror[E0599]: the method `collect` exists for struct `Flatten<Zip<std::vec::IntoIter<isize>,\
    \ std::vec::IntoIter<isize>>>`, but its trait bounds were not satisfied\n   -->\
    \ /tmp/tmpl4ym525a.rs:19:55\n    |\n19  |       odds.into_iter().zip(evens.into_iter()).flatten().collect()\n\
    \    |                                                         ^^^^^^^ method\
    \ cannot be called on `Flatten<Zip<std::vec::IntoIter<isize>, std::vec::IntoIter<isize>>>`\
    \ due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds\
    \ were not satisfied:\n            `<(isize, isize) as IntoIterator>::IntoIter\
    \ = _`\n            which is required by `Flatten<Zip<std::vec::IntoIter<isize>,\
    \ std::vec::IntoIter<isize>>>: Iterator`\n            `<(isize, isize) as IntoIterator>::Item\
    \ = _`\n            which is required by `Flatten<Zip<std::vec::IntoIter<isize>,\
    \ std::vec::IntoIter<isize>>>: Iterator`\n            `(isize, isize): IntoIterator`\n\
    \            which is required by `Flatten<Zip<std::vec::IntoIter<isize>, std::vec::IntoIter<isize>>>:\
    \ Iterator`\n            `Flatten<Zip<std::vec::IntoIter<isize>, std::vec::IntoIter<isize>>>:\
    \ Iterator`\n            which is required by `&mut Flatten<Zip<std::vec::IntoIter<isize>,\
    \ std::vec::IntoIter<isize>>>: Iterator`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut temp = l.clone();\n\
    \    for i in (0..l.len()).step_by(2) {\n        let even_sorted = merge_sort(&l[i..i+2]);\n\
    \        temp[i] = even_sorted[0];\n        temp[i+1] = even_sorted[1];\n    }\n\
    \    temp\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `merge_sort` in this scope\n  --> /tmp/tmpxxxlgpdd.rs:11:27\n\
    \   |\n11 |         let even_sorted = merge_sort(&l[i..i+2]);\n   |          \
    \                 ^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l = l;\n\
    \    let len = l.len();\n    let even_indicies = (0..len).step_by(2);\n    let\
    \ mut odd_indicies = (1..len).step_by(2);\n    for even_index in even_indicies\
    \ {\n        let odd_index = odd_indicies.next().unwrap();\n        if l[even_index]\
    \ > l[odd_index] {\n            l.swap(even_index, odd_index);\n        }\n  \
    \  }\n    l\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmp1b0_j6g4.rs:14:45\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut new_list\
    \ = l.clone();\n    let mut sorted_evens = new_list.as_mut_slice().chunks_mut(2).skip(1).fold(\n\
    \        Vec::new(),\n        |mut vec, item| {\n            vec.extend(item.to_vec());\n\
    \            vec\n        },\n    );\n    sorted_evens.sort();\n    let mut evens_list\
    \ = new_list.as_mut_slice().chunks_mut(2).skip(1).fold(\n        Vec::new(),\n\
    \        |mut vec, item| {\n            vec.extend(item.to_vec());\n         \
    \   vec\n        },\n    );\n    let mut new_new_list = new_list.as_mut_slice().chunks_mut(2).take(1).fold(\n\
    \        Vec::new(),\n        |mut vec, item| {\n            vec.extend(item.to_vec());\n\
    \            vec\n        },\n    );\n    new_new_list.append(&mut sorted_evens);\n\
    \    new_new_list.append(&mut evens_list);\n    new_new_list\n}\n\nfn main() {\n\
    \    let candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1,\
    \ 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 3]`,\n right: `[1, 2, 3]`', /tmp/tmp1t80l_y5.rs:39:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l.clone();\n\
    \    let mut l2 = l.clone();\n    for i in 0..l1.len() {\n        if i % 2 ==\
    \ 0 {\n            l1[i] = l2[i + 1];\n            l2[i + 1] = l[i];\n       \
    \ }\n    }\n    l1\n}\n\nfn main() {\n    let candidate = sort_even;\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9,\
    \ 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 3 but the index\
    \ is 3', /tmp/tmpwksbs0vn.rs:13:21\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let len = l.len();\n\
    \    let mut j = 0;\n    let mut new_list = Vec::new();\n    let mut temp_list\
    \ = Vec::new();\n    for i in 0..len {\n        if i % 2 == 0 {\n            new_list.push(l[i]);\n\
    \        } else {\n            temp_list.push(l[i]);\n        }\n    }\n    temp_list.sort();\n\
    \    while j < len {\n        if j % 2 == 0 {\n            j += 1;\n        }\
    \ else {\n            new_list.push(temp_list[j / 2]);\n            j += 1;\n\
    \        }\n    }\n    new_list\n}\n\nfn main() {\n    let candidate = sort_even;\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]), vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1,\
    \ 123]);\n    assert_eq!(candidate(vec![5, 8, -12, 4, 23, 2, 3, 11, 12, -10]),\
    \ vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 3, 2]`,\n right: `[1, 2, 3]`', /tmp/tmp9yhd7d_e.rs:34:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// This function takes a list l and returns a list l' such that\n///\
    \ l' is identical to l in the odd indicies, while its values at the even indicies\
    \ are equal\n/// to the values of the even indicies of l, but sorted.\n/// >>>\
    \ sort_even([1, 2, 3])\n/// [1, 2, 3]\n/// >>> sort_even([5, 6, 3, 4])\n/// [3,\
    \ 6, 5, 4]\nfn sort_even(l: Vec<isize>) -> Vec<isize> {\n    let mut l_ = l.clone();\n\
    \    let evens = even_indices(&l);\n    let mut sorted_evens = evens.clone();\n\
    \    sorted_evens.sort();\n    for (i, elem) in evens.iter().enumerate() {\n \
    \       l_[*elem] = sorted_evens[i];\n    }\n    l_\n}\n\nfn main() {\n    let\
    \ candidate = sort_even;\n    assert_eq!(candidate(vec![1, 2, 3]), vec![1, 2,\
    \ 3]);\n    assert_eq!(candidate(vec![5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]),\
    \ vec![-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]);\n    assert_eq!(candidate(vec![5,\
    \ 8, -12, 4, 23, 2, 3, 11, 12, -10]), vec![-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `even_indices` in this scope\n  -->\
    \ /tmp/tmpvbggivle.rs:10:17\n   |\n10 |     let evens = even_indices(&l);\n  \
    \ |                 ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
