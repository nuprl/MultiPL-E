name: HumanEval_9_rolling_max
language: rust
results:
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut rolling_max = Vec::new();\n    rolling_max.push(numbers[0]);\n\
    \    for i in 1..numbers.len() {\n        let max = cmp::max(rolling_max[i - 1],\
    \ numbers[i]);\n        rolling_max.push(max);\n    }\n    rolling_max\n}\n\n\
    fn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \ --> /tmp/tmpei281162.rs:9:19\n  |\n9 |         let max = cmp::max(rolling_max[i\
    \ - 1], numbers[i]);\n  |                   ^^^ use of undeclared crate or module\
    \ `cmp`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut mx = numbers[0];\n    let mut output = vec![mx];\n\
    \    for i in numbers[1..].iter() {\n        mx = std::cmp::max(mx, *i);\n   \
    \     output.push(mx);\n    }\n    output\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpbin5r_bb.rs:6:18\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    if numbers.is_empty() {\n        return vec![];\n    }\n\
    \n    let mut numbers = numbers;\n    numbers.reverse();\n\n    let mut rolling_max\
    \ = vec![numbers[0]];\n    for n in numbers.iter().skip(1) {\n        let last_max\
    \ = rolling_max.last().unwrap();\n        rolling_max.push(last_max.max(*n));\n\
    \    }\n\n    rolling_max.reverse();\n    rolling_max\n}\n\nfn main() {\n    let\
    \ candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcdsnvxs8.rs:16:39\n   |\n\
    16 |         rolling_max.push(last_max.max(*n));\n   |                       \
    \                ^^\n   |                                       |\n   |      \
    \                                 expected `&isize`, found `isize`\n   |     \
    \                                  help: consider borrowing here: `&*n`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcdsnvxs8.rs:16:26\n   |\n16 |         rolling_max.push(last_max.max(*n));\n\
    \   |                          ^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n16 |         rolling_max.push(*last_max.max(*n));\n\
    \   |                          +\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut current_max = numbers[0];\n    result.push(current_max);\n    for\
    \ number in numbers.iter().skip(1) {\n        current_max = std::cmp::max(current_max,\
    \ *number);\n        result.push(current_max);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmprbjf6zza.rs:7:27\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut res = Vec::with_capacity(numbers.len());\n    let\
    \ mut current_max = numbers[0];\n    res.push(current_max);\n    for el in numbers.iter().skip(1)\
    \ {\n        if *el > current_max {\n            current_max = *el;\n        }\n\
    \        res.push(current_max);\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp8iup0qce.rs:7:27\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_values = Vec::new();\n    for (i, num) in numbers.iter().enumerate()\
    \ {\n        if i == 0 {\n            max_values.push(*num);\n        } else {\n\
    \            max_values.push(max_values[i - 1].max(*num));\n        }\n    }\n\
    \    max_values\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    use std::cmp::max;\n    let mut rolling_max = vec![];\n\
    \    let mut m = numbers[0];\n    rolling_max.push(m);\n    for i in 1..numbers.len()\
    \ {\n        m = max(m, numbers[i]);\n        rolling_max.push(m);\n    }\n  \
    \  rolling_max\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmps2wdtarq.rs:8:17\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max_sofar = std::isize::MIN;\n\
    \    for &v in numbers.iter() {\n        max_sofar = std::cmp::max(max_sofar,\
    \ v);\n        result.push(max_sofar);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = None;\n    let mut new_numbers = Vec::new();\n\
    \    for n in numbers {\n        if max.is_none() || n > max.unwrap() {\n    \
    \        max = Some(n);\n        }\n        new_numbers.push(max.unwrap());\n\
    \    }\n    new_numbers\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut acc = vec![];\n    let mut current_max = numbers[0];\n\
    \    for num in numbers {\n        if num > current_max {\n            current_max\
    \ = num;\n        }\n        acc.push(current_max);\n    }\n    acc\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpe30s2jty.rs:7:27\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max_so_far =\
    \ std::isize::MIN;\n    for i in numbers {\n        if i > max_so_far {\n    \
    \        max_so_far = i;\n        }\n        result.push(max_so_far);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut max = isize::min_value();\n    for i in 0..numbers.len() {\n     \
    \   if numbers[i] > max {\n            max = numbers[i];\n        }\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut current_max = isize::min_value();\n    for n in numbers {\n      \
    \  if n > current_max {\n            current_max = n;\n        }\n        result.push(current_max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max_value = 0;\n\
    \    for number in numbers {\n        max_value = std::cmp::max(max_value, number);\n\
    \        result.push(max_value);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut maximums = vec![];\n    let mut maximum = isize::min_value();\n\
    \    for number in numbers {\n        maximum = std::cmp::max(maximum, number);\n\
    \        maximums.push(maximum);\n    }\n    maximums\n}\n\nfn main() {\n    let\
    \ candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut rolling_max = Vec::new();\n\
    \    rolling_max.push(max);\n    for &number in numbers.iter().skip(1) {\n   \
    \     max = std::cmp::max(max, number);\n        rolling_max.push(max);\n    }\n\
    \    rolling_max\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpsy7txlps.rs:6:19\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut res = Vec::new();\n    let mut rolling_max = 0;\n\
    \    for n in numbers {\n        rolling_max = max(rolling_max, n);\n        res.push(rolling_max);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n --> /tmp/tmpeqt64eq1.rs:9:23\n\
    \  |\n9 |         rolling_max = max(rolling_max, n);\n  |                    \
    \   ^^^ not found in this scope\n  |\nhelp: consider importing this function\n\
    \  |\n1 | use std::cmp::max;\n  |\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    use std::cmp::max;\n    let mut result = Vec::new();\n\
    \    let mut rolling_max = numbers[0];\n    result.push(rolling_max);\n    for\
    \ x in numbers[1..].iter() {\n        rolling_max = max(rolling_max, *x);\n  \
    \      result.push(rolling_max);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpa1lmv1w6.rs:8:27\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut solution = Vec::with_capacity(numbers.len());\n\
    \    let mut max = isize::min_value();\n    for i in numbers {\n        max =\
    \ max.max(i);\n        solution.push(max);\n    }\n    solution\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut current_max = numbers[0];\n    result.push(current_max);\n    for\
    \ (i, number) in numbers.iter().enumerate().skip(1) {\n        if number > &current_max\
    \ {\n            current_max = *number;\n        }\n        result.push(current_max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpckiplfmn.rs:7:27\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    use std::cmp::max;\n    let mut result = Vec::new();\n\
    \    result.push(numbers[0]);\n    for i in 1..numbers.len() {\n        result.push(max(result[i\
    \ - 1], numbers[i]));\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpimx2x0m2.rs:8:17\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut rolling_max = vec![];\n    let mut max_number =\
    \ std::isize::MIN;\n    for n in numbers {\n        if n > max_number {\n    \
    \        max_number = n;\n        }\n        rolling_max.push(max_number);\n \
    \   }\n    rolling_max\n}\n\nfn main() {\n    let candidate = rolling_max;\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_elements = Vec::new();\n    let mut current_max\
    \ = None;\n\n    for number in numbers {\n        if let Some(last_max) = current_max\
    \ {\n            if number >= last_max {\n                current_max = Some(number);\n\
    \            }\n        } else {\n            current_max = Some(number);\n  \
    \      }\n\n        max_elements.push(current_max.unwrap());\n    }\n\n    max_elements\n\
    }\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut maximums = Vec::new();\n    for number in numbers\
    \ {\n        if maximums.is_empty() {\n            maximums.push(number);\n  \
    \      } else {\n            maximums.push(cmp::max(maximums.last().unwrap(),\
    \ &number));\n        }\n    }\n    maximums\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmp2fku5nzn.rs:11:27\n   |\n11 |             maximums.push(cmp::max(maximums.last().unwrap(),\
    \ &number));\n   |                           ^^^ use of undeclared crate or module\
    \ `cmp`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut maxes = Vec::with_capacity(numbers.len());\n  \
    \  for i in 0..numbers.len() {\n        let current_max = if i == 0 {\n      \
    \      numbers[i]\n        } else {\n            maxes[i - 1].max(numbers[i])\n\
    \        };\n        maxes.push(current_max);\n    }\n    maxes\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmp8gszytas.rs:11:13\n\
    \   |\n6  |     let mut maxes = Vec::with_capacity(numbers.len());\n   |     \
    \    --------- consider giving `maxes` the explicit type `Vec<T>`, with the type\
    \ parameters specified\n...\n11 |             maxes[i - 1].max(numbers[i])\n \
    \  |             ^^^^^^^^^^^^ cannot infer type\n   |\n   = note: type must be\
    \ known at this point\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut out = Vec::new();\n    let mut curr_max = std::isize::MIN;\n\
    \    for &n in numbers.iter() {\n        curr_max = std::cmp::max(curr_max, n);\n\
    \        out.push(curr_max);\n    }\n    out\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    // Method one: O(n^2)\n    // let mut result = Vec::new();\n\
    \    // for (i, elem) in numbers.iter().enumerate() {\n    //     let mut max\
    \ = *elem;\n    //     for number in &numbers[..i] {\n    //         if *number\
    \ > max {\n    //             max = *number;\n    //         }\n    //     }\n\
    \    //     result.push(max);\n    // }\n    // result\n\n    // Method two: O(n)\n\
    \    let mut stack = Vec::new();\n    let mut result = Vec::new();\n    for number\
    \ in numbers {\n        if stack.is_empty() || number > stack[stack.len() - 1]\
    \ {\n            stack.push(number);\n        } else {\n            let mut i\
    \ = stack.len() - 1;\n            while !stack.is_empty() && stack[i] > number\
    \ {\n                stack.pop();\n                i -= 1;\n            }\n  \
    \          stack.push(number);\n        }\n        result.push(stack[stack.len()\
    \ - 1]);\n    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp_7rgzowm.rs:29:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max: Vec<isize> = Vec::new();\n    let mut max_so_far\
    \ = std::isize::MIN;\n    for i in numbers {\n        max_so_far = std::cmp::max(max_so_far,\
    \ i);\n        max.push(max_so_far);\n    }\n    max\n}\n\nfn main() {\n    let\
    \ candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut output = Vec::with_capacity(numbers.len());\n \
    \   let mut curr_max = 0;\n    for num in numbers {\n        curr_max = if num\
    \ > curr_max { num } else { curr_max };\n        output.push(curr_max);\n    }\n\
    \    output\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut current_max =\
    \ std::isize::MIN;\n    for number in numbers {\n        if number > current_max\
    \ {\n            current_max = number;\n        }\n        result.push(current_max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut maximums = Vec::with_capacity(numbers.len());\n\
    \    let mut current_max = std::isize::MIN;\n    for i in numbers {\n        if\
    \ i > current_max {\n            current_max = i;\n        }\n        maximums.push(current_max);\n\
    \    }\n    maximums\n}\n\nfn main() {\n    let candidate = rolling_max;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    numbers\n        .iter()\n        .scan(std::isize::MIN,\
    \ |acc, &curr| {\n            *acc = std::cmp::max(*acc, curr);\n            Some(*acc)\n\
    \        })\n        .collect()\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut curr_max = *numbers.first().unwrap();\n    for &n in numbers.iter()\
    \ {\n        curr_max = std::cmp::max(curr_max, n);\n        result.push(curr_max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmph_u2tv4f.rs:7:41\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    numbers\n        .into_iter()\n        .scan(None, |state,\
    \ next| {\n            *state = Some(state.map_or(next, |s| s.max(next)));\n \
    \           state.clone()\n        })\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `&mut Option<T>`\n --> /tmp/tmpwehqrmiw.rs:8:22\n\
    \  |\n8 |         .scan(None, |state, next| {\n  |                      ^^^^^\
    \ consider giving this closure parameter the explicit type `&mut Option<T>`, with\
    \ the type parameters specified\n  |\n  = note: type must be known at this point\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   result.push(numbers[0]);\n    for i in 1..numbers.len() {\n        let max\
    \ = std::cmp::max(result[i - 1], numbers[i]);\n        result.push(max);\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpgrpu44eu.rs:7:17\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut rolling_max: Vec<isize> = vec![numbers[0]];\n \
    \   let mut it = numbers.iter();\n    it.next();\n    for x in it {\n        rolling_max.push(cmp::max(*x,\
    \ *rolling_max.last().unwrap()));\n    }\n    rolling_max\n}\n\nfn main() {\n\
    \    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmp8f_g7ck6.rs:10:26\n   |\n10 |         rolling_max.push(cmp::max(*x,\
    \ *rolling_max.last().unwrap()));\n   |                          ^^^ use of undeclared\
    \ crate or module `cmp`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = std::isize::MIN;\n    let mut results = Vec::new();\n\
    \    for n in numbers {\n        max = std::cmp::max(max, n);\n        results.push(max);\n\
    \    }\n    results\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut results = vec![max];\n\
    \    for n in numbers[1..].iter() {\n        max = n.max(max);\n        results.push(max);\n\
    \    }\n    results\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpsnvydfd3.rs:9:21\n  |\n9 |\
    \         max = n.max(max);\n  |                     ^^^\n  |                \
    \     |\n  |                     expected `&isize`, found `isize`\n  |       \
    \              help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpsnvydfd3.rs:9:15\n  |\n6 |     let mut max = numbers[0];\n\
    \  |                   ---------- expected due to this value\n...\n9 |       \
    \  max = n.max(max);\n  |               ^^^^^^^^^^ expected `isize`, found `&isize`\n\
    \  |\nhelp: consider dereferencing the borrow\n  |\n9 |         max = *n.max(max);\n\
    \  |               +\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut max = isize::min_value();\n    for n in numbers {\n        if n >\
    \ max {\n            max = n;\n        }\n        result.push(max);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut rolling_max = Vec::with_capacity(numbers.len());\n\
    \    let mut current_max = numbers[0];\n    rolling_max.push(current_max);\n \
    \   for &number in numbers.iter().skip(1) {\n        if number > current_max {\n\
    \            current_max = number;\n        }\n        rolling_max.push(current_max);\n\
    \    }\n    rolling_max\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpwumj58h5.rs:7:27\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut maximums = vec![];\n    maximums.push(numbers[0]);\n\
    \    for number in numbers.iter().skip(1) {\n        let last_maximum = maximums.last().unwrap();\n\
    \        if *number > *last_maximum {\n            maximums.push(*number);\n \
    \       } else {\n            maximums.push(*last_maximum);\n        }\n    }\n\
    \    maximums\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpg8a_oz86.rs:7:19\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_value = std::isize::MIN;\n    let mut rolling_max\
    \ = Vec::new();\n    for number in numbers {\n        max_value = std::cmp::max(max_value,\
    \ number);\n        rolling_max.push(max_value);\n    }\n    rolling_max\n}\n\n\
    fn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut current_max = numbers[0];\n    result.push(current_max);\n    for\
    \ item in numbers.iter().skip(1) {\n        if *item > current_max {\n       \
    \     current_max = *item;\n        }\n        result.push(current_max);\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpahrdc0p5.rs:7:27\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let n = numbers.len();\n    let mut window = Vec::with_capacity(n);\n\
    \    let mut res = Vec::with_capacity(n);\n    for i in 0..n {\n        while\
    \ !window.is_empty() && numbers[i] >= numbers[window[window.len() - 1]] {\n  \
    \          window.pop();\n        }\n        window.push(i);\n        res.push(numbers[window[0]]);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut results = Vec::new();\n    let mut current_max\
    \ = -100;\n\n    for number in numbers {\n        current_max = std::cmp::max(current_max,\
    \ number);\n        results.push(current_max);\n    }\n\n    results\n}\n\nfn\
    \ main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut max_so_far = numbers[0];\n    result.push(max_so_far);\n    for i\
    \ in 1..numbers.len() {\n        max_so_far = max(max_so_far, numbers[i]);\n \
    \       result.push(max_so_far);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp9di17vb7.rs:10:22\n\
    \   |\n10 |         max_so_far = max(max_so_far, numbers[i]);\n   |          \
    \            ^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut rolling_max = Vec::with_capacity(numbers.len());\n\
    \    let mut current_max = std::isize::MIN;\n    for number in numbers {\n   \
    \     if number > current_max {\n            current_max = number;\n        }\n\
    \        rolling_max.push(current_max);\n    }\n    rolling_max\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max_till_now\
    \ = -1;\n    for n in numbers {\n        if n > max_till_now {\n            max_till_now\
    \ = n;\n        }\n        result.push(max_till_now);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut res = Vec::new();\n    let mut maximum = 0;\n \
    \   for i in numbers {\n        maximum = std::cmp::max(maximum, i);\n       \
    \ res.push(maximum);\n    }\n    res\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = None;\n\
    \    for number in numbers {\n        match max {\n            None => {\n   \
    \             max = Some(number);\n            }\n            Some(last_max) =>\
    \ {\n                max = Some(last_max.max(number));\n            }\n      \
    \  }\n        result.push(max.unwrap());\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut max = numbers[0];\n    result.push(max);\n    for n in numbers.iter().skip(1)\
    \ {\n        if n > &max {\n            max = *n;\n        }\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpnwkmeqb5.rs:7:19\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max_element =\
    \ isize::min_value();\n    for element in numbers {\n        if element > max_element\
    \ {\n            max_element = element;\n        }\n        result.push(max_element);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_elements = vec![];\n    let mut max_element\
    \ = numbers[0];\n    max_elements.push(max_element);\n    for i in 1..numbers.len()\
    \ {\n        if numbers[i] > max_element {\n            max_element = numbers[i];\n\
    \        }\n        max_elements.push(max_element);\n    }\n    max_elements\n\
    }\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpectqjepx.rs:7:27\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut max_element = std::isize::MIN;\n    for element in numbers {\n   \
    \     max_element = max(max_element, element);\n        result.push(max_element);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n --> /tmp/tmpaqcsgy_3.rs:9:23\n\
    \  |\n9 |         max_element = max(max_element, element);\n  |              \
    \         ^^^ not found in this scope\n  |\nhelp: consider importing this function\n\
    \  |\n1 | use std::cmp::max;\n  |\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut rolling_max: Vec<isize> = Vec::new();\n    for\
    \ &number in numbers.iter() {\n        if rolling_max.is_empty() {\n         \
    \   rolling_max.push(number);\n        } else {\n            let current_max =\
    \ rolling_max.last().unwrap();\n            rolling_max.push(current_max.max(number));\n\
    \        }\n    }\n    rolling_max\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkmg0x31l.rs:12:46\n   |\n\
    12 |             rolling_max.push(current_max.max(number));\n   |            \
    \                                  ^^^^^^\n   |                              \
    \                |\n   |                                              expected\
    \ `&isize`, found `isize`\n   |                                              help:\
    \ consider borrowing here: `&number`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpkmg0x31l.rs:12:30\n   |\n12 |             rolling_max.push(current_max.max(number));\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |        \
    \     rolling_max.push(*current_max.max(number));\n   |                      \
    \        +\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = -1;\n    let mut result = Vec::with_capacity(numbers.len());\n\
    \    for number in numbers {\n        if number > max {\n            max = number;\n\
    \        }\n        result.push(max);\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for number in numbers.iter().skip(1) {\n        max\
    \ = max.max(*number);\n        result.push(max);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpululruro.rs:7:19\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = std::isize::MIN;\n    let mut res = Vec::with_capacity(numbers.len());\n\
    \    for n in numbers {\n        max = std::cmp::max(max, n);\n        res.push(max);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = isize::min_value();\n    let mut rolling_max\
    \ = Vec::new();\n    for n in numbers {\n        max = n.max(max);\n        rolling_max.push(max);\n\
    \    }\n    rolling_max\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for n in numbers.iter().skip(1) {\n        if *n >\
    \ max {\n            max = *n;\n        }\n        result.push(max);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmppuipw56p.rs:7:19\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut current_max =\
    \ isize::min_value();\n    for &n in numbers.iter() {\n        current_max = current_max.max(n);\n\
    \        result.push(current_max);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_stack = Vec::new();\n    let mut res = Vec::new();\n\
    \n    for number in numbers {\n        if number >= max_stack.last().unwrap_or(&number)\
    \ {\n            max_stack.push(number);\n        }\n        res.push(max_stack.last().unwrap().clone());\n\
    \    }\n\n    res\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmdkrr0ql.rs:10:22\n   |\n\
    10 |         if number >= max_stack.last().unwrap_or(&number) {\n   |        \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n10 |         if number >=\
    \ *max_stack.last().unwrap_or(&number) {\n   |                      +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut max = isize::min_value();\n    for n in numbers {\n        if n >\
    \ max {\n            max = n;\n        }\n        result.push(max);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    numbers\n        .into_iter()\n        .scan(std::isize::MIN,\
    \ |state, x| {\n            *state = *state.max(&x);\n            Some(*state)\n\
    \        })\n        .collect()\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpq5xcmg50.rs:9:33\n  |\n9 |\
    \             *state = *state.max(&x);\n  |                                 ^^\
    \ types differ in mutability\n  |\n  = note: expected mutable reference `&mut\
    \ isize`\n                     found reference `&isize`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_num = None;\n    let mut max_nums = Vec::new();\n\
    \    for num in numbers {\n        if let Some(max) = max_num {\n            if\
    \ num > max {\n                max_num = Some(num);\n            }\n        }\
    \ else {\n            max_num = Some(num);\n        }\n        max_nums.push(max_num.unwrap());\n\
    \    }\n    max_nums\n}\n\nfn main() {\n    let candidate = rolling_max;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_numbers = Vec::with_capacity(numbers.len());\n\
    \    let mut max_number = isize::min_value();\n    for number in numbers {\n \
    \       max_number = std::cmp::max(max_number, number);\n        max_numbers.push(max_number);\n\
    \    }\n    max_numbers\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut result = vec![];\n\
    \    for number in numbers {\n        if number > max {\n            max = number;\n\
    \        }\n        result.push(max);\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpx9c3rgkr.rs:6:19\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut current_max = std::isize::MIN;\n    for n in numbers {\n        current_max\
    \ = std::cmp::max(current_max, n);\n        result.push(current_max);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut current_max =\
    \ isize::min_value();\n    for num in numbers {\n        if num > current_max\
    \ {\n            current_max = num;\n        }\n        result.push(current_max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    for n in numbers {\n\
    \        if result.len() == 0 {\n            result.push(n);\n        } else {\n\
    \            result.push(std::cmp::max(result[result.len() - 1], n));\n      \
    \  }\n    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_number = 0;\n    let mut maximums = Vec::new();\n\
    \    for number in numbers {\n        max_number = std::cmp::max(max_number, number);\n\
    \        maximums.push(max_number);\n    }\n    maximums\n}\n\nfn main() {\n \
    \   let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = Vec::with_capacity(numbers.len());\n\
    \    let mut max = numbers[0];\n    max_so_far.push(max);\n    for &number in\
    \ numbers.iter().skip(1) {\n        max = max.max(number);\n        max_so_far.push(max);\n\
    \    }\n    max_so_far\n}\n\nfn main() {\n    let candidate = rolling_max;\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp4mzqie_r.rs:7:19\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max: isize = numbers[0];\n    let mut ret = Vec::new();\n\
    \    ret.push(max);\n    for i in 1..numbers.len() {\n        if numbers[i] >\
    \ max {\n            max = numbers[i];\n        }\n        ret.push(max);\n  \
    \  }\n    ret\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpifcdjvgs.rs:6:26\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max: isize = std::isize::MIN;\n    let mut result:\
    \ Vec<isize> = Vec::new();\n    for number in numbers {\n        max = max.max(number);\n\
    \        result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max: isize = 0;\n    let mut result: Vec<isize>\
    \ = Vec::new();\n    for i in numbers {\n        max = std::cmp::max(max, i);\n\
    \        result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    numbers\n        .into_iter()\n        .scan(isize::min_value(),\
    \ |state, next| {\n            *state = *state.max(&next);\n            Some(*state)\n\
    \        })\n        .collect()\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp6_pf3grr.rs:9:33\n  |\n9 |\
    \             *state = *state.max(&next);\n  |                               \
    \  ^^^^^ types differ in mutability\n  |\n  = note: expected mutable reference\
    \ `&mut isize`\n                     found reference `&isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut maximums = vec![];\n    let mut current_max = isize::min_value();\n\
    \    for n in numbers {\n        if n > current_max {\n            current_max\
    \ = n;\n        }\n        maximums.push(current_max);\n    }\n    maximums\n\
    }\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut current_max = numbers[0];\n    let mut results\
    \ = vec![current_max];\n\n    for n in numbers.iter().skip(1) {\n        if n\
    \ > &current_max {\n            current_max = *n;\n        }\n        results.push(current_max);\n\
    \    }\n\n    results\n}\n\nfn main() {\n    let candidate = rolling_max;\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpt505g627.rs:6:27\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   if let Some(first) = numbers.first() {\n        result.push(*first);\n   \
    \ }\n    for i in 1..numbers.len() {\n        let max = numbers[i]\n         \
    \   .max(result[i - 1])\n            .max(result[result.len() - 1]);\n       \
    \ result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = -999;\n\
    \    for number in numbers {\n        if number > max {\n            max = number;\n\
    \        }\n        result.push(max);\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut result = vec![max];\n\
    \    for number in numbers.iter().skip(1) {\n        max = number.max(max);\n\
    \        result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpvtwmvgbs.rs:9:26\n  |\n9 |\
    \         max = number.max(max);\n  |                          ^^^\n  |      \
    \                    |\n  |                          expected `&isize`, found\
    \ `isize`\n  |                          help: consider borrowing here: `&max`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpvtwmvgbs.rs:9:15\n  |\n6 |    \
    \ let mut max = numbers[0];\n  |                   ---------- expected due to\
    \ this value\n...\n9 |         max = number.max(max);\n  |               ^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the borrow\n\
    \  |\n9 |         max = *number.max(max);\n  |               +\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut rolling_max_numbers = Vec::new();\n    let mut\
    \ rolling_max = 0;\n    for n in numbers {\n        rolling_max = std::cmp::max(rolling_max,\
    \ n);\n        rolling_max_numbers.push(rolling_max);\n    }\n    rolling_max_numbers\n\
    }\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut accumulator = Vec::new();\n    let mut current_max\
    \ = isize::min_value();\n    for number in numbers {\n        if number > current_max\
    \ {\n            current_max = number;\n        }\n        accumulator.push(current_max);\n\
    \    }\n    accumulator\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_elems = Vec::with_capacity(numbers.len());\n\
    \    let mut local_max = None;\n    for n in numbers {\n        if let Some(x)\
    \ = local_max {\n            if n > x {\n                local_max = Some(n);\n\
    \            }\n        } else {\n            local_max = Some(n);\n        }\n\
    \        max_elems.push(local_max.unwrap_or(n));\n    }\n    max_elems\n}\n\n\
    fn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut rolling_max = vec![];\n    let mut current_max\
    \ = std::isize::MIN;\n    for number in numbers {\n        if number > current_max\
    \ {\n            current_max = number;\n        }\n        rolling_max.push(current_max);\n\
    \    }\n    rolling_max\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   if numbers.len() > 0 {\n        let mut rolling_max = numbers[0];\n      \
    \  result.push(rolling_max);\n        for i in 1..numbers.len() {\n          \
    \  rolling_max = cmp::max(rolling_max, numbers[i]);\n            result.push(rolling_max);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmp9go2cjwj.rs:11:27\n   |\n11 |             rolling_max = cmp::max(rolling_max,\
    \ numbers[i]);\n   |                           ^^^ use of undeclared crate or\
    \ module `cmp`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut max = numbers[0];\n    result.push(max);\n    for i in 1..numbers.len()\
    \ {\n        if numbers[i] > max {\n            max = numbers[i];\n        }\n\
    \        result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpsu1tcmik.rs:7:19\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut ret = Vec::new();\n    let mut max = numbers[0];\n\
    \    ret.push(max);\n    for &number in numbers.iter().skip(1) {\n        if number\
    \ > max {\n            max = number;\n        }\n        ret.push(max);\n    }\n\
    \    ret\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpwfurk1fn.rs:7:19\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut rolling_max: Vec<isize> = vec![];\n    let mut\
    \ max_value = std::isize::MIN;\n    for number in numbers {\n        max_value\
    \ = std::cmp::max(max_value, number);\n        rolling_max.push(max_value);\n\
    \    }\n    rolling_max\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_found = None;\n    let mut result = Vec::new();\n\
    \    for number in numbers {\n        match max_found {\n            None => max_found\
    \ = Some(number),\n            Some(max) => max_found = Some(max.max(number)),\n\
    \        }\n        result.push(max_found.unwrap());\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut res = Vec::with_capacity(numbers.len());\n    let\
    \ mut max = numbers[0];\n    res.push(max);\n    for i in numbers.iter().skip(1)\
    \ {\n        if i > &max {\n            max = *i;\n        }\n        res.push(max);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpybq_wdhw.rs:7:19\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut rolling_max = Vec::new();\n    let mut max = std::isize::MIN;\n\
    \    for number in numbers {\n        max = std::cmp::max(max, number);\n    \
    \    rolling_max.push(max);\n    }\n    rolling_max\n}\n\nfn main() {\n    let\
    \ candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut max = numbers[0];\n    result.push(max);\n    for i in 1..numbers.len()\
    \ {\n        if numbers[i] > max {\n            max = numbers[i];\n        }\n\
    \        result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpc4n96bvr.rs:7:19\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ vec![max_so_far];\n    for current in numbers.iter().skip(1) {\n        max_so_far\
    \ = std::cmp::max(max_so_far, *current);\n        result.push(max_so_far);\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpny2xkdmu.rs:6:26\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    numbers\n        .iter()\n        .scan(isize::min_value(),\
    \ |state, x| {\n            *state = std::cmp::max(*state, *x);\n            Some(*state)\n\
    \        })\n        .collect()\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut rolling_maxes = vec![];\n    for number in numbers\
    \ {\n        if rolling_maxes.is_empty() {\n            rolling_maxes.push(number);\n\
    \        } else {\n            rolling_maxes.push(rolling_maxes.last().unwrap().max(number));\n\
    \        }\n    }\n    rolling_maxes\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx23j6cud.rs:11:66\n   |\n\
    11 |             rolling_maxes.push(rolling_maxes.last().unwrap().max(number));\n\
    \   |                                                                  ^^^^^^\n\
    \   |                                                                  |\n   |\
    \                                                                  expected `&isize`,\
    \ found `isize`\n   |                                                        \
    \          help: consider borrowing here: `&number`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpx23j6cud.rs:11:32\n   |\n11 |             rolling_maxes.push(rolling_maxes.last().unwrap().max(number));\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n11 |             rolling_maxes.push(*rolling_maxes.last().unwrap().max(number));\n\
    \   |                                +\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut rolling_max = Vec::new();\n    let mut current_max\
    \ = isize::min_value();\n    for n in numbers {\n        current_max = max(current_max,\
    \ n);\n        rolling_max.push(current_max);\n    }\n    rolling_max\n}\n\nfn\
    \ main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n --> /tmp/tmph4u22ccq.rs:9:23\n\
    \  |\n9 |         current_max = max(current_max, n);\n  |                    \
    \   ^^^ not found in this scope\n  |\nhelp: consider importing this function\n\
    \  |\n1 | use std::cmp::max;\n  |\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut result = vec![max];\n\
    \    for &number in numbers.iter().skip(1) {\n        if number > max {\n    \
    \        max = number;\n        }\n        result.push(max);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpve1zheq7.rs:6:19\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_numbers = vec![];\n    let mut current_max\
    \ = 0;\n    for num in numbers {\n        if num > current_max {\n           \
    \ current_max = num;\n        }\n        max_numbers.push(current_max);\n    }\n\
    \    max_numbers\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = std::isize::MIN;\n\
    \    for number in numbers {\n        max = std::cmp::max(max, number);\n    \
    \    result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = isize::min_value();\n    let mut result =\
    \ Vec::new();\n    for number in numbers {\n        max = max.max(number);\n \
    \       result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut maximum = 0;\n    let mut result = Vec::with_capacity(numbers.len());\n\
    \    for i in numbers {\n        maximum = max(maximum, i);\n        result.push(maximum);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n --> /tmp/tmp75pcgdmz.rs:9:19\n\
    \  |\n9 |         maximum = max(maximum, i);\n  |                   ^^^ not found\
    \ in this scope\n  |\nhelp: consider importing this function\n  |\n1 | use std::cmp::max;\n\
    \  |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut running_max = numbers[0];\n    let mut max_list\
    \ = vec![running_max];\n    for i in 1..numbers.len() {\n        if numbers[i]\
    \ > running_max {\n            running_max = numbers[i];\n        }\n        max_list.push(running_max);\n\
    \    }\n    max_list\n}\n\nfn main() {\n    let candidate = rolling_max;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpbwy00e3m.rs:6:27\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut max = numbers[0];\n    result.push(max);\n    for number in numbers[1..].iter()\
    \ {\n        max = max.max(*number);\n        result.push(max);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpmzz6tob5.rs:7:19\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    numbers\n        .iter()\n        .scan(0, |state, &next|\
    \ {\n            if next > *state {\n                *state = next;\n        \
    \    }\n            Some(*state)\n        })\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut current_max = numbers[0];\n    result.push(current_max);\n    for\
    \ number in numbers.iter().skip(1) {\n        if *number > current_max {\n   \
    \         current_max = *number;\n        }\n        result.push(current_max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpkm8tvkte.rs:7:27\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut results = Vec::new();\n    let mut max_so_far =\
    \ isize::min_value();\n    for number in numbers {\n        max_so_far = max(max_so_far,\
    \ number);\n        results.push(max_so_far);\n    }\n    results\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n --> /tmp/tmp5ccrixgj.rs:9:22\n\
    \  |\n9 |         max_so_far = max(max_so_far, number);\n  |                 \
    \     ^^^ not found in this scope\n  |\nhelp: consider importing this function\n\
    \  |\n1 | use std::cmp::max;\n  |\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut output = Vec::with_capacity(numbers.len());\n \
    \   let mut current_max = -1;\n    for (i, n) in numbers.iter().enumerate() {\n\
    \        current_max = if *n > current_max {\n            *n\n        } else {\n\
    \            current_max\n        };\n        output.push(current_max);\n    }\n\
    \    output\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut stack = vec![];\n    let mut rolling_max = vec![];\n\
    \n    for n in numbers {\n        if stack.is_empty() || n > stack[stack.len()\
    \ - 1] {\n            stack.push(n);\n        } else {\n            let mut smallest_index\
    \ = stack.len() - 1;\n            while !stack.is_empty() && stack[stack.len()\
    \ - 1] > n {\n                stack.pop();\n                smallest_index -=\
    \ 1;\n            }\n            stack.push(n);\n        }\n        rolling_max.push(stack[smallest_index]);\n\
    \    }\n\n    rolling_max\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `smallest_index` in this scope\n  --> /tmp/tmpei5o_e2_.rs:20:32\n\
    \   |\n20 |         rolling_max.push(stack[smallest_index]);\n   |           \
    \                     ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    numbers\n        .iter()\n        .scan(isize::min_value(),\
    \ |max, &x| {\n            *max = *max.max(&x);\n            Some(*max)\n    \
    \    })\n        .collect()\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpy1cqzi79.rs:9:29\n  |\n9 |\
    \             *max = *max.max(&x);\n  |                             ^^ types differ\
    \ in mutability\n  |\n  = note: expected mutable reference `&mut isize`\n    \
    \                 found reference `&isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut last_max = numbers[0];\n    let mut result = vec![last_max];\n\
    \    for number in numbers.iter().skip(1) {\n        let max = if *number > last_max\
    \ {\n            *number\n        } else {\n            last_max\n        };\n\
    \        result.push(max);\n        last_max = max;\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpt568hnk9.rs:6:24\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut current_max = numbers[0];\n    result.push(current_max);\n    for\
    \ i in 1..numbers.len() {\n        if numbers[i] > current_max {\n           \
    \ current_max = numbers[i];\n        }\n        result.push(current_max);\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpn8hjwi8n.rs:7:27\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut res = Vec::new();\n    let mut max_number = numbers[0];\n\
    \    res.push(max_number);\n    for i in 1..numbers.len() {\n        max_number\
    \ = std::cmp::max(max_number, numbers[i]);\n        res.push(max_number);\n  \
    \  }\n    res\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpg1v1wogt.rs:7:26\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut current_max =\
    \ 0;\n    for num in numbers {\n        if num > current_max {\n            current_max\
    \ = num;\n        }\n        result.push(current_max);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   result.push(numbers[0]);\n    for number in numbers.iter().skip(1) {\n   \
    \     result.push(number.max(result.last().unwrap()));\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpsk0vhsz7.rs:9:21\n  |\n9 |\
    \         result.push(number.max(result.last().unwrap()));\n  |              \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n\
    \  |\nhelp: consider dereferencing the borrow\n  |\n9 |         result.push(*number.max(result.last().unwrap()));\n\
    \  |                     +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max: isize = std::isize::MIN;\n    let mut r: Vec<isize>\
    \ = Vec::new();\n    for n in numbers {\n        max = max.max(n);\n        r.push(max);\n\
    \    }\n    r\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut current_max = numbers[0];\n    result.push(current_max);\n    for\
    \ &number in numbers.iter().skip(1) {\n        current_max = max(current_max,\
    \ number);\n        result.push(current_max);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp6hl9qa2n.rs:10:23\n\
    \   |\n10 |         current_max = max(current_max, number);\n   |            \
    \           ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut max_so_far = 0;\n    for x in numbers {\n        if x > max_so_far\
    \ {\n            max_so_far = x;\n        }\n        result.push(max_so_far);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut current_max =\
    \ 0;\n    for i in 0..numbers.len() {\n        current_max = std::cmp::max(current_max,\
    \ numbers[i]);\n        result.push(current_max);\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_elements = Vec::new();\n    for i in numbers\
    \ {\n        max_elements.push(max(i, *max_elements.last().unwrap_or(&i)));\n\
    \    }\n    max_elements\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n --> /tmp/tmpgznfb5nc.rs:8:27\n\
    \  |\n8 |         max_elements.push(max(i, *max_elements.last().unwrap_or(&i)));\n\
    \  |                           ^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this function\n  |\n1 | use std::cmp::max;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp3xi7yh6s.rs:6:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max_so_far =\
    \ numbers[0];\n    result.push(max_so_far);\n    for n in numbers.iter().skip(1)\
    \ {\n        max_so_far = max_so_far.max(*n);\n        result.push(max_so_far);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp2xj0juy2.rs:7:26\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for &n in numbers.iter().skip(1) {\n        if n >\
    \ max {\n            max = n;\n        }\n        result.push(max);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpnihzb846.rs:7:19\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut ret = Vec::new();\n    let mut max = numbers[0];\n\
    \    ret.push(max);\n    for number in numbers.iter().skip(1) {\n        if *number\
    \ > max {\n            max = *number;\n        }\n        ret.push(max);\n   \
    \ }\n    ret\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp3uh97nb0.rs:7:19\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = 0;\n    let mut maxes = Vec::new();\n   \
    \ for number in numbers {\n        max = std::cmp::max(max, number);\n       \
    \ maxes.push(max);\n    }\n    maxes\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut result = vec![max];\n\
    \    for n in numbers.iter().skip(1) {\n        max = cmp::max(max, *n);\n   \
    \     result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \ --> /tmp/tmpz7ikfsbc.rs:9:15\n  |\n9 |         max = cmp::max(max, *n);\n  |\
    \               ^^^ use of undeclared crate or module `cmp`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for &number in numbers.iter().skip(1) {\n        max\
    \ = max.max(number);\n        result.push(max);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpwzyed978.rs:7:19\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut output = Vec::with_capacity(numbers.len());\n \
    \   if numbers.len() == 0 {\n        return output;\n    }\n    output.push(numbers[0]);\n\
    \    for n in numbers[1..].iter() {\n        output.push(cmp::max(output[output.len()\
    \ - 1], *n));\n    }\n    output\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpun3hiboa.rs:12:21\n   |\n12 |         output.push(cmp::max(output[output.len()\
    \ - 1], *n));\n   |                     ^^^ use of undeclared crate or module\
    \ `cmp`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_numbers = Vec::new();\n    let mut running_max\
    \ = numbers[0];\n    max_numbers.push(running_max);\n    for number in numbers.iter().skip(1)\
    \ {\n        if number > &running_max {\n            running_max = *number;\n\
    \        }\n        max_numbers.push(running_max);\n    }\n    max_numbers\n}\n\
    \nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpd5ltbd72.rs:7:27\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut rolling_max = Vec::with_capacity(numbers.len());\n\
    \    let mut current_max = isize::min_value();\n    for number in numbers {\n\
    \        if number > current_max {\n            current_max = number;\n      \
    \  }\n        rolling_max.push(current_max);\n    }\n    rolling_max\n}\n\nfn\
    \ main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    // Create a vector of the same size, to be filled with\
    \ maximum elements\n    let mut rolling_max: Vec<isize> = Vec::with_capacity(numbers.len());\n\
    \n    // Use the head of the list as the first element of the rolling maximum\n\
    \    rolling_max.push(numbers[0]);\n\n    // Iterate over all elements except\
    \ the first one, comparing them to\n    // the value pushed to rolling_max.\n\
    \    // Push the maximum value of the two to the rolling_max vector.\n    for\
    \ number in numbers.iter().skip(1) {\n        rolling_max.push(std::cmp::max(rolling_max[rolling_max.len()\
    \ - 1], *number));\n    }\n\n    rolling_max\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpqvf44_nb.rs:10:22\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    numbers\n        .into_iter()\n        .scan(None, |state,\
    \ x| {\n            let max = state.map_or(x, |s| cmp::max(s, x));\n         \
    \   *state = Some(max);\n            Some(max)\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \ --> /tmp/tmplgj_cmrs.rs:9:43\n  |\n9 |             let max = state.map_or(x,\
    \ |s| cmp::max(s, x));\n  |                                           ^^^ use\
    \ of undeclared crate or module `cmp`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = 0;\n  \
    \  for n in numbers {\n        max = std::cmp::max(max, n);\n        result.push(max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut current_max =\
    \ std::isize::MIN;\n    for n in numbers {\n        current_max = std::cmp::max(current_max,\
    \ n);\n        result.push(current_max);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut rolling_max: Vec<isize> = Vec::new();\n    let\
    \ mut max = std::isize::MIN;\n    for i in numbers {\n        if i > max {\n \
    \           max = i;\n        }\n        rolling_max.push(max);\n    }\n    rolling_max\n\
    }\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut rolling_max: Vec<isize> = Vec::new();\n    let\
    \ mut max_value = std::isize::MIN;\n    for number in numbers {\n        if number\
    \ > max_value {\n            max_value = number;\n        }\n        rolling_max.push(max_value);\n\
    \    }\n    rolling_max\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_numbers = Vec::new();\n    let mut max_value\
    \ = isize::min_value();\n    for num in numbers {\n        max_value = std::cmp::max(max_value,\
    \ num);\n        max_numbers.push(max_value);\n    }\n    max_numbers\n}\n\nfn\
    \ main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut maxes = Vec::with_capacity(numbers.len());\n  \
    \  let mut current_max = std::isize::MIN;\n    for &number in numbers.iter() {\n\
    \        current_max = current_max.max(number);\n        maxes.push(current_max);\n\
    \    }\n    maxes\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut current_max = numbers[0];\n    let mut result =\
    \ vec![current_max];\n\n    for i in numbers.iter().skip(1) {\n        current_max\
    \ = max(current_max, *i);\n        result.push(current_max);\n    }\n\n    result\n\
    }\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmppva112nm.rs:10:23\n\
    \   |\n10 |         current_max = max(current_max, *i);\n   |                \
    \       ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut rolling_max = vec![numbers[0]];\n    for i in numbers.iter().skip(1)\
    \ {\n        rolling_max.push(cmp::max(rolling_max.last().unwrap(), i));\n   \
    \ }\n    rolling_max\n}\n\nfn main() {\n    let candidate = rolling_max;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \ --> /tmp/tmpcnb2qimm.rs:8:26\n  |\n8 |         rolling_max.push(cmp::max(rolling_max.last().unwrap(),\
    \ i));\n  |                          ^^^ use of undeclared crate or module `cmp`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut rolling_max\
    \ = Vec::new();\n    rolling_max.push(max_so_far);\n\n    for i in 1..numbers.len()\
    \ {\n        max_so_far = cmp::max(max_so_far, numbers[i]);\n        rolling_max.push(max_so_far);\n\
    \    }\n\n    rolling_max\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpddzd0eco.rs:11:22\n   |\n11 |         max_so_far = cmp::max(max_so_far,\
    \ numbers[i]);\n   |                      ^^^ use of undeclared crate or module\
    \ `cmp`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max_till_now\
    \ = numbers[0];\n    result.push(max_till_now);\n    for n in numbers.iter().skip(1)\
    \ {\n        max_till_now = isize::max(max_till_now, *n);\n        result.push(max_till_now);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpeqxei980.rs:7:28\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut current_max =\
    \ isize::min_value();\n    for n in numbers {\n        if n > current_max {\n\
    \            current_max = n;\n        }\n        result.push(current_max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = std::isize::MIN;\n\
    \    for i in numbers {\n        if i > max {\n            max = i;\n        }\n\
    \        result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    if numbers.is_empty() {\n        return Vec::new();\n \
    \   }\n\n    let mut max_so_far = numbers[0];\n    let mut rolling_max = Vec::new();\n\
    \    rolling_max.push(max_so_far);\n\n    for number in numbers.iter().skip(1)\
    \ {\n        if number > &max_so_far {\n            max_so_far = *number;\n  \
    \      }\n        rolling_max.push(max_so_far);\n    }\n\n    rolling_max\n}\n\
    \nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = Vec::with_capacity(numbers.len());\n    let\
    \ mut current_max = 0;\n    for n in numbers {\n        current_max = std::cmp::max(current_max,\
    \ n);\n        max.push(current_max);\n    }\n    max\n}\n\nfn main() {\n    let\
    \ candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut rolling_max = vec![numbers[0]];\n    for n in numbers.iter().skip(1)\
    \ {\n        rolling_max.push(rolling_max.last().unwrap().max(*n));\n    }\n \
    \   rolling_max\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp__z_e92p.rs:8:58\n  |\n8 |\
    \         rolling_max.push(rolling_max.last().unwrap().max(*n));\n  |        \
    \                                                  ^^\n  |                   \
    \                                       |\n  |                               \
    \                           expected `&isize`, found `isize`\n  |            \
    \                                              help: consider borrowing here:\
    \ `&*n`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp__z_e92p.rs:8:26\n  |\n\
    8 |         rolling_max.push(rolling_max.last().unwrap().max(*n));\n  |      \
    \                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ `&isize`\n  |\nhelp: consider dereferencing the borrow\n  |\n8 |         rolling_max.push(*rolling_max.last().unwrap().max(*n));\n\
    \  |                          +\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut current_max =\
    \ numbers[0];\n    result.push(current_max);\n    for n in numbers.iter().skip(1)\
    \ {\n        current_max = std::cmp::max(current_max, *n);\n        result.push(current_max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpy_sbjxj4.rs:7:27\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut current_max =\
    \ numbers[0];\n    result.push(current_max);\n    for i in numbers.iter().skip(1)\
    \ {\n        current_max = std::cmp::max(current_max, *i);\n        result.push(current_max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpl52t99do.rs:7:27\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = 0;\n    let mut maxes = Vec::new();\n\
    \    for num in numbers {\n        max_so_far = max(max_so_far, num);\n      \
    \  maxes.push(max_so_far);\n    }\n    maxes\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n --> /tmp/tmpb34yc_0_.rs:9:22\n\
    \  |\n9 |         max_so_far = max(max_so_far, num);\n  |                    \
    \  ^^^ not found in this scope\n  |\nhelp: consider importing this function\n\
    \  |\n1 | use std::cmp::max;\n  |\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for &x in numbers.iter().skip(1) {\n        max =\
    \ max.max(x);\n        result.push(max);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpk5cmvsgm.rs:7:19\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut maxes = vec![];\n    let mut max = numbers[0];\n\
    \    for &number in numbers.iter() {\n        max = max.max(number);\n       \
    \ maxes.push(max);\n    }\n    maxes\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpjp4bw8qu.rs:7:19\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = numbers[0];\n    let mut rolling_max = vec![max];\n\
    \    for i in 1..numbers.len() {\n        max = max.max(numbers[i]);\n       \
    \ rolling_max.push(max);\n    }\n    rolling_max\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmplqrpzxfy.rs:6:19\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    numbers\n        .iter()\n        .scan(std::isize::MIN,\
    \ |max, x| {\n            if *x > *max {\n                *max = *x;\n       \
    \     }\n            Some(*max)\n        })\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut max = numbers[0];\n    result.push(max);\n    for i in 1..numbers.len()\
    \ {\n        if numbers[i] > max {\n            max = numbers[i];\n        }\n\
    \        result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp69drwiv2.rs:7:19\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    numbers\n        .iter()\n        .scan(isize::min_value(),\
    \ |state, item| {\n            if *item > *state {\n                *state = *item;\n\
    \            }\n            Some(*state)\n        })\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut candidate = std::isize::MIN;\n\
    \    for number in numbers {\n        if number > candidate {\n            candidate\
    \ = number;\n        }\n        result.push(candidate);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = std::isize::MIN;\n    let mut out = Vec::new();\n\
    \    for &n in numbers.iter() {\n        if n > max {\n            max = n;\n\
    \        }\n        out.push(max);\n    }\n    out\n}\n\nfn main() {\n    let\
    \ candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut mx = numbers[0];\n    let mut res = vec![];\n \
    \   for i in numbers {\n        mx = if i > mx { i } else { mx };\n        res.push(mx);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp7t68obdl.rs:6:18\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    if numbers.is_empty() {\n        return Vec::new();\n \
    \   }\n\n    let mut max = numbers[0];\n    let mut indices = vec![max];\n\n \
    \   for n in numbers.iter().skip(1) {\n        if n > &max {\n            max\
    \ = *n;\n        }\n        indices.push(max);\n    }\n\n    indices\n}\n\nfn\
    \ main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut rolling_max: Vec<isize> = Vec::new();\n    let\
    \ mut max_so_far = isize::min_value();\n    for number in numbers {\n        max_so_far\
    \ = max(max_so_far, number);\n        rolling_max.push(max_so_far);\n    }\n \
    \   rolling_max\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n --> /tmp/tmpdqtvrom8.rs:9:22\n\
    \  |\n9 |         max_so_far = max(max_so_far, number);\n  |                 \
    \     ^^^ not found in this scope\n  |\nhelp: consider importing this function\n\
    \  |\n1 | use std::cmp::max;\n  |\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut rolling_max = vec![];\n    let mut max = std::isize::MIN;\n\
    \    for i in numbers {\n        max = max.max(i);\n        rolling_max.push(max);\n\
    \    }\n    rolling_max\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_val = -1;\n    let mut numbers = numbers;\n\
    \    numbers.reverse();\n    for number in numbers.iter_mut() {\n        if *number\
    \ > max_val {\n            max_val = *number;\n        }\n        *number = max_val;\n\
    \    }\n    numbers.reverse();\n    numbers\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 4, 4, 4]`,\n right: `[1, 2, 3, 4]`', /tmp/tmp57hpuyu2.rs:22:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = isize::min_value();\n    let mut result\
    \ = Vec::with_capacity(numbers.len());\n    for x in numbers {\n        if x >\
    \ max_so_far {\n            max_so_far = x;\n        }\n        result.push(max_so_far);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut current_max = numbers[0];\n    result.push(current_max);\n    for\
    \ i in 1..numbers.len() {\n        current_max = current_max.max(numbers[i]);\n\
    \        result.push(current_max);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp_b52ffu1.rs:7:27\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = numbers[0];\n    let mut result =\
    \ vec![max_so_far];\n    for n in numbers[1..].iter() {\n        if *n > max_so_far\
    \ {\n            max_so_far = *n;\n        }\n        result.push(max_so_far);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpqyj8e40s.rs:6:26\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut max = 0;\n    for n in numbers {\n        max = std::cmp::max(max,\
    \ n);\n        result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = 0;\n    let mut result = Vec::new();\n\
    \    for n in numbers {\n        max_so_far = max(max_so_far, n);\n        result.push(max_so_far);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n --> /tmp/tmpybwjb0ib.rs:9:22\n\
    \  |\n9 |         max_so_far = max(max_so_far, n);\n  |                      ^^^\
    \ not found in this scope\n  |\nhelp: consider importing this function\n  |\n\
    1 | use std::cmp::max;\n  |\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_until_idx = Vec::with_capacity(numbers.len());\n\
    \    let mut current_max = isize::min_value();\n    for i in 0..numbers.len()\
    \ {\n        if numbers[i] > current_max {\n            current_max = numbers[i];\n\
    \        }\n        max_until_idx.push(current_max);\n    }\n    max_until_idx\n\
    }\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    numbers\n        .into_iter()\n        .scan(std::isize::MIN,\
    \ |max, x| {\n            *max = std::cmp::max(*max, x);\n            Some(*max)\n\
    \        })\n        .collect()\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_found_so_far = 0;\n    let mut rolling_max_list\
    \ = Vec::new();\n    for number in numbers {\n        max_found_so_far = if number\
    \ > max_found_so_far {\n            number\n        } else {\n            max_found_so_far\n\
    \        };\n        rolling_max_list.push(max_found_so_far);\n    }\n    rolling_max_list\n\
    }\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    if numbers.is_empty() {\n        return vec![];\n    }\n\
    \n    let first = numbers[0];\n    let mut max = first;\n    let mut result =\
    \ vec![first];\n\n    for n in numbers.iter().skip(1) {\n        max = if n >\
    \ &max {\n            *n\n        } else {\n            max\n        };\n    \
    \    result.push(max);\n    }\n\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut rolling_max: Vec<isize> = Vec::new();\n    let\
    \ mut current_max = std::isize::MIN;\n    for number in numbers {\n        current_max\
    \ = std::cmp::max(current_max, number);\n        rolling_max.push(current_max);\n\
    \    }\n    rolling_max\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = 0;\n    let mut max_values = Vec::new();\n\
    \    for i in numbers {\n        max_so_far = std::cmp::max(max_so_far, i);\n\
    \        max_values.push(max_so_far);\n    }\n    max_values\n}\n\nfn main() {\n\
    \    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    numbers\n        .iter()\n        .scan(None, |state, &item|\
    \ {\n            *state = match *state {\n                None => Some(item),\n\
    \                Some(last_max) => Some(std::cmp::max(last_max, item)),\n    \
    \        };\n            Some(state.unwrap())\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_until_now = numbers[0];\n    let mut result\
    \ = vec![max_until_now];\n    for &number in numbers.iter().skip(1) {\n      \
    \  if number > max_until_now {\n            max_until_now = number;\n        }\n\
    \        result.push(max_until_now);\n    }\n    result\n}\n\nfn main() {\n  \
    \  let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp4zz3a_04.rs:6:29\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    numbers\n        .iter()\n        .scan(isize::min_value(),\
    \ |max, x| {\n            *max = *max.max(x);\n            Some(*max)\n      \
    \  })\n        .collect()\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpq1iis98h.rs:9:29\n  |\n9 |\
    \             *max = *max.max(x);\n  |                             ^ types differ\
    \ in mutability\n  |\n  = note: expected mutable reference `&mut isize`\n    \
    \                 found reference `&isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut max_found = isize::min_value();\n\
    \    for i in numbers {\n        max_found = std::cmp::max(max_found, i);\n  \
    \      result.push(max_found);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut rolling_max: Vec<isize> = Vec::new();\n    for\
    \ number in numbers {\n        if rolling_max.is_empty() {\n            rolling_max.push(number);\n\
    \        } else {\n            rolling_max.push(max(rolling_max[rolling_max.len()\
    \ - 1], number));\n        }\n    }\n    rolling_max\n}\n\nfn main() {\n    let\
    \ candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpdpi3xfyu.rs:11:30\n\
    \   |\n11 |             rolling_max.push(max(rolling_max[rolling_max.len() - 1],\
    \ number));\n   |                              ^^^ not found in this scope\n \
    \  |\nhelp: consider importing this function\n   |\n1  | use std::cmp::max;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    numbers\n        .iter()\n        .scan(0, |state, &x|\
    \ {\n            *state = (*state).max(x);\n            Some(*state)\n       \
    \ })\n        .collect()\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut current_max = numbers[0];\n    let mut result =\
    \ vec![current_max];\n\n    for number in numbers.iter().skip(1) {\n        current_max\
    \ = isize::max(current_max, *number);\n        result.push(current_max);\n   \
    \ }\n\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpyc_67w8m.rs:6:27\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_so_far = -1;\n    let mut result = Vec::new();\n\
    \    for &number in numbers.iter() {\n        max_so_far = max(max_so_far, number);\n\
    \        result.push(max_so_far);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n --> /tmp/tmpwlwjzodw.rs:9:22\n\
    \  |\n9 |         max_so_far = max(max_so_far, number);\n  |                 \
    \     ^^^ not found in this scope\n  |\nhelp: consider importing this function\n\
    \  |\n1 | use std::cmp::max;\n  |\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut rolling_max = Vec::new();\n    let mut max = numbers[0];\n\
    \    rolling_max.push(max);\n    for number in numbers.iter().skip(1) {\n    \
    \    max = cmp::max(max, *number);\n        rolling_max.push(max);\n    }\n  \
    \  rolling_max\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmp_q0tg0mf.rs:10:15\n   |\n10 |         max = cmp::max(max, *number);\n\
    \   |               ^^^ use of undeclared crate or module `cmp`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max: isize = 0;\n    let mut result: Vec<isize>\
    \ = Vec::new();\n    for &number in numbers.iter() {\n        max = std::cmp::max(max,\
    \ number);\n        result.push(max);\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut rolling_max = isize::min_value();\n    for (i, n) in numbers.iter().enumerate()\
    \ {\n        rolling_max = max(rolling_max, *n);\n        result.push(rolling_max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n --> /tmp/tmpn393lgsn.rs:9:23\n\
    \  |\n9 |         rolling_max = max(rolling_max, *n);\n  |                   \
    \    ^^^ not found in this scope\n  |\nhelp: consider importing this function\n\
    \  |\n1 | use std::cmp::max;\n  |\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut current_max =\
    \ *numbers.first().unwrap();\n    for &number in numbers.iter() {\n        current_max\
    \ = std::cmp::max(current_max, number);\n        result.push(current_max);\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmpjowove_c.rs:7:44\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut max = std::isize::MIN;\n    for &number in numbers.iter() {\n    \
    \    max = max.max(number);\n        result.push(max);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut maxes = vec![];\n    for (i, num) in numbers.iter().enumerate()\
    \ {\n        if i == 0 {\n            maxes.push(*num);\n        } else {\n  \
    \          maxes.push(std::cmp::max(maxes[i - 1], *num));\n        }\n    }\n\
    \    maxes\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = isize::min_value();\n    let mut max_vec\
    \ = Vec::new();\n    for n in numbers {\n        max = max.max(n);\n        max_vec.push(max);\n\
    \    }\n    max_vec\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut rolling_max_list = Vec::new();\n    let mut rolling_max\
    \ = std::isize::MIN;\n    for num in numbers {\n        rolling_max = std::cmp::max(rolling_max,\
    \ num);\n        rolling_max_list.push(rolling_max);\n    }\n    rolling_max_list\n\
    }\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    numbers\n        .iter()\n        .scan(0, |state, &x|\
    \ {\n            *state = if x > *state { x } else { *state };\n            Some(*state)\n\
    \        })\n        .collect()\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max = 0;\n    let mut result = Vec::new();\n  \
    \  for num in numbers {\n        if num > max {\n            max = num;\n    \
    \    }\n        result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut res = Vec::with_capacity(numbers.len());\n    let\
    \ mut current_max = None;\n    for n in numbers {\n        match current_max {\n\
    \            None => current_max = Some(n),\n            Some(m) => current_max\
    \ = Some(std::cmp::max(m, n)),\n        }\n        res.push(current_max.unwrap());\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut rolling_max = Vec::new();\n    let mut maximum\
    \ = numbers[0];\n    rolling_max.push(maximum);\n    for x in numbers.iter().skip(1)\
    \ {\n        maximum = cmp::max(maximum, *x);\n        rolling_max.push(maximum);\n\
    \    }\n    rolling_max\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmphu7oc49w.rs:10:19\n   |\n10 |         maximum = cmp::max(maximum,\
    \ *x);\n   |                   ^^^ use of undeclared crate or module `cmp`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut max_elements = Vec::new();\n    let mut max_so_far\
    \ = numbers[0];\n    max_elements.push(max_so_far);\n    for i in 1..numbers.len()\
    \ {\n        if numbers[i] > max_so_far {\n            max_so_far = numbers[i];\n\
    \        }\n        max_elements.push(max_so_far);\n    }\n    max_elements\n\
    }\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpl21zdlz0.rs:7:26\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut current_max =\
    \ numbers[0];\n    result.push(current_max);\n    for next in numbers.iter().skip(1)\
    \ {\n        current_max = std::cmp::max(current_max, *next);\n        result.push(current_max);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
    \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n  \
    \  assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp4aq0sm2c.rs:7:27\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut rolling_max = Vec::with_capacity(numbers.len());\n\
    \    let mut current_max = 0;\n    for &number in numbers.iter() {\n        current_max\
    \ = std::cmp::max(current_max, number);\n        rolling_max.push(current_max);\n\
    \    }\n    rolling_max\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut maximums = vec![];\n    let mut maximum = numbers[0];\n\
    \    for (i, number) in numbers.iter().enumerate() {\n        if i == 0 {\n  \
    \          maximums.push(*number);\n        } else {\n            if number >\
    \ &maximum {\n                maximum = *number;\n            }\n            maximums.push(maximum);\n\
    \        }\n    }\n    maximums\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpe4s030e9.rs:7:23\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::with_capacity(numbers.len());\n \
    \   let mut max = numbers[0];\n    result.push(max);\n    for i in 1..numbers.len()\
    \ {\n        if numbers[i] > max {\n            max = numbers[i];\n        }\n\
    \        result.push(max);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]),\
    \ vec![3, 3, 3, 100, 100]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpmpcov8s4.rs:7:19\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>)\
    \ -> Vec<isize> {\n    numbers\n        .into_iter()\n        .scan(isize::min_value(),\
    \ |max, n| {\n            *max = n.max(*max);\n            Some(*max)\n      \
    \  })\n        .collect()\n}\n\nfn main() {\n    let candidate = rolling_max;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4,\
    \ 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100,\
    \ 100]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
