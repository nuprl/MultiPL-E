name: HumanEval_49_modp
language: rust
prompt: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n///\
  \ 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
  \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
  \ {\n"
tests: "}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5),\
  \ 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101),\
  \ 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101),\
  \ 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
  }\n"
completions: ["    let (p, n) = (p as i64, n as i64);\n    let mut m = 1;\n    let\
    \ mut x = n % p;\n    while n > 0 {\n        if n % 2 == 1 {\n            m =\
    \ (m * x) % p;\n        }\n        x = (x * x) % p;\n        n /= 2;\n    }\n\
    \    m as isize", "    let mut m = 1;\n    let mut i = 0;\n    while i < n {\n\
    \        m = (m * 2) % p;\n        i += 1;\n    }\n    m", "    let mut ret =\
    \ 1;\n    for _ in 0..n {\n        ret = (ret * 2) % p;\n    }\n    ret", "  \
    \  if n % p == 0 {\n        1\n    } else {\n        (2 * modp(n / 2, p)) % p\n\
    \    }", "    let mut result = 1;\n    for _ in 0..n {\n        result = (result\
    \ * 2) % p;\n    }\n    result", "    let mut res = 1;\n    let mut pwr = n;\n\
    \    while pwr > 0 {\n        if pwr % 2 == 1 {\n            res = (res * n) %\
    \ p;\n        }\n        n = (n * n) % p;\n        pwr /= 2;\n    }\n    res",
  "    let mut n = n;\n    let mut res = 1;\n    while n > 0 {\n        if n % 2 ==\
    \ 1 {\n            res = (res * n) % p;\n        }\n        n = n / 2;\n    }\n\
    \    res", "    if n == 0 {\n        return 1;\n    }\n    let mut r = modp(n\
    \ >> 1, p);\n    r = (r * r) % p;\n    if n & 1 == 1 {\n        r = (r * 2) %\
    \ p;\n    }\n    r", "    let mut n = n;\n    let mut res = 1;\n    while n >\
    \ 0 {\n        if n % 2 == 1 {\n            res = (res * n) % p;\n        }\n\
    \        n = n / 2;\n    }\n    res", "    if n == 0 {\n        return 1;\n  \
    \  }\n    let mut d = modp(n / 2, p);\n    d = (d * d) % p;\n    if n % 2 == 1\
    \ {\n        d = (d * 2) % p;\n    }\n    d", "    let mut ret = 1;\n    let mut\
    \ base = n;\n    let mut exp = p - 2;\n    while exp > 0 {\n        if exp % 2\
    \ == 1 {\n            ret = (ret * base) % p;\n        }\n        base = (base\
    \ * base) % p;\n        exp /= 2;\n    }\n    ret", "    if n == 0 {\n       \
    \ return 1;\n    }\n    if n % 2 == 0 {\n        return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n    }\n    return modp(n - 1, p) * modp(n, p) % p;", "    let\
    \ mut a = 1;\n    let mut exp = n;\n    let mut two = 2;\n    while exp > 0 {\n\
    \        if exp % 2 == 1 {\n            a = (a * two) % p;\n        }\n      \
    \  two = (two * two) % p;\n        exp /= 2;\n    }\n    a", "    let mut res\
    \ = 1;\n    let mut x = n;\n    let mut p = p;\n    while x > 0 {\n        if\
    \ x % 2 == 1 {\n            res = (res * n) % p;\n        }\n        x = x / 2;\n\
    \        n = (n * n) % p;\n    }\n    res", "    let mut res = 1;\n    let mut\
    \ n = n;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res *\
    \ n) % p;\n        }\n        n = n / 2;\n    }\n    res", "    let mut m = n;\n\
    \    let mut result = 1;\n    while m > 0 {\n        if m % 2 == 1 {\n       \
    \     result = (result * n) % p;\n        }\n        n = (n * n) % p;\n      \
    \  m = m / 2;\n    }\n    result", "    let mut n = n;\n    let mut res = 1;\n\
    \    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n) % p;\n\
    \        }\n        n = n / 2;\n    }\n    res", "    if n == 0 {\n        return\
    \ 1;\n    }\n\n    let mut k = n;\n    let mut a = 1;\n    let mut b = 0;\n  \
    \  let mut x = 1;\n    let mut y = 0;\n\n    while k > 0 {\n        let q = k\
    \ / 2;\n        let r = k % 2;\n        let temp = a;\n        a = (a * x + b\
    \ * y) % p;\n        b = (temp * y + b * x) % p;\n        k = q;\n        x =\
    \ x * x % p;\n        y = y * y % p;\n        if r == 1 {\n            temp =\
    \ a;\n            a = (a + b) % p;\n            b = (temp + b) % p;\n        \
    \    x = (x + y) % p;\n        }\n    }\n\n    a", "    let mut tmp: isize = n;\n\
    \    let mut res: isize = 1;\n    while tmp > 0 {\n        if tmp % 2 == 1 {\n\
    \            res = (res * n) % p;\n        }\n        n = (n * n) % p;\n     \
    \   tmp /= 2;\n    }\n    res", "    if n == 0 {\n        return 1;\n    }\n\n\
    \    let x = modp(n / 2, p);\n    let y = x * x % p;\n    if n % 2 == 0 {\n  \
    \      y\n    } else {\n        y * 2 % p\n    }", "    if n == 0 {\n        return\
    \ 1;\n    }\n\n    if n % 2 == 0 {\n        let a = modp(n / 2, p);\n        a\
    \ * a % p\n    } else {\n        let a = modp(n - 1, p);\n        a * n % p\n\
    \    }", "    if n == 0 {\n        return 1;\n    }\n    if n % 2 == 0 {\n   \
    \     let temp = modp(n / 2, p);\n        return (temp * temp) % p;\n    }\n \
    \   let temp = modp(n - 1, p);\n    return (temp * (n % p)) % p;", "    if n ==\
    \ 0 {\n        return 1;\n    }\n    if n == 1 {\n        return n;\n    }\n \
    \   let mut r = 1;\n    for _ in 0..n {\n        r = (r * 2) % p;\n    }\n   \
    \ r", "    let mut y = 1;\n    let mut b = n;\n    let mut x = p;\n    while b\
    \ > 0 {\n        if b % 2 == 1 {\n            y = (y * b) % x;\n        }\n  \
    \      b = b / 2;\n        x = (x * x) % p;\n    }\n    y", "    let mut res =\
    \ 1;\n    let mut n = n;\n    while n > 0 {\n        if n % 2 == 1 {\n       \
    \     res = (res * n) % p;\n        }\n        n = n / 2;\n    }\n    res", " \
    \   assert!(p > 0);\n    let mut res = 1;\n    let mut i = n;\n    let mut x =\
    \ 2;\n    while i > 0 {\n        if i % 2 == 1 {\n            res = (res * x)\
    \ % p;\n        }\n        x = (x * x) % p;\n        i = i / 2;\n    }\n    res",
  "    let mut result = 1;\n    let mut i = 0;\n    let mut two_i = 1;\n    while\
    \ i < n {\n        result = result * 2;\n        while result >= p {\n       \
    \     result = result - p;\n        }\n        i = i + 1;\n        two_i = two_i\
    \ * 2;\n    }\n    result", "    let res = if n == 0 {\n        1\n    } else\
    \ if n % 2 == 0 {\n        let tmp = modp(n / 2, p);\n        (tmp * tmp) % p\n\
    \    } else {\n        (2 * modp(n - 1, p)) % p\n    };\n    if res < 0 {\n  \
    \      res + p\n    } else {\n        res\n    }", "    let mut t = 1;\n    let\
    \ mut s = n;\n    while s > 0 {\n        if s % 2 == 1 {\n            t = (t *\
    \ n) % p;\n        }\n        n = (n * n) % p;\n        s /= 2;\n    }\n    t",
  "    if n == 0 {\n        return 1;\n    }\n\n    let mut n = n;\n    let mut ret\
    \ = 1;\n    while n > 0 {\n        if n % 2 == 1 {\n            ret = (ret * 2)\
    \ % p;\n        }\n        n /= 2;\n    }\n    ret", "    let mut r = 1;\n   \
    \ let mut x = n;\n    let mut i = p - 2;\n    while i > 0 {\n        while i %\
    \ 2 == 0 {\n            x = (x * x) % p;\n            i = i / 2;\n        }\n\
    \        r = (r * x) % p;\n        i = i - 1;\n    }\n    r", "    // ????\n \
    \   if n == 0 {\n        return 1;\n    }\n    let mut y = 1;\n    let mut x =\
    \ n;\n    while x > 1 {\n        if x % 2 == 0 {\n            x = x / 2;\n   \
    \         y = (y * y) % p;\n        } else {\n            x = x - 1;\n       \
    \     y = (y * y * n) % p;\n        }\n    }\n    y", '    (n % p + p) % p', " \
    \   if n == 0 {\n        return 1;\n    }\n    let mut i = n;\n    let mut result\
    \ = 2;\n    while i > 1 {\n        result = (result * 2) % p;\n        i -= 1;\n\
    \    }\n    result", "    // check if n is a power of 2:\n    if n == 1 || (n\
    \ & (n - 1)) == 0 {\n        return n % p;\n    }\n    let mut res = 1;\n    let\
    \ mut curr = 2;\n    let mut nn = n;\n    while nn > 0 {\n        if nn & 1 ==\
    \ 1 {\n            res = (res * curr) % p;\n        }\n        curr = (curr *\
    \ curr) % p;\n        nn >>= 1;\n    }\n    res", "    var a = 1;\n    var b =\
    \ n;\n    while b > 0 {\n        if b & 1 == 1 {\n            a = (a * n) % p;\n\
    \        }\n        b >>= 1;\n        n = (n * n) % p;\n    }\n    a", "    if\
    \ n < 0 {\n        p + modp(n, p)\n    } else if n == 0 {\n        1\n    } else\
    \ if n % 2 == 0 {\n        modp(n / 2, p) * modp(n / 2, p) % p\n    } else {\n\
    \        p * modp(n - 1, p) % p\n    }", "    let mut res = 1;\n    for _ in 0..n\
    \ {\n        res = res * 2 % p;\n    }\n    res", "    let n = n % p;\n    if\
    \ n < 0 {\n        n + p\n    } else {\n        n\n    }", "    let mut r = 1;\n\
    \    let mut b = n;\n    while b > 0 {\n        if b % 2 == 1 {\n            r\
    \ = (r * n) % p;\n        }\n        b = b / 2;\n        n = (n * n) % p;\n  \
    \  }\n    r", "    let mut res = 1;\n    let mut n = n;\n    let mut i = p - 2;\n\
    \    while i > 0 {\n        if i % 2 == 1 {\n            res = (res * n) % p;\n\
    \        }\n        n = (n * n) % p;\n        i /= 2;\n    }\n    res", "    let\
    \ mut r = 1;\n    let mut x = n;\n    let mut y = p;\n    while y > 0 {\n    \
    \    if y % 2 == 1 {\n            r = (r * x) % p;\n        }\n        y = y /\
    \ 2;\n        x = (x * x) % p;\n    }\n    r", "    if n == 0 {\n        return\
    \ 1;\n    }\n    let mut result = 1;\n    let mut t = 2;\n    let mut k = n %\
    \ (p - 1);\n    while k > 0 {\n        if k % 2 == 1 {\n            result = (result\
    \ * t) % p;\n        }\n        t = (t * t) % p;\n        k /= 2;\n    }\n   \
    \ result", "    let mut n = n % p;\n    let mut res = 1;\n    for _ in 0..n {\n\
    \        res = (res * 2) % p;\n    }\n    res", "    let r = pow(2, n) % p;\n\
    \    assert!(r >= 0, \"Not a positive number!\");\n    r", "    assert!(n > 0);\n\
    \    assert!(p > 1);\n    let mut r = 1;\n    let mut n = n;\n    while n > 0\
    \ {\n        if n % 2 == 1 {\n            r = (r * n) % p;\n        }\n      \
    \  n = n / 2;\n    }\n    r", "    let mut res = 1;\n    let mut base = n;\n \
    \   while base > 0 {\n        if base & 1 == 1 {\n            res = (res * n)\
    \ % p;\n        }\n        base >>= 1;\n        n = (n * n) % p;\n    }\n    res",
  "    let mut i = 1;\n    let mut j = n;\n    while j >= p {\n        j = n % p;\n\
    \        n = n / p;\n    }\n    i * j", "    let mut x = 1;\n    let mut p = p\
    \ as usize;\n    let mut n = n as usize;\n    while n > 0 {\n        if n % 2\
    \ == 1 {\n            x = (x * p) % MODP;\n        }\n        p = (p * p) % MODP;\n\
    \        n = n / 2;\n    }\n    x as isize", "    let mut r = 1;\n    let mut\
    \ b = n;\n    while b > 0 {\n        if b % 2 == 1 {\n            r = (r * n)\
    \ % p;\n        }\n        b /= 2;\n        n = (n * n) % p;\n    }\n    r", " \
    \   let mut n = n;\n    let mut m = 1;\n    while n > 0 {\n        if n % 2 ==\
    \ 1 {\n            m = (m * n) % p;\n        }\n        n = n / 2;\n    }\n  \
    \  m", "    let mut m = n;\n    let mut r = 1;\n    while m > 0 {\n        if\
    \ m % 2 == 1 {\n            r = (r * n) % p;\n        }\n        n = (n * n) %\
    \ p;\n        m /= 2;\n    }\n    r", "    let mut ans = 1;\n    let mut k = n;\n\
    \    let mut x = 2;\n    while k > 0 {\n        if k % 2 == 1 {\n            ans\
    \ = (ans * x) % p;\n        }\n        k = k / 2;\n        x = (x * x) % p;\n\
    \    }\n    ans", "    if n < 0 {\n        modp(n % p + p, p)\n    } else if n\
    \ == 0 {\n        1\n    } else if n == 1 {\n        n\n    } else if n % 2 ==\
    \ 0 {\n        modp(n * n, p) % p\n    } else {\n        n * modp(n - 1, p) %\
    \ p\n    }", "    let mut ret = 1;\n    let mut b = n;\n    while b > 0 {\n  \
    \      if b % 2 == 1 {\n            ret = (ret * n) % p;\n        }\n        b\
    \ /= 2;\n        n = (n * n) % p;\n    }\n    ret", "    if n == 0 {\n       \
    \ return 1;\n    }\n    let r = modp(n / 2, p);\n    let mut rr = (r * r) % p;\n\
    \    if n % 2 == 1 {\n        rr = (rr * 2) % p;\n    }\n    return rr;", "  \
    \  let n = n as f64;\n    let p = p as f64;\n    let (p1, p2) = (p.ceil() / 2.0,\
    \ p.floor() / 2.0);\n    let result = (2_f64.powf(n) - 1_f64).rem_euclid(p);\n\
    \    if result < p2 {\n        result\n    } else {\n        result - p\n    }",
  "    if n == 0 {\n        return 1;\n    }\n    if n % 2 == 0 {\n        let tmp\
    \ = modp(n / 2, p);\n        return tmp * tmp % p;\n    }\n    modp(n - 1, p)\
    \ * n % p", "    let mut res = 1;\n    let mut pow = n;\n    let mut b = 2;\n\
    \    while pow > 0 {\n        if pow % 2 == 1 {\n            res = (res * b) %\
    \ p;\n        }\n        pow = pow / 2;\n        b = (b * b) % p;\n    }\n   \
    \ res", "    let mut res = 1;\n    let mut x = n;\n    let mut y = p;\n    while\
    \ x > 0 {\n        if x % 2 == 1 {\n            res = (res * y) % p;\n       \
    \ }\n        x /= 2;\n        y = (y * y) % p;\n    }\n    res", "    if n ==\
    \ 0 {\n        return 1;\n    }\n\n    let mut res = 1;\n    let mut d = 2;\n\
    \    while d <= n {\n        res = (res * d) % p;\n        d *= 2;\n    }\n\n\
    \    res", "    if n == 0 {\n        return 1;\n    }\n\n    let mut f = modp(n\
    \ / 2, p);\n    f = f * f % p;\n    if n % 2 == 1 {\n        f = f * 2 % p;\n\
    \    }\n    f", "    let mut d: isize = 1;\n    let mut k: isize = 0;\n    while\
    \ (1 << k) <= n {\n        k += 1;\n    }\n    for i in 0..k {\n        d = (d\
    \ * d) % p;\n        if ((n >> i) & 1) == 1 {\n            d = (d * 2) % p;\n\
    \        }\n    }\n    d", "    let mut n = n;\n    let mut res = 1;\n    let\
    \ mut base = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            res =\
    \ (res * base) % p;\n        }\n        base = (base * base) % p;\n        n /=\
    \ 2;\n    }\n    res", "    if n == 0 {\n        return 1;\n    }\n    if n %\
    \ 2 == 0 {\n        let a = modp(n / 2, p);\n        return a * a % p;\n    }\n\
    \    let a = modp(n - 1, p);\n    return a * n % p;", "    let n: isize = if n\
    \ < 0 { n + p } else { n };\n    if n == 0 {\n        return 1;\n    } else if\
    \ n == 1 {\n        return n;\n    }\n    let m = if n % 2 == 0 { modp(n / 2,\
    \ p) } else { modp(n - 1, p) };\n    let m = m * m % p;\n    if n % 2 == 0 {\n\
    \        m\n    } else {\n        m * n % p\n    }", "    if n == 0 {\n      \
    \  return 1;\n    }\n    let mut _n = n;\n    let mut _p = p;\n    let mut res\
    \ = 1;\n    while _n > 0 {\n        if _n % 2 == 1 {\n            res = (res *\
    \ _p) % INT_OVERFLOW;\n        }\n        _p = (_p * _p) % INT_OVERFLOW;\n   \
    \     _n = _n / 2;\n    }\n    res", "    // TODO\n    0", "    if n == 0 {\n\
    \        return 1;\n    }\n    if n == 1 {\n        return n;\n    }\n    modp(n\
    \ / 2, p) * modp(n - n / 2, p) % p", "    if n == 0 {\n        return 1;\n   \
    \ }\n    let mut s = modp(n / 2, p);\n    s = (s * s) % p;\n    if n % 2 == 1\
    \ {\n        s = (s * 2) % p;\n    }\n    return s;", "    let mut b = 1;\n  \
    \  let mut x = n;\n    while x > 0 {\n        if x % 2 == 1 {\n            b =\
    \ (b * n) % p;\n        }\n        x /= 2;\n        n = (n * n) % p;\n    }\n\
    \    b", "    let two = BigUint::from(2u8);\n    let n = BigUint::from(n);\n \
    \   let p = BigUint::from(p);\n    let pow = n.modpow(&two, &p);\n    match pow.to_str_radix(10)\
    \ {\n        Ok(s) => s.parse::<isize>().unwrap(),\n        Err(_) => panic!(\"\
    No parse\"),\n    }", "    if n == 0 {\n        return 1;\n    }\n\n    if n %\
    \ 2 == 0 {\n        modp(n / 2, p) * modp(n / 2, p) % p\n    } else {\n      \
    \  n * modp(n - 1, p) % p\n    }", "    let (mut n, mut p) = (n, p);\n    let\
    \ mut res = 1;\n    while n > 0 {\n        if n % 2 == 1 {\n            res =\
    \ (res * p) % MODULO;\n        }\n        n = n / 2;\n        p = (p * p) % MODULO;\n\
    \    }\n    res", "    let mut n = n;\n    let mut res = 1;\n    let mut s = p\
    \ - 2;\n    let mut t = n;\n    while s > 0 {\n        if s % 2 == 1 {\n     \
    \       res = (res * t) % p;\n        }\n        t = (t * t) % p;\n        s /=\
    \ 2;\n    }\n    res", "    // let m = n % p;\n    // if m < 0 {\n    //     m\
    \ + p\n    // } else {\n    //     m\n    // }\n    n % p", "    let mut d = n;\n\
    \    let mut r = 1;\n    while d > 0 {\n        if d % 2 == 1 {\n            r\
    \ = (r * n) % p;\n        }\n        d = d / 2;\n        n = (n * n) % p;\n  \
    \  }\n    r", "    let mut result = 1;\n    let mut base = n;\n    let mut exponent\
    \ = p;\n    while exponent > 0 {\n        if exponent % 2 == 1 {\n           \
    \ result = (result * base) % p;\n        }\n        exponent >>= 1;\n        base\
    \ = (base * base) % p;\n    }\n    result", "    // O(log n)\n    let mut r =\
    \ 1;\n    let mut b = n;\n    let mut p = p;\n    while b > 0 {\n        if b\
    \ % 2 == 1 {\n            r = (r * n) % p;\n        }\n        b = b / 2;\n  \
    \      n = (n * n) % p;\n    }\n    r", "    let mut result = 1;\n    let mut\
    \ base = n;\n    let mut exp = p;\n    while exp > 0 {\n        if exp % 2 ==\
    \ 1 {\n            result = (result * base) % p;\n        }\n        exp = exp\
    \ >> 1;\n        base = (base * base) % p;\n    }\n    result", "    let mut res\
    \ = 1;\n    let mut n = n;\n    while n > 0 {\n        if n % 2 == 1 {\n     \
    \       res = (res * n) % p;\n        }\n        n = n / 2;\n    }\n    res",
  "    let mut s = 1;\n    let mut m = n;\n    while m > 0 {\n        if m % 2 ==\
    \ 1 {\n            s = (s * n) % p;\n        }\n        n = (n * n) % p;\n   \
    \     m = m / 2;\n    }\n    s", "    if n == 0 {\n        return 1;\n    }\n\n\
    \    if n % 2 == 0 {\n        let half_result = modp(n / 2, p);\n        return\
    \ (half_result * half_result) % p;\n    } else {\n        return (modp(n - 1,\
    \ p) * n) % p;\n    }", "    if n == 0 {\n        return 1;\n    }\n    if n %\
    \ 2 == 0 {\n        let t = modp(n / 2, p);\n        return t * t % p;\n    }\n\
    \    return n * modp(n - 1, p) % p;", "    let mut ret = 1;\n    for _ in 0..n\
    \ {\n        ret = (ret * 2) % p;\n    }\n    ret", "    let mut r = 1;\n    let\
    \ mut k = n;\n    let mut a = 2;\n    while k > 0 {\n        if k % 2 == 1 {\n\
    \            r = (r * a) % p;\n        }\n        k = k / 2;\n        a = (a *\
    \ a) % p;\n    }\n    r", "    let mut n = n % p;\n    let mut nn = n;\n    let\
    \ mut out = 1;\n    while nn > 0 {\n        if nn % 2 == 1 {\n            out\
    \ = (out * n) % p;\n        }\n        n = (n * n) % p;\n        nn /= 2;\n  \
    \  }\n    out", "    let mut res = 1;\n    let mut num = n;\n    let mut p = p;\n\
    \    while num > 0 {\n        if num % 2 == 1 {\n            res = (res * p) %\
    \ 101;\n        }\n        p = (p * p) % 101;\n        num /= 2;\n    }\n    res",
  "    if n == 0 {\n        return 1;\n    }\n\n    if n % 2 == 0 {\n        modp(n\
    \ / 2, p) * modp(n / 2, p) % p\n    } else {\n        n * modp(n - 1, p) % p\n\
    \    }", "    // Return 2^n modulo p (be aware of numerics).\n    match n {\n\
    \        0 => 1,\n        n => {\n            let (result, _) = powmod(2, n, p);\n\
    \            result\n        }\n    }", "    if n == 0 {\n        return 1;\n\
    \    }\n    if n == 1 {\n        return n;\n    }\n    if n % 2 == 0 {\n     \
    \   let nh = modp(n / 2, p);\n        nh * nh % p\n    } else {\n        n * modp(n\
    \ - 1, p) % p\n    }", "    let mut res = 1;\n    let mut base = n;\n    let mut\
    \ pot = p - 2;\n    while pot > 0 {\n        if pot % 2 == 1 {\n            res\
    \ = (res * base) % p;\n        }\n        base = (base * base) % p;\n        pot\
    \ /= 2;\n    }\n    res", "    let mut n = n;\n    let mut ret = 1;\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            ret = (ret * p) % MOD;\n     \
    \   }\n        n /= 2;\n        p = (p * p) % MOD;\n    }\n    ret", "    if n\
    \ == 0 {\n        return 1;\n    }\n    if n == 1 {\n        return n;\n    }\n\
    \    let mut answer = 1;\n    let mut base = n;\n    let mut exponent = p - 2;\n\
    \    while exponent > 0 {\n        if exponent % 2 == 1 {\n            answer\
    \ = (answer * base) % p;\n        }\n        base = (base * base) % p;\n     \
    \   exponent /= 2;\n    }\n    answer", "    let mut ret = 1;\n    let mut n =\
    \ n;\n    while n > 0 {\n        if n % 2 == 1 {\n            ret = (ret * n)\
    \ % p;\n        }\n        n = n / 2;\n    }\n    ret", "    assert!(n >= 0);\n\
    \    assert!(p > 0);\n    let mut res = 1;\n    let mut base = n;\n    while base\
    \ > 0 {\n        if base & 1 == 1 {\n            res = res * n % p;\n        }\n\
    \        base >>= 1;\n        n = n * n % p;\n    }\n    res", "    let mut n\
    \ = n;\n    let mut result = 1;\n    while n > 0 {\n        if n % 2 == 1 {\n\
    \            result = (result * n) % p;\n        }\n        n = n / 2;\n    }\n\
    \    result", "    let mut r = 1;\n    let mut x = n;\n    let mut y = p;\n  \
    \  while y > 0 {\n        if y % 2 == 1 {\n            r = (r * x) % p;\n    \
    \    }\n        y /= 2;\n        x = (x * x) % p;\n    }\n    r", "    // 2^(2^x)\
    \ mod p\n    let twos: Vec<isize> = (0..p)\n        .map(|x| modpow(2, x, p))\n\
    \        .collect();\n    // 2^(2^(2^x)) mod p\n    let twos_twos: Vec<isize>\
    \ = twos\n        .iter()\n        .map(|x| twos[(*x - 1) as usize])\n       \
    \ .collect();\n    // 2^(2^(2^(2^x))) mod p\n    let twos_twos_twos: Vec<isize>\
    \ = twos_twos\n        .iter()\n        .map(|x| twos_twos[(*x - 1) as usize])\n\
    \        .collect();\n    // 2^(2^(2^(2^(2^x)))) mod p\n    let twos_twos_twos_twos:\
    \ Vec<isize> = twos_twos_twos\n        .iter()\n        .map(|x| twos_twos_twos[(*x\
    \ - 1) as usize])\n        .collect();\n    // 2^(2^(2^(2^(2^(2^x))))) mod p\n\
    \    let twos_twos_twos_twos_twos: Vec<isize> = twos_twos_twos_twos\n        .iter()\n\
    \        .map(|x| twos_twos_twos_twos[(*x - 1) as usize])\n        .collect();\n\
    \    // 2^(2^(2^(2^(2^(2^(2^x)))))) mod p\n    let twos_twos_twos_twos_twos_twos:\
    \ Vec<isize> = twos_twos_twos_twos_twos\n        .iter()\n        .map(|x| twos_twos_twos_twos_twos[(*x\
    \ - 1) as usize])\n        .collect();\n    // 2^(2^(2^(2^(2^(2^(2^(2^x))))",
  "    let mut r = 1;\n    let mut x = n;\n    while x > 0 {\n        if x % 2 ==\
    \ 1 {\n            r = (r * n) % p;\n        }\n        x /= 2;\n        n = (n\
    \ * n) % p;\n    }\n    r", "    let mut res = 1;\n    let mut modp = n % p;\n\
    \    let mut mult = modp;\n    for _ in 1..32 {\n        if (res & 1) == 1 {\n\
    \            res = (res * mult) % p;\n        }\n        mult = (mult * mult)\
    \ % p;\n        res = res >> 1;\n    }\n    return res;", "    if n < 0 {\n  \
    \      modp(p as isize - (-n % p), p)\n    } else {\n        let mut res = 1;\n\
    \        let mut k = n;\n        let mut y = 2;\n        while k > 0 {\n     \
    \       if k % 2 == 1 {\n                res = (res * y) % p;\n            }\n\
    \            y = (y * y) % p;\n            k /= 2;\n        }\n        res\n \
    \   }", "    let two = 2;\n    // modulo p of 2^n\n    fn modp_rec(n: isize, m:\
    \ isize, p: isize) -> isize {\n        if n == 0 {\n            return m;\n  \
    \      } else {\n            let m2 = m * m;\n            let m2 = m2 % p;\n \
    \           return modp_rec(n - 1, m2, p);\n        }\n    }\n    return modp_rec(n,\
    \ two, p);", "    let mut r = 1;\n    let mut x = n;\n    while x > 0 {\n    \
    \    if x % 2 == 1 {\n            r = (r * n) % p;\n        }\n        x /= 2;\n\
    \        n = (n * n) % p;\n    }\n    r", "    if n == 0 {\n        return 1;\n\
    \    }\n\n    let mut res = modp(n / 2, p);\n    res = (res * res) % p;\n\n  \
    \  if n % 2 == 1 {\n        res = (res * n) % p;\n    }\n\n    res", "    if n\
    \ == 0 {\n        return 1;\n    }\n    let mut res = modp(n / 2, p);\n    res\
    \ = (res * res) % p;\n    if n % 2 == 1 {\n        res = (res * 2) % p;\n    }\n\
    \    res", "    if n == 0 {\n        return 1;\n    }\n\n    let mut a = 1;\n\
    \    let mut b = n;\n    while b != 0 {\n        if b % 2 == 1 {\n           \
    \ a = (a * n) % p;\n        }\n        b /= 2;\n        n = (n * n) % p;\n   \
    \ }\n    a", "    let mut n = n;\n    let mut result = 1;\n    let mut m = n %\
    \ p;\n    n = n / p;\n    while n > 0 {\n        result = (result * m) % p;\n\
    \        m = (m * m) % p;\n        n = n / 2;\n    }\n    result", "    if n %\
    \ p == 0 {\n        return 1;\n    }\n    let mut i = 0;\n    let mut res = 1;\n\
    \    while i < n {\n        res = (res * 2) % p;\n        i += 1;\n    }\n   \
    \ res", "    if n == 0 {\n        return 1;\n    }\n    if n % 2 == 0 {\n    \
    \    let t = modp(n / 2, p);\n        return t * t % p;\n    }\n    modp(n - 1,\
    \ p) * n % p", "    // (n mod p)\n    let mut n = n % p;\n    // fast exponentiation\n\
    \    let mut result = 1;\n    while n > 0 {\n        // (n & 1) == (n % 2)\n \
    \       if n & 1 == 1 {\n            result = (result * result) % p;\n       \
    \ }\n        n >>= 1;\n    }\n    result", "    let mut result = 1;\n    for _\
    \ in 0..n {\n        result = (result * 2) % p;\n    }\n    result", "    if n\
    \ == 0 {\n        return 1;\n    }\n    if n % 2 == 0 {\n        let result =\
    \ modp(n / 2, p);\n        return (result * result) % p;\n    }\n    return (n\
    \ * modp(n - 1, p)) % p;", "    let mut n = n;\n    let mut r = 1;\n    let mut\
    \ s = 0;\n    loop {\n        let q = n / p;\n        r = (r * (n - p * q)) %\
    \ p;\n        if r == 0 {\n            return 0;\n        }\n        s += 1;\n\
    \        if q == 0 {\n            return r;\n        }\n        n = q;\n    }",
  "    let mut m = n;\n    let mut b = 1;\n    let mut e = p - 2;\n    while e > 0\
    \ {\n        if e % 2 == 1 {\n            b = (b * m) % p;\n        }\n      \
    \  m = (m * m) % p;\n        e = e / 2;\n    }\n    b", "    let mut n = n;\n\
    \    let mut res = 1;\n    let mut base = 2;\n    while n > 0 {\n        if n\
    \ % 2 == 1 {\n            res = res * base % p;\n        }\n        base = base\
    \ * base % p;\n        n = n / 2;\n    }\n    res", "    let mut n = n % p;\n\
    \    if n < 0 {\n        n += p;\n    }\n    if n < 0 {\n        panic!(\"Numerics\
    \ for modp were not good enough.\")\n    }\n    n", "    if n == 0 {\n       \
    \ return 1;\n    }\n    // Maximum number of steps is n.\n    let steps = std::cmp::min(n,\
    \ p - 2);\n    let mut res = 2;\n    for _ in 0..steps {\n        res = res *\
    \ 2 % p;\n    }\n    res", "    assert!(p > 0);\n    let mut n = n;\n    let mut\
    \ res = 1;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res\
    \ * n) % p;\n        }\n        n = n / 2;\n        n = (n * n) % p;\n    }\n\
    \    res", "    let mut res = 1;\n    let mut n = n;\n    let mut p = p;\n   \
    \ while n > 0 {\n        if n % 2 == 1 {\n            res = (res * n) % p;\n \
    \       }\n        n = n / 2;\n        p = (p * p) % 101;\n    }\n    res", " \
    \   let mut result = 1;\n    let mut current = n;\n    while current > 0 {\n \
    \       if current % 2 == 1 {\n            result = (result * n) % p;\n      \
    \  }\n        current = current / 2;\n        n = (n * n) % p;\n    }\n    result",
  "    if n == 0 {\n        return 1;\n    }\n    if n == 1 {\n        return n;\n\
    \    }\n    let mut res = modp(n / 2, p);\n    res = (res * res) % p;\n    if\
    \ n % 2 == 1 {\n        res = (res * n) % p;\n    }\n    res", "    var a = 1;\n\
    \    for _ in 0..n {\n        a = (a * 2) % p;\n    }\n    a", "    assert!(p\
    \ > 0);\n    if n == 0 {\n        return 1;\n    }\n    let mut m = modp(n / 2,\
    \ p);\n    m = (m * m) % p;\n    if n % 2 == 1 {\n        m = (m * 2) % p;\n \
    \   }\n    return m;", "    if n == 0 {\n        return 1;\n    }\n    if n %\
    \ 2 == 0 {\n        let n2 = modp(n / 2, p);\n        return (n2 * n2) % p;\n\
    \    }\n    let n1 = modp(n - 1, p);\n    return (n1 * n) % p;", "    if n ==\
    \ 0 {\n        return 1;\n    }\n    let mut res = 1;\n    let mut k = 1;\n  \
    \  while k <= n {\n        res = res * 2 % p;\n        k = k + 1;\n    }\n   \
    \ res", "    if n < 0 {\n        return modp(-n, p);\n    }\n    let mut r = 1;\n\
    \    let mut n = n;\n    while n > 0 {\n        if n % 2 == 1 {\n            r\
    \ = (r * 2) % p;\n        }\n        n /= 2;\n    }\n    r", "    let mut res\
    \ = 1;\n    let mut mult = n;\n    while mult > 0 {\n        if mult % 2 == 1\
    \ {\n            res = (res * n) % p;\n        }\n        mult = mult / 2;\n \
    \       n = (n * n) % p;\n    }\n    res", "    // ToDo: because of the numerics,\
    \ the current implementation is not correct\n    // for large numbers.\n\n   \
    \ // Special case: modulo 1 is always 0.\n    if p == 1 {\n        return 0;\n\
    \    }\n\n    // n: number to exponentiate\n    // p: modulo\n    // x: current\
    \ power of n\n    // m: current number (x * n)\n    let mut n = n;\n    let mut\
    \ p = p;\n    let mut x = 1;\n    let mut m = n;\n\n    // Because we are calculating\
    \ modulo p,\n    // we only need to calculate modulo p - 1.\n    // We stop as\
    \ soon as we get a multiple of p - 1.\n    // Because (p - 1) * (p - 1) = p\xB2\
    \ - 2p + 1 = 1 mod p,\n    // we can use p\xB2 - 2p + 1 as stop criterion.\n \
    \   while m != p - 1 {\n        m = (m * n) % p;\n        x = x + 1;\n    }\n\n\
    \    x", "    assert!(p > 1);\n    let mut result = 1;\n    for _ in 0..n {\n\
    \        result = (result * 2) % p;\n    }\n    result", "    if n == 0 {\n  \
    \      return 1;\n    }\n\n    let mut result = 1;\n    let mut factor = n;\n\
    \    let mut pow = p - 2;\n\n    while pow > 0 {\n        if pow % 2 == 1 {\n\
    \            result = (result * factor) % p;\n        }\n        factor = (factor\
    \ * factor) % p;\n        pow = pow / 2;\n    }\n\n    result", "    if n == 0\
    \ {\n        return 1;\n    }\n    if n % 2 == 0 {\n        return modp(n / 2,\
    \ p) * modp(n / 2, p) % p;\n    }\n    return modp(n - 1, p) * modp(n / 2, p)\
    \ % p;", "    if n == 0 {\n        return 1;\n    }\n    if n % 2 == 0 {\n   \
    \     modp(n / 2, p) * modp(n / 2, p) % p\n    } else {\n        n * modp(n -\
    \ 1, p) % p\n    }", "    let mut ln: isize = n;\n    let mut lp: isize = p;\n\
    \    let mut pow: isize = 1;\n    let mut rem: isize = 1;\n    while ln > 0 {\n\
    \        if ln % 2 == 1 {\n            rem = (rem * pow) % lp;\n        }\n  \
    \      pow = (pow * pow) % lp;\n        ln = ln / 2;\n    }\n    rem", "    let\
    \ mut base = 1;\n    let mut tmp = n;\n    while tmp > 0 {\n        if tmp % 2\
    \ == 1 {\n            base = (base * n) % p;\n        }\n        n = (n * n) %\
    \ p;\n        tmp /= 2;\n    }\n    base", "    if n == 0 {\n        return 1;\n\
    \    }\n    let mut res = modp(n / 2, p);\n    res = (res * res) % p;\n    if\
    \ n % 2 == 1 {\n        res = (res * 2) % p;\n    }\n    res", "    let mut n\
    \ = n;\n    let mut r = 1;\n    while n > 0 {\n        if n % 2 == 1 {\n     \
    \       r = (r * n) % p;\n        }\n        n = n / 2;\n    }\n    r", "    let\
    \ mut n = n;\n    let mut ret = 1;\n    while n > 0 {\n        if n % 2 == 1 {\n\
    \            ret = (ret * 2) % p;\n        }\n        n /= 2;\n    }\n    ret",
  "    if n == 0 {\n        return 1;\n    }\n    if n == 1 {\n        return n;\n\
    \    }\n    let mut n = n;\n    let mut res = 1;\n    while n > 0 {\n        if\
    \ n % 2 == 1 {\n            res = (res * n) % p;\n        }\n        n = n / 2;\n\
    \        n = (n * n) % p;\n    }\n    res", "    let mut acc = 1;\n    let mut\
    \ base = n;\n    let mut exp = p - 2;\n    while exp > 0 {\n        if exp % 2\
    \ == 1 {\n            acc = (acc * base) % p;\n        }\n        base = (base\
    \ * base) % p;\n        exp = exp / 2;\n    }\n    acc", "    if n == 0 {\n  \
    \      return 1;\n    }\n    let mut r: isize = 1;\n    let mut nn = n;\n    while\
    \ nn > 0 {\n        if nn % 2 == 1 {\n            r = (r * n) % p;\n        }\n\
    \        nn /= 2;\n        n = (n * n) % p;\n    }\n    r", "    let mut n = n\
    \ % p;\n    if n < 0 {\n        n += p;\n    }\n    n", "    if n == 0 {\n   \
    \     return 1;\n    }\n    let mut k = modp(n / 2, p);\n    k = (k * k) % p;\n\
    \    if n % 2 == 1 {\n        k = (k * (n % p)) % p;\n    }\n    k", "    let\
    \ mut pow = 1;\n    let mut i = 0;\n    while i < n {\n        pow = (pow * 2)\
    \ % p;\n        i += 1;\n    }\n    pow", "    if n == 0 {\n        return 1;\n\
    \    }\n    if n % 2 == 0 {\n        let temp = modp(n / 2, p);\n        return\
    \ (temp * temp) % p;\n    }\n    return (modp(n - 1, p) * (n % p)) % p;", "  \
    \  let mut r = 1;\n    let mut t = 2;\n    let mut i = n;\n    while i > 0 {\n\
    \        if i % 2 == 1 {\n            r = (r * t) % p;\n        }\n        t =\
    \ (t * t) % p;\n        i = i / 2;\n    }\n    r", "    if n == 0 {\n        return\
    \ 1;\n    }\n    let mut i = 0;\n    let mut res = 1;\n    while i < n.abs() {\n\
    \        res = (res * 2) % p;\n        i += 1;\n    }\n    res", "    let mut\
    \ res = 1;\n    let mut tmp = n;\n    while tmp > 0 {\n        if tmp % 2 == 1\
    \ {\n            res = (res * n) % p;\n        }\n        n = (n * n) % p;\n \
    \       tmp /= 2;\n    }\n    res", "    let mut n = n;\n    let mut r = 1;\n\
    \    while n > 0 {\n        if n % 2 == 1 {\n            r = (r * 2) % p;\n  \
    \      }\n        n /= 2;\n    }\n    r", "    if n == 0 {\n        return 1;\n\
    \    }\n    let mut result = modp(n / 2, p);\n    result = result * result % p;\n\
    \    if n % 2 == 1 {\n        result = result * 2 % p;\n    }\n    result", " \
    \   let one = match n % p {\n        0 => 1,\n        r => r,\n    };\n    let\
    \ mut result = one;\n    for _ in 0..n {\n        result = (result * 2) % p;\n\
    \    }\n    result", "    let mut r = 1;\n    let mut x = n;\n    while x > 0\
    \ {\n        if x % 2 == 1 {\n            r = (r * n) % p;\n        }\n      \
    \  x = x / 2;\n        n = (n * n) % p;\n    }\n    r", "    // TODO: implement\
    \ modp\n    0", "    if n == 0 {\n        return 1;\n    }\n    if n == 1 {\n\
    \        return n;\n    }\n    if n % 2 == 0 {\n        let val = modp(n / 2,\
    \ p);\n        return (val * val) % p;\n    }\n    if n % 2 == 1 {\n        let\
    \ val = modp(n - 1, p);\n        return (val * n) % p;\n    }\n    1", "    let\
    \ e = modulo(n, p - 1);\n    modulo(2, e)", "    if n == 0 {\n        return 1;\n\
    \    }\n    let mut tmp = modp(n / 2, p);\n    tmp = (tmp * tmp) % p;\n    if\
    \ n % 2 == 1 {\n        tmp = (tmp * 2) % p;\n    }\n    return tmp;", "    match\
    \ n {\n        0 => 1,\n        _ => {\n            let b = modp(n / 2, p);\n\
    \            let c = (b * b) % p;\n            if n % 2 == 0 {\n             \
    \   c\n            } else {\n                (c * n) % p\n            }\n    \
    \    }\n    }", "    if n == 0 {\n        return 1;\n    }\n\n    if n == 1 {\n\
    \        return n;\n    }\n\n    let x = n % 2;\n    let y = n - x;\n    let z\
    \ = modp(y / 2, p);\n\n    if x == 0 {\n        return z * z % p;\n    } else\
    \ {\n        return z * z * n % p;\n    }", "    if n == 0 {\n        return 1;\n\
    \    }\n    let mut result = 1;\n    let mut a = 2;\n    let mut b = n;\n    while\
    \ b > 0 {\n        if b % 2 == 1 {\n            result = (result * a) % p;\n \
    \       }\n        a = (a * a) % p;\n        b = b / 2;\n    }\n    result", " \
    \   let mut n = n % p;\n    if n < 0 {\n        n += p;\n    }\n    n", "    let\
    \ mut n = n;\n    if n < 0 {\n        n = (n % p) + p;\n    }\n    n % p", " \
    \   match n {\n        0 => 1,\n        1 => n,\n        _ => {\n            let\
    \ mut r = modp(n / 2, p);\n            r = (r * r) % p;\n            if n % 2\
    \ == 1 {\n                r = (r * n) % p;\n            }\n            r\n   \
    \     }\n    }", "    let mut num: isize = n;\n    let mut result: isize = 1;\n\
    \    while num > 0 {\n        result = (result * num) % p;\n        num = num\
    \ - 1;\n    }\n    result", "    match n {\n        0 => 1,\n        _ => {\n\
    \            let res = modp(n / 2, p);\n            let res = res * res % p;\n\
    \            if n % 2 == 0 {\n                res\n            } else {\n    \
    \            res * 2 % p\n            }\n        }\n    }", "    if n >= p {\n\
    \        return modp(n % p, p);\n    }\n    let mut n = n;\n    let mut n_pow_1\
    \ = 1;\n    let mut n_pow_2 = n;\n    while n_pow_2 > 1 {\n        n_pow_2 = modp(n_pow_2\
    \ * n_pow_2, p);\n        if n % 2 == 1 {\n            n_pow_1 = modp(n_pow_1\
    \ * n_pow_2, p);\n        }\n        n /= 2;\n    }\n    n_pow_1", "    let mut\
    \ r = 1;\n    let mut n = n;\n    while n > 0 {\n        if n % 2 == 1 {\n   \
    \         r = (r * n) % p;\n        }\n        n = n / 2;\n    }\n    r", "  \
    \  let mut n = n;\n    let mut k = 1;\n    let mut x = n % p;\n    n = n / p;\n\
    \    while n > 0 {\n        if n % 2 == 1 {\n            k = (k * x) % p;\n  \
    \      }\n        x = (x * x) % p;\n        n = n / 2;\n    }\n    k", "    let\
    \ mut i = 1;\n    let mut c = 1;\n    while i <= n {\n        c = (c * 2) % p;\n\
    \        i += 1;\n    }\n    c", "    let mut res = 1;\n    let mut cur = n;\n\
    \    let mut p = p;\n    while p > 0 {\n        if p % 2 == 1 {\n            res\
    \ = (res * cur) % p;\n        }\n        cur = (cur * cur) % p;\n        p = p\
    \ / 2;\n    }\n    res", "    match n {\n        0 => 1,\n        n => ((modp(n\
    \ / 2, p) * modp(n / 2, p)) % p * modp(n % 2, p)) % p,\n    }", "    if n == 0\
    \ {\n        return 1;\n    }\n    let mut x = modp(n / 2, p);\n    x = x * x\
    \ % p;\n    if n % 2 == 1 {\n        x = x * 2 % p;\n    }\n    x", "    let mut\
    \ res = 1;\n    let mut n = n;\n    let mut x = 2;\n    while n > 0 {\n      \
    \  if n % 2 == 1 {\n            res = (res * x) % p;\n        }\n        n = n\
    \ / 2;\n        x = (x * x) % p;\n    }\n    res", "    if n == 0 {\n        return\
    \ 1;\n    }\n    if n % 2 == 0 {\n        let z = modp(n / 2, p);\n        return\
    \ (z * z) % p;\n    }\n    return (modp(n - 1, p) * n) % p;", "    if n >= p {\n\
    \        return modp(n - p, p);\n    }\n    if n == 0 {\n        return 1;\n \
    \   }\n    if n == 1 {\n        return n;\n    }\n    let k = modp(n / 2, p);\n\
    \    if n % 2 == 0 {\n        return k * k % p;\n    }\n    return k * k * n %\
    \ p;", "    assert!(n >= 0 && p > 0);\n    let mut result = 1;\n    for _ in 0..n\
    \ {\n        result = (result * 2) % p;\n    }\n    result", "    assert!(n >=\
    \ 0);\n    assert!(p > 0);\n    if n == 0 {\n        return 1;\n    }\n    if\
    \ n == 1 {\n        return n;\n    }\n    let mut x = modp(n / 2, p);\n    x =\
    \ (x * x) % p;\n    if n % 2 == 1 {\n        x = (x * n) % p;\n    }\n    x",
  "    let mut m = n;\n    let mut r = 1;\n    while m > 0 {\n        if m % 2 ==\
    \ 1 {\n            r = (r * n) % p;\n        }\n        n = (n * n) % p;\n   \
    \     m = m / 2;\n    }\n    r", "    if n == 0 {\n        return 1;\n    }\n\
    \    let mut y = modp(n / 2, p);\n    y = (y * y) % p;\n    if n % 2 == 0 {\n\
    \        return y;\n    }\n    return (y * n) % p;", "    let mut result = 1;\n\
    \    let mut i = 0;\n    while i < n {\n        result = (result * 2) % p;\n \
    \       i += 1;\n    }\n    result", '    return (1..n + 1).fold(1, |product,
    _| (product * 2) % p);', "    if n == 0 {\n        return 1;\n    }\n    let mut\
    \ result = 1;\n    let mut n = n;\n    let mut n_pow_p = n % p;\n    loop {\n\
    \        if n % 2 == 1 {\n            result = (result * n_pow_p) % p;\n     \
    \   }\n        n = n / 2;\n        if n == 0 {\n            break;\n        }\n\
    \        n_pow_p = (n_pow_p * n_pow_p) % p;\n    }\n    result", "    let mut\
    \ q = n;\n    let mut result = 1;\n    loop {\n        if q & 1 == 1 {\n     \
    \       result = (result * n) % p;\n        }\n        q = q >> 1;\n        if\
    \ q == 0 {\n            break;\n        }\n        n = (n * n) % p;\n    }\n \
    \   result", "    let mut y = 1;\n    let mut x = n;\n    while x > 1 {\n    \
    \    if x % 2 == 0 {\n            x = x / 2;\n            y = y * 2;\n       \
    \ } else {\n            x = (x + p) / 2;\n            y = (y + n) / 2;\n     \
    \   }\n    }\n    y", "    let mut res = 1;\n    let mut b = n;\n    let mut e\
    \ = p;\n    while e > 0 {\n        if e % 2 == 1 {\n            res = (res * b)\
    \ % p;\n        }\n        e = e >> 1;\n        b = (b * b) % p;\n    }\n    res",
  "    if n == 0 {\n        return 1;\n    }\n    let mut res = modp(n / 2, p);\n\
    \    res = (res * res) % p;\n    if n % 2 == 1 {\n        res = (res * 2) % p;\n\
    \    }\n    res", "    if n == 0 {\n        return 1;\n    }\n    let mut result\
    \ = modp(n / 2, p);\n    result = (result * result) % p;\n    if n % 2 == 1 {\n\
    \        result = (result * 2) % p;\n    }\n    return result;", "    if n ==\
    \ 0 {\n        return 1;\n    }\n    let mut r = 1;\n    let mut x = n;\n    loop\
    \ {\n        if x & 1 == 1 {\n            r = (r * n) % p;\n        }\n      \
    \  x = x >> 1;\n        if x == 0 {\n            break;\n        }\n        n\
    \ = (n * n) % p;\n    }\n    r", "    if n < 0 {\n        let mut x = 1;\n   \
    \     let mut i = -n;\n        while i > 0 {\n            x = (x * n) % p;\n \
    \           i -= 1;\n        }\n        return inv(x, p);\n    } else {\n    \
    \    let mut x = 1;\n        let mut i = n;\n        while i > 0 {\n         \
    \   x = (x * n) % p;\n            i -= 1;\n        }\n        return x;\n    }",
  "    let mut a = 1;\n    let mut b = n;\n    while b > 0 {\n        if b % 2 ==\
    \ 1 {\n            a = (a * n) % p;\n        }\n        b = b / 2;\n        n\
    \ = (n * n) % p;\n    }\n    a", "    if n == 0 {\n        return 1;\n    }\n\n\
    \    if n % 2 == 0 {\n        let a = modp(n / 2, p);\n        return a * a %\
    \ p;\n    }\n\n    modp(n - 1, p) * n % p", "    let mut result = 1;\n    let\
    \ mut b = n;\n    let mut x = p;\n    while b > 0 {\n        if b % 2 == 1 {\n\
    \            result = (result * x) % p;\n        }\n        b = b / 2;\n     \
    \   x = (x * x) % p;\n    }\n    result", "    if n % p == 0 {\n        return\
    \ 1;\n    }\n    let mut k = 1;\n    let mut power = 2;\n    while power <= n\
    \ {\n        power *= 2;\n        k += 1;\n    }\n    let mut result = 1;\n  \
    \  let mut power = 1;\n    for _ in 0..k {\n        power = modmul(power, power,\
    \ p);\n        if (n & (1 << (k - 1))) != 0 {\n            result = modmul(result,\
    \ power, p);\n        }\n    }\n    result", "    if n == 0 {\n        return\
    \ 1;\n    }\n    if n % 2 == 0 {\n        let m = modp(n / 2, p);\n        return\
    \ m * m % p;\n    }\n    let m = modp(n - 1, p);\n    return n * m % p;", "  \
    \  let mut r = 1;\n    let mut x = n;\n    let mut m = p;\n    while m > 0 {\n\
    \        if m % 2 == 1 {\n            r = (r * x) % p;\n        }\n        x =\
    \ (x * x) % p;\n        m = m / 2;\n    }\n    r", "    if n < p {\n        n\n\
    \    } else {\n        let d: isize = n / p;\n        let r: isize = n - p * d;\n\
    \        modp(r, p)\n    }", "    let mut res = 1;\n    let mut a = n;\n    let\
    \ mut b = p;\n    let mut b0 = b;\n    let mut hi = 1;\n    let mut lo = 0;\n\
    \    let mut t;\n    while a > 0 {\n        if a & 1 == 1 {\n            t = hi;\n\
    \            hi = (res * t) % b;\n            lo = (lo * t + res * hi) % b;\n\
    \            res = (lo & ((1 << 31) - 1)) + (lo >> 31) + (hi << 31 >> 31) + (hi\
    \ >> 1);\n            res = res % b;\n        }\n        t = a;\n        a = t\
    \ >> 1;\n        t = hi;\n        hi = (t * t) % b;\n        lo = (lo * t + t\
    \ * hi) % b;\n        hi = (lo & ((1 << 31) - 1)) + (lo >> 31) + (hi << 31 >>\
    \ 31) + (hi >> 1);\n        hi = hi % b;\n    }\n    if res < 0 {\n        res\
    \ = res + b0;\n    }\n    res", "    if n == 0 {\n        return 1;\n    }\n \
    \   if n % 2 == 0 {\n        let t = modp(n / 2, p);\n        return (t * t) %\
    \ p;\n    }\n    return (modp(n - 1, p) * n) % p;", "    if n == 0 {\n       \
    \ return 1;\n    }\n    let mut res = 1;\n    for _ in 0..n {\n        res = (res\
    \ * 2) % p;\n    }\n    res", "    if n == 0 {\n        return 1;\n    }\n\n \
    \   if n % 2 == 0 {\n        let m = modp(n / 2, p);\n        return (m * m) %\
    \ p;\n    }\n\n    (modp(n - 1, p) * n) % p", "    if n == 0 {\n        return\
    \ 1;\n    }\n    if n % 2 == 0 {\n        let half = modp(n / 2, p);\n       \
    \ return (half * half) % p;\n    }\n    return (modp(n - 1, p) * n) % p;"]
stop_tokens:
- "\n}"
