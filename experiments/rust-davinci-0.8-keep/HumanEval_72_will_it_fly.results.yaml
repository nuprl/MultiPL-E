name: HumanEval_72_will_it_fly
language: rust
results:
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut a = 0;\n    let\
    \ mut b = q.len() - 1;\n    let mut weight = 0;\n    let mut is_balanced = true;\n\
    \    while a < b {\n        if q[a] != q[b] {\n            is_balanced = false;\n\
    \            break;\n        }\n        weight += q[a];\n        a += 1;\n   \
    \     b -= 1;\n    }\n    if a == b {\n        weight += q[a];\n    }\n    return\
    \ is_balanced && weight <= w;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    q == q.iter().rev().collect::<Vec<&isize>>() && sum <= w\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp5susic38.rs:14:7\n\
    \   |\n14 |     q == q.iter().rev().collect::<Vec<&isize>>() && sum <= w\n   |\
    \       ^^ no implementation for `isize == &isize`\n   |\n   = help: the trait\
    \ `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    let rev = q.iter().rev().collect::<Vec<&isize>>();\n    if sum <= w && rev\
    \ == q {\n        true\n    } else {\n        false\n    }\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpbufshjzt.rs:15:24\n\
    \   |\n15 |     if sum <= w && rev == q {\n   |                        ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n   = note: required because of the requirements\
    \ on the impl of `PartialEq<Vec<isize>>` for `Vec<&isize>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    if sum <= w && q == q.iter().rev().collect::<Vec<_>>() { true } else { false\
    \ }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpea663sin.rs:14:22\n\
    \   |\n14 |     if sum <= w && q == q.iter().rev().collect::<Vec<_>>() { true\
    \ } else { false }\n   |                      ^^ no implementation for `isize\
    \ == &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    let s = q.len() as isize;\n    sum <= w && (sum - w).abs() < s\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpiy_jwqvb.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() == 1 || q.len()\
    \ == 0 { return true; }\n    let mut l = 0;\n    let mut r = q.len() - 1;\n  \
    \  let mut sum = 0;\n    while l < r {\n        if q[l] != q[r] { return false;\
    \ }\n        sum += q[l];\n        sum += q[r];\n        l += 1;\n        r -=\
    \ 1;\n    }\n    if l == r { sum += q[l]; }\n    return sum <= w;\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    let mut queue = q.clone();\n    queue.reverse();\n    sum <= w && q == queue\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if !is_palindrome(&q) {\n\
    \        return false;\n    }\n    let sum: isize = q.iter().sum();\n    sum <=\
    \ w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp2d13j051.rs:13:9\n   |\n13 |     if !is_palindrome(&q) {\n   |     \
    \    ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ n in q.iter() {\n        sum += n;\n    }\n    sum <= w && q == q.iter().rev().cloned().collect::<Vec<isize>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    q.iter().sum::<isize>()\
    \ <= w && q == q.iter().rev().cloned().collect::<Vec<isize>>()\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    sum <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpigubrzlt.rs:14:19\n\
    \   |\n14 |     sum <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n   |\
    \                   ^^ no implementation for `isize == &isize`\n   |\n   = help:\
    \ the trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let len = q.len();\n  \
    \  len == 1 ||\n    len > 1 &&\n    w >= q.iter().fold(0, |acc, e| acc + e) &&\n\
    \    q.iter().take(len / 2).zip(q.iter().rev().take(len / 2)).all(|(e1, e2)| e1\
    \ == e2)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut rev_q = q.clone();\n\
    \    rev_q.reverse();\n    q == rev_q && q.iter().sum::<isize>() <= w\n}\n\nfn\
    \ main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpnwzmnnci.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() == 1 {\n   \
    \     return true;\n    }\n    let sum: isize = q.iter().sum();\n    if sum >\
    \ w {\n        return false;\n    }\n    let mut left = 0;\n    let mut right\
    \ = q.len() - 1;\n    while left < right {\n        if q[left] != q[right] {\n\
    \            return false;\n        }\n        left += 1;\n        right -= 1;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    sum <= w && q == q.iter().rev().cloned().collect::<Vec<isize>>()\n}\n\nfn\
    \ main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    q.iter().sum::<isize>()\
    \ <= w && q == q.iter().rev().cloned().collect::<Vec<isize>>()\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    sum <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpd8txkc5a.rs:14:19\n\
    \   |\n14 |     sum <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n   |\
    \                   ^^ no implementation for `isize == &isize`\n   |\n   = help:\
    \ the trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let is_balanced = q.iter().fold(true,\
    \ |acc, &x| acc && x == q[q.len() - 1 - (x as usize)]);\n    let total_weight\
    \ = q.iter().fold(0, |acc, &x| acc + x);\n    is_balanced && total_weight <= w\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpcr55s3mx.rs:13:67\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpe7umcwm5.rs:14:19\n\
    \   |\n14 |     sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n   |    \
    \               ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.iter().sum::<isize>()\
    \ <= w && q == q.iter().rev().collect::<Vec<_>>() {\n        true\n    } else\
    \ {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpxbyhwy6e.rs:13:42\n\
    \   |\n13 |     if q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\
    \ {\n   |                                          ^^ no implementation for `isize\
    \ == &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let l = q.len();\n    let\
    \ sum = q.iter().sum::<isize>();\n    l % 2 == 0 && sum <= w\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp8lkvqt3w.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() < 2 {\n    \
    \    return true;\n    }\n    let middle = q.len() / 2;\n    let front = &q[..middle];\n\
    \    let back = &q[q.len() - middle..];\n    if front == back.iter().rev() &&\
    \ front.iter().sum::<isize>() <= w {\n        return true;\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&[isize]` with `Rev<std::slice::Iter<'_, isize>>`\n\
    \  --> /tmp/tmpux513g4t.rs:19:14\n   |\n19 |     if front == back.iter().rev()\
    \ && front.iter().sum::<isize>() <= w {\n   |              ^^ no implementation\
    \ for `&[isize] == Rev<std::slice::Iter<'_, isize>>`\n   |\n   = help: the trait\
    \ `PartialEq<Rev<std::slice::Iter<'_, isize>>>` is not implemented for `&[isize]`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&[B] as PartialEq<[A; N]>>\n             <&[T] as PartialEq<Vec<U,\
    \ A>>>\n             <&mut [B] as PartialEq<[A; N]>>\n             <&mut [T] as\
    \ PartialEq<Vec<U, A>>>\n             <[A; N] as PartialEq<&[B]>>\n          \
    \   <[A; N] as PartialEq<&mut [B]>>\n             <[A; N] as PartialEq<[B; N]>>\n\
    \             <[A; N] as PartialEq<[B]>>\n           and 3 others\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    let is_palindrome = q.iter().rev().eq(q.iter());\n    sum <= w && is_palindrome\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    let len = q.len();\n    sum <= w && q[..len / 2] == q[len / 2 + len % 2..].iter().rev()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `[isize]` with `Rev<std::slice::Iter<'_, isize>>`\n\
    \  --> /tmp/tmp1gek1q10.rs:15:30\n   |\n15 |     sum <= w && q[..len / 2] == q[len\
    \ / 2 + len % 2..].iter().rev()\n   |                              ^^ no implementation\
    \ for `[isize] == Rev<std::slice::Iter<'_, isize>>`\n   |\n   = help: the trait\
    \ `PartialEq<Rev<std::slice::Iter<'_, isize>>>` is not implemented for `[isize]`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&[B] as PartialEq<[A; N]>>\n             <&[T] as PartialEq<Vec<U,\
    \ A>>>\n             <&mut [B] as PartialEq<[A; N]>>\n             <&mut [T] as\
    \ PartialEq<Vec<U, A>>>\n             <[A; N] as PartialEq<&[B]>>\n          \
    \   <[A; N] as PartialEq<&mut [B]>>\n             <[A; N] as PartialEq<[B; N]>>\n\
    \             <[A; N] as PartialEq<[B]>>\n           and 3 others\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    q.iter().sum::<isize>()\
    \ <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n}\n\nfn main() {\n   \
    \ let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpbhl_cq_k.rs:13:39\n\
    \   |\n13 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    sum <= w && is_palindrome(&q)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpcnonj53z.rs:14:17\n   |\n14 |     sum <= w && is_palindrome(&q)\n  \
    \ |                 ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() == 1 {\n   \
    \     return true;\n    }\n    if q.iter().sum::<isize>() > w {\n        return\
    \ false;\n    }\n    if q.iter().sum::<isize>() <= w && is_palindrome(&q) {\n\
    \        return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate =\
    \ will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpnz8vmxzj.rs:19:40\n   |\n19 |     if q.iter().sum::<isize>() <= w &&\
    \ is_palindrome(&q) {\n   |                                        ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.iter().sum::<isize>()\
    \ <= w && is_palindrome(&q) {\n        true\n    } else {\n        false\n   \
    \ }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpme5w6tlr.rs:13:40\n   |\n13 |     if q.iter().sum::<isize>() <= w &&\
    \ is_palindrome(&q) {\n   |                                        ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    q.reverse();\n\
    \    q == q.iter().rev().cloned().collect::<Vec<isize>>() && q.iter().sum::<isize>()\
    \ <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n\tq.len() == 1 || (q.len()\
    \ > 1 && q.iter().sum::<isize>() <= w && q.iter().take(q.len() / 2).eq(q.iter().rev().take(q.len()\
    \ / 2)))\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n\
    \    q.iter().sum::<isize>() <= w && q == q.iter().rev().cloned().collect::<Vec<isize>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpd0s7dmhf.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    let mut rev = q.clone();\n    rev.reverse();\n    sum <= w && q == rev\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    q.iter().fold(0, |acc,\
    \ x| acc + x) <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpgxqlm7_w.rs:13:50\n\
    \   |\n13 |     q.iter().fold(0, |acc, x| acc + x) <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                                  ^^ no implementation for\
    \ `isize == &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let q_reversed = &q.clone();\n\
    \    q_reversed.reverse();\n    let sum: isize = q.iter().sum();\n    sum <= w\
    \ && q == q_reversed\n}\n\nfn main() {\n    let candidate = will_it_fly;\n   \
    \ assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `Vec<isize>` with `&Vec<isize>`\n  --> /tmp/tmpktk_d8uk.rs:16:19\n\
    \   |\n16 |     sum <= w && q == q_reversed\n   |                   ^^ no implementation\
    \ for `Vec<isize> == &Vec<isize>`\n   |\n   = help: the trait `PartialEq<&Vec<isize>>`\
    \ is not implemented for `Vec<isize>`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n\
    \             <Vec<T, A> as PartialEq<&[U; N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n\
    \             <Vec<T, A> as PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<[U]>>\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    q.iter().sum::<isize>()\
    \ <= w && q == q.iter().rev().cloned().collect::<Vec<isize>>()\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut curr_weight = 0;\n\
    \    for i in q.iter() {\n        curr_weight += i;\n    }\n    if curr_weight\
    \ <= w && q == q.iter().rev().collect::<Vec<&isize>>() {\n        return true;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpqzgav3dg.rs:17:30\n\
    \   |\n17 |     if curr_weight <= w && q == q.iter().rev().collect::<Vec<&isize>>()\
    \ {\n   |                              ^^ no implementation for `isize == &isize`\n\
    \   |\n   = help: the trait `PartialEq<&isize>` is not implemented for `isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n   = note: required because of the requirements on the impl of\
    \ `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let weight: isize = q.iter().sum();\n\
    \    if weight <= w && q == q.iter().rev().cloned().collect::<Vec<isize>>() {\n\
    \        true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    let mut reversed = q.clone();\n    reversed.reverse();\n    sum <= w && q\
    \ == reversed\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() == 1 {\n   \
    \     return true;\n    }\n    let mut sum = 0;\n    for x in q.iter() {\n   \
    \     sum += x;\n    }\n    if sum > w {\n        return false;\n    }\n\n   \
    \ let mut new_q = q.clone();\n    new_q.reverse();\n    if q == new_q {\n    \
    \    return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    let q_clone = q.clone();\n    sum <= w && q == q_clone.iter().rev().collect::<Vec<&isize>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp9em3eods.rs:15:19\n\
    \   |\n15 |     sum <= w && q == q_clone.iter().rev().collect::<Vec<&isize>>()\n\
    \   |                   ^^ no implementation for `isize == &isize`\n   |\n   =\
    \ help: the trait `PartialEq<&isize>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() < 2 {\n    \
    \    return true;\n    }\n    if q[0] + q[q.len() - 1] > w {\n        return false;\n\
    \    }\n    let (a, b) = q.split_at(q.len() / 2);\n    a == b.iter().rev().collect::<Vec<&isize>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpxm6up0p6.rs:20:7\n\
    \   |\n20 |     a == b.iter().rev().collect::<Vec<&isize>>()\n   |       ^^ no\
    \ implementation for `isize == &isize`\n   |\n   = help: the trait `PartialEq<&isize>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n   = note: required because of the requirements\
    \ on the impl of `PartialEq<Vec<&isize>>` for `&[isize]`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    sum <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpae7itff1.rs:14:19\n\
    \   |\n14 |     sum <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n   |\
    \                   ^^ no implementation for `isize == &isize`\n   |\n   = help:\
    \ the trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in &q {\n        sum += i;\n    }\n    if sum <= w {\n        if palindrome(&q)\
    \ {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `palindrome` in this scope\n  --> /tmp/tmpuuldudfe.rs:18:12\n\
    \   |\n18 |         if palindrome(&q) {\n   |            ^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let n = q.len();\n    if\
    \ n == 0 { return false; }\n    let m = n / 2;\n    let v = q.iter().fold(0, |acc,\
    \ x| acc + x);\n    if v > w { return false; }\n    for i in 0..m {\n        if\
    \ q[i] != q[n-i-1] { return false; }\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if w >= 0 {\n        let\
    \ sum = q.iter().sum::<isize>();\n        if sum <= w {\n            let mut left\
    \ = 0;\n            let mut right = q.len() - 1;\n            while left < right\
    \ {\n                if q[left] != q[right] {\n                    return false;\n\
    \                }\n                left += 1;\n                right -= 1;\n\
    \            }\n            return true;\n        }\n    }\n    false\n}\n\nfn\
    \ main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.iter().sum::<isize>()\
    \ <= w && q == q.iter().rev().collect::<Vec<&isize>>() {\n        true\n    }\
    \ else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpscto2iui.rs:13:42\n\
    \   |\n13 |     if q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<&isize>>()\
    \ {\n   |                                          ^^ no implementation for `isize\
    \ == &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    q == q.iter().rev().collect::<Vec<_>>() && sum <= w\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpmmx78gtf.rs:14:7\n\
    \   |\n14 |     q == q.iter().rev().collect::<Vec<_>>() && sum <= w\n   |    \
    \   ^^ no implementation for `isize == &isize`\n   |\n   = help: the trait `PartialEq<&isize>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n   = note: required because of the requirements\
    \ on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum > w {\n        return\
    \ false;\n    }\n    let mut q_rev = q.clone();\n    q_rev.reverse();\n    q ==\
    \ q_rev\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut l = 0;\n    let\
    \ mut r = q.len() - 1;\n    let mut sum = 0;\n    while l < r {\n        if q[l]\
    \ != q[r] {\n            return false;\n        }\n        sum += q[l];\n    \
    \    l += 1;\n        r -= 1;\n    }\n    sum += q[l];\n    sum <= w\n}\n\nfn\
    \ main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n\tlet mut sum = 0;\n\tfor i\
    \ in q.iter() {\n\t\tsum += i;\n\t}\n\tif sum <= w {\n\t\tlet mut list = q.clone();\n\
    \t\tlist.reverse();\n\t\tlist == q\n\t} else {\n\t\tfalse\n\t}\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    // == C#\n    // return\
    \ q.Zip(q.Reverse(), (a, b) => a + b).All(x => x <= w) && q.Sum() <= w;\n    //\
    \ == F#\n    // q.Zip(q.Reverse(), fun a b -> a + b).All(fun x -> x <= w) && q.Sum()\
    \ <= w;;\n    let q_iter = q.iter();\n    let q_rev_iter = q.iter().rev();\n \
    \   let zipped_iter = q_iter.zip(q_rev_iter);\n    let mut result: Vec<isize>\
    \ = Vec::new();\n    for (x, y) in zipped_iter {\n        result.push(x + y);\n\
    \    }\n    result.iter().all(|&x| x <= w) && q.iter().sum::<isize>() <= w\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp21gnl1kt.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n\tlet mut q_iter = q.iter();\n\
    \tlet len = q.len();\n\tlet mut balanced = true;\n\tlet mut weight = 0;\n\tfor\
    \ i in 0..len {\n\t\tif i >= len/2 {\n\t\t\tweight += q[i];\n\t\t} else {\n\t\t\
    \tweight += q[i];\n\t\t\tif *q_iter.next().unwrap() != q[len-i-1] {\n\t\t\t\t\
    balanced = false;\n\t\t\t}\n\t\t}\n\t}\n\treturn balanced && weight <= w;\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    w >= q.iter().sum::<isize>()\
    \ && q == q.iter().rev().collect::<Vec<&isize>>()\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpb7qeew85.rs:13:39\n\
    \   |\n13 |     w >= q.iter().sum::<isize>() && q == q.iter().rev().collect::<Vec<&isize>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut s = 0;\n    for\
    \ i in q.iter() {\n        s += i;\n    }\n    if s > w {\n        return false;\n\
    \    }\n    for i in 0..q.len() / 2 {\n        if q[i] != q[q.len() - i - 1] {\n\
    \            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n   \
    \ let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let len = q.len();\n  \
    \  let mut sum = 0;\n    for i in 0..len/2 {\n        if q[i] != q[len-i-1] {\n\
    \            return false;\n        }\n        sum += q[i];\n    }\n    if len\
    \ % 2 == 1 {\n        sum += q[len/2];\n    }\n    sum <= w\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    let mut queue = q.clone();\n    if sum <= w {\n        if queue.len() <=\
    \ 1 { return true; }\n        else {\n            let mut l = 0;\n           \
    \ let mut r = queue.len() - 1;\n            while l < r {\n                if\
    \ queue[l] != queue[r] { return false; }\n                l += 1;\n          \
    \      r -= 1;\n            }\n            return true;\n        }\n    }\n  \
    \  false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    q.iter().sum::<isize>()\
    \ <= w && is_palindrome(&q)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpo1ixoo93.rs:13:37\n   |\n13 |     q.iter().sum::<isize>() <= w && is_palindrome(&q)\n\
    \   |                                     ^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    if sum <= w && q == q.iter().rev().collect::<Vec<&isize>>() {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp1xtvazae.rs:14:22\n\
    \   |\n14 |     if sum <= w && q == q.iter().rev().collect::<Vec<&isize>>() {\n\
    \   |                      ^^ no implementation for `isize == &isize`\n   |\n\
    \   = help: the trait `PartialEq<&isize>` is not implemented for `isize`\n   =\
    \ help: the following other types implement trait `PartialEq<Rhs>`:\n        \
    \     f32\n             f64\n             i128\n             i16\n           \
    \  i32\n             i64\n             i8\n             isize\n           and\
    \ 6 others\n   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.iter().sum::<isize>()\
    \ <= w && is_palindrome(&q) {\n        true\n    } else {\n        false\n   \
    \ }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp0u6cfe98.rs:13:40\n   |\n13 |     if q.iter().sum::<isize>() <= w &&\
    \ is_palindrome(&q) {\n   |                                        ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    q.iter().sum::<isize>()\
    \ <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n}\n\nfn main() {\n   \
    \ let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpfs74p2l2.rs:13:39\n\
    \   |\n13 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    let is_palindrome = q.iter().zip(q.iter().rev()).all(|(a, b)| a == b);\n\
    \    sum <= w && is_palindrome\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    sum <= w && is_palindrome(&q)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpzbad4_kt.rs:14:17\n   |\n14 |     sum <= w && is_palindrome(&q)\n  \
    \ |                 ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let balanced = q.len()\
    \ % 2 == 0;\n    balanced && q.iter().sum::<isize>() <= w\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp70h4uriq.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut half_q = q.len() / 2;\n    for (i, x) in q.iter().enumerate() {\n      \
    \  sum += x;\n        if half_q < i { break }\n        if q[i] != q[q.len() -\
    \ i - 1] { return false }\n    }\n    sum <= w\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut s = 0;\n    for\
    \ i in &q {\n        s += i;\n    }\n    let mut t = q.clone();\n    t.reverse();\n\
    \    s <= w && q == t\n}\n\nfn main() {\n    let candidate = will_it_fly;\n  \
    \  assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() < 2 {\n    \
    \    return true;\n    }\n    let sum = q.iter().sum::<isize>();\n    if sum >\
    \ w {\n        return false;\n    }\n    // let mut iter = q.iter();\n    // let\
    \ mut iter_rev = q.iter().rev();\n    // loop {\n    //     let rev = iter_rev.next();\n\
    \    //     let normal = iter.next();\n    //     if normal == None || rev ==\
    \ None {\n    //         break;\n    //     }\n    //     if normal != rev {\n\
    \    //         return false;\n    //     }\n    // }\n    q == q.iter().rev().collect::<Vec<&isize>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpr47_3we0.rs:32:7\n\
    \   |\n32 |     q == q.iter().rev().collect::<Vec<&isize>>()\n   |       ^^ no\
    \ implementation for `isize == &isize`\n   |\n   = help: the trait `PartialEq<&isize>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n   = note: required because of the requirements\
    \ on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let len = q.len();\n  \
    \  let mut q_len = q.len();\n    let mut mid_l = len / 2;\n    let mut mid_r =\
    \ mid_l;\n    if len % 2 == 0 {\n        mid_l -= 1;\n    }\n    let mut total\
    \ = 0;\n    while q_len > 0 {\n        total += q[mid_l];\n        if mid_l !=\
    \ mid_r {\n            total += q[mid_r];\n        }\n        if total > w {\n\
    \            return false;\n        }\n        mid_l -= 1;\n        mid_r += 1;\n\
    \        q_len -= 2;\n    }\n    true\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmps_2m03b1.rs:29:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    let mut q = q.clone();\n    q.reverse();\n    q == q.clone() && sum <= w\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpnkh0t7ga.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n\tif q.len() < 2 { return true;\
    \ }\n\tif !is_palindrome(&q) { return false; }\n\tq.iter().sum::<isize>() <= w\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp4484j9dh.rs:14:6\n   |\n14 |     if !is_palindrome(&q) { return false;\
    \ }\n   |         ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    q == q.iter().rev().cloned().collect::<Vec<isize>>() && sum <= w\n}\n\nfn\
    \ main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    // let mut current_sum\
    \ = 0;\n    // for i in q {\n    //     current_sum += i;\n    // }\n    // let\
    \ mut rq = q.clone();\n    // rq.reverse();\n    // return q == rq && current_sum\
    \ <= w;\n    return q == q.iter().rev().cloned().collect::<Vec<isize>>() && q.iter().sum::<isize>()\
    \ <= w;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp2tark29d.rs:14:19\n\
    \   |\n14 |     sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n   |    \
    \               ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut qq = q.clone();\n\
    \    qq.reverse();\n    qq == q && q.iter().sum::<isize>() <= w\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut reversed_q = Vec::new();\n    for element in q.iter() {\n        sum +=\
    \ element;\n        reversed_q.insert(0, *element);\n    }\n    sum <= w && q\
    \ == reversed_q\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpm58hvqkl.rs:14:19\n\
    \   |\n14 |     sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n   |    \
    \               ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n\tlet sum = q.iter().sum::<isize>();\n\
    \tlet len = q.len();\n\tlet reversed: Vec<isize> = q.iter().rev().cloned().collect();\n\
    \tsum <= w && q == reversed\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let balanced = q.len()\
    \ % 2 == 0;\n    let sum = q.iter().sum::<isize>();\n    balanced && sum <= w\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpre2a0e19.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    let reversed = &q.iter().rev().cloned().collect::<Vec<isize>>();\n    sum\
    \ <= w && q == *reversed\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    let balanced = q.iter().rev().eq(q.iter());\n    sum <= w && balanced\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if w < q.iter().sum() {\n\
    \        return false;\n    }\n    let mut half = q.len() / 2;\n    q.iter().zip(q.iter().rev()).all(|(f,\
    \ s)| {\n        half -= 1;\n        f == s || half < 0\n    })\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp4o9n6q4r.rs:18:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    // The sum of the elements\
    \ in Q must be less than or equal to the maximum weight W.\n    // The list Q\
    \ must be a palindrome.\n    let mut acc = 0;\n    let mut i = 0;\n    let mut\
    \ j = q.len() - 1;\n    while i < j {\n        if q[i] != q[j] {\n           \
    \ return false;\n        }\n        acc += q[i];\n        i += 1;\n        j -=\
    \ 1;\n    }\n    if i == j {\n        acc += q[i];\n    }\n    acc <= w\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let n = q.len();\n    let\
    \ mut i = 0;\n    let mut j = n - 1;\n    let mut sum = 0;\n    while i < j {\n\
    \        if q[i] != q[j] {\n            return false;\n        }\n        sum\
    \ += q[i];\n        sum += q[j];\n        i += 1;\n        j -= 1;\n    }\n  \
    \  if n % 2 == 1 {\n        sum += q[i];\n    }\n    return sum <= w;\n}\n\nfn\
    \ main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    q.iter().fold(0, |acc,\
    \ x| acc + x) <= w && \n        q.iter().fold(0, |acc, x| acc + x) == q.iter().rev().fold(0,\
    \ |acc, x| acc + x)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmprbzn487u.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    q.iter().sum::<isize>()\
    \ <= w && is_palindrome(&q)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp69lu3n1g.rs:13:37\n   |\n13 |     q.iter().sum::<isize>() <= w && is_palindrome(&q)\n\
    \   |                                     ^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.iter().sum::<isize>()\
    \ <= w && q == q.iter().rev().collect::<Vec<_>>() {\n        true\n    } else\
    \ {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpj4tuto4h.rs:13:42\n\
    \   |\n13 |     if q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\
    \ {\n   |                                          ^^ no implementation for `isize\
    \ == &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q1 = q.clone();\n\
    \    q1.reverse();\n    q == q1 && q.iter().sum::<isize>() <= w\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    q.iter().sum::<isize>()\
    \ <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpwza58z2r.rs:13:39\n\
    \   |\n13 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let len = q.len();\n  \
    \  let sum: isize = q.iter().sum();\n    let balanced = q.iter().take(len / 2).eq(q.iter().rev().take(len\
    \ / 2));\n    balanced && sum <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpkdx7g079.rs:14:19\n\
    \   |\n14 |     sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n   |    \
    \               ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut total = 0;\n  \
    \  for i in &q {\n        total += i;\n    }\n    if total <= w {\n        let\
    \ mut is_palindrome = true;\n        for i in 0..(q.len()/2) {\n            if\
    \ q[i] != q[q.len()-1-i] {\n                is_palindrome = false;\n         \
    \   }\n        }\n        return is_palindrome;\n    }\n    return false;\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut curr_weight = 0;\n\
    \    for item in q.iter() {\n        curr_weight += item;\n    }\n    if !is_palindrome(&q)\
    \ || curr_weight > w {\n        return false;\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpwnlxpmsl.rs:17:9\n   |\n17 |     if !is_palindrome(&q) || curr_weight\
    \ > w {\n   |         ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if sum <= w {\n        let mut\
    \ it_is_palindrome = true;\n        for j in 0..q.len() / 2 {\n            if\
    \ q[j] != q[q.len() - 1 - j] {\n                it_is_palindrome = false;\n  \
    \          }\n        }\n        return it_is_palindrome;\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    // let mut qq = q.clone();\n\
    \    // qq.reverse();\n    // let sum = q.iter().sum::<isize>();\n    // q ==\
    \ qq && sum <= w\n    let sum = q.iter().sum::<isize>();\n    q == q.iter().rev().collect::<Vec<isize>>()\
    \ && sum <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `&isize`\n    --> /tmp/tmp5gckj8q7.rs:18:25\n     |\n\
    18   |     q == q.iter().rev().collect::<Vec<isize>>() && sum <= w\n     |   \
    \                      ^^^^^^^ value of type `Vec<isize>` cannot be built from\
    \ `std::iter::Iterator<Item=&isize>`\n     |\n     = help: the trait `FromIterator<&isize>`\
    \ is not implemented for `Vec<isize>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut i = 0;\n    let\
    \ mut sum = 0;\n    for weight in q.iter() {\n        sum += weight;\n       \
    \ if sum > w {\n            return false;\n        }\n        i += 1;\n    }\n\
    \    return i % 2 == 0;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmppi78u481.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut weight: isize =\
    \ 0;\n    let mut is_balanced = true;\n    let mut i = 0;\n    let len = q.len();\n\
    \    while i < len && is_balanced {\n        if i + i + 1 >= len {\n         \
    \   weight += q[i];\n            is_balanced = q[i] == q[len - i - 1];\n     \
    \   } else {\n            weight += q[i] + q[len - i - 1];\n            is_balanced\
    \ = q[i] == q[len - i - 1];\n        }\n        i += 1;\n    }\n    weight <=\
    \ w && is_balanced\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1y0vu1xp.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q1 = q.clone();\n\
    \    q1.reverse();\n    q == q1 && q.iter().sum::<isize>() <= w\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    sum <= w && is_palindrome(&q)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpp02_ex5c.rs:14:17\n   |\n14 |     sum <= w && is_palindrome(&q)\n  \
    \ |                 ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    q.iter().fold(0, |acc,\
    \ x| acc + x) <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp887_o8r3.rs:13:50\n\
    \   |\n13 |     q.iter().fold(0, |acc, x| acc + x) <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n\
    \   |                                                  ^^ no implementation for\
    \ `isize == &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    q.iter().sum::<isize>()\
    \ <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmptl4q7k0p.rs:13:39\n\
    \   |\n13 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut i = 0;\n    let\
    \ mut j = q.len() - 1;\n    let mut sum = 0;\n    while i < j {\n        if q[i]\
    \ != q[j] {\n            return false;\n        }\n        sum += q[i];\n    \
    \    sum += q[j];\n        i += 1;\n        j -= 1;\n    }\n    if i == j {\n\
    \        sum += q[i];\n    }\n    return sum <= w;\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n\
    \    for i in 0..q.len()/2 {\n        if q[i] != q[q.len()-1-i] {\n          \
    \  return false;\n        }\n    }\n    return q.iter().sum::<isize>() <= w;\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpnjl_yx31.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut count = 0;\n  \
    \  for i in q.iter() {\n        count += i;\n    }\n    if count > w {\n     \
    \   return false;\n    }\n    let mut q = q.clone();\n    q.reverse();\n    q\
    \ == q\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp1ck_dnu6.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let is_balanced = q.iter().all(|&a|\
    \ a == q[0]);\n    let sum = q.iter().sum::<isize>();\n    sum <= w && is_balanced\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpx2v8x7nz.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    q == q.iter().rev().collect::<Vec<&isize>>() && sum <= w\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpn0_vi4gh.rs:14:7\n\
    \   |\n14 |     q == q.iter().rev().collect::<Vec<&isize>>() && sum <= w\n   |\
    \       ^^ no implementation for `isize == &isize`\n   |\n   = help: the trait\
    \ `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut t = q.clone();\n\
    \    t.reverse();\n    q == t && q.iter().sum::<isize>() <= w\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() == 1 {\n   \
    \     return true;\n    }\n    let mut sum = 0;\n    for i in q.iter() {\n   \
    \     sum += i;\n    }\n    if sum > w {\n        return false;\n    }\n    let\
    \ mut i = 0;\n    let mut j = q.len() - 1;\n    while i < j {\n        if q[i]\
    \ != q[j] {\n            return false;\n        }\n        i += 1;\n        j\
    \ -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() == 1 {\n   \
    \     return true;\n    }\n    let mut sum = 0;\n    for i in 0..q.len() {\n \
    \       sum += q[i];\n    }\n    if sum > w {\n        return false;\n    }\n\
    \    for i in 0..q.len() / 2 {\n        if q[i] != q[q.len() - 1 - i] {\n    \
    \        return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() <= 1 { return\
    \ true; }\n    let sum = q.iter().sum::<isize>();\n    if sum > w { return false;\
    \ }\n    let mut rq = q.clone();\n    rq.reverse();\n    q == rq\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    let rev = q.iter().rev().cloned().collect::<Vec<isize>>();\n    sum <= w\
    \ && q == rev\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    let mid = q.len() / 2;\n    let mut result = true;\n    for i in 0..mid {\n\
    \        if q[i] != q[q.len() - i - 1] {\n            result = false;\n      \
    \      break;\n        }\n    }\n    if sum <= w && result {\n        true\n \
    \   } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    if sum <= w && is_palindrome(&q) {\n        true\n    } else {\n        false\n\
    \    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpxi4wuch4.rs:14:20\n   |\n14 |     if sum <= w && is_palindrome(&q) {\n\
    \   |                    ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    q.iter().sum::<isize>()\
    \ <= w && q == q.iter().rev().cloned().collect::<Vec<isize>>()\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut i = 0;\n    let len = q.len();\n    while i < len {\n        sum += q[i];\n\
    \        i += 1;\n    }\n    sum <= w && q == q.iter().rev().cloned().collect::<Vec<isize>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    sum <= w && is_palindrome(&q)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp8ocylopm.rs:14:17\n   |\n14 |     sum <= w && is_palindrome(&q)\n  \
    \ |                 ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    let mut half = q.len() / 2;\n    if q.len() % 2 == 1 {\n        half += 1;\n\
    \    }\n    let left = q[..half].iter().sum::<isize>();\n    let right = q[half..].iter().sum::<isize>();\n\
    \    sum <= w && left == right\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcjtoklng.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let m_w = w / (q.len()\
    \ as isize);\n    let balanced = q.iter().zip(q.iter().rev()).all(|(a, b)| a ==\
    \ b);\n    let sum = q.iter().sum::<isize>();\n    balanced && sum <= w\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n\tif q.iter().sum::<isize>()\
    \ > w {\n\t\treturn false;\n\t}\n\tfor index in 0..q.len() / 2 {\n\t\tif q[index]\
    \ != q[q.len() - index - 1] {\n\t\t\treturn false;\n\t\t}\n\t}\n\ttrue\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let s: isize = q.iter().sum();\n\
    \    let mut buf = Vec::new();\n    for x in q.iter() {\n        buf.push(x);\n\
    \    }\n    buf.reverse();\n    buf == q && s <= w\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpd47tus2g.rs:19:9\n\
    \   |\n19 |     buf == q && s <= w\n   |         ^^ no implementation for `&isize\
    \ == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<isize>>` for `Vec<&isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() == 1 {\n   \
    \     return true;\n    }\n    let sum: isize = q.iter().sum();\n    if sum >\
    \ w {\n        return false;\n    }\n    let mut left = 0;\n    let mut right\
    \ = q.len() - 1;\n    while left < right {\n        if q[left] != q[right] {\n\
    \            return false;\n        }\n        left += 1;\n        right -= 1;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut start = 0;\n  \
    \  let mut end = q.len() - 1;\n    let mut weight = 0;\n    let mut balanced =\
    \ true;\n    while start < end {\n        weight += q[start] + q[end];\n     \
    \   balanced = balanced && q[start] == q[end];\n        start += 1;\n        end\
    \ -= 1;\n    }\n    if start == end {\n        weight += q[start];\n    }\n  \
    \  weight <= w && balanced\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut left = 0;\n    let mut right = q.len() - 1;\n    while left < right {\n\
    \        sum += q[left] + q[right];\n        left += 1;\n        right -= 1;\n\
    \    }\n    sum <= w && q.len() % 2 == 0 || sum + q[left] <= w && q.len() % 2\
    \ == 1\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpk5tn_pvy.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut copy = q.clone();\n\
    \    copy.reverse();\n    if q == copy && q.iter().sum::<isize>() <= w {\n   \
    \     true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    (q.len() == 1 || q == q.iter().rev().collect::<Vec<&isize>>()) && sum <=\
    \ w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpkdxwyien.rs:14:24\n\
    \   |\n14 |     (q.len() == 1 || q == q.iter().rev().collect::<Vec<&isize>>())\
    \ && sum <= w\n   |                        ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n\
    \    q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmptbkmld_5.rs:15:39\n\
    \   |\n15 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q1 = q.clone();\n\
    \    q1.reverse();\n    if q1 == q && q.iter().sum::<isize>() <= w {\n       \
    \ true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    let\
    \ mut h = q.len() / 2;\n    let q_len = q.len();\n    for i in 0..h {\n      \
    \  q[i] += q[q_len - i - 1];\n    }\n    q.iter().sum::<isize>() <= w\n}\n\nfn\
    \ main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpt5hz119a.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let rev: Vec<isize> = q.iter().rev().map(|x|\
    \ *x).collect();\n    let sum: isize = q.iter().sum();\n    sum <= w && q == rev\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp1xq_d36b.rs:14:19\n\
    \   |\n14 |     sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n   |    \
    \               ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let l = q.len();\n    q.iter().take(l\
    \ / 2).eq(q.iter().rev().take(l / 2)) && q.iter().sum::<isize>() <= w\n}\n\nfn\
    \ main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() == 1 {\n   \
    \     q[0] <= w\n    } else {\n        let q_iter = q.iter();\n        let mut\
    \ sum = 0;\n        for element in q_iter {\n            sum += element;\n   \
    \     }\n        if sum <= w {\n            let mut q_reversed = q.clone();\n\
    \            q_reversed.reverse();\n            q_reversed == q\n        } else\
    \ {\n            false\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let length = q.len();\n\
    \    if length == 0 {\n        return false;\n    }\n\n    if length == 1 {\n\
    \        return q[0] <= w;\n    }\n\n    let sum = q.iter().sum::<isize>();\n\
    \    sum <= w && q[0..length / 2] == q[length / 2 + length % 2..].iter().rev().map(|x|\
    \ *x).collect::<Vec<isize>>()\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpvml8whc1.rs:14:19\n\
    \   |\n14 |     sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n   |    \
    \               ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n\
    \    let left = q.iter().take(q.len() / 2).sum::<isize>();\n    let right = q.iter().skip(q.len()\
    \ / 2).sum::<isize>();\n    left <= w && left == right\n}\n\nfn main() {\n   \
    \ let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpg69v6t9i.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let s = q.iter().sum::<isize>();\n\
    \    let l = q.len();\n    let v = (0..l/2).all(|i| q[i] == q[l-i-1]);\n    s\
    \ <= w && v\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut s = 0;\n    let\
    \ mut p = q.clone();\n    p.reverse();\n    for i in q {\n        s += i;\n  \
    \  }\n    s <= w && p == q\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `q`\n   --> /tmp/tmp3jmp0xp2.rs:19:20\n\
    \    |\n12  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \         - move occurs because `q` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n16  |     for i in q {\n    |              - `q` moved\
    \ due to this implicit call to `.into_iter()`\n...\n19  |     s <= w && p == q\n\
    \    |                    ^ value borrowed here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `q`\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n    |\n16  |     for i in &q {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    let mut r = q.clone();\n    r.reverse();\n    q == r && sum <= w\n}\n\nfn\
    \ main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    if sum <= w && q == q.iter().rev().collect::<Vec<&isize>>() {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp55oz8t1w.rs:14:22\n\
    \   |\n14 |     if sum <= w && q == q.iter().rev().collect::<Vec<&isize>>() {\n\
    \   |                      ^^ no implementation for `isize == &isize`\n   |\n\
    \   = help: the trait `PartialEq<&isize>` is not implemented for `isize`\n   =\
    \ help: the following other types implement trait `PartialEq<Rhs>`:\n        \
    \     f32\n             f64\n             i128\n             i16\n           \
    \  i32\n             i64\n             i8\n             isize\n           and\
    \ 6 others\n   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    let mut iter = q.iter();\n    sum <= w && q.iter().zip(iter.rev()).all(|(a,\
    \ b)| a == b)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    // Returns true if the\
    \ sum of q is less than or equal to w\n    // and if q is a palindrome.\n    q.iter().sum::<isize>()\
    \ <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n}\n\nfn main() {\n   \
    \ let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp_5yrriuj.rs:15:39\n\
    \   |\n15 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() == 1 {\n   \
    \     return true;\n    }\n    if q.iter().sum::<isize>() > w {\n        return\
    \ false;\n    }\n    let mut x = q.clone();\n    x.reverse();\n    x == q\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut list: Vec<isize>\
    \ = q.to_vec();\n    list.sort();\n    (q == list.clone().into_iter().rev().collect::<Vec<isize>>())\
    \ && (q.iter().sum::<isize>() <= w)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp07xxu_vw.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    // check if the vector\
    \ is a palindrome\n    let mut i = 0;\n    let mut j = q.len() - 1;\n    let mut\
    \ balanced = true;\n    while i < j {\n        if q[i] != q[j] {\n           \
    \ balanced = false;\n            break;\n        }\n        i += 1;\n        j\
    \ -= 1;\n    }\n    if !balanced {\n        return false;\n    }\n    // check\
    \ if the sum of elements is less than the max weight\n    let sum = q.iter().sum();\n\
    \    sum <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpojlmd26b.rs:29:9\n\
    \   |\n29 |     let sum = q.iter().sum();\n   |         ^^^ consider giving `sum`\
    \ a type\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    q.iter().sum::<isize>()\
    \ <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpyzshpdw8.rs:13:39\n\
    \   |\n13 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    if q.len() == 1 {\n        sum <= w\n    } else {\n        is_palindrome(&q)\
    \ && sum <= w\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n   \
    \ assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpgmn3olfr.rs:17:9\n   |\n17 |         is_palindrome(&q) && sum <= w\n\
    \   |         ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut result = false;\n\
    \    if q.len() < 2 || q.len() % 2 == 0 {\n        result = true;\n    }\n   \
    \ let mid_index = (q.len() as f64 / 2.0).floor() as usize;\n    if q[..mid_index]\
    \ == q[mid_index..].iter().rev().cloned().collect::<Vec<isize>>() {\n        result\
    \ = true;\n    }\n    if result && q.iter().sum::<isize>() <= w {\n        result\
    \ = true;\n    }\n    result\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp65imfdmn.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let n = q.len();\n    let\
    \ total_weight = q.iter().sum::<isize>();\n    total_weight <= w && q[..n/2] ==\
    \ q[n-n/2..].iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp_lk35vzk.rs:15:35\n\
    \   |\n15 |     total_weight <= w && q[..n/2] == q[n-n/2..].iter().rev().collect::<Vec<_>>()\n\
    \   |                                   ^^ no implementation for `isize == &isize`\n\
    \   |\n   = help: the trait `PartialEq<&isize>` is not implemented for `isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n   = note: required because of the requirements on the impl of\
    \ `PartialEq<Vec<&isize>>` for `[isize]`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let len = q.len();\n  \
    \  let sum: isize = q.iter().sum();\n    if sum <= w && len % 2 == 0 && q.iter().zip(q.iter().rev()).all(|(x,\
    \ y)| x == y) {\n        true\n    } else {\n        false\n    }\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4u_e3y3g.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    // Is the list palindromic?\n\
    \    if q.iter().zip(q.iter().rev()).any(|(x, y)| x != y) {\n        return false;\n\
    \    }\n    // Is the total weight less than the maximum possible weight?\n  \
    \  q.iter().sum::<isize>() <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    let mut q_copy = q.clone();\n    q_copy.reverse();\n    q == q_copy && sum\
    \ <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    q == q.iter().rev().collect::<Vec<&isize>>() && sum <= w\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpqoof4bg3.rs:14:7\n\
    \   |\n14 |     q == q.iter().rev().collect::<Vec<&isize>>() && sum <= w\n   |\
    \       ^^ no implementation for `isize == &isize`\n   |\n   = help: the trait\
    \ `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    sum <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp74difkyt.rs:14:19\n\
    \   |\n14 |     sum <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n   |\
    \                   ^^ no implementation for `isize == &isize`\n   |\n   = help:\
    \ the trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    // unimplemented!()\n \
    \   let sum = q.iter().sum();\n    let eq = q.iter().zip(q.iter().rev()).all(|(x,\
    \ y)| x == y);\n    return sum <= w && eq;\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpqi17vai5.rs:14:9\n\
    \   |\n14 |     let sum = q.iter().sum();\n   |         ^^^ consider giving `sum`\
    \ a type\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut i = 0;\n    let\
    \ mut sum = 0;\n    while i < q.len() {\n        sum += q[i];\n        i += 1;\n\
    \    }\n    if sum <= w {\n        return true;\n    }\n    return false;\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpdwrzxy_0.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    let len = q.len();\n    let half = len / 2;\n    let rest = len - half;\n\
    \    if sum <= w {\n        for i in 0..half {\n            if q[i] != q[rest\
    \ - i - 1] {\n                return false;\n            }\n        }\n      \
    \  return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpr4n6pp0_.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let total = q.iter().sum::<isize>();\n\
    \    w >= total && q == q.iter().rev().collect::<Vec<&isize>>()\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpzgh9h_4t.rs:14:21\n\
    \   |\n14 |     w >= total && q == q.iter().rev().collect::<Vec<&isize>>()\n \
    \  |                     ^^ no implementation for `isize == &isize`\n   |\n  \
    \ = help: the trait `PartialEq<&isize>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    let mut r = q.clone();\n    r.reverse();\n    r == q && sum <= w\n}\n\nfn\
    \ main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    // sum the queue\n    let\
    \ sum: isize = q.iter().sum();\n    // if the queue length is even, then check\
    \ the front half against the back half of the queue\n    // otherwise, check the\
    \ front half - 1 against the back half of the queue\n    let check = if q.len()\
    \ % 2 == 0 {\n        (q.len() / 2) as usize\n    } else {\n        ((q.len()\
    \ / 2) - 1) as usize\n    };\n    // check the first half of the queue\n    let\
    \ forward = &q[..check];\n    // check the second half of the queue\n    let reverse\
    \ = &q[q.len() - check..];\n    // if the sum is less than or equal to the weight,\
    \ and the forward and reverse halves are the same, the queue will fly\n    (sum\
    \ <= w) && (forward == reverse)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpu3nm4ocs.rs:20:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    if sum <= w && is_palindrome(&q) {\n        true\n    } else {\n        false\n\
    \    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpnutlzz4i.rs:14:20\n   |\n14 |     if sum <= w && is_palindrome(&q) {\n\
    \   |                    ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpj5fpcjbc.rs:14:19\n\
    \   |\n14 |     sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n   |    \
    \               ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let n = q.len();\n    q.iter().fold(0,\
    \ |sum, x| sum + x) <= w && (0..n / 2).all(|i| q[i] == q[n - i - 1])\n}\n\nfn\
    \ main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    let mut rq = q.clone();\n   \
    \ rq.reverse();\n    if q == rq && sum <= w {\n        return true;\n    }\n \
    \   false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() < 2 {\n    \
    \    return true;\n    }\n    if q.iter().sum::<isize>() > w {\n        return\
    \ false;\n    }\n    let mut i = 0;\n    let mut j = q.len() - 1;\n    while i\
    \ < j {\n        if q[i] != q[j] {\n            return false;\n        }\n   \
    \     i += 1;\n        j -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    q == q.iter().rev().collect::<Vec<&isize>>() && sum <= w\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmptej_sxrt.rs:14:7\n\
    \   |\n14 |     q == q.iter().rev().collect::<Vec<&isize>>() && sum <= w\n   |\
    \       ^^ no implementation for `isize == &isize`\n   |\n   = help: the trait\
    \ `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q = q;\n    q.reverse();\n\
    \    let mut p = 0;\n    let mut b = true;\n    for i in q {\n        p += i;\n\
    \        if i != q[q.len() - 1 - q.iter().position(|&x| x == i).unwrap()] {\n\
    \            b = false;\n        }\n    }\n    return p <= w && b;\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `q`\n   --> /tmp/tmpvmlk0orh.rs:19:17\n\
    \    |\n13  |     let mut q = q;\n    |         ----- move occurs because `q`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n17  |\
    \     for i in q {\n    |              - `q` moved due to this implicit call to\
    \ `.into_iter()`\n18  |         p += i;\n19  |         if i != q[q.len() - 1 -\
    \ q.iter().position(|&x| x == i).unwrap()] {\n    |                 ^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `q`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n17  |     for i in &q {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let weight: isize = q.iter().sum();\n\
    \    let mut q_rev = q.clone();\n    q_rev.reverse();\n    weight <= w && q ==\
    \ q_rev\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    q.len() > 1 && q.iter().fold(0,\
    \ |acc, &x| acc + x) <= w && q == q.iter().rev().cloned().collect::<Vec<isize>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpmlglpnvo.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.iter().sum::<isize>()\
    \ <= w && q == q.iter().rev().collect::<Vec<_>>() {\n        true\n    } else\
    \ {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpvpo1_km5.rs:13:42\n\
    \   |\n13 |     if q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\
    \ {\n   |                                          ^^ no implementation for `isize\
    \ == &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut is_palindrome =\
    \ true;\n    let mut half_len = q.len() / 2;\n    if q.len() > 1 {\n        for\
    \ i in 0..half_len {\n            if q[i] != q[q.len() - 1 - i] {\n          \
    \      is_palindrome = false;\n                break;\n            }\n       \
    \ }\n    }\n    if is_palindrome {\n        let sum: isize = q.iter().sum();\n\
    \        if sum <= w {\n            return true;\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() % 2 == 0 {\n\
    \        return false;\n    }\n    q.iter().sum::<isize>() <= w && q == q.iter().rev().cloned().collect::<Vec<isize>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let l = q.len();\n    let\
    \ s = q.iter().sum::<isize>();\n    l == 0 || l == 1 || l % 2 == 0 && q[..l /\
    \ 2] == q[l / 2..].iter().rev().collect::<Vec<_>>() && s <= w\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp5bktn5ip.rs:15:50\n\
    \   |\n15 |     l == 0 || l == 1 || l % 2 == 0 && q[..l / 2] == q[l / 2..].iter().rev().collect::<Vec<_>>()\
    \ && s <= w\n   |                                                  ^^ no implementation\
    \ for `isize == &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not\
    \ implemented for `isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n   = note: required because of the requirements\
    \ on the impl of `PartialEq<Vec<&isize>>` for `[isize]`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    q.len() % 2 == 0\n    &&\
    \ w >= q.iter().sum::<isize>()\n    && w >= q.iter().rev().sum::<isize>()\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpp1qqp62p.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    q.iter().sum::<isize>()\
    \ <= w && is_palindrome(&q)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpn71zg7a7.rs:13:37\n   |\n13 |     q.iter().sum::<isize>() <= w && is_palindrome(&q)\n\
    \   |                                     ^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp6ij05b8x.rs:14:19\n\
    \   |\n14 |     sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n   |    \
    \               ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in &q {\n        sum += i;\n    }\n    if sum <= w {\n        for i in 0..(q.len()\
    \ / 2) {\n            if q[i] != q[q.len() - i - 1] {\n                return\
    \ false;\n            }\n        }\n        return true;\n    }\n    false\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    q == q.iter().rev().collect::<Vec<_>>() && sum <= w\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpi0vvbw0p.rs:14:7\n\
    \   |\n14 |     q == q.iter().rev().collect::<Vec<_>>() && sum <= w\n   |    \
    \   ^^ no implementation for `isize == &isize`\n   |\n   = help: the trait `PartialEq<&isize>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n   = note: required because of the requirements\
    \ on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    return q.iter().sum::<isize>()\
    \ <= w && q == q.iter().rev().collect::<Vec<_>>();\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpzizpb4wa.rs:13:46\n\
    \   |\n13 |     return q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>();\n\
    \   |                                              ^^ no implementation for `isize\
    \ == &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q_clone = q.clone();\n\
    \    let mut a = 0;\n    let mut b = q_clone.len()-1;\n    while a < b {\n   \
    \     if q_clone[a] != q_clone[b] {\n            return false;\n        }\n  \
    \      a += 1;\n        b -= 1;\n    }\n    let sum = q.iter().sum();\n    sum\
    \ <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpjefacd5v.rs:23:9\n\
    \   |\n23 |     let sum = q.iter().sum();\n   |         ^^^ consider giving `sum`\
    \ a type\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    q.iter().sum::<isize>()\
    \ <= w && palindrome(q)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `palindrome` in this scope\n  --> /tmp/tmprig7f9o4.rs:13:37\n\
    \   |\n13 |     q.iter().sum::<isize>() <= w && palindrome(q)\n   |          \
    \                           ^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in &q {\n        sum += i;\n    }\n    let len = q.len();\n    let mid = len\
    \ / 2;\n    if sum <= w {\n        let mut flag = true;\n        for i in 0..mid\
    \ {\n            if q[i] != q[len - i - 1] {\n                flag = false;\n\
    \                break;\n            }\n        }\n        flag\n    } else {\n\
    \        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n  \
    \  assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut i = 0;\n    let\
    \ mut q1 = q.clone();\n    let mut q2 = q.clone();\n    let sum = q.iter().sum();\n\
    \    q1.reverse();\n    q2 == q1 && sum <= w\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp0atekk4q.rs:16:9\n\
    \   |\n16 |     let sum = q.iter().sum();\n   |         ^^^ consider giving `sum`\
    \ a type\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut palin = true;\n    let length = q.len();\n    let half = length / 2;\n \
    \   let mut i = 0;\n    while i < half {\n        if q[i] != q[length - i - 1]\
    \ {\n            palin = false;\n            break;\n        }\n        sum +=\
    \ q[i];\n        i += 1;\n    }\n    if length % 2 == 1 {\n        sum += q[half];\n\
    \    }\n    sum <= w && palin\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    q.iter().sum::<isize>()\
    \ <= w &&\n    q.iter().eq(q.iter().rev())\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let len = q.len();\n  \
    \  let center = len / 2;\n    let half1 = &q[..center];\n    let half2 = &q[center\
    \ + len % 2..];\n    half1 == half2.iter().rev() && half1.iter().sum::<isize>()\
    \ <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&[isize]` with `Rev<std::slice::Iter<'_, isize>>`\n\
    \  --> /tmp/tmp8xiykpz2.rs:17:11\n   |\n17 |     half1 == half2.iter().rev() &&\
    \ half1.iter().sum::<isize>() <= w\n   |           ^^ no implementation for `&[isize]\
    \ == Rev<std::slice::Iter<'_, isize>>`\n   |\n   = help: the trait `PartialEq<Rev<std::slice::Iter<'_,\
    \ isize>>>` is not implemented for `&[isize]`\n   = help: the following other\
    \ types implement trait `PartialEq<Rhs>`:\n             <&[B] as PartialEq<[A;\
    \ N]>>\n             <&[T] as PartialEq<Vec<U, A>>>\n             <&mut [B] as\
    \ PartialEq<[A; N]>>\n             <&mut [T] as PartialEq<Vec<U, A>>>\n      \
    \       <[A; N] as PartialEq<&[B]>>\n             <[A; N] as PartialEq<&mut [B]>>\n\
    \             <[A; N] as PartialEq<[B; N]>>\n             <[A; N] as PartialEq<[B]>>\n\
    \           and 3 others\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() % 2 == 0 {\n\
    \        return false;\n    }\n    let mut b: isize = 0;\n    let mut e: isize\
    \ = q.len() as isize - 1;\n    while b < e {\n        if q[b as usize] != q[e\
    \ as usize] {\n            return false;\n        }\n        b += 1;\n       \
    \ e -= 1;\n    }\n    let sum: isize = q.iter().sum();\n    return sum <= w;\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.iter().sum::<isize>()\
    \ <= w && q == q.iter().rev().collect::<Vec<&isize>>() {\n        true\n    }\
    \ else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpqoo73tmd.rs:13:42\n\
    \   |\n13 |     if q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<&isize>>()\
    \ {\n   |                                          ^^ no implementation for `isize\
    \ == &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() == 1 {\n   \
    \     return true;\n    }\n    q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpbp9nik9x.rs:16:39\n\
    \   |\n16 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.iter().sum::<isize>()\
    \ <= w && q == q.iter().rev().collect::<Vec<_>>() {\n        true\n    } else\
    \ {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpnhse128y.rs:13:42\n\
    \   |\n13 |     if q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\
    \ {\n   |                                          ^^ no implementation for `isize\
    \ == &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut h = 0;\n    let mut t = q.len() - 1;\n    for _ in 0..q.len() / 2 {\n  \
    \      if q[h] != q[t] {\n            return false;\n        }\n        sum +=\
    \ q[h] + q[t];\n        h += 1;\n        t -= 1;\n    }\n    if q.len() % 2 ==\
    \ 1 {\n        sum += q[h];\n    }\n    sum <= w\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    let middle = q.len() / 2;\n    let (left, right) = q.split_at(middle);\n\
    \    left == right.iter().rev() && sum <= w\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&[isize]` with `Rev<std::slice::Iter<'_, isize>>`\n\
    \  --> /tmp/tmpnf8h4_73.rs:16:10\n   |\n16 |     left == right.iter().rev() &&\
    \ sum <= w\n   |          ^^ no implementation for `&[isize] == Rev<std::slice::Iter<'_,\
    \ isize>>`\n   |\n   = help: the trait `PartialEq<Rev<std::slice::Iter<'_, isize>>>`\
    \ is not implemented for `&[isize]`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&[B] as PartialEq<[A; N]>>\n        \
    \     <&[T] as PartialEq<Vec<U, A>>>\n             <&mut [B] as PartialEq<[A;\
    \ N]>>\n             <&mut [T] as PartialEq<Vec<U, A>>>\n             <[A; N]\
    \ as PartialEq<&[B]>>\n             <[A; N] as PartialEq<&mut [B]>>\n        \
    \     <[A; N] as PartialEq<[B; N]>>\n             <[A; N] as PartialEq<[B]>>\n\
    \           and 3 others\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut q_temp = q.clone();\n\
    \    q_temp.sort();\n    let (mut low, mut high) = (0, q_temp.len() - 1);\n  \
    \  let mut sum = 0;\n    while low < high {\n        sum += q_temp[low] + q_temp[high];\n\
    \        low += 1;\n        high -= 1;\n    }\n    if low == high {\n        sum\
    \ += q_temp[low];\n    }\n    sum <= w\n}\n\nfn main() {\n    let candidate =\
    \ will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp_fs5wm6z.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    (q.len() as isize <= w)\
    \ && q == q.iter().rev().cloned().collect::<Vec<isize>>()\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    q == q.iter().rev().cloned().collect::<Vec<isize>>() && sum <= w\n}\n\nfn\
    \ main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    let\
    \ mut i = 0;\n    let mut j = q.len() - 1;\n    while i < j {\n        if q[i]\
    \ != q[j] {\n            return false;\n        }\n        sum += q[i];\n    \
    \    i += 1;\n        j -= 1;\n    }\n    sum += q[i];\n    sum <= w\n}\n\nfn\
    \ main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut sum = 0;\n    for\
    \ i in q.iter() {\n        sum += i;\n    }\n    if q == q.iter().rev().collect::<Vec<_>>()\
    \ && sum <= w {\n        true\n    } else {\n        false\n    }\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpu995eq37.rs:17:10\n\
    \   |\n17 |     if q == q.iter().rev().collect::<Vec<_>>() && sum <= w {\n   |\
    \          ^^ no implementation for `isize == &isize`\n   |\n   = help: the trait\
    \ `PartialEq<&isize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    if q.len() < 2 {\n    \
    \    return true;\n    }\n    if q.iter().sum::<isize>() > w {\n        return\
    \ false;\n    }\n    if q != q.iter().rev().cloned().collect::<Vec<isize>>() {\n\
    \        return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate =\
    \ will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n\
    \    if sum <= w && is_palindrome(&q) {\n        true\n    } else {\n        false\n\
    \    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp6agj8iqr.rs:14:20\n   |\n14 |     if sum <= w && is_palindrome(&q) {\n\
    \   |                    ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    sum <= w && is_palindrome(&q)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpr8efmkdf.rs:14:17\n   |\n14 |     sum <= w && is_palindrome(&q)\n  \
    \ |                 ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let mut t = q.clone();\n\
    \    t.reverse();\n    let balanced = q == t;\n    let weight = q.iter().sum::<isize>();\n\
    \    balanced && weight <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// will_it_fly([1, 2], 5) \u279E False \n/// # 1+2\
    \ is less than the maximum possible weight, but it's unbalanced.\n/// will_it_fly([3,\
    \ 2, 3], 1) \u279E False\n/// # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n/// will_it_fly([3, 2, 3], 9) \u279E True\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// will_it_fly([3],\
    \ 5) \u279E True\n/// # 3 is less than the maximum possible weight, and it's balanced.\n\
    fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n\
    \    let palindrome = is_palindrome(&q);\n    if sum <= w && palindrome {\n  \
    \      true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpwe03gl1q.rs:14:22\n   |\n14 |     let palindrome = is_palindrome(&q);\n\
    \   |                      ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
