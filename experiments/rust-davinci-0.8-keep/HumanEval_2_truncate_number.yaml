name: HumanEval_2_truncate_number
language: rust
prompt: "/// Given a positive floating point number, it can be decomposed into\n///\
  \ and integer part (largest integer smaller than given number) and decimals\n///\
  \ (leftover part always smaller than 1).\n/// Return the decimal part of the number.\n\
  /// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64) -> f64 {\n"
tests: "}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
  \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
  \ 0.0);\n}\n"
completions: ["    let integer_part = number.floor();\n    let decimal_part = number\
    \ - integer_part;\n    decimal_part", "    if number >= 0.0 {\n        number\
    \ - number.floor()\n    } else {\n        number - number.ceil()\n    }", '    number
    - number.floor()', "    let int_part = number.floor();\n    return number - int_part;",
  "    let integer_part = number.floor();\n    number - integer_part", "    let truncate_number_negative\
    \ = if number < 0.0 {\n        truncate_number(-number)\n    } else {\n      \
    \  number - number.floor()\n    };\n    if truncate_number_negative >= 1.0 {\n\
    \        truncate_number_negative - 1.0\n    } else {\n        truncate_number_negative\n\
    \    }", "    if number.is_infinite() {\n        panic!(\"Number is infinite\"\
    );\n    }\n    if number.is_nan() {\n        panic!(\"Number is not a number\"\
    );\n    }\n    if number < 0.0 {\n        panic!(\"Number must be positive\");\n\
    \    }\n    let mut number = number;\n    while number > 1.0 {\n        number\
    \ -= 1.0;\n    }\n    number", "    let int_part = number.floor();\n    return\
    \ number - int_part;", '    number - (number as i64) as f64', '    number.fract()',
  "    if number > 0.0 {\n        number - number.floor()\n    } else {\n        number\
    \ - number.ceil()\n    }", '    number - number.floor()', '    number - number.floor()',
  "    let mut number = number;\n    let mut integer_part = 0.0;\n    while number\
    \ >= 1.0 {\n        number -= 1.0;\n        integer_part += 1.0;\n    }\n    number",
  '    number - number.floor()', '    number - number.floor()', '    number - number.floor()',
  "    let (int_part, _) = number.modf();\n    return number - int_part;", "    //\
    \ TODO\n    number - number.floor()", '    number - number.floor()', '    number
    - number.floor()', '    number - number.floor()', '    return number - number.floor();',
  '    number - number.floor()', '    (number - number.floor())', "    let int_part\
    \ = number.floor();\n    number - int_part", '    number - number.floor()', '    number
    - number.floor()', '    number - number.floor()', "    let mut number_int = number.trunc();\n\
    \    number - number_int", "    if number >= 0.0 {\n        return number.fract();\n\
    \    }\n    return number.fract() + 1.0;", '    number - number.floor()', '    number
    - (number as i64) as f64', '    return number - (number as i64) as f64;', '    number
    - number.floor()', '    (number % 1.0)', "    let integer_part = number.floor();\n\
    \    let decimals = number - integer_part;\n    decimals", '    number - number.floor()',
  '    number.fract()', '    return number - number.floor();', "    if number >= 0.0\
    \ {\n        number - number.floor()\n    } else {\n        -(number - (number\
    \ + 1.0).floor())\n    }", '    number.fract()', "    let rounded_number = number.round();\n\
    \    if rounded_number > number {\n        rounded_number - number\n    } else\
    \ {\n        number - rounded_number\n    }", '    number - number.floor()', '    number.trunc()
    - number', "    let integer_part = number.floor();\n    let decimal_part = number\
    \ - integer_part;\n    return decimal_part;", "    if number.fract() == 0.0 {\n\
    \        0.0\n    } else {\n        number.fract()\n    }", '    number.fract()',
  "    let mut number = number;\n    let decimals = number - number.floor();\n   \
    \ if number > 1.0 {\n        number -= 1.0;\n    }\n    decimals", "    let n\
    \ = number.floor();\n    number - n", "    let integer_part = number.floor();\n\
    \    number - integer_part", '    number.fract()', "    let integer_part = number.floor();\n\
    \    let decimal_part = number - integer_part;\n    return decimal_part;", '    number
    - number.floor()', '    number.fract()', '    number.fract()', '    number - number.floor()',
  '    number - number.floor()', '    number.fract()', '    number.fract()', '    number
    - (number as i64) as f64', '    number.fract()', '    number - number.floor()',
  '    number.fract()', '    number - number.floor()', "    // TODO\n    unimplemented!()",
  "    let integer = number.floor();\n    number - integer", "    // Returns the decimal\
    \ part of a number\n    return number - number.floor();", '    number - number.floor()',
  '    number - number.floor()', '    (number * 100_f64).trunc() / 100_f64', '    number.fract()',
  "    let int_part = number.floor();\n    number - int_part", '    number.fract()',
  "    let (int_part, dec_part) = split_number(number);\n    dec_part", '    number
    - number.floor()', "    if number > 0.0 {\n        return number - (number as\
    \ i64) as f64;\n    } else {\n        return number + (number as i64) as f64;\n\
    \    }", "    let result = number - number.floor();\n    result", "    // If the\
    \ number is positive\n    if number > 0.0 {\n        number - number.floor()\n\
    \    } else {\n        // If the number is negative\n        number.ceil() - number\n\
    \    }", "    let int_part = number.floor();\n    number - int_part", '    number
    - (number as i64) as f64', "    if number > 0.0 {\n        number.fract()\n  \
    \  } else {\n        number - number.trunc()\n    }", "    if number < 0.0 {\n\
    \        return 0.0;\n    }\n    let mut number_cpy = number;\n    let int_part\
    \ = (number_cpy as u64) as f64;\n    number_cpy -= int_part;\n    number_cpy",
  "    let ipart = number.trunc();\n    return number - ipart;", '    number.fract()',
  '    number - number.floor()', "    let integer_part = number.floor();\n    number\
    \ - integer_part", '    number.fract()', "    let int = number.trunc();\n    number\
    \ - int", "    let integer_part = number.floor();\n    let decimal_part = number\
    \ - integer_part;\n    return decimal_part;", '    number.trunc()', '    number.fract()',
  '    number - number.floor()', "    // Make sure it's a positive number\n    let\
    \ number = if number < 0.0 { -number } else { number };\n\n    // Integer part\
    \ is the largest integer smaller than the number\n    let integer_part = number.floor();\n\
    \n    // Subtract the integer part to get only the decimals\n    number - integer_part",
  '    return number.trunc();', '    return number.fract();', '    number.trunc()',
  '    number - number.floor()', "    let integer = integer_part(number);\n    return\
    \ number - integer;", '    number - (number as i64) as f64', "    let integer_part\
    \ = number.floor();\n    let fractional_part = number - integer_part;\n    fractional_part",
  "    let truncated = number.trunc();\n    number - truncated", "    let integer_part\
    \ = number.floor();\n    number - integer_part", "    if number < 0.0 {\n    \
    \    return number.fract();\n    }\n    return number.fract();", "    let number_truncated\
    \ = number.trunc();\n    let mut decimals = number - number_truncated;\n    if\
    \ decimals < 0.0 {\n        decimals = -decimals;\n    }\n    decimals", '    number
    - number.floor()', '    number - number.floor()', '    number - number.floor()',
  '    number.fract()', '    number - number.floor()', '    number.fract()', '    number.fract()',
  '    number - number.floor()', '    number - number.floor()', "    let integer_part\
    \ = number.floor();\n    number - integer_part", '    return number - number.floor();',
  "    let integer_part = number.floor();\n    number - integer_part", '    number
    - (number as i64) as f64', '    number.trunc() - number', '    number - (number
    as u64) as f64', '    number.fract()', "    if number >= 0.0 {\n        number\
    \ - (number as i64) as f64\n    } else {\n        1.0 + (number - (number as i64)\
    \ as f64)\n    }", "    match number.floor() {\n        num if num < 0.0 => number\
    \ - num,\n        num => number - num,\n    }", '    number.fract()', '    number
    - number.floor()', '    number - number.floor()', '    number - (number as u64)
    as f64', '    number - (number as i64) as f64', "    let integer_part = number.floor();\n\
    \    number - integer_part", '    number.fract()', "    if number >= 0.0 {\n \
    \       number - (number as i64) as f64\n    } else {\n        1.0 + (number -\
    \ (number as i64) as f64)\n    }", '    number - number.floor()', "    // TODO\n\
    \    unimplemented!();", "    match number.fract() {\n        fract if fract ==\
    \ 0.0 => 0.0,\n        fract => fract,\n    }", '    number - number.floor()',
  '    number.fract()', '    number - number.floor()', "    // TODO Check if there\
    \ is a libary function to do this\n    number - (number as i64) as f64", "   \
    \ let fractional_part = number - number.floor();\n    fractional_part", '    number.fract()',
  "    match number.fract() {\n        n if n >= 0.0 => n,\n        n => n + 1.0,\n\
    \    }", '    (number - number.floor())', '    number.fract()', "    if number\
    \ < 0.0 {\n        return -truncate_number(-number);\n    }\n    let truncated\
    \ = number.trunc();\n    number - truncated", '    number - number.floor()', '    number
    - (number as i64) as f64', "    // TODO: implement truncate_number()\n    unimplemented!();",
  "    let (n, decimals) = integer_and_decimals(number);\n    return decimals;", '    return
    number - f64::floor(number);', "    let ten = 10.0;\n    let ipart = number.trunc();\n\
    \    let fpart = number - ipart;\n    fpart * ten", '    number - number.floor()',
  '    return number - number.floor();', '    number - number.floor()', "    // TODO\n\
    \    number - number.floor()", '    number.fract()', "    let mut number = number;\n\
    \    while number > 1.0 {\n        number -= 1.0;\n    }\n    number", "    if\
    \ number < 0.0 {\n        return -number.trunc();\n    }\n\n    number.trunc()",
  '    number - number.floor()', '    number.fract()', '    return number - (number
    as i64) as f64;', "    let mut number = number;\n    number -= (number as i64)\
    \ as f64;\n    number", "    let mut truncated = (number * 100.0).round() / 100.0;\n\
    \    if truncated < number {\n        truncated += 0.01;\n    }\n    truncated",
  '    number - number.floor()', '    number.fract()', '    number.fract()', '    number.fract()',
  '    number - number.floor()', '    number - number.floor()', "    match number.fract()\
    \ {\n        number if number == 0.0 => 0.0,\n        number => number,\n    }",
  "    // TODO\n    return number - number.floor();", "    let integer_part = number.floor();\n\
    \    let decimal_part = number - integer_part;\n    decimal_part", "    if number\
    \ < 0.0 {\n        panic!(\"Number must be positive\");\n    }\n    let int_part\
    \ = number.trunc();\n    number - int_part", '    number - number.floor()', '    return
    number - number.floor();', "    let raw = number.trunc();\n    let mut truncated\
    \ = number - raw;\n    if truncated < 0.0 {\n        truncated = 1.0 + truncated;\n\
    \    }\n    truncated", '    number - number.floor()', '    number.fract()', " \
    \   let integer = number.floor();\n    number - integer", '    number.fract()',
  "    let mut number = number;\n    let int_part = number.trunc();\n    number -=\
    \ int_part;\n    number", '    number - number.floor()', "    let int_part = number.floor();\n\
    \    number - int_part", "    if number.is_sign_positive() {\n        return number.fract();\n\
    \    }\n    return number.fract() + 1.0;", '    return number.fract();', "   \
    \ let integer_part = number.floor();\n    let leftover = number - integer_part;\n\
    \    leftover", '    number - number.floor()', '    number.fract()', '    number
    - number.floor()', '    number - number.floor()', '    number - number.floor()',
  '    number.fract()', '    number.fract()', '    return number.fract();', '    number
    - number.floor()', "    // TODO\n    unimplemented!()", "    let integer_part\
    \ = number.floor();\n    number - integer_part", "    // https://stackoverflow.com/questions/5773690/how-do-i-truncate-a-float-in-rust\n\
    \    number - number.trunc()", '    number - number.floor()', '    number - number.floor()',
  "    let integer_part = number.floor();\n    let decimal_part = number - integer_part;\n\
    \    decimal_part"]
stop_tokens:
- "\n}"
