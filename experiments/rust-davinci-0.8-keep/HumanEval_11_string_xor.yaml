name: HumanEval_11_string_xor
language: rust
prompt: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
  \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor('010',\
  \ '110')\n/// '100'\nfn string_xor(a: String, b: String) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
  111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
  1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
  0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
completions: ["    let a = u8::from_str_radix(&a, 2).unwrap();\n    let b = u8::from_str_radix(&b,\
    \ 2).unwrap();\n    format!(\"{:b}\", a ^ b)", "    let mut result = Vec::new();\n\
    \    for i in 0..a.len() {\n        let x = a.chars().nth(i).unwrap();\n     \
    \   let y = b.chars().nth(i).unwrap();\n        let z = if x == y {\n        \
    \    '0'\n        } else {\n            '1'\n        };\n        result.push(z);\n\
    \    }\n    String::from_iter(result)", "    let mut result = String::new();\n\
    \    let mut a_iter = a.chars();\n    let mut b_iter = b.chars();\n    while let\
    \ (Some(a_val), Some(b_val)) = (a_iter.next(), b_iter.next()) {\n        result.push_str(&format!(\"\
    {}\", a_val.to_digit(10).unwrap() ^ b_val.to_digit(10).unwrap()));\n    }\n  \
    \  result", "    let mut output = String::new();\n    let mut s1 = a.chars();\n\
    \    let mut s2 = b.chars();\n    loop {\n        let c1 = s1.next();\n      \
    \  let c2 = s2.next();\n        if c1 == None || c2 == None {\n            break;\n\
    \        }\n        if c1.unwrap() == c2.unwrap() {\n            output.push('0');\n\
    \        } else {\n            output.push('1');\n        }\n    }\n    output",
  "    let mut out = String::new();\n    let mut chars_a = a.chars();\n    let mut\
    \ chars_b = b.chars();\n    while let (Some(char_a), Some(char_b)) = (chars_a.next(),\
    \ chars_b.next()) {\n        out.push(match (char_a, char_b) {\n            ('0',\
    \ '0') => '0',\n            ('0', '1') => '1',\n            ('1', '0') => '1',\n\
    \            ('1', '1') => '0',\n            _ => panic!(\"Unexpected character.\"\
    ),\n        });\n    }\n    out", "    if a.len() != b.len() {\n        panic!(\"\
    string_xor: strings must be the same length\");\n    }\n    let mut ret: String\
    \ = String::new();\n    for i in 0..a.len() {\n        if a.chars().nth(i).unwrap()\
    \ == b.chars().nth(i).unwrap() {\n            ret.push('0');\n        } else {\n\
    \            ret.push('1');\n        }\n    }\n    ret", "    let mut result =\
    \ String::new();\n    let mut a = a.chars();\n    let mut b = b.chars();\n   \
    \ while let (Some(ai), Some(bi)) = (a.next(), b.next()) {\n        result.push(char::from(ai.to_digit(10).unwrap()\
    \ ^ bi.to_digit(10).unwrap() + 48));\n    }\n    result", "    let mut xor = String::new();\n\
    \    for i in 0..std::cmp::min(a.len(), b.len()) {\n        let a_char = a.chars().nth(i).unwrap();\n\
    \        let b_char = b.chars().nth(i).unwrap();\n        xor.push(if a_char ==\
    \ b_char { '0' } else { '1' });\n    }\n    xor", "    let mut a_bits = BitVec::from_bytes(&a.into_bytes());\n\
    \    let mut b_bits = BitVec::from_bytes(&b.into_bytes());\n    let mut result\
    \ = BitVec::new();\n    for _ in 0..a_bits.len() {\n        result.push(a_bits.pop().unwrap()\
    \ ^ b_bits.pop().unwrap());\n    }\n    result.into_bytes().into_iter().map(|byte|\
    \ char::from(byte)).collect()", "    // replace all characters with '1'\n    a.chars().zip(b.chars()).map(|(c1,\
    \ c2)| {\n        match (c1, c2) {\n            ('0', '0') => '0',\n         \
    \   ('1', '1') => '0',\n            _ => '1',\n        }\n    }).collect()", " \
    \   String::from_utf8(\n        a.into_bytes()\n            .into_iter()\n   \
    \         .zip(b.into_bytes().into_iter())\n            .map(|(a, b)| a ^ b)\n\
    \            .collect::<Vec<u8>>(),\n    )\n    .unwrap()", "    let mut result\
    \ = String::new();\n    for i in 0..a.len() {\n        let bit_a = a.as_bytes()[i]\
    \ - 48;\n        let bit_b = b.as_bytes()[i] - 48;\n        let bit_xor = bit_a\
    \ ^ bit_b;\n        result.push_str(&bit_xor.to_string());\n    }\n    result",
  "    let bytes_a = a.as_bytes();\n    let bytes_b = b.as_bytes();\n    let max_bytes\
    \ = cmp::max(bytes_a.len(), bytes_b.len());\n    let mut res = Vec::with_capacity(max_bytes);\n\
    \    for i in 0..max_bytes {\n        let mut b = 0u8;\n        if i < bytes_a.len()\
    \ {\n            b = b | bytes_a[i];\n        }\n        if i < bytes_b.len()\
    \ {\n            b = b ^ bytes_b[i];\n        }\n        res.push(b);\n    }\n\
    \    String::from_utf8(res).unwrap()", "    let mut ret = String::new();\n   \
    \ for ((i, j), _k) in a.chars().zip(b.chars()).enumerate() {\n        let c =\
    \ i32::from_str_radix(&a[i..i + 1], 2).unwrap()\n            ^ i32::from_str_radix(&b[j..j\
    \ + 1], 2).unwrap();\n        ret.push_str(&c.to_string());\n    }\n    ret",
  "    if a.len() != b.len() {\n        panic!(\"Strings are not of the same length.\"\
    );\n    }\n    let mut res = String::new();\n    for i in 0..a.len() {\n     \
    \   res.push(if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap() {\n   \
    \         '0'\n        } else {\n            '1'\n        });\n    }\n    res",
  "    let mut res = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n\
    \        if i == j {\n            res.push('0');\n        } else {\n         \
    \   res.push('1');\n        }\n    }\n    res", "    let a: Vec<u8> = a.into_bytes();\n\
    \    let b: Vec<u8> = b.into_bytes();\n    let mut result = String::new();\n \
    \   let mut buf = [0u8; 1];\n    for i in 0..a.len() {\n        buf[0] = a[i]\
    \ ^ b[i];\n        result.push_str(&String::from_utf8(buf.to_vec()).unwrap());\n\
    \    }\n    result", "    let mut out: String = String::new();\n    let mut carry\
    \ = 0;\n    let mut count = 0;\n    if a.len() > b.len() {\n        for _ in 0..(a.len()\
    \ - b.len()) {\n            b.insert(0, '0');\n        }\n    } else if a.len()\
    \ < b.len() {\n        for _ in 0..(b.len() - a.len()) {\n            a.insert(0,\
    \ '0');\n        }\n    }\n    println!(\"{:?} {:?}\", a, b);\n    for (i, a_)\
    \ in a.chars().rev().enumerate() {\n        for (j, b_) in b.chars().rev().enumerate()\
    \ {\n            if j == i {\n                if a_ == '1' && b_ == '1' {\n  \
    \                  if carry == 0 {\n                        out.insert(0, '0');\n\
    \                        carry = 1;\n                    } else {\n          \
    \              out.insert(0, '1');\n                        carry = 1;\n     \
    \               }\n                } else if a_ == '0' && b_ == '0' {\n      \
    \              if carry == 0 {\n                        out.insert(0, '0');\n\
    \                        carry = 0;\n                    } else {\n          \
    \              out.insert(0, '1');\n                        carry = 0;\n     \
    \               }\n                } else {\n                    if carry == 0\
    \ {\n                        out.insert(0, '1');\n                        carry\
    \ = 0;\n                    } else {\n                        out.insert(0, '0');\n\
    \                        carry = 1;\n                    }\n                }\n\
    \            }\n        }\n        count += 1;\n    }\n    if carry == 1 {\n \
    \       out.insert(0, '1');\n    }\n    out", "    let a = a.chars();\n    let\
    \ b = b.chars();\n    a.zip(b)\n        .map(|(a, b)| if a == b { '0' } else {\
    \ '1' })\n        .collect()", "    let mut res = String::new();\n    for i in\
    \ 0..std::cmp::min(a.len(), b.len()) {\n        res.push(if a.chars().nth(i) ==\
    \ b.chars().nth(i) {\n            '0'\n        } else {\n            '1'\n   \
    \     });\n    }\n    res", "    assert_eq!(a.len(), b.len());\n    let mut res\
    \ = String::new();\n    for i in 0..a.len() {\n        let a_char = a.chars().nth(i).unwrap();\n\
    \        let b_char = b.chars().nth(i).unwrap();\n        assert!(a_char == '0'\
    \ || a_char == '1');\n        assert!(b_char == '0' || b_char == '1');\n     \
    \   let res_char = if a_char == b_char { '0' } else { '1' };\n        res.push(res_char);\n\
    \    }\n    res", "    (0..a.len())\n        .map(|i| if a.chars().nth(i) == b.chars().nth(i)\
    \ {\n            '0'\n        } else {\n            '1'\n        })\n        .collect()",
  "    let a: Vec<u8> = a.into_bytes();\n    let b: Vec<u8> = b.into_bytes();\n  \
    \  let mut res = Vec::new();\n    for i in 0..a.len() {\n        if a[i] == b[i]\
    \ {\n            res.push(48);\n        } else {\n            res.push(49);\n\
    \        }\n    }\n    unsafe { std::str::from_utf8_unchecked(&res).to_string()\
    \ }", '    unimplemented!();', "    a.chars()\n        .zip(b.chars())\n     \
    \   .map(|(a, b)| {\n            format!(\n                \"{}\",\n         \
    \       if a == b {\n                    0\n                } else {\n       \
    \             1\n                }\n            )\n        })\n        .collect()",
  "    assert_eq!(a.len(), b.len());\n    let mut out = String::new();\n    for (&i,\
    \ &j) in a.as_bytes().iter().zip(b.as_bytes().iter()) {\n        let i = (i -\
    \ b'0') as i8;\n        let j = (j - b'0') as i8;\n        let c = i ^ j;\n  \
    \      out.push(c.to_string().as_str());\n    }\n    out", "    let a = a.parse::<u32>().unwrap();\n\
    \    let b = b.parse::<u32>().unwrap();\n    let c = a ^ b;\n    format!(\"{:b}\"\
    , c)", "    assert_eq!(a.len(), b.len());\n    let a_bytes = a.as_bytes();\n \
    \   let b_bytes = b.as_bytes();\n    let mut result = Vec::with_capacity(a_bytes.len());\n\
    \    for i in 0..a_bytes.len() {\n        result.push(a_bytes[i] ^ b_bytes[i]);\n\
    \    }\n    String::from_utf8(result).unwrap()", "    let mut result = \"\".to_string();\n\
    \    for i in 0..a.len() {\n        if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap()\
    \ {\n            result.push('0');\n        } else {\n            result.push('1');\n\
    \        }\n    }\n    result", "    let mut xor = String::new();\n    let mut\
    \ a = a.into_bytes();\n    let mut b = b.into_bytes();\n    a.reverse();\n   \
    \ b.reverse();\n    for (ai, bi) in a.iter().zip(b.iter()) {\n        xor.push(match\
    \ (ai, bi) {\n            (b'0', b'0') => '0',\n            (b'1', b'1') => '0',\n\
    \            _ => '1',\n        });\n    }\n    xor.reverse();\n    xor", "  \
    \  let mut c = String::new();\n    for i in 0..a.len() {\n        c.push(if a.chars().nth(i).unwrap()\
    \ == b.chars().nth(i).unwrap() {\n            '0'\n        } else {\n        \
    \    '1'\n        });\n    }\n    c", "    a.chars()\n        .zip(b.chars())\n\
    \        .map(|(ch1, ch2)| match (ch1, ch2) {\n            ('0', '0') => '0',\n\
    \            ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1',\
    \ '1') => '0',\n            _ => panic!(\"unexpected input\"),\n        })\n \
    \       .collect()", "    let xors: Vec<_> = a.chars().zip(b.chars()).map(|(x,\
    \ y)| x.eq(&y)).collect();\n    xors.iter().map(|x| match x {\n        true =>\
    \ \"0\",\n        false => \"1\",\n    }).collect()", '    String::from_utf8(a.into_bytes().iter().zip(b.into_bytes().iter()).map(|(&x,
    &y)| x ^ y).collect()).unwrap()', "    let a = parse_binary_string(&a);\n    let\
    \ b = parse_binary_string(&b);\n    let xor_result = xor(&a, &b);\n    xor_result.iter().map(|val|\
    \ val.to_string()).collect()", "    let mut res = String::new();\n    for (x,\
    \ y) in a.chars().zip(b.chars()) {\n        res.push(if x == y { '0' } else {\
    \ '1' });\n    }\n    res", "    let mut xor_string = String::new();\n    let\
    \ a_bytes = a.as_bytes();\n    let b_bytes = b.as_bytes();\n    for i in 0..std::cmp::min(a_bytes.len(),\
    \ b_bytes.len()) {\n        xor_string.push((a_bytes[i] ^ b_bytes[i]) as char);\n\
    \    }\n    xor_string", "    let mut res = String::new();\n    let mut last_bit\
    \ = false;\n    for (a_bit, b_bit) in a.chars().zip(b.chars()) {\n        if a_bit\
    \ == '1' && b_bit == '1' {\n            res.push(if last_bit { '1' } else { '0'\
    \ });\n            last_bit = true;\n        } else if a_bit == '1' || b_bit ==\
    \ '1' {\n            res.push(if last_bit { '0' } else { '1' });\n           \
    \ last_bit = false;\n        } else {\n            res.push(if last_bit { '1'\
    \ } else { '0' });\n            last_bit = false;\n        }\n    }\n    if last_bit\
    \ {\n        res.push('1');\n    }\n    res", "    let mut xor = String::new();\n\
    \    for i in 0..a.len() {\n        let x = a.as_bytes()[i] ^ b.as_bytes()[i];\n\
    \        xor.push_str(&format!(\"{:x}\", x));\n    }\n    xor", "    //    let\
    \ mut result: String = \"\".to_string();\n    //    if a.len() == b.len() {\n\
    \    //        for i in 0..a.len() {\n    //            result.push(char::from(u8::from(a.chars().nth(i).unwrap())\
    \ ^ u8::from(b.chars().nth(i).unwrap())));\n    //        }\n    //    }\n   \
    \ //    result\n    let mut result: String = \"\".to_string();\n    if a.len()\
    \ == b.len() {\n        for (ca, cb) in a.chars().zip(b.chars()) {\n         \
    \   result.push(char::from(u8::from(ca) ^ u8::from(cb)));\n        }\n    }\n\
    \    result", "    // Your code here.\n    // And maybe add some tests in lib.rs\n\
    \    unimplemented!()", "    assert_eq!(a.len(), b.len());\n    let mut result\
    \ = String::new();\n    for i in 0..a.len() {\n        result.push(if a.chars().nth(i).unwrap()\
    \ == b.chars().nth(i).unwrap() {\n            '0'\n        } else {\n        \
    \    '1'\n        });\n    }\n    result", "    a.chars()\n        .zip(b.chars())\n\
    \        .map(|(a, b)| a.to_digit(2).unwrap() ^ b.to_digit(2).unwrap())\n    \
    \    .map(|n| n.to_string())\n        .collect::<Vec<String>>()\n        .join(\"\
    \")", "    // Make strings same length by adding leading zeros.\n    let mut a_len\
    \ = a.len();\n    let mut b_len = b.len();\n    let mut a = a;\n    let mut b\
    \ = b;\n    if a_len < b_len {\n        a = a.repeat(b_len / a_len + 1).chars().take(b_len).collect();\n\
    \        a_len = a.len();\n    } else if b_len < a_len {\n        b = b.repeat(a_len\
    \ / b_len + 1).chars().take(a_len).collect();\n        b_len = b.len();\n    }\n\
    \n    let mut result = String::new();\n    for i in 0..a_len {\n        result.push(\n\
    \            match (a.chars().nth(i).unwrap(), b.chars().nth(i).unwrap()) {\n\
    \                ('0', '0') => '0',\n                ('0', '1') => '1',\n    \
    \            ('1', '0') => '1',\n                ('1', '1') => '0',\n        \
    \        _ => unreachable!(),\n            }\n        );\n    }\n    result",
  "    a.chars()\n        .zip(b.chars())\n        .map(|(x, y)| match (x, y) {\n\
    \            ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"unexpected\"\
    ),\n        })\n        .collect()", "    let a_int = usize::from_str_radix(&a,\
    \ 2).unwrap();\n    let b_int = usize::from_str_radix(&b, 2).unwrap();\n    format!(\"\
    {:b}\", a_int ^ b_int)", "    let mut res = Vec::new();\n    let length = cmp::max(a.len(),\
    \ b.len());\n    for i in 0..length {\n        let char_a = a.chars().nth(i).unwrap_or('0');\n\
    \        let char_b = b.chars().nth(i).unwrap_or('0');\n        if char_a == char_b\
    \ {\n            res.push('0');\n        } else {\n            res.push('1');\n\
    \        }\n    }\n    res.iter().collect()", "    a.chars()\n        .zip(b.chars())\n\
    \        .map(|(x, y)| x == y)\n        .map(|x| if x { '0' } else { '1' })\n\
    \        .collect()", "    let mut i = 0;\n    let mut result = String::new();\n\
    \    for (c1, c2) in a.chars().zip(b.chars()) {\n        result.push_str(&(c1.to_digit(10).unwrap()\
    \ ^ c2.to_digit(10).unwrap()).to_string());\n        i += 1;\n    }\n    result",
  "    let mut asplit = a.chars();\n    let mut bsplit = b.chars();\n    let mut res\
    \ = String::new();\n    loop {\n        match (asplit.next(), bsplit.next()) {\n\
    \            (Some(x), Some(y)) => {\n                if x == y {\n          \
    \          res.push('0');\n                } else {\n                    res.push('1');\n\
    \                }\n            }\n            _ => break,\n        }\n    }\n\
    \    res", "    let string_a = a.as_bytes();\n    let string_b = b.as_bytes();\n\
    \    let mut result: Vec<u8> = Vec::new();\n    for (a, b) in string_a.iter().zip(string_b.iter())\
    \ {\n        result.push(a ^ b);\n    }\n    String::from_utf8(result).unwrap()",
  "    let mut out = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        out.push(if a == b { '0' } else { '1' });\n    }\n    out", "    let\
    \ mut res = String::with_capacity(a.len());\n    for pair in a.chars().zip(b.chars())\
    \ {\n        res.push(match pair {\n            (c1, c2) if c1 == c2 => '0',\n\
    \            _ => '1',\n        });\n    }\n    res", "    let as_bytes = a.as_bytes();\n\
    \    let bs_bytes = b.as_bytes();\n    if as_bytes.len() != bs_bytes.len() {\n\
    \        panic!(\"Unequal input string lengths.\");\n    }\n    let mut res =\
    \ Vec::new();\n    for i in 0..as_bytes.len() {\n        let one = as_bytes[i]\
    \ - 48;\n        let two = bs_bytes[i] - 48;\n        res.push((one ^ two) + 48);\n\
    \    }\n    String::from_utf8(res).unwrap()", "    a.chars()\n        .zip(b.chars())\n\
    \        .map(|(x, y)| xor(x, y))\n        .collect()", "    let v1: Vec<u8> =\
    \ a.as_bytes().to_vec();\n    let v2: Vec<u8> = b.as_bytes().to_vec();\n    v1.iter().zip(v2.iter()).map(|(x,\
    \ y)| if x == y { '0' as u8 } else { '1' as u8 }).collect()", "    let mut a_bit_iter\
    \ = a.chars().rev();\n    let mut b_bit_iter = b.chars().rev();\n    let mut result\
    \ = String::new();\n\n    while let (Some(a_bit), Some(b_bit)) = (a_bit_iter.next(),\
    \ b_bit_iter.next()) {\n        if a_bit == b_bit {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n\n    result.chars().rev().collect()",
  "    a.chars()\n        .zip(b.chars())\n        .map(|(aa, bb)| aa == bb)\n   \
    \     .map(|e| if e { '0' } else { '1' })\n        .collect()", "    // TODO 1.0\n\
    \    \"\".to_string()", "    let a_bytes = a.as_bytes();\n    let b_bytes = b.as_bytes();\n\
    \    let mut out = String::new();\n    let mut carry = '0';\n    for (i, j) in\
    \ a_bytes.iter().zip(b_bytes.iter()) {\n        if *i == j {\n            out.push(carry);\n\
    \            carry = '0';\n        } else {\n            if carry == '0' {\n \
    \               out.push('1');\n            } else {\n                out.push('0');\n\
    \            }\n        }\n    }\n    out", "    let mut result = String::new();\n\
    \    let mut a_chars = a.chars();\n    let mut b_chars = b.chars();\n    loop\
    \ {\n        match (a_chars.next(), b_chars.next()) {\n            (Some(a_char),\
    \ Some(b_char)) => {\n                let char_result = match (a_char, b_char)\
    \ {\n                    ('0', '0') => '0',\n                    ('0', '1') =>\
    \ '1',\n                    ('1', '0') => '1',\n                    ('1', '1')\
    \ => '0',\n                    _ => panic!(\"String XOR contains invalid characters\"\
    ),\n                };\n                result.push(char_result);\n          \
    \  }\n            (None, None) => break,\n            _ => panic!(\"String XOR\
    \ inputs are not of equal length\"),\n        }\n    }\n    result", "    let\
    \ (a, b) = xor_preconditions(a, b);\n    a.chars()\n        .zip(b.chars())\n\
    \        .map(|(a, b)| if a == b { '0' } else { '1' })\n        .collect()", " \
    \   let mut c = String::new();\n    let mut a = a.chars();\n    let mut b = b.chars();\n\
    \    loop {\n        match (a.next(), b.next()) {\n            (Some(e), Some(f))\
    \ => {\n                c.push_str(&match (e, f) {\n                    ('0',\
    \ '0') => \"0\",\n                    ('0', '1') => \"1\",\n                 \
    \   ('1', '0') => \"1\",\n                    ('1', '1') => \"0\",\n         \
    \           _ => panic!(\"invalid string\"),\n                });\n          \
    \  }\n            (None, None) => break,\n            _ => panic!(\"strings must\
    \ be equal length\"),\n        }\n    }\n    c", "    let mut v: Vec<_> = a.chars().zip(b.chars()).collect();\n\
    \    for (c, d) in v.iter_mut() {\n        if *c == '1' ^ *d == '1' {\n      \
    \      *c = '1';\n        } else {\n            *c = '0';\n        }\n    }\n\
    \    v.into_iter().collect()", "    let mut result = String::with_capacity(a.len());\n\
    \    for (ch_a, ch_b) in a.chars().zip(b.chars()) {\n        result.push(if ch_a\
    \ == ch_b { '0' } else { '1' });\n    }\n    result", "    //ascii 48 is 0, 49\
    \ is 1\n    a.chars()\n        .zip(b.chars())\n        .map(|(a, b)| {\n    \
    \        (if a == '0' { 48 } else { 49 }) ^ (if b == '0' { 48 } else { 49 })\n\
    \        })\n        .map(|x| x.to_string())\n        .collect::<Vec<String>>()\n\
    \        .join(\"\")", "    let ret: String = a\n        .chars()\n        .zip(b.chars())\n\
    \        .map(|(x, y)| if x == y { '0' } else { '1' })\n        .collect();\n\
    \    ret", "    let a_bytes = a.into_bytes();\n    let b_bytes = b.into_bytes();\n\
    \    let mut output = vec![];\n    for i in 0..a_bytes.len() {\n        let dec\
    \ = (a_bytes[i] - 48) ^ (b_bytes[i] - 48);\n        output.push(dec + 48);\n \
    \   }\n    String::from_utf8(output).unwrap()", "    a.chars()\n        .zip(b.chars())\n\
    \        .map(|(x, y)| if x == y { '0' } else { '1' })\n        .collect()", " \
    \   let mut ans = String::new();\n    for (c, d) in a.chars().zip(b.chars()) {\n\
    \        let val = (c == '1') ^ (d == '1');\n        if val {\n            ans.push('1');\n\
    \        } else {\n            ans.push('0');\n        }\n    }\n    ans", " \
    \   let mut result = String::new();\n    let mut a_iter = a.chars();\n    let\
    \ mut b_iter = b.chars();\n    loop {\n        let a_next = a_iter.next();\n \
    \       let b_next = b_iter.next();\n        if a_next.is_none() || b_next.is_none()\
    \ {\n            break;\n        }\n        let a_val = a_next.unwrap();\n   \
    \     let b_val = b_next.unwrap();\n        if a_val == b_val {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result",
  "    let mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars())\
    \ {\n        let a = a == '1';\n        let b = b == '1';\n        let c = a ^\
    \ b;\n        result.push(if c { '1' } else { '0' });\n    }\n    result", " \
    \   let mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars())\
    \ {\n        result.push(if a == b { '0' } else { '1' });\n    }\n    result",
  "    let mut ret = String::new();\n    for (i, (x, y)) in a.chars().zip(b.chars()).enumerate()\
    \ {\n        if x == y {\n            ret.push('0');\n        } else {\n     \
    \       ret.push('1');\n        }\n    }\n    ret", "    a.chars()\n        .zip(b.chars())\n\
    \        .map(|(c, d)| {\n            if c == d {\n                \"0\"\n   \
    \         } else {\n                \"1\"\n            }\n        })\n       \
    \ .collect()", "    /// Credit: https://rosettacode.org/wiki/Bitwise_operations#Rust\n\
    \    fn char_to_binary(c: char) -> u8 {\n        match c {\n            '0' =>\
    \ 0,\n            '1' => 1,\n            _ => panic!(\"Invalid input: {}\", c),\n\
    \        }\n    }\n\n    /// Credit: https://rosettacode.org/wiki/Bitwise_operations#Rust\n\
    \    fn binary_to_char(x: u8) -> char {\n        match x {\n            0 => '0',\n\
    \            1 => '1',\n            _ => panic!(\"Invalid input: {}\", x),\n \
    \       }\n    }\n\n    let a_binary = a.chars().map(char_to_binary).collect::<Vec<u8>>();\n\
    \    let b_binary = b.chars().map(char_to_binary).collect::<Vec<u8>>();\n\n  \
    \  let xored = xor_vectors(&a_binary, &b_binary);\n\n    xored.iter().map(binary_to_char).collect()",
  "    let a: Vec<u8> = a.chars().map(|c| c.to_digit(10).unwrap() as u8).collect();\n\
    \    let b: Vec<u8> = b.chars().map(|c| c.to_digit(10).unwrap() as u8).collect();\n\
    \    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect::<Vec<u8>>().iter().map(|c|\
    \ c.to_string()).collect::<Vec<String>>().join(\"\")", "    let a_bytes = a.into_bytes();\n\
    \    let b_bytes = b.into_bytes();\n    let a_bits = bits_from_bytes(&a_bytes);\n\
    \    let b_bits = bits_from_bytes(&b_bytes);\n    let result_bits = xor(&a_bits,\
    \ &b_bits);\n    let result_bytes = bytes_from_bits(&result_bits);\n    // Convert\
    \ bytes to a string\n    result_bytes.iter().map(|b| char::from(*b)).collect()",
  "    let mut result = \"\".to_string();\n    let mut a_bytes = a.into_bytes();\n\
    \    let mut b_bytes = b.into_bytes();\n    a_bytes.reverse();\n    b_bytes.reverse();\n\
    \    for (i, _) in a_bytes.iter().enumerate() {\n        let n = match (a_bytes[i],\
    \ b_bytes[i]) {\n            (48, 48) => '0',\n            (48, 49) => '1',\n\
    \            (49, 48) => '1',\n            (49, 49) => '0',\n            _ =>\
    \ panic!(\"Unexpected value\"),\n        };\n        result.push(n);\n    }\n\
    \    result.chars().rev().collect()", "    // TODO\n    String::new()", "    let\
    \ mut result = String::with_capacity(a.len());\n    let a_chars = a.chars();\n\
    \    let b_chars = b.chars();\n    for (a_char, b_char) in a_chars.zip(b_chars)\
    \ {\n        let a_bit = a_char.to_digit(10).unwrap();\n        let b_bit = b_char.to_digit(10).unwrap();\n\
    \        let xor_bit = a_bit ^ b_bit;\n        result.push_str(&xor_bit.to_string());\n\
    \    }\n    result", "    let mut result = String::new();\n    let len = a.len();\n\
    \    for i in 0..len {\n        if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap()\
    \ {\n            result.push('0');\n        } else {\n            result.push('1');\n\
    \        }\n    }\n    result", "    let mut result = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        if a == b {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result",
  "    assert_eq!(a.len(), b.len());\n    let mut out: Vec<char> = Vec::new();\n \
    \   for (i, j) in a.chars().zip(b.chars()) {\n        out.push(char_xor(i, j));\n\
    \    }\n    out.iter().collect()", "    let mut a_iter = a.chars();\n    let mut\
    \ b_iter = b.chars();\n    let mut buffer = String::new();\n    loop {\n     \
    \   let a_char = a_iter.next();\n        let b_char = b_iter.next();\n       \
    \ match (a_char, b_char) {\n            (Some(a_char), Some(b_char)) => {\n  \
    \              if a_char == b_char {\n                    buffer.push('0');\n\
    \                } else {\n                    buffer.push('1');\n           \
    \     }\n            }\n            _ => {\n                break;\n         \
    \   }\n        }\n    }\n    buffer", "    let a_vals: Vec<char> = a.chars().collect();\n\
    \    let b_vals: Vec<char> = b.chars().collect();\n    if a_vals.len() != b_vals.len()\
    \ {\n        panic!(\"Strings are of different length\");\n    }\n    let mut\
    \ results: Vec<char> = Vec::new();\n    for i in 0..a_vals.len() {\n        if\
    \ a_vals[i] == b_vals[i] {\n            results.push('0');\n        } else {\n\
    \            results.push('1');\n        }\n    }\n    results.iter().collect()",
  "    a.chars()\n        .zip(b.chars())\n        .map(|(a, b)| if a == b { '0' }\
    \ else { '1' })\n        .collect()", "    let mut result = String::new();\n \
    \   let mut a_chars = a.chars();\n    let mut b_chars = b.chars();\n    loop {\n\
    \        let a_char = a_chars.next();\n        let b_char = b_chars.next();\n\
    \        match (a_char, b_char) {\n            (Some(a_char), Some(b_char)) =>\
    \ {\n                result.push(if a_char == b_char { '0' } else { '1' });\n\
    \            }\n            _ => break,\n        }\n    }\n    result", "    let\
    \ mut res = Vec::with_capacity(a.len());\n    for (&a, &b) in a.bytes().zip(b.bytes())\
    \ {\n        res.push(a ^ b);\n    }\n    String::from_utf8(res).unwrap()", " \
    \   let mut out = String::new();\n    for i in 0..std::cmp::min(a.len(), b.len())\
    \ {\n        let a_num = a.chars().nth(i).unwrap();\n        let b_num = b.chars().nth(i).unwrap();\n\
    \        let a_bit = match a_num {\n            '0' => false,\n            '1'\
    \ => true,\n            _ => panic!(\"Unexpected character {}\", a_num),\n   \
    \     };\n        let b_bit = match b_num {\n            '0' => false,\n     \
    \       '1' => true,\n            _ => panic!(\"Unexpected character {}\", b_num),\n\
    \        };\n        let bit = a_bit ^ b_bit;\n        out.push(if bit { '1' }\
    \ else { '0' });\n    }\n    out", "    let mut xor_str = String::new();\n   \
    \ if a.len() == b.len() {\n        for i in 0..a.len() {\n            xor_str.push(match\
    \ (a.chars().nth(i), b.chars().nth(i)) {\n                (Some('0'), Some('0'))\
    \ => '0',\n                (Some('0'), Some('1')) => '1',\n                (Some('1'),\
    \ Some('0')) => '1',\n                (Some('1'), Some('1')) => '0',\n       \
    \         _ => panic!(\"Non binary character in input\"),\n            });\n \
    \       }\n    } else {\n        panic!(\"The lengths of the two inputs are not\
    \ equal\");\n    }\n    xor_str", "    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        result.push(if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap()\
    \ {\n            '0'\n        } else {\n            '1'\n        });\n    }\n\
    \    result", "    let mut result = String::new();\n    for (i, (a_char, b_char))\
    \ in a.chars().zip(b.chars()).enumerate() {\n        result.push(match (a_char,\
    \ b_char) {\n            ('0', '0') => '0',\n            ('0', '1') => '1',\n\
    \            ('1', '0') => '1',\n            ('1', '1') => '0',\n            _\
    \ => panic!(\"Unexpected input at index {}\", i),\n        });\n    }\n    result",
  "    a.chars()\n        .zip(b.chars())\n        .map(|(a, b)| if a == b { '0' }\
    \ else { '1' })\n        .collect()", "    let mut result = String::with_capacity(a.len());\n\
    \    for i in 0..a.len() {\n        let ax = a.chars().nth(i).unwrap();\n    \
    \    let bx = b.chars().nth(i).unwrap();\n        if ax == bx {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result",
  "    a.bytes()\n        .zip(b.bytes())\n        .map(|(x, y)| x ^ y)\n        .map(|x|\
    \ x.to_string())\n        .collect::<Vec<String>>()\n        .join(\"\")", " \
    \   let a: Vec<bool> = a.chars().map(|x| x == '1').collect();\n    let b: Vec<bool>\
    \ = b.chars().map(|x| x == '1').collect();\n    let len = cmp::max(a.len(), b.len());\n\
    \    let mut a: Vec<bool> = a.into_iter().cycle().take(len).collect();\n    let\
    \ mut b: Vec<bool> = b.into_iter().cycle().take(len).collect();\n    a.iter_mut().zip(b.iter_mut()).for_each(|(x,\
    \ y)| *x ^= *y);\n    a.into_iter().map(|x| if x { '1' } else { '0' }).collect()",
  "    let mut result = String::new();\n    let mut a_iter = a.chars();\n    let mut\
    \ b_iter = b.chars();\n    loop {\n        let a_next = a_iter.next();\n     \
    \   let b_next = b_iter.next();\n        match (a_next, b_next) {\n          \
    \  (Some(a_char), Some(b_char)) => {\n                let a_int = a_char.to_digit(10).unwrap();\n\
    \                let b_int = b_char.to_digit(10).unwrap();\n                result.push_str(&(a_int\
    \ ^ b_int).to_string());\n            }\n            (Some(_), None) => {\n  \
    \              result.push_str(\"0\");\n            }\n            (None, Some(_))\
    \ => {\n                result.push_str(\"0\");\n            }\n            (None,\
    \ None) => {\n                break;\n            }\n        }\n    }\n    result",
  "    assert_eq!(a.len(), b.len());\n    let mut out = String::with_capacity(a.len());\n\
    \    for i in 0..a.len() {\n        let x = a.as_bytes()[i] ^ b.as_bytes()[i];\n\
    \        out.push(char::from(x));\n    }\n    out", "    let mut result = String::new();\n\
    \    let mut a_char_iter = a.chars();\n    let mut b_char_iter = b.chars();\n\
    \    while let (Some(a_char), Some(b_char)) = (a_char_iter.next(), b_char_iter.next())\
    \ {\n        let (a_bit, b_bit) = (a_char.to_digit(10).unwrap(), b_char.to_digit(10).unwrap());\n\
    \        result.push_str(&(a_bit ^ b_bit).to_string());\n    }\n    result", " \
    \   xor(\n        a.as_bytes().to_vec(),\n        b.as_bytes().to_vec(),\n   \
    \ ).iter()\n    .map(|x| format!(\"{:x}\", x))\n    .collect::<String>()", '    format!("{:b}",
    u32::from_str_radix(&a, 2).unwrap() ^ u32::from_str_radix(&b, 2).unwrap())', " \
    \   let mut result = String::new();\n    for (idx, val) in a.chars().enumerate()\
    \ {\n        let xor = val != b.chars().nth(idx).unwrap();\n        result.push(if\
    \ xor { '1' } else { '0' });\n    }\n    result", "    let mut res = String::new();\n\
    \    for (x, y) in a.chars().zip(b.chars()) {\n        if x == y {\n         \
    \   res.push('0');\n        } else {\n            res.push('1');\n        }\n\
    \    }\n    res", "    // string -> byte vector\n    let mut a = a.as_bytes().to_vec();\n\
    \    let mut b = b.as_bytes().to_vec();\n\n    let mut result = String::new();\n\
    \n    // pad the shorter string with zeros\n    if a.len() < b.len() {\n     \
    \   a.extend(std::iter::repeat(b'0').take(b.len() - a.len()));\n    } else if\
    \ a.len() > b.len() {\n        b.extend(std::iter::repeat(b'0').take(a.len() -\
    \ b.len()));\n    }\n\n    // xor the bytes\n    for i in 0..a.len() {\n     \
    \   match a[i] ^ b[i] {\n            48 => result.push('0'),\n            49 =>\
    \ result.push('1'),\n            _ => println!(\"err\"),\n        }\n    }\n\n\
    \    result", "    let chars_a: Vec<_> = a.chars().collect();\n    let chars_b:\
    \ Vec<_> = b.chars().collect();\n    let mut results: Vec<char> = Vec::new();\n\
    \n    for i in 0..a.len() {\n        let num_a = char_to_num(chars_a[i]);\n  \
    \      let num_b = char_to_num(chars_b[i]);\n        let result = num_a ^ num_b;\n\
    \        results.push(num_to_char(result));\n    }\n\n    results.iter().collect()",
  '    (a.parse::<u8>().unwrap() ^ b.parse::<u8>().unwrap()).to_string()', "    let\
    \ mut result = String::with_capacity(a.len());\n    for i in 0..a.len() {\n  \
    \      result.push(if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap() {\n\
    \            '0'\n        } else {\n            '1'\n        });\n    }\n    result",
  "    let length = if a.len() > b.len() { a.len() } else { b.len() };\n    let mut\
    \ result = String::new();\n    for i in 0..length {\n        let bit_a = if i\
    \ < a.len() { a.chars().nth(i).unwrap() } else { '0' };\n        let bit_b = if\
    \ i < b.len() { b.chars().nth(i).unwrap() } else { '0' };\n        result.push(char_xor(bit_a,\
    \ bit_b));\n    }\n    result", "    let mut result = String::new();\n    let\
    \ mut xor_chars = a.chars().zip(b.chars());\n    while let Some((first, second))\
    \ = xor_chars.next() {\n        let xor = first.to_digit(2).unwrap() ^ second.to_digit(2).unwrap();\n\
    \        result.push_str(&xor.to_string());\n    }\n    result", "    let mut\
    \ a = a.chars();\n    let mut b = b.chars();\n    let mut c = String::new();\n\
    \    while let (Some(aa), Some(bb)) = (a.next(), b.next()) {\n        c.push(if\
    \ aa == bb {\n            '0'\n        } else {\n            '1'\n        });\n\
    \    }\n    c", "    assert_eq!(a.len(), b.len());\n    let a = a.into_bytes();\n\
    \    let b = b.into_bytes();\n    let c = a.iter().zip(b.iter()).map(|(x, y)|\
    \ {\n        assert!(*x == b'0' || *x == b'1');\n        assert!(*y == b'0' ||\
    \ *y == b'1');\n        if *x == *y {\n            b'0'\n        } else {\n  \
    \          b'1'\n        }\n    });\n    String::from_utf8(c.collect()).unwrap()",
  "    let mut ret = String::new();\n    let a = a.as_bytes();\n    let b = b.as_bytes();\n\
    \    assert_eq!(a.len(), b.len());\n    for i in 0..a.len() {\n        let a =\
    \ a[i] - b'0';\n        let b = b[i] - b'0';\n        let x = (a + b) % 2;\n \
    \       ret.push(x as char);\n    }\n    ret", "    a.chars()\n        .zip(b.chars())\n\
    \        .map(|(x, y)| if x == y { '0' } else { '1' })\n        .collect()", " \
    \   let a_bytes = a.as_bytes();\n    let b_bytes = b.as_bytes();\n    let mut\
    \ bytes = Vec::new();\n    assert_eq!(a_bytes.len(), b_bytes.len());\n    for\
    \ i in 0..a_bytes.len() {\n        let a_byte = a_bytes[i];\n        let b_byte\
    \ = b_bytes[i];\n        assert!(a_byte == b'0' || a_byte == b'1');\n        assert!(b_byte\
    \ == b'0' || b_byte == b'1');\n        if a_byte == b_byte {\n            bytes.push(b'0');\n\
    \        } else {\n            bytes.push(b'1');\n        }\n    }\n    String::from_utf8(bytes).unwrap()",
  "    let a: Vec<char> = a.chars().collect();\n    let b: Vec<char> = b.chars().collect();\n\
    \    let c: Vec<char> = xor(a, b);\n    c.iter().collect()", "    let mut result\
    \ = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n        result.push(a.xor(b));\n\
    \    }\n    result", "    let mut a = a.chars();\n    let mut b = b.chars();\n\
    \    let mut result = String::new();\n    while let (Some(a), Some(b)) = (a.next(),\
    \ b.next()) {\n        result.push(if a == b { '0' } else { '1' });\n    }\n \
    \   result", "    let mut result = String::new();\n    let mut a = a.chars();\n\
    \    let mut b = b.chars();\n    for _ in 0..a.count() {\n        match (a.next(),\
    \ b.next()) {\n            (Some('0'), Some('0')) => result.push('0'),\n     \
    \       (Some('1'), Some('1')) => result.push('0'),\n            (Some('0'), Some('1'))\
    \ => result.push('1'),\n            (Some('1'), Some('0')) => result.push('1'),\n\
    \            _ => panic!(\"Invalid input\"),\n        }\n    }\n    result", " \
    \   let a_bytes = a.as_bytes();\n    let b_bytes = b.as_bytes();\n    assert_eq!(a_bytes.len(),\
    \ b_bytes.len());\n    let mut result = Vec::with_capacity(a_bytes.len());\n \
    \   for i in 0..a_bytes.len() {\n        let a_byte = a_bytes[i];\n        let\
    \ b_byte = b_bytes[i];\n        assert!(a_byte == b'0' || a_byte == b'1');\n \
    \       assert!(b_byte == b'0' || b_byte == b'1');\n        result.push(\n   \
    \         match (a_byte, b_byte) {\n                (b'0', b'0') => b'0',\n  \
    \              (b'1', b'1') => b'0',\n                (b'0', b'1') => b'1',\n\
    \                (b'1', b'0') => b'1',\n                _ => unreachable!(),\n\
    \            }\n        );\n    }\n    String::from_utf8(result).unwrap()", " \
    \   a.chars()\n        .zip(b.chars())\n        .map(|(c, d)| c.to_digit(2).unwrap()\
    \ ^ d.to_digit(2).unwrap())\n        .map(|e| e.to_string())\n        .collect::<Vec<String>>()\n\
    \        .join(\"\")", "    let a = a.chars().rev().map(|c| c.to_digit(10).unwrap()).collect::<Vec<_>>();\n\
    \    let b = b.chars().rev().map(|c| c.to_digit(10).unwrap()).collect::<Vec<_>>();\n\
    \    let mut result = vec![];\n    for (i, x) in a.iter().enumerate() {\n    \
    \    result.push(if let Some(y) = b.get(i) { x ^ y } else { *x });\n    }\n  \
    \  for (i, x) in b.iter().enumerate() {\n        if a.get(i).is_none() {\n   \
    \         result.push(*x);\n        }\n    }\n    result.iter().rev().map(|&x|\
    \ std::char::from_digit(x, 10).unwrap()).collect()", "    a.chars()\n        .zip(b.chars())\n\
    \        .map(|(a, b)| match (a, b) {\n            ('0', '0') => '0',\n      \
    \      ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        })\n        .collect()",
  "    let x = String::from(\"0\")\n        .chars()\n        .zip(a.chars())\n  \
    \      .map(|(a, b)| if a == b { '0' } else { '1' })\n        .collect::<String>();\n\
    \    let y = String::from(\"0\")\n        .chars()\n        .zip(b.chars())\n\
    \        .map(|(a, b)| if a == b { '0' } else { '1' })\n        .collect::<String>();\n\
    \    let z = x\n        .chars()\n        .zip(y.chars())\n        .map(|(a, b)|\
    \ if a == b { '0' } else { '1' })\n        .collect::<String>();\n    z", "  \
    \  // The unwrap here is safe because we know that a.len() == b.len()\n    let\
    \ a_bytes = a.as_bytes();\n    let b_bytes = b.as_bytes();\n    let mut result\
    \ = Vec::with_capacity(a_bytes.len());\n    for i in 0..a_bytes.len() {\n    \
    \    result.push(a_bytes[i] ^ b_bytes[i]);\n    }\n    String::from_utf8(result).unwrap()",
  "    // Transform the strings into an array of bytes\n    let a_bytes = a.as_bytes();\n\
    \    let b_bytes = b.as_bytes();\n\n    // As we expect the strings to have equal\
    \ length, we take the\n    // length of the first string.\n    let len = a_bytes.len();\n\
    \n    // Initialize the result string to empty.\n    let mut result = String::new();\n\
    \n    // Iterate over each byte in the arrays.\n    for i in 0..len {\n      \
    \  // XOR each byte of the strings and add the result to the result string.\n\
    \        result.push_str(&format!(\"{}\", a_bytes[i] ^ b_bytes[i]));\n    }\n\n\
    \    // Return the result string.\n    result", "    let a = a.chars().map(|x|\
    \ x == '1').collect::<Vec<bool>>();\n    let b = b.chars().map(|x| x == '1').collect::<Vec<bool>>();\n\
    \    let x = repeat_xor(a, b);\n    x.iter().map(|x| if *x { '1' } else { '0'\
    \ }).collect()", "    let mut result = String::new();\n    for (a, b) in a.chars().zip(b.chars())\
    \ {\n        result.push(if a == b { '0' } else { '1' });\n    }\n    result",
  "    let a_bytes = a.into_bytes();\n    let b_bytes = b.into_bytes();\n    let result\
    \ = a_bytes\n        .iter()\n        .zip(b_bytes.iter())\n        .map(|(x,\
    \ y)| x ^ y)\n        .collect::<Vec<u8>>();\n    String::from_utf8(result).unwrap()",
  "    let a: Vec<u8> = a.into_bytes();\n    let b: Vec<u8> = b.into_bytes();\n  \
    \  let mut out = Vec::with_capacity(a.len());\n    for (a, b) in a.into_iter().zip(b.into_iter())\
    \ {\n        out.push(a ^ b);\n    }\n    String::from_utf8(out).unwrap()", " \
    \   let mut a = a.chars();\n    let mut b = b.chars();\n    let mut result = String::new();\n\
    \    while let (Some(x), Some(y)) = (a.next(), b.next()) {\n        let x = x.to_digit(10).unwrap();\n\
    \        let y = y.to_digit(10).unwrap();\n        let z = x ^ y;\n        result.push_str(&z.to_string());\n\
    \    }\n    result", '    xor(a.as_bytes(), b.as_bytes()).iter().map(|&b| b as
    char).collect()', "    let mut output = String::new();\n    for i in 0..a.len()\
    \ {\n        let mut c = 0;\n        match a.chars().nth(i) {\n            Some('0')\
    \ => {},\n            Some('1') => { c += 1; },\n            Some(_) => panic!(\"\
    not a valid character in string a\"),\n            None => panic!(\"no such character\
    \ in string a\"),\n        }\n        match b.chars().nth(i) {\n            Some('0')\
    \ => {},\n            Some('1') => { c += 1; },\n            Some(_) => panic!(\"\
    not a valid character in string b\"),\n            None => panic!(\"no such character\
    \ in string b\"),\n        }\n        match c {\n            0 => output.push('0'),\n\
    \            1 => output.push('1'),\n            2 => output.push('0'),\n    \
    \        _ => panic!(\"something went wrong with the XOR\"),\n        }\n    }\n\
    \    output", "    let mut result = String::with_capacity(a.len());\n    let bytes_a\
    \ = a.as_bytes();\n    let bytes_b = b.as_bytes();\n    for i in 0..a.len() {\n\
    \        result.push(match (bytes_a[i], bytes_b[i]) {\n            (48, 48) =>\
    \ '0',\n            (48, 49) => '1',\n            (49, 48) => '1',\n         \
    \   (49, 49) => '0',\n            _ => unreachable!(),\n        });\n    }\n \
    \   result", "    let a_bytes = a.as_bytes();\n    let b_bytes = b.as_bytes();\n\
    \    // a and b are guaranteed to be the same length.\n    let result_bytes =\
    \ a_bytes.iter().zip(b_bytes.iter()).map(|(a, b)| a ^ b);\n    // Convert `Vec<u8>`\
    \ to `String`.\n    let result_string = std::str::from_utf8(result_bytes.collect::<Vec<u8>>().as_slice()).unwrap();\n\
    \    result_string.to_string()", "    let mut result = String::new();\n    let\
    \ mut a = a.chars();\n    let mut b = b.chars();\n    loop {\n        match (a.next(),\
    \ b.next()) {\n            (Some(aa), Some(bb)) => {\n                if aa ==\
    \ bb {\n                    result.push('0');\n                } else {\n    \
    \                result.push('1');\n                }\n            }\n       \
    \     _ => break,\n        }\n    }\n    result", "    // Convert strings to bytes\n\
    \    let a_bytes = a.into_bytes();\n    let b_bytes = b.into_bytes();\n\n    //\
    \ Make sure the lengths are the same\n    if a_bytes.len() != b_bytes.len() {\n\
    \        panic!(\"string_xor called with strings of different lengths\");\n  \
    \  }\n\n    // Iterate over each byte, producing xor\n    let mut res_bytes =\
    \ Vec::new();\n    for (a_byte, b_byte) in a_bytes.iter().zip(b_bytes.iter())\
    \ {\n        res_bytes.push(a_byte ^ b_byte);\n    }\n\n    // Return the result\
    \ as a string\n    String::from_utf8(res_bytes).unwrap()", "    a.chars()\n  \
    \      .zip(b.chars())\n        .map(|(a, b)| xor(a, b))\n        .collect()",
  "    let mut result = String::new();\n    for i in 0..a.len() {\n        result.push(match\
    \ a.chars().nth(i).unwrap() {\n            '0' => match b.chars().nth(i).unwrap()\
    \ {\n                '0' => '0',\n                '1' => '1',\n              \
    \  _ => '',\n            },\n            '1' => match b.chars().nth(i).unwrap()\
    \ {\n                '0' => '1',\n                '1' => '0',\n              \
    \  _ => '',\n            },\n            _ => '',\n        });\n    }\n    result",
  "    let mut a = a.into_bytes();\n    let mut b = b.into_bytes();\n    let mut result\
    \ = Vec::new();\n    while a.len() > 0 || b.len() > 0 {\n        let c1 = a.pop().unwrap_or(48);\n\
    \        let c2 = b.pop().unwrap_or(48);\n        if c1 == c2 {\n            result.push(48);\n\
    \        } else {\n            result.push(49);\n        }\n    }\n    result.reverse();\n\
    \    String::from_utf8(result).unwrap()", "    // create Vec of u8 from each string,\n\
    \    // and XOR elements of each Vec at the same position.\n    // An element\
    \ of the resulting Vec is cast back to a char\n    // and appended to a String.\n\
    \    a.chars()\n        .zip(b.chars())\n        .map(|(ac, bc)| ac.to_digit(2).unwrap()\
    \ ^ bc.to_digit(2).unwrap())\n        .map(|x| char::from(x as u8 + 48))\n   \
    \     .collect()", '    unimplemented!();', "    let mut v = vec![];\n    for\
    \ (x, y) in a.chars().zip(b.chars()) {\n        v.push(if x == y { '0' } else\
    \ { '1' });\n    }\n    v.into_iter().collect()", "    assert_eq!(a.len(), b.len());\n\
    \    let a: Vec<char> = a.chars().collect();\n    let b: Vec<char> = b.chars().collect();\n\
    \    let mut xor: Vec<char> = Vec::new();\n    for (idx, _) in a.iter().enumerate()\
    \ {\n        xor.push(if a[idx] == b[idx] {\n            '0'\n        } else {\n\
    \            '1'\n        });\n    }\n    xor.iter().collect()", "    let xor_bytes\
    \ = xor(a.as_bytes(), b.as_bytes());\n    String::from_utf8(xor_bytes).unwrap()",
  "    if a.len() != b.len() {\n        panic!(\"a and b should have the same length.\"\
    );\n    }\n    let mut result = String::new();\n    for i in 0..a.len() {\n  \
    \      let mut c = &a[i..i+1];\n        let mut d = &b[i..i+1];\n        result.push_str(&string_xor_char(c,\
    \ d).to_string());\n    }\n    result", "    let mut result = String::new();\n\
    \    for (a, b) in a.chars().zip(b.chars()) {\n        let res = match (a, b)\
    \ {\n            ('0', '0') => '0',\n            ('0', '1') => '1',\n        \
    \    ('1', '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"\
    Unexpected input\"),\n        };\n        result.push(res);\n    }\n    result",
  "    let a_as_int = a.parse::<u8>().unwrap();\n    let b_as_int = b.parse::<u8>().unwrap();\n\
    \    let xor_as_int = a_as_int ^ b_as_int;\n    return format!(\"{:b}\", xor_as_int);",
  "    a.chars()\n        .zip(b.chars())\n        .map(|(a, b)| match (a, b) {\n\
    \            ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Invalid\
    \ input.\"),\n        })\n        .collect()", "    let a_chars: Vec<char> = a.chars().collect();\n\
    \    let b_chars: Vec<char> = b.chars().collect();\n    let mut result = String::new();\n\
    \    for i in 0..a_chars.len() {\n        let a_val = a_chars[i];\n        let\
    \ b_val = b_chars[i];\n        if a_val == b_val {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result",
  "    a.chars()\n        .zip(b.chars())\n        .map(|(x, y)| x == y && '0' ||\
    \ '1')\n        .collect()", "    return a.chars().zip(b.chars()).map(|(c1, c2)|\
    \ if c1 == c2 { '0' } else { '1' }).collect();", "    let mut output = String::new();\n\
    \    let mut a_chars = a.chars();\n    let mut b_chars = b.chars();\n    while\
    \ let (Some(a_char), Some(b_char)) = (a_chars.next(), b_chars.next()) {\n    \
    \    if a_char == b_char {\n            output.push('0');\n        } else {\n\
    \            output.push('1');\n        }\n    }\n    output", "    let (a, b)\
    \ = (a.into_bytes(), b.into_bytes());\n    let z = a.iter().zip(b);\n    let res\
    \ = z.map(|(c, d)| *c ^ *d).collect::<Vec<u8>>();\n    String::from_utf8(res).unwrap()",
  "    let mut res = String::new();\n    for (a, b) in a.chars().zip(b.chars()) {\n\
    \        res.push(if a == b {\n            '0'\n        } else {\n           \
    \ '1'\n        });\n    }\n    res", "    if a.len() != b.len() {\n        panic!(\"\
    Strings don't have the same length!\");\n    }\n\n    let mut result = String::new();\n\
    \    for (i, c) in a.chars().enumerate() {\n        let c1 = b.chars().nth(i).unwrap();\n\
    \        if c == c1 {\n            result.push('0');\n        } else {\n     \
    \       result.push('1');\n        }\n    }\n    result", "    let mut a = a.chars();\n\
    \    let mut b = b.chars();\n    let mut ret = String::new();\n    loop {\n  \
    \      let ac = a.next();\n        let bc = b.next();\n        if ac.is_none()\
    \ && bc.is_none() {\n            break;\n        }\n        if ac.is_none() ||\
    \ bc.is_none() {\n            panic!(\"a and b must be of the same length\");\n\
    \        }\n        let ac = ac.unwrap();\n        let bc = bc.unwrap();\n   \
    \     if ac == '0' && bc == '0' {\n            ret.push('0');\n        } else\
    \ if ac == '1' && bc == '1' {\n            ret.push('0');\n        } else {\n\
    \            ret.push('1');\n        }\n    }\n    ret", "    let a_arr: Vec<char>\
    \ = a.chars().collect();\n    let b_arr: Vec<char> = b.chars().collect();\n  \
    \  let mut xor_arr: Vec<char> = vec![];\n    for i in 0..a_arr.len() {\n     \
    \   xor_arr.push(if a_arr[i] == b_arr[i] {\n            '0'\n        } else {\n\
    \            '1'\n        });\n    }\n    xor_arr.iter().collect()", "    let\
    \ a = a.into_bytes();\n    let b = b.into_bytes();\n    assert_eq!(a.len(), b.len());\n\
    \    a.iter().zip(b.iter()).map(|(x, y)| x ^ y).collect()", "    let mut string\
    \ = String::new();\n    let mut a_chars = a.chars();\n    let mut b_chars = b.chars();\n\
    \    loop {\n        let xor = match (a_chars.next(), b_chars.next()) {\n    \
    \        (Some(x), Some(y)) => x ^ y,\n            _ => break,\n        };\n \
    \       string.push(xor);\n    }\n    string", "    let a_bytes = a.as_bytes();\n\
    \    let b_bytes = b.as_bytes();\n    let mut result = String::new();\n    for\
    \ i in 0..a_bytes.len() {\n        let char_a = a_bytes[i];\n        let char_b\
    \ = b_bytes[i];\n        let char_xor = char_a ^ char_b;\n        result.push(char_xor\
    \ as char);\n    }\n    result", "    let mut xored = String::new();\n    for\
    \ (ai, bi) in a.chars().zip(b.chars()) {\n        xored.push(match (ai, bi) {\n\
    \            ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"unexpected\
    \ character: {} {}\", ai, bi),\n        });\n    }\n    xored", "    let mut a:\
    \ Vec<_> = a.chars().collect();\n    let mut b: Vec<_> = b.chars().collect();\n\
    \    let mut len = a.len();\n    if b.len() > len {\n        len = b.len();\n\
    \    }\n    for _ in 0..len {\n        a.insert(0, '0');\n        b.insert(0,\
    \ '0');\n    }\n    let mut result = Vec::new();\n    for i in 0..len {\n    \
    \    if a[i] == b[i] {\n            result.push('0');\n        } else {\n    \
    \        result.push('1');\n        }\n    }\n    result.into_iter().collect()",
  "    a.bytes()\n        .zip(b.bytes())\n        .map(|(x, y)| (x ^ y) as char)\n\
    \        .collect()", "    // TODO\n    \"\".to_string()", '    unimplemented!()',
  "    // Convert strings to vecs of integers.\n    let mut a_vec: Vec<char> = a.chars().collect();\n\
    \    let mut b_vec: Vec<char> = b.chars().collect();\n\n    // Ensure that both\
    \ vecs are the same length.\n    if a_vec.len() > b_vec.len() {\n        let mut\
    \ delta = a_vec.len() - b_vec.len();\n        while delta > 0 {\n            b_vec.insert(0,\
    \ '0');\n            delta -= 1;\n        }\n    } else if b_vec.len() > a_vec.len()\
    \ {\n        let mut delta = b_vec.len() - a_vec.len();\n        while delta >\
    \ 0 {\n            a_vec.insert(0, '0');\n            delta -= 1;\n        }\n\
    \    }\n\n    // Perform the XOR operation.\n    let c_vec: Vec<char> = a_vec\n\
    \        .iter()\n        .zip(b_vec.iter())\n        .map(|(x, y)| if x == y\
    \ { '0' } else { '1' })\n        .collect();\n\n    // Convert the result to a\
    \ string.\n    return c_vec.iter().collect();", "    // TODO: implement me!\n\
    \    a.chars().zip(b.chars()).map(|(a, b)| match (a, b) {\n        ('0', '0')\
    \ => '0',\n        ('0', '1') => '1',\n        ('1', '0') => '1',\n        ('1',\
    \ '1') => '0',\n        _ => '0',\n    }).collect()", '    format!("{:0>1$b}",
    u8::from_str_radix(&a, 2) ^ u8::from_str_radix(&b, 2), a.len())', "    let mut\
    \ result = String::new();\n    for (c1, c2) in a.chars().zip(b.chars()) {\n  \
    \      if c1 == c2 {\n            result.push('0');\n        } else {\n      \
    \      result.push('1');\n        }\n    }\n    result", "    let mut result =\
    \ String::new();\n    for i in 0..a.len() {\n        let x = a.chars().nth(i).unwrap();\n\
    \        let y = b.chars().nth(i).unwrap();\n        if x == y {\n           \
    \ result.push('0');\n        } else {\n            result.push('1');\n       \
    \ }\n    }\n    result", "    // TODO!\n    unimplemented!();", "    a.chars()\n\
    \        .zip(b.chars())\n        .map(|(c1, c2)| (c1.to_digit(2).unwrap() ^ c2.to_digit(2).unwrap()).to_string())\n\
    \        .collect()", "    a.chars()\n        .zip(b.chars())\n        .map(|(a,\
    \ b)| if a == b { '0' } else { '1' })\n        .collect()", "    let a = a.as_bytes();\n\
    \    let b = b.as_bytes();\n    (0..a.len()).map(|i| a[i] ^ b[i]).collect()",
  "    let a = a.into_bytes();\n    let b = b.into_bytes();\n    let mut out = String::new();\n\
    \    for (&c, &d) in a.iter().zip(b.iter()) {\n        out.push(char::from(c ^\
    \ d));\n    }\n    out", "    a.bytes()\n        .zip(b.bytes())\n        .map(|(aa,\
    \ bb)| aa ^ bb)\n        .map(|bb| bb.to_string())\n        .collect::<Vec<String>>()\n\
    \        .join(\"\")", "    let mut result = String::new();\n    for pair in a.chars().zip(b.chars())\
    \ {\n        result.push(match pair {\n            (a, b) if a == b => '0',\n\
    \            _ => '1',\n        });\n    }\n    result", "    let a = a.as_bytes();\n\
    \    let b = b.as_bytes();\n    let mut out = vec![0; a.len()];\n    for i in\
    \ 0..a.len() {\n        let a = a[i] == b'1';\n        let b = b[i] == b'1';\n\
    \        let c = if a ^ b { b'1' } else { b'0' };\n        out[i] = c;\n    }\n\
    \    std::str::from_utf8(&out).unwrap().to_string()", "    let mut bytes = Vec::new();\n\
    \    for i in 0..a.len() {\n        let c1 = a.as_bytes()[i];\n        let c2\
    \ = b.as_bytes()[i];\n        bytes.push(c1 ^ c2);\n    }\n    unsafe { String::from_utf8_unchecked(bytes)\
    \ }", "    let mut res = String::new();\n    let a = a.chars().collect::<Vec<char>>();\n\
    \    let b = b.chars().collect::<Vec<char>>();\n    for (i, ch) in a.iter().enumerate()\
    \ {\n        res.push(match ch {\n            '0' => match b[i] {\n          \
    \      '0' => '0',\n                '1' => '1',\n                _ => panic!(\"\
    impossible\"),\n            },\n            '1' => match b[i] {\n            \
    \    '0' => '1',\n                '1' => '0',\n                _ => panic!(\"\
    impossible\"),\n            },\n            _ => panic!(\"impossible\"),\n   \
    \     });\n    }\n    res", "    let mut v: Vec<u8> = Vec::new();\n    let mut\
    \ s: String = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n \
    \       if i == j {\n            v.push(0);\n        } else {\n            v.push(1);\n\
    \        }\n    }\n    for i in v {\n        s.push_str(&i.to_string());\n   \
    \ }\n    s", "    let a = a.chars().collect::<Vec<char>>();\n    let b = b.chars().collect::<Vec<char>>();\n\
    \    let mut xor = String::new();\n    for i in 0..a.len() {\n        if a[i]\
    \ == b[i] {\n            xor.push('0');\n        } else {\n            xor.push('1');\n\
    \        }\n    }\n    xor", "    a.chars()\n        .zip(b.chars())\n       \
    \ .map(|(a, b)| match (a, b) {\n            ('0', '0') => '0',\n            ('0',\
    \ '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1') => '0',\n\
    \            _ => panic!(\"unexpected character\"),\n        })\n        .collect()",
  "    let mut result = String::new();\n    for (i, j) in a.chars().zip(b.chars())\
    \ {\n        result.push(\n            if i == j {\n                '0'\n    \
    \        } else {\n                '1'\n            }\n        );\n    }\n   \
    \ result", "    a.chars()\n        .zip(b.chars())\n        .map(|(x, y)| if x\
    \ == y { '0' } else { '1' })\n        .collect()", "    a.chars()\n        .zip(b.chars())\n\
    \        .map(|(a, b)| (a.to_digit(2).unwrap() ^ b.to_digit(2).unwrap()).to_string())\n\
    \        .collect()", "    if a.len() != b.len() {\n        panic!(\"Invalid inputs:\
    \ {} {}\", a, b);\n    }\n    a.chars()\n        .zip(b.chars())\n        .map(|(ca,\
    \ cb)| if ca == cb { '0' } else { '1' })\n        .collect()", "    let mut output\
    \ = String::new();\n    let mut ia = a.chars();\n    let mut ib = b.chars();\n\
    \    loop {\n        let ca = ia.next();\n        let cb = ib.next();\n      \
    \  match (ca, cb) {\n            (Some(a), Some(b)) => {\n                output.push(char_xor(a,\
    \ b));\n            }\n            (Some(_), None) => {\n                panic!(\"\
    Input error: input string b shorter than input string a\");\n            }\n \
    \           (None, Some(_)) => {\n                panic!(\"Input error: input\
    \ string a shorter than input string b\");\n            }\n            (None,\
    \ None) => {\n                break;\n            }\n        }\n    }\n    output",
  "    let mut a = a.chars();\n    let mut b = b.chars();\n    let mut s = String::new();\n\
    \    loop {\n        match (a.next(), b.next()) {\n            (Some(c1), Some(c2))\
    \ => s.push(xor(c1, c2)),\n            _ => break,\n        }\n    }\n    s",
  '    unimplemented!()', "    let zipped = a.chars().zip(b.chars());\n    zipped.map(|(x,\
    \ y)| if x == y { '0' } else { '1' }).collect()", '    format!("{:?}", a.into_bytes().iter().zip(b.into_bytes().iter()).map(|(x,
    y)| x ^ y).collect::<Vec<u8>>())', "    let mut res = String::new();\n    for\
    \ (char_a, char_b) in a.chars().zip(b.chars()) {\n        if char_a == char_b\
    \ {\n            res.push('0');\n        } else {\n            res.push('1');\n\
    \        }\n    }\n    res", "    let mut result = String::new();\n    for i in\
    \ 0..a.len() {\n        if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap()\
    \ {\n            result.push('0');\n        } else {\n            result.push('1');\n\
    \        }\n    }\n    result", "    a.chars()\n        .zip(b.chars())\n    \
    \    .map(|(x, y)| if x == y { '0' } else { '1' })\n        .collect()", "   \
    \ let mut c = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n \
    \       c.push(if i == j { '0' } else { '1' });\n    }\n    c", "    let mut a\
    \ = a.chars();\n    let mut b = b.chars();\n    let mut output = String::new();\n\
    \    loop {\n        match (a.next(), b.next()) {\n            (Some(ai), Some(bi))\
    \ => output.push(xor(ai, bi)),\n            _ => break,\n        }\n    }\n  \
    \  output", '    format!("{:b}", u32::from_str_radix(&a, 2).unwrap() ^ u32::from_str_radix(&b,
    2).unwrap())', "    let a_bytes = a.into_bytes();\n    let b_bytes = b.into_bytes();\n\
    \    let mut results = Vec::new();\n    for (index, a_byte) in a_bytes.iter().enumerate()\
    \ {\n        let b_byte = b_bytes[index];\n        let result = a_byte ^ b_byte;\n\
    \        results.push(result);\n    }\n    let result = String::from_utf8(results).unwrap();\n\
    \    result"]
stop_tokens:
- "\n}"
