name: HumanEval_115_max_fill
language: rust
results:
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut heights = grid.iter().map(|row| {\n        row.iter().sum::<isize>()\n\
    \    }).collect::<Vec<_>>();\n    let mut steps = 0;\n    while let Some(max)\
    \ = heights.iter().max() {\n        let mut full = false;\n        for h in heights.iter_mut()\
    \ {\n            if *h < *max {\n                if *h + capacity <= *max {\n\
    \                    steps += 1;\n                    *h += capacity;\n      \
    \          } else {\n                    *h = *max;\n                    full\
    \ = true;\n                }\n            }\n        }\n        if full {\n  \
    \          break;\n        }\n    }\n    steps\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `heights` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmp29ls3hik.rs:35:18\n   |\n33 |     while let Some(max)\
    \ = heights.iter().max() {\n   |                           -------------- immutable\
    \ borrow occurs here\n34 |         let mut full = false;\n35 |         for h in\
    \ heights.iter_mut() {\n   |                  ^^^^^^^^^^^^^^^^^^ mutable borrow\
    \ occurs here\n36 |             if *h < *max {\n   |                     ----\
    \ immutable borrow later used here\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut fill = 0;\n    let\
    \ mut last_height = -1;\n    let mut count = 0;\n    loop {\n        let max_height\
    \ = grid.iter().map(|row| row.iter().max().unwrap_or(&0)).max().unwrap_or(&0);\n\
    \        if max_height == &0 {\n            return count;\n        }\n       \
    \ count += 1;\n        if max_height != &last_height {\n            last_height\
    \ = *max_height;\n            fill = capacity;\n        }\n        for row in\
    \ grid.iter_mut() {\n            for i in 0..row.len() {\n                if row[i]\
    \ > 0 {\n                    row[i] -= fill;\n                }\n            }\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmp6pybf3ox.rs:55:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let row_count = grid.len();\n    let column_count = grid[0].len();\n\
    \    let mut result = 0;\n    for row in 0..row_count {\n        let mut is_full\
    \ = true;\n        for column in 0..column_count {\n            if grid[row][column]\
    \ == 0 {\n                is_full = false;\n                continue;\n      \
    \      }\n            let mut bucket = capacity;\n            while bucket > 0\
    \ {\n                if grid[row][column] < bucket {\n                    bucket\
    \ -= grid[row][column];\n                    grid[row][column] = 0;\n        \
    \        } else {\n                    grid[row][column] -= bucket;\n        \
    \            bucket = 0;\n                }\n                result += 1;\n  \
    \          }\n        }\n        if is_full {\n            break;\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `grid` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp1_tk0ttm.rs:43:21\n   |\n28 | fn max_fill(grid: Vec<Vec<isize>>,\
    \ capacity: isize) -> isize {\n   |             ---- help: consider changing this\
    \ to be mutable: `mut grid`\n...\n43 |                     grid[row][column] =\
    \ 0;\n   |                     ^^^^ cannot borrow as mutable\n\nerror[E0596]:\
    \ cannot borrow `grid` as mutable, as it is not declared as mutable\n  --> /tmp/tmp1_tk0ttm.rs:45:21\n\
    \   |\n28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |             ---- help: consider changing this to be mutable: `mut grid`\n\
    ...\n45 |                     grid[row][column] -= bucket;\n   |             \
    \        ^^^^ cannot borrow as mutable\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    0\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `6`', /tmp/tmp37it5gjg.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut num_fill = 0;\n    let num_row = grid.len();\n\
    \    let mut total_cells = 0;\n    for row in &grid {\n        total_cells +=\
    \ row.len();\n    }\n    let mut cells_filled = 0;\n    while cells_filled < total_cells\
    \ {\n        let mut cur_row = 0;\n        while cur_row < num_row {\n       \
    \     let mut cur_col = 0;\n            while cur_col < grid[cur_row].len() {\n\
    \                if grid[cur_row][cur_col] > 0 {\n                    cells_filled\
    \ += 1;\n                    grid[cur_row][cur_col] -= 1;\n                  \
    \  num_fill += 1;\n                }\n                cur_col += 1;\n        \
    \    }\n            cur_row += 1;\n        }\n    }\n    num_fill\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `capacity`\n  --> /tmp/tmpf_qwarpb.rs:28:36\n\
    \   |\n28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                    ^^^^^^^^ help: if this is intentional,\
    \ prefix it with an underscore: `_capacity`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0596]: cannot borrow `grid` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmpf_qwarpb.rs:43:21\n   |\n28 | fn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n   |             ---- help: consider\
    \ changing this to be mutable: `mut grid`\n...\n43 |                     grid[cur_row][cur_col]\
    \ -= 1;\n   |                     ^^^^ cannot borrow as mutable\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut total_water = 0;\n    for (row, _) in grid.iter().enumerate()\
    \ {\n        for col in 0..grid[row].len() {\n            if grid[row][col] ==\
    \ 1 {\n                total_water += 1;\n            }\n        }\n    }\n  \
    \  total_water / capacity\n}\n\nfn main() {\n    let candidate = max_fill;\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1,\
    \ 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0,\
    \ 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `5`', /tmp/tmp3exctou8.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    use std::cmp::max;\n    let rows = grid.len();\n    let\
    \ cols = grid[0].len();\n    let mut wells = vec![0; cols];\n    let mut result\
    \ = 0;\n    for row in grid {\n        for (col, &val) in row.iter().enumerate()\
    \ {\n            wells[col] += val;\n        }\n        let mut total = 0;\n \
    \       for &well in &wells {\n            if well < capacity {\n            \
    \    total += well;\n            } else {\n                total += capacity;\n\
    \            }\n        }\n        if total < capacity * cols as isize {\n   \
    \         let max_well = wells.iter().max().unwrap();\n            result += capacity\
    \ * cols as isize - total;\n            for well in &mut wells {\n           \
    \     if *well > capacity {\n                    *well -= capacity;\n        \
    \        } else {\n                    *well = 0;\n                }\n       \
    \     }\n            if *max_well >= capacity {\n                result += capacity;\n\
    \                *max_well -= capacity;\n            } else {\n              \
    \  result += *max_well;\n                *max_well = 0;\n            }\n     \
    \   }\n    }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n  \
    \  assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1,\
    \ 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0,\
    \ 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "warning: unused import: `std::cmp::max`\n  --> /tmp/tmpa1rtxsgn.rs:29:9\n\
    \   |\n29 |     use std::cmp::max;\n   |         ^^^^^^^^^^^^^\n   |\n   = note:\
    \ `#[warn(unused_imports)]` on by default\n\nwarning: unused variable: `rows`\n\
    \  --> /tmp/tmpa1rtxsgn.rs:30:9\n   |\n30 |     let rows = grid.len();\n   | \
    \        ^^^^ help: if this is intentional, prefix it with an underscore: `_rows`\n\
    \   |\n   = note: `#[warn(unused_variables)]` on by default\n\nerror[E0502]: cannot\
    \ borrow `wells` as mutable because it is also borrowed as immutable\n  --> /tmp/tmpa1rtxsgn.rs:49:25\n\
    \   |\n47 |             let max_well = wells.iter().max().unwrap();\n   |    \
    \                        ------------ immutable borrow occurs here\n48 |     \
    \        result += capacity * cols as isize - total;\n49 |             for well\
    \ in &mut wells {\n   |                         ^^^^^^^^^^ mutable borrow occurs\
    \ here\n...\n56 |             if *max_well >= capacity {\n   |               \
    \ --------- immutable borrow later used here\n\nerror[E0594]: cannot assign to\
    \ `*max_well`, which is behind a `&` reference\n  --> /tmp/tmpa1rtxsgn.rs:58:17\n\
    \   |\n47 |             let max_well = wells.iter().max().unwrap();\n   |    \
    \             -------- help: consider changing this to be a mutable reference:\
    \ `&mut isize`\n...\n58 |                 *max_well -= capacity;\n   |       \
    \          ^^^^^^^^^^^^^^^^^^^^^ `max_well` is a `&` reference, so the data it\
    \ refers to cannot be written\n\nerror[E0594]: cannot assign to `*max_well`, which\
    \ is behind a `&` reference\n  --> /tmp/tmpa1rtxsgn.rs:61:17\n   |\n47 |     \
    \        let max_well = wells.iter().max().unwrap();\n   |                 --------\
    \ help: consider changing this to be a mutable reference: `&mut isize`\n...\n\
    61 |                 *max_well = 0;\n   |                 ^^^^^^^^^^^^^ `max_well`\
    \ is a `&` reference, so the data it refers to cannot be written\n\nerror: aborting\
    \ due to 3 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations:\
    \ E0502, E0594.\nFor more information about an error, try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let rows = grid.len();\n    let cols = grid[0].len();\n\
    \    let mut copied = grid.clone();\n    let mut count = 0;\n    for i in 0..rows\
    \ {\n        for j in 0..cols {\n            if copied[i][j] == 1 {\n        \
    \        copied[i][j] = capacity;\n                count += 1;\n            }\n\
    \        }\n    }\n    let mut result = 0;\n    for i in 0..rows {\n        for\
    \ j in 0..cols {\n            let mut is_valid = false;\n            if i > 0\
    \ && copied[i - 1][j] > 0 {\n                copied[i - 1][j] -= 1;\n        \
    \        is_valid = true;\n            }\n            if i < rows - 1 && copied[i\
    \ + 1][j] > 0 {\n                copied[i + 1][j] -= 1;\n                is_valid\
    \ = true;\n            }\n            if j > 0 && copied[i][j - 1] > 0 {\n   \
    \             copied[i][j - 1] -= 1;\n                is_valid = true;\n     \
    \       }\n            if j < cols - 1 && copied[i][j + 1] > 0 {\n           \
    \     copied[i][j + 1] -= 1;\n                is_valid = true;\n            }\n\
    \            if is_valid {\n                result += 1;\n            }\n    \
    \    }\n    }\n    result + count\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `11`,\n right: `6`', /tmp/tmpz2odalag.rs:71:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut ans = 0;\n    let mut\
    \ wells_done = 0;\n    while wells_done < grid.len() {\n        let fill_col =\
    \ find_fill_col(&grid);\n        if fill_col.is_none() {\n            break;\n\
    \        }\n        let fill_col = fill_col.unwrap();\n        wells_done += fill_col.1;\n\
    \        for row in &mut grid {\n            if row[fill_col.0] == 1 {\n     \
    \           ans += 1;\n                for _ in 0..capacity {\n              \
    \      *row.get_mut(fill_col.0).unwrap() -= 1;\n                }\n          \
    \  }\n        }\n    }\n    ans\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_fill_col` in this scope\n  -->\
    \ /tmp/tmpc9k7sfn8.rs:33:24\n   |\n33 |         let fill_col = find_fill_col(&grid);\n\
    \   |                        ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let m = grid.len();\n    let n = grid[0].len();\n   \
    \ let mut grid = grid;\n    let mut sum = 0;\n    for i in 0..m {\n        for\
    \ j in 0..n {\n            sum += grid[i][j];\n        }\n    }\n    if sum <=\
    \ capacity {\n        return 0;\n    }\n    let mut result = isize::MAX;\n   \
    \ for col in 0..n {\n        for i in 0..m {\n            let mut row = vec![0;\
    \ m];\n            for j in 0..i {\n                row[j] = isize::MAX;\n   \
    \         }\n            for j in i..m {\n                let mut cur = capacity;\n\
    \                let mut step = 0;\n                let mut found = false;\n \
    \               for k in 0..n {\n                    if col == k {\n         \
    \               if grid[j][k] > cur {\n                            step += 1;\n\
    \                            cur = capacity;\n                        }\n    \
    \                    cur -= grid[j][k];\n                        if cur == 0 {\n\
    \                            if k == n - 1 {\n                               \
    \ found = true;\n                            } else {\n                      \
    \          step += 1;\n                                cur = capacity;\n     \
    \                       }\n                        }\n                    } else\
    \ {\n                        cur -= grid[j][k];\n                        if cur\
    \ == 0 {\n                            if k == n - 1 {\n                      \
    \          found = true;\n                            } else {\n             \
    \                   step += 1;\n                                cur = capacity;\n\
    \                            }\n                        }\n                  \
    \  }\n                }\n                if found {\n                    row[j]\
    \ = step;\n                } else {\n                    row[j] = isize::MAX;\n\
    \                }\n            }\n            for j in i + 1..m {\n         \
    \       if row[j] == isize::MAX {\n                    row[j] = row[j - 1];\n\
    \                } else {\n                    row[j] = row[j - 1].min(row[j]);\n\
    \                }\n            }\n            result = result.min(row[m - 1]);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmps81mry17.rs:100:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut count = 0;\n    for row in grid {\n        let\
    \ mut water = 0;\n        for well in row {\n            water += well;\n    \
    \        if water > capacity {\n                count += water - capacity;\n \
    \               water = capacity;\n            }\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmpcr5m9rgr.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut result = 0;\n    let rows = grid.len();\n   \
    \ let cols = grid[0].len();\n    for col in 0..cols {\n        let mut top = 0;\n\
    \        for row in 0..rows {\n            if grid[row][col] == 1 {\n        \
    \        result += (top..row).filter(|i| grid[*i][col] == 0).count() as isize;\n\
    \                top = row + 1;\n            }\n        }\n        let mut bottom\
    \ = rows - 1;\n        for row in (0..rows).rev() {\n            if grid[row][col]\
    \ == 1 {\n                result += (row + 1..bottom + 1).filter(|i| grid[*i][col]\
    \ == 0).count() as isize;\n                bottom = row - 1;\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmphd7oolg3.rs:44:26\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut count = 0;\n    let mut max = 0;\n    let mut\
    \ length = 0;\n    for row in grid {\n        max = 0;\n        length = 0;\n\
    \        for i in row {\n            if i == 1 {\n                max += 1;\n\
    \            } else {\n                length += 1;\n            }\n        }\n\
    \        count += max / capacity;\n        if max % capacity > 0 {\n         \
    \   count += 1;\n        }\n        if length < max {\n            count += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `6`', /tmp/tmpzocee871.rs:55:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut fill = 0;\n    for row in grid {\n        let\
    \ mut water = 0;\n        for &cell in &row {\n            if cell == 1 {\n  \
    \              water += 1;\n            } else if water > 0 {\n              \
    \  water -= 1;\n            }\n        }\n        if water > 0 {\n           \
    \ fill += water;\n        }\n    }\n    let mut rows = Vec::new();\n    for row\
    \ in grid {\n        let mut water = 0;\n        for &cell in &row {\n       \
    \     if cell == 1 {\n                water += 1;\n            } else if water\
    \ > 0 {\n                water -= 1;\n            }\n        }\n        if water\
    \ > 0 {\n            rows.push(water);\n        }\n    }\n    let mut buckets\
    \ = 0;\n    for &water in &rows {\n        buckets += water / capacity;\n    \
    \    if water % capacity > 0 {\n            buckets += 1;\n        }\n    }\n\
    \    buckets\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "warning: variable `fill` is assigned to, but never used\n  --> /tmp/tmpzkie02yp.rs:29:13\n\
    \   |\n29 |     let mut fill = 0;\n   |             ^^^^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_fill` instead\n\nerror[E0382]: use\
    \ of moved value: `grid`\n   --> /tmp/tmpzkie02yp.rs:44:16\n    |\n28  | fn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    |             ---- move occurs\
    \ because `grid` has type `Vec<Vec<isize>>`, which does not implement the `Copy`\
    \ trait\n29  |     let mut fill = 0;\n30  |     for row in grid {\n    |     \
    \           ---- `grid` moved due to this implicit call to `.into_iter()`\n...\n\
    44  |     for row in grid {\n    |                ^^^^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `grid`\nhelp: consider iterating over a slice of the `Vec<Vec<isize>>`'s content\
    \ to avoid moving into the `for` loop\n    |\n30  |     for row in &grid {\n \
    \   |                +\n\nerror: aborting due to previous error; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut ops = 0;\n    let n = grid.len();\n    for i\
    \ in 0..n {\n        let level = grid[i].iter().sum();\n        if level > 0 {\n\
    \            let to_fill = capacity - level;\n            if to_fill > 0 {\n \
    \               ops += 1;\n            }\n            ops += to_fill;\n      \
    \  }\n    }\n    ops\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp9xa_v16h.rs:32:13\n\
    \   |\n32 |         let level = grid[i].iter().sum();\n   |             ^^^^^\
    \ consider giving `level` a type\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut fill_count = 0;\n    let mut pos = 0;\n    let\
    \ height = grid.len();\n    let width = grid[0].len();\n    for row in grid {\n\
    \        for (i, &well) in row.iter().enumerate() {\n            if well == 1\
    \ {\n                let mut fill = capacity;\n                while fill > 0\
    \ {\n                    let (y, x) = (pos, i);\n                    if x > 0\
    \ && grid[y][x - 1] == 1 {\n                        fill -= 1;\n             \
    \           grid[y][x - 1] = 0;\n                    }\n                    if\
    \ x < width - 1 && grid[y][x + 1] == 1 {\n                        fill -= 1;\n\
    \                        grid[y][x + 1] = 0;\n                    }\n        \
    \            if y > 0 && grid[y - 1][x] == 1 {\n                        fill -=\
    \ 1;\n                        grid[y - 1][x] = 0;\n                    }\n   \
    \                 if y < height - 1 && grid[y + 1][x] == 1 {\n               \
    \         fill -= 1;\n                        grid[y + 1][x] = 0;\n          \
    \          }\n                    fill_count += 1;\n                }\n      \
    \      }\n        }\n        pos += 1;\n    }\n    fill_count\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `grid`\n   --> /tmp/tmpigol4x4l.rs:39:33\n\
    \    |\n28  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |             ---- move occurs because `grid` has type `Vec<Vec<isize>>`,\
    \ which does not implement the `Copy` trait\n...\n33  |     for row in grid {\n\
    \    |                ---- `grid` moved due to this implicit call to `.into_iter()`\n\
    ...\n39  |                     if x > 0 && grid[y][x - 1] == 1 {\n    |      \
    \                           ^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `grid`\nhelp:\
    \ consider iterating over a slice of the `Vec<Vec<isize>>`'s content to avoid\
    \ moving into the `for` loop\n    |\n33  |     for row in &grid {\n    |     \
    \           +\n\nerror[E0596]: cannot borrow `grid` as mutable, as it is not declared\
    \ as mutable\n  --> /tmp/tmpigol4x4l.rs:41:25\n   |\n28 | fn max_fill(grid: Vec<Vec<isize>>,\
    \ capacity: isize) -> isize {\n   |             ---- help: consider changing this\
    \ to be mutable: `mut grid`\n...\n41 |                         grid[y][x - 1]\
    \ = 0;\n   |                         ^^^^ cannot borrow as mutable\n\nerror[E0596]:\
    \ cannot borrow `grid` as mutable, as it is not declared as mutable\n  --> /tmp/tmpigol4x4l.rs:45:25\n\
    \   |\n28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |             ---- help: consider changing this to be mutable: `mut grid`\n\
    ...\n45 |                         grid[y][x + 1] = 0;\n   |                  \
    \       ^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `grid` as\
    \ mutable, as it is not declared as mutable\n  --> /tmp/tmpigol4x4l.rs:49:25\n\
    \   |\n28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |             ---- help: consider changing this to be mutable: `mut grid`\n\
    ...\n49 |                         grid[y - 1][x] = 0;\n   |                  \
    \       ^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `grid` as\
    \ mutable, as it is not declared as mutable\n  --> /tmp/tmpigol4x4l.rs:53:25\n\
    \   |\n28 | fn max_fill(grid: Vec<V"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut wells = grid.into_iter().map(|r| r.into_iter().sum()).collect::<Vec<_>>();\n\
    \    let mut res = 0;\n    while *wells.iter().max().unwrap() > 0 {\n        wells\
    \ = wells.into_iter().map(|w| if w > capacity { w - capacity } else { 0 }).collect();\n\
    \        res += 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpjfjsbp98.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let n = grid.len();\n    let m = grid[0].len();\n   \
    \ let mut result = 0;\n    let mut max_height = vec![0; m];\n    for row in grid\
    \ {\n        for i in 0..m {\n            max_height[i] = max(max_height[i], row[i]);\n\
    \        }\n    }\n    for row in grid {\n        for i in 0..m {\n          \
    \  let fill = max_height[i] - row[i];\n            if fill > 0 {\n           \
    \     result += fill;\n                max_height[i] -= fill;\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpdp_2ym5z.rs:35:29\n\
    \   |\n35 |             max_height[i] = max(max_height[i], row[i]);\n   |    \
    \                         ^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    // \n    let num_wells = grid.len();\n    let mut bucket\
    \ = capacity;\n    let mut num_steps = 0;\n    // make a priority queue of wells,\
    \ sorting first by height of well, then position\n    let mut wells: Vec<&Vec<isize>>\
    \ = grid.iter().collect();\n    wells.sort_by(|a, b| b.cmp(a));\n    wells.sort_by(|a,\
    \ b| a.iter().sum::<isize>().cmp(&b.iter().sum::<isize>()));\n    // while the\
    \ queue is not empty,\n    while !wells.is_empty() {\n        // remove the top\
    \ well from the queue\n        let well = wells.pop().unwrap();\n        // if\
    \ the bucket has water in it,\n        if bucket > 0 {\n            // get the\
    \ number of units of water in the well\n            let max_units = well.iter().sum::<isize>();\n\
    \            // fill the bucket until it reaches capacity or the well is empty\n\
    \            bucket = std::cmp::min(bucket + max_units, capacity);\n         \
    \   // if the well is not empty, return it to the queue\n            if well.iter().sum::<isize>()\
    \ > 0 {\n                wells.push(well);\n            }\n        }\n       \
    \ // otherwise,\n        else {\n            // the bucket is empty, so reset\
    \ to capacity\n            bucket = capacity;\n            // if the well is not\
    \ empty,\n            if well.iter().sum::<isize>() > 0 {\n                //\
    \ return it to the queue\n                wells.push(well);\n            }\n \
    \       }\n        // increment the number of steps\n        num_steps += 1;\n\
    \    }\n    // return the number of steps\n    num_steps\n}\n\nfn main() {\n \
    \   let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut row_maxes = vec![0; grid.len()];\n    let mut\
    \ col_maxes = vec![0; grid[0].len()];\n    let mut max_max = 0;\n    for (row_index,\
    \ row) in grid.iter().enumerate() {\n        let mut row_max = 0;\n        for\
    \ (col_index, cell) in row.iter().enumerate() {\n            row_max = cmp::max(row_max,\
    \ *cell);\n            col_maxes[col_index] = cmp::max(col_maxes[col_index], *cell);\n\
    \            max_max = cmp::max(max_max, *cell);\n        }\n        row_maxes[row_index]\
    \ = row_max;\n    }\n    let mut max_water = 0;\n    let mut cur_water = 0;\n\
    \    let mut row_index = 0;\n    let mut col_index = 0;\n    let mut bucket_water\
    \ = 0;\n    let mut max_fill = 0;\n    while max_water < max_max {\n        if\
    \ row_index < grid.len() {\n            let row_max = row_maxes[row_index];\n\
    \            if row_max > 0 {\n                if bucket_water == 0 {\n      \
    \              bucket_water = capacity;\n                    max_fill += 1;\n\
    \                }\n                if bucket_water < row_max {\n            \
    \        cur_water += bucket_water;\n                    bucket_water = 0;\n \
    \               } else {\n                    cur_water += row_max;\n        \
    \            bucket_water -= row_max;\n                }\n                max_water\
    \ = cmp::max(max_water, cur_water);\n                row_maxes[row_index] = 0;\n\
    \                col_index = 0;\n            }\n            row_index += 1;\n\
    \        } else {\n            let col_max = col_maxes[col_index];\n         \
    \   if col_max > 0 {\n                if bucket_water == 0 {\n               \
    \     bucket_water = capacity;\n                    max_fill += 1;\n         \
    \       }\n                if bucket_water < col_max {\n                    cur_water\
    \ += bucket_water;\n\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpv3j5csl7.rs:86:3\n\
    \   |\n28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                                              - unclosed delimiter\n\
    ...\n47 |     while max_water < max_max {\n   |                              \
    \ - unclosed delimiter\n...\n67 |         } else {\n   |                - unclosed\
    \ delimiter\n68 |             let col_max = col_maxes[col_index];\n69 |      \
    \       if col_max > 0 {\n   |                            - unclosed delimiter\n\
    ...\n74 |                 if bucket_water < col_max {\n   |                  \
    \                         - this delimiter might not be properly closed...\n...\n\
    77 | }\n   | - ...as it matches this but it has different indentation\n...\n86\
    \ | }\n   |   ^\n\nerror[E0433]: failed to resolve: use of undeclared crate or\
    \ module `cmp`\n  --> /tmp/tmpv3j5csl7.rs:35:23\n   |\n35 |             row_max\
    \ = cmp::max(row_max, *cell);\n   |                       ^^^ use of undeclared\
    \ crate or module `cmp`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ crate or module `cmp`\n  --> /tmp/tmpv3j5csl7.rs:36:36\n   |\n36 |         \
    \    col_maxes[col_index] = cmp::max(col_maxes[col_index], *cell);\n   |     \
    \                               ^^^ use of undeclared crate or module `cmp`\n\n\
    error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n  -->\
    \ /tmp/tmpv3j5csl7.rs:37:23\n   |\n37 |             max_max = cmp::max(max_max,\
    \ *cell);\n   |                       ^^^ use of undeclared crate or module `cmp`\n\
    \nerror[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n \
    \ --> /tmp/tmpv3j5csl7.rs:62:29\n   |\n62 |                 max_water = cmp::max(max_water,\
    \ cur_water);\n   |                             ^^^ use of undeclared crate or\
    \ module `cmp`\n\nerror[E0434]: can't capture dynamic environment in a fn item\n\
    \  --> /tmp/tmpv3j5csl7.rs:80:21\n   |\n80 |     let candidate = max_fill;\n \
    \  |                     ^^^^^^^^\n   |\n   = help: use the `|| { ... }` closure\
    \ form instead\n\nerror[E0308]: mismatched types\n  --> /t"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    if grid.is_empty() || grid[0].is_empty() {\n        return\
    \ 0;\n    }\n    let height = grid.len();\n    let width = grid[0].len();\n  \
    \  let mut filled = vec![0; width];\n    let mut drops = 0;\n    for y in 0..height\
    \ {\n        let row = &grid[y];\n        for x in 0..width {\n            if\
    \ row[x] == 1 {\n                filled[x] += 1;\n            } else {\n     \
    \           if filled[x] > 0 {\n                    drops += 1;\n            \
    \        for i in 0..width {\n                        filled[i] = filled[i].saturating_sub(1);\n\
    \                    }\n                }\n            }\n        }\n        if\
    \ filled.iter().all(|&f| f == 0) {\n            break;\n        }\n        drops\
    \ += 1;\n        for i in 0..width {\n            filled[i] = filled[i].saturating_sub(1);\n\
    \        }\n    }\n    drops\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0689]: can't call method `saturating_sub` on ambiguous numeric type\
    \ `{integer}`\n  --> /tmp/tmp8nvieyo9.rs:45:47\n   |\n45 |                   \
    \      filled[i] = filled[i].saturating_sub(1);\n   |                        \
    \                       ^^^^^^^^^^^^^^\n\nerror[E0689]: can't call method `saturating_sub`\
    \ on ambiguous numeric type `{integer}`\n  --> /tmp/tmp8nvieyo9.rs:55:35\n   |\n\
    55 |             filled[i] = filled[i].saturating_sub(1);\n   |              \
    \                     ^^^^^^^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0689`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut ret = 0;\n    for (row,\
    \ col) in grid.iter_mut().zip(grid[1..].iter_mut()) {\n        for (well, next_well)\
    \ in row.iter_mut().zip(col.iter_mut()) {\n            let to_raise = next_well.max(0);\n\
    \            *well -= to_raise;\n            *next_well -= to_raise;\n       \
    \     ret += to_raise;\n        }\n    }\n    let last_row = grid.last_mut().unwrap();\n\
    \    let mut left = capacity;\n    let mut full_buckets = 0;\n    for well in\
    \ last_row.iter_mut() {\n        if left == 0 {\n            full_buckets += 1;\n\
    \            left = capacity;\n        }\n        let to_raise = *well.min(left);\n\
    \        *well -= to_raise;\n        left -= to_raise;\n        ret += to_raise;\n\
    \    }\n    ret += full_buckets * capacity;\n    ret\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl6vgurn1.rs:33:42\n   |\n\
    33 |             let to_raise = next_well.max(0);\n   |                      \
    \                    ^\n   |                                          |\n   |\
    \                                          expected `&mut isize`, found integer\n\
    \   |                                          help: consider mutably borrowing\
    \ here: `&mut 0`\n\nerror[E0277]: cannot subtract-assign `&mut isize` from `isize`\n\
    \  --> /tmp/tmpl6vgurn1.rs:34:19\n   |\n34 |             *well -= to_raise;\n\
    \   |                   ^^ no implementation for `isize -= &mut isize`\n   |\n\
    \   = help: the trait `SubAssign<&mut isize>` is not implemented for `isize`\n\
    \   = help: the following other types implement trait `SubAssign<Rhs>`:\n    \
    \         <f32 as SubAssign<&f32>>\n             <f32 as SubAssign>\n        \
    \     <f64 as SubAssign<&f64>>\n             <f64 as SubAssign>\n            \
    \ <i128 as SubAssign<&i128>>\n             <i128 as SubAssign>\n             <i16\
    \ as SubAssign<&i16>>\n             <i16 as SubAssign>\n           and 20 others\n\
    \nerror[E0277]: cannot subtract-assign `&mut isize` from `isize`\n  --> /tmp/tmpl6vgurn1.rs:35:24\n\
    \   |\n35 |             *next_well -= to_raise;\n   |                        ^^\
    \ no implementation for `isize -= &mut isize`\n   |\n   = help: the trait `SubAssign<&mut\
    \ isize>` is not implemented for `isize`\n   = help: the following other types\
    \ implement trait `SubAssign<Rhs>`:\n             <f32 as SubAssign<&f32>>\n \
    \            <f32 as SubAssign>\n             <f64 as SubAssign<&f64>>\n     \
    \        <f64 as SubAssign>\n             <i128 as SubAssign<&i128>>\n       \
    \      <i128 as SubAssign>\n             <i16 as SubAssign<&i16>>\n          \
    \   <i16 as SubAssign>\n           and 20 others\n\nerror[E0277]: cannot add-assign\
    \ `&mut isize` to `{integer}`\n  --> /tmp/tmpl6vgurn1.rs:36:17\n   |\n36 |   \
    \          ret += to_raise;\n   |                 ^^ no implementation for `{integer}\
    \ += &mut isize`\n   |\n   = help: the trait `AddAssign<&mut isize>` is not implemented\
    \ for `{integer}`\n   = help: the following"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let n = grid.len();\n    let m = grid[0].len();\n   \
    \ let mut result = 0;\n    for _ in 0..n {\n        let mut max_h = capacity;\n\
    \        for j in 0..m {\n            max_h = max_h.min(grid[j][0]);\n       \
    \ }\n        result += max_h;\n        for j in 0..m {\n            grid[j].remove(0);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `grid` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpuc8g7zzc.rs:39:13\n   |\n28 | fn max_fill(grid: Vec<Vec<isize>>,\
    \ capacity: isize) -> isize {\n   |             ---- help: consider changing this\
    \ to be mutable: `mut grid`\n...\n39 |             grid[j].remove(0);\n   |  \
    \           ^^^^ cannot borrow as mutable\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    // Count the number of wells to be filled.\n    let n\
    \ = grid.iter().fold(0, |acc, row| acc + row.iter().filter(|&&v| v == 1).count());\n\
    \    let m = grid[0].len();\n    // Depth-first search is used to find the minimum\
    \ number of fill operations.\n    let mut max_fills = n as isize;\n    let mut\
    \ wells = grid.clone();\n    dfs(0, 0, n, capacity, m, &mut wells, &mut max_fills);\n\
    \    max_fills\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `dfs` in this scope\n  --> /tmp/tmptbrfcr_v.rs:35:5\n\
    \   |\n35 |     dfs(0, 0, n, capacity, m, &mut wells, &mut max_fills);\n   | \
    \    ^^^ not found in this scope\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    use std::cmp::max;\n    // sum(max(capacity - height,\
    \ 0))\n    grid.iter().map(|row| capacity - row.iter().max().unwrap()).sum()\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `6`', /tmp/tmpckdaakcz.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut count = 0;\n    let rows = grid.len();\n    let\
    \ cols = grid[0].len();\n    for i in 0..rows {\n        for j in 0..cols {\n\
    \            if grid[i][j] != 0 {\n                grid[i][j] -= capacity;\n \
    \               count += 1;\n            }\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `grid` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpv8819gcm.rs:35:17\n   |\n28 | fn max_fill(grid: Vec<Vec<isize>>,\
    \ capacity: isize) -> isize {\n   |             ---- help: consider changing this\
    \ to be mutable: `mut grid`\n...\n35 |                 grid[i][j] -= capacity;\n\
    \   |                 ^^^^ cannot borrow as mutable\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let (mut row, col) = (grid.len(), grid[0].len());\n \
    \   let mut w = vec![vec![0; col]; row];\n    let mut h = vec![0; col];\n    for\
    \ (i, row) in grid.iter().enumerate() {\n        for (j, &w) in row.iter().enumerate()\
    \ {\n            if w == 1 {\n                h[j] += 1;\n                w[i][j]\
    \ = capacity;\n            }\n        }\n    }\n    let mut ans = 0;\n    while\
    \ let Some(pos) = h.iter().position(|&h| h > 0) {\n        ans += fill(w, h, pos,\
    \ capacity);\n    }\n    ans\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `fill` in this scope\n  --> /tmp/tmpiff1x8_y.rs:42:16\n\
    \   |\n42 |         ans += fill(w, h, pos, capacity);\n   |                ^^^^\
    \ not found in this scope\n\nerror[E0608]: cannot index into a value of type `isize`\n\
    \  --> /tmp/tmpiff1x8_y.rs:36:17\n   |\n36 |                 w[i][j] = capacity;\n\
    \   |                 ^^^^\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0425, E0608.\nFor more information about\
    \ an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut sum = 0;\n    for row in grid {\n        let\
    \ mut prev = 0;\n        for &ch in row.iter() {\n            if ch == 1 {\n \
    \               sum += capacity - prev;\n                prev = capacity;\n  \
    \          } else {\n                prev = 0;\n            }\n        }\n   \
    \ }\n    sum\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmpmk_3x5e8.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let n = grid.len();\n    let m = grid[0].len();\n   \
    \ let mut result = 0;\n    for x in 0..n {\n        let mut y = 0;\n        while\
    \ y < m && grid[x][y] == 0 {\n            y += 1;\n        }\n        if y < m\
    \ {\n            let mut fill = capacity;\n            let mut z = y;\n      \
    \      while z < m && fill > 0 {\n                fill -= grid[x][z];\n      \
    \          if fill < 0 {\n                    result += -fill;\n             \
    \       fill = 0;\n                }\n                z += 1;\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `6`', /tmp/tmp5ra39igb.rs:55:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let (rows, cols) = (grid.len(), grid[0].len());\n   \
    \ let mut result = 0;\n    for row in 0..rows {\n        let mut count = 0;\n\
    \        for col in 0..cols {\n            count += grid[row][col];\n        \
    \    if count == capacity {\n                count = 0;\n                result\
    \ += 1;\n            }\n        }\n        if count > 0 {\n            result\
    \ += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut moved = true;\n    let m = grid.len();\n    let\
    \ n = grid[0].len();\n    let mut buckets = vec![vec![0; n]; m];\n    let mut\
    \ fill_cnt = 0;\n    while moved {\n        moved = false;\n        for i in 0..m\
    \ {\n            for j in 0..n {\n                if grid[i][j] == 1 {\n     \
    \               if buckets[i][j] < capacity {\n                        buckets[i][j]\
    \ += 1;\n                        moved = true;\n                        fill_cnt\
    \ += 1;\n                    }\n                } else {\n                   \
    \ if i > 0 && buckets[i - 1][j] > 0 {\n                        buckets[i - 1][j]\
    \ -= 1;\n                        buckets[i][j] += 1;\n                       \
    \ moved = true;\n                    }\n                    if j > 0 && buckets[i][j\
    \ - 1] > 0 {\n                        buckets[i][j - 1] -= 1;\n              \
    \          buckets[i][j] += 1;\n                        moved = true;\n      \
    \              }\n                }\n            }\n        }\n    }\n    fill_cnt\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut num_lowers = 0;\n    for row in &grid {\n   \
    \     for &water in row {\n            num_lowers += (water + capacity - 1) /\
    \ capacity;\n        }\n    }\n    num_lowers\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmpy11dj9co.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let m = grid.len();\n    let n = grid[0].len();\n   \
    \ let mut total = 0;\n    let mut min_fill = isize::max_value();\n    for row\
    \ in grid {\n        for col in row {\n            if col > 0 {\n            \
    \    total += 1;\n                min_fill = min_fill.min(col);\n            }\n\
    \        }\n    }\n    if total == 0 {\n        return 0;\n    }\n    let mut\
    \ high = capacity * total;\n    let mut low = min_fill;\n    while low < high\
    \ {\n        let mid = low + (high - low) / 2;\n        let fill = fill_grid(grid.clone(),\
    \ capacity, mid);\n        if fill > mid {\n            low = mid + 1;\n     \
    \   } else {\n            high = mid;\n        }\n    }\n    low\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `fill_grid` in this scope\n  --> /tmp/tmpyribk02n.rs:48:20\n\
    \   |\n48 |         let fill = fill_grid(grid.clone(), capacity, mid);\n   | \
    \                   ^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut fill = 0;\n    let mut cols = 0;\n    let rows\
    \ = grid.len();\n    let height = grid.iter().map(|r| r.iter().sum::<isize>()).max().unwrap();\n\
    \    for row in &grid {\n        if row.iter().sum::<isize>() > 0 {\n        \
    \    cols = row.len();\n            break;\n        }\n    }\n    let mut count\
    \ = vec![0; cols];\n    for i in 0..rows {\n        let row = &grid[i];\n    \
    \    for j in 0..cols {\n            if row[j] == 1 {\n                count[j]\
    \ += 1;\n            }\n        }\n    }\n    let mut fill = 0;\n    let mut empties\
    \ = 0;\n    let mut columns = vec![0; cols];\n    for i in 0..height {\n     \
    \   for j in 0..cols {\n            if columns[j] < capacity && count[j] > 0 {\n\
    \                columns[j] += 1;\n                count[j] -= 1;\n          \
    \      fill += 1;\n            }\n        }\n        for j in 0..cols {\n    \
    \        if columns[j] > 0 {\n                fill += 1;\n                columns[j]\
    \ -= 1;\n            }\n        }\n    }\n    fill\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `12`,\n right: `6`', /tmp/tmpp5_urc5j.rs:71:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut result = 0;\n    let m = grid.len();\n    let\
    \ n = grid[0].len();\n    for i in 0..m {\n        for j in 0..n {\n         \
    \   if grid[i][j] == 1 {\n                result += 1;\n            }\n      \
    \  }\n    }\n    let mut water = Vec::new();\n    for _ in 0..m {\n        water.push(vec![0;\
    \ n]);\n    }\n    let mut q = std::collections::VecDeque::new();\n    for i in\
    \ 0..m {\n        if grid[i][0] == 1 {\n            water[i][0] = capacity;\n\
    \            q.push_back((i, 0));\n        }\n    }\n    for j in 0..n {\n   \
    \     if grid[0][j] == 1 {\n            water[0][j] = capacity;\n            q.push_back((0,\
    \ j));\n        }\n    }\n    while !q.is_empty() {\n        let (i, j) = q.pop_front().unwrap();\n\
    \        if grid[i][j] == 1 {\n            result -= 1;\n        }\n        let\
    \ water_left = water[i][j] - grid[i][j];\n        if water_left > 0 {\n      \
    \      if i > 0 && water[i-1][j] < capacity {\n                let water_new =\
    \ std::cmp::min(water_left, capacity - water[i-1][j]);\n                water[i-1][j]\
    \ += water_new;\n                q.push_back((i-1, j));\n            }\n     \
    \       if j > 0 && water[i][j-1] < capacity {\n                let water_new\
    \ = std::cmp::min(water_left, capacity - water[i][j-1]);\n                water[i][j-1]\
    \ += water_new;\n                q.push_back((i, j-1));\n            }\n     \
    \       if i < m-1 && water[i+1][j] < capacity {\n                let water_new\
    \ = std::cmp::min(water_left, capacity - water[i+1][j]);\n                water[i+\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpn3alnkxa.rs:85:3\n\
    \   |\n28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                                              - unclosed delimiter\n\
    ...\n56 |     while !q.is_empty() {\n   |                         - unclosed delimiter\n\
    ...\n62 |         if water_left > 0 {\n   |                           - unclosed\
    \ delimiter\n...\n73 |             if i < m-1 && water[i+1][j] < capacity {\n\
    \   |                                                    - this delimiter might\
    \ not be properly closed...\n...\n76 | }\n   | - ...as it matches this but it\
    \ has different indentation\n...\n85 | }\n   |   ^\n\nerror: expected expression,\
    \ found `]`\n  --> /tmp/tmpn3alnkxa.rs:76:1\n   |\n76 | }\n   | ^ expected expression\n\
    \nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpn3alnkxa.rs:75:22\n\
    \   |\n28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                                              - closing delimiter\
    \ possibly meant for this\n...\n75 |                 water[i+\n   |          \
    \            ^ unclosed delimiter\n76 | }\n   | ^ mismatched closing delimiter\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpn3alnkxa.rs:56:5\n   |\n28 | \
    \  fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n   |      \
    \                                                    ----- expected `isize` because\
    \ of return type\n...\n56 | /     while !q.is_empty() {\n57 | |         let (i,\
    \ j) = q.pop_front().unwrap();\n58 | |         if grid[i][j] == 1 {\n59 | |  \
    \           result -= 1;\n...  |\n84 | |     assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n85 | | }\n   | |__^ expected `isize`,\
    \ found `()`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut queue = VecDeque::new();\n    let mut visited\
    \ = vec![vec![false; grid[0].len()]; grid.len()];\n    let mut result = 0;\n \
    \   for i in 0..grid.len() {\n        for j in 0..grid[0].len() {\n          \
    \  if grid[i][j] == 1 {\n                queue.push_back((i, j));\n          \
    \      visited[i][j] = true;\n            }\n        }\n    }\n    while !queue.is_empty()\
    \ {\n        let size = queue.len();\n        result += 1;\n        for _ in 0..size\
    \ {\n            let (i, j) = queue.pop_front().unwrap();\n            for k in\
    \ i..i + capacity as usize {\n                if k >= grid.len() { break; }\n\
    \                for l in j..j + capacity as usize {\n                    if l\
    \ >= grid[0].len() { break; }\n                    if grid[k][l] == 1 && !visited[k][l]\
    \ {\n                        queue.push_back((k, l));\n                      \
    \  visited[k][l] = true;\n                    }\n                }\n         \
    \   }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `VecDeque`\n  -->\
    \ /tmp/tmp35a7qoaj.rs:29:21\n   |\n29 |     let mut queue = VecDeque::new();\n\
    \   |                     ^^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::VecDeque;\n   |\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut result = 0;\n    let mut row_offset = 0;\n  \
    \  for r in 0..grid.len() {\n        let mut row = grid[r].clone();\n        let\
    \ mut i = row_offset;\n        while row.iter().any(|&v| v > 0) {\n          \
    \  i = (i + 1) % row.len();\n            if row[i] > 0 {\n                row[i]\
    \ -= capacity;\n                if row[i] < 0 {\n                    row_offset\
    \ = i;\n                }\n                result += 1;\n            }\n     \
    \   }\n    }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n  \
    \  assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1,\
    \ 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0,\
    \ 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmpyou5ojzs.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut total = 0;\n    for row in grid {\n        let\
    \ mut fill = 0;\n        for c in row {\n            fill += c;\n            if\
    \ fill == capacity {\n                total += 1;\n                fill = 0;\n\
    \            }\n        }\n        if fill > 0 {\n            total += 1;\n  \
    \      }\n    }\n    total\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let rows = grid.len();\n    let cols = grid[0].len();\n\
    \    let mut drops = 0;\n    let mut row = 0;\n    loop {\n        let mut level\
    \ = 0;\n        // find max level\n        let mut col = 0;\n        while col\
    \ < cols {\n            if grid[row][col] == 1 {\n                level = col;\n\
    \            }\n            col += 1;\n        }\n        // drop all wells with\
    \ water to max level\n        col = 0;\n        while col < cols {\n         \
    \   if grid[row][col] == 1 {\n                let count = col as isize - level;\n\
    \                if count > 0 {\n                    drops += count;\n       \
    \             col = 0;\n                    row = 0;\n                    continue;\n\
    \                }\n            }\n            col += 1;\n        }\n        //\
    \ move to next row\n        row += 1;\n        if row == rows {\n            break;\n\
    \        }\n    }\n    drops\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpafq4kjxl.rs:47:44\n   |\n\
    47 |                 let count = col as isize - level;\n   |                 \
    \                           ^^^^^ expected `isize`, found `usize`\n\nerror[E0277]:\
    \ cannot subtract `usize` from `isize`\n  --> /tmp/tmpafq4kjxl.rs:47:42\n   |\n\
    47 |                 let count = col as isize - level;\n   |                 \
    \                         ^ no implementation for `isize - usize`\n   |\n   =\
    \ help: the trait `Sub<usize>` is not implemented for `isize`\n   = help: the\
    \ following other types implement trait `Sub<Rhs>`:\n             <&'a f32 as\
    \ Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n\
    \             <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n    \
    \         <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n          \
    \   <&'a isize as Sub<isize>>\n           and 48 others\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    0\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `6`', /tmp/tmp6fzj5oiv.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut buckets = vec![capacity; grid[0].len()];\n  \
    \  let mut ops = 0;\n    for row in grid {\n        for (c, w) in row.iter().zip(buckets.iter_mut())\
    \ {\n            if *c > 0 {\n                let reduction = std::cmp::min(*c,\
    \ *w);\n                *c -= reduction;\n                *w -= reduction;\n \
    \               ops += reduction;\n            }\n        }\n    }\n    ops\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0594]: cannot assign to `*c`, which is behind a `&` reference\n\
    \  --> /tmp/tmp7r7i8tkc.rs:35:17\n   |\n32 |         for (c, w) in row.iter().zip(buckets.iter_mut())\
    \ {\n   |                       ---------------------------------- this iterator\
    \ yields `&` references\n...\n35 |                 *c -= reduction;\n   |    \
    \             ^^^^^^^^^^^^^^^ `c` is a `&` reference, so the data it refers to\
    \ cannot be written\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0594`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    use std::cmp::max;\n    let row_count = grid.len();\n\
    \    let col_count = grid[0].len();\n    let mut fill_count = 0;\n    for row\
    \ in 0..row_count {\n        let mut empty_count = 0;\n        for col in 0..col_count\
    \ {\n            if grid[row][col] == 0 {\n                empty_count += 1;\n\
    \            } else {\n                let fill_count_this_row = max(1, empty_count\
    \ / capacity);\n                fill_count += fill_count_this_row;\n         \
    \       empty_count = 0;\n            }\n        }\n    }\n    fill_count\n}\n\
    \nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `6`', /tmp/tmp31uyhnwx.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max = 0;\n    for row in grid {\n        for\
    \ x in row {\n            if x > max {\n                max = x;\n           \
    \ }\n        }\n    }\n    let mut x = 0;\n    let mut left = max;\n    while\
    \ left > 0 {\n        let mut local_sum = 0;\n        for row in grid.iter() {\n\
    \            for w in row.iter() {\n                if *w > x {\n            \
    \        local_sum += 1;\n                }\n            }\n        }\n      \
    \  left -= local_sum;\n        x += 1;\n    }\n    x\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `capacity`\n  --> /tmp/tmp5fef19ld.rs:28:36\n\
    \   |\n28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                    ^^^^^^^^ help: if this is intentional,\
    \ prefix it with an underscore: `_capacity`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `grid`\n   --> /tmp/tmp5fef19ld.rs:41:20\n\
    \    |\n28  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |             ---- move occurs because `grid` has type `Vec<Vec<isize>>`,\
    \ which does not implement the `Copy` trait\n29  |     let mut max = 0;\n30  |\
    \     for row in grid {\n    |                ---- `grid` moved due to this implicit\
    \ call to `.into_iter()`\n...\n41  |         for row in grid.iter() {\n    | \
    \                   ^^^^^^^^^^^ value borrowed here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `grid`\n    = note:\
    \ borrow occurs due to deref coercion to `[Vec<isize>]`\nhelp: consider iterating\
    \ over a slice of the `Vec<Vec<isize>>`'s content to avoid moving into the `for`\
    \ loop\n    |\n30  |     for row in &grid {\n    |                +\n\nerror:\
    \ aborting due to previous error; 1 warning emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let n = grid.len();\n    let mut max_fill = 0;\n    for\
    \ row in grid {\n        let mut count = 0;\n        for &item in row {\n    \
    \        if item == 1 {\n                count += 1;\n            }\n        }\n\
    \        max_fill = max(max_fill, count);\n    }\n    max_fill * n * capacity\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpwotc4dl0.rs:38:20\n\
    \   |\n38 |         max_fill = max(max_fill, count);\n   |                   \
    \ ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::max;\n   |\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpwotc4dl0.rs:33:13\n   |\n33 |         for &item in row {\n   |     \
    \        ^^^^^    --- this expression has type `Option<isize>`\n   |         \
    \    |\n   |             expected `isize`, found reference\n   |             help:\
    \ you can probably remove the explicit borrow: `item`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwotc4dl0.rs:40:20\n   |\n40 |     max_fill * n * capacity\n   |\
    \                    ^^^^^^^^ expected `usize`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwotc4dl0.rs:40:5\n   |\n28 | fn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n   |                         \
    \                               ----- expected `isize` because of return type\n\
    ...\n40 |     max_fill * n * capacity\n   |     ^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n40 |     (max_fill * n *\
    \ capacity).try_into().unwrap()\n   |     +                       +++++++++++++++++++++\n\
    \nerror[E0277]: cannot multiply `usize` by `isize`\n  --> /tmp/tmpwotc4dl0.rs:40:18\n\
    \   |\n40 |     max_fill * n * capacity\n   |                  ^ no implementation\
    \ for `usize * isize`\n   |\n   = help: the trait `Mul<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `Mul<Rhs>`:\n\
    \             <&'a f32 as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n    \
    \         <&'a i128 as Mul<i128>>\n             <&'a i16 as Mul<i16>>\n      \
    \       <&'a i32 as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n          \
    \   <&'a i8 as Mul<i8>>\n             <&'a isize as Mul<isize>>\n           and\
    \ 49 others\n\nerror: aborting due to 5 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    // let mut t = 0;\n    // let mut w = vec![0; grid.len()];\n\
    \    // let mut carry = 0;\n    // while !grid.iter().all(|r| r.iter().all(|x|\
    \ *x == 0)) {\n    //     t += 1;\n    //     for (j, row) in grid.iter().enumerate()\
    \ {\n    //         for (i, well) in row.iter().enumerate() {\n    //        \
    \     if *well == 1 {\n    //                 grid[j][i] = 0;\n    //        \
    \         if w[j] < capacity {\n    //                     let fill = capacity\
    \ - w[j];\n    //                     w[j] += fill;\n    //                  \
    \   carry += fill;\n    //                 }\n    //             }\n    //   \
    \      }\n    //     }\n    //     for (j, row) in grid.iter().enumerate() {\n\
    \    //         for (i, well) in row.iter().enumerate() {\n    //            \
    \ if carry > 0 && *well == 0 {\n    //                 grid[j][i] = 1;\n    //\
    \                 carry -= 1;\n    //             }\n    //         }\n    //\
    \     }\n    // }\n    // t\n\n    // Another solution\n    let mut t = 0;\n \
    \   let mut w = vec![0; grid.len()];\n    let mut carry = 0;\n    while !grid.iter().all(|r|\
    \ r.iter().all(|x| *x == 0)) {\n        t += 1;\n        for (j, row) in grid.iter().enumerate()\
    \ {\n            for (i, well) in row.iter().enumerate() {\n                if\
    \ *well == 1 {\n                    grid[j][i] = 0;\n                    if w[j]\
    \ < capacity {\n                        let fill = capacity - w[j];\n        \
    \                w[j] += fill;\n                        carry += fill;\n     \
    \               }\n                }\n            }\n        }\n        for (j,\
    \ row) in grid.iter().enumerate() {\n            for (i, well) in row.iter().enumerate()\
    \ {\n                if carry >\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpt8qej_ad.rs:87:3\n\
    \   |\n28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                                              - unclosed delimiter\n\
    ...\n61 |     while !grid.iter().all(|r| r.iter().all(|x| *x == 0)) {\n   |  \
    \                                                         - unclosed delimiter\n\
    ...\n75 |         for (j, row) in grid.iter().enumerate() {\n   |            \
    \                                     - unclosed delimiter\n76 |             for\
    \ (i, well) in row.iter().enumerate() {\n   |                                \
    \                     - this delimiter might not be properly closed...\n77 | \
    \                if carry >\n78 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n87 | }\n   |   ^\n\nerror: expected expression, found `}`\n\
    \  --> /tmp/tmpt8qej_ad.rs:78:1\n   |\n78 | }\n   | ^ expected expression\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpt8qej_ad.rs:61:5\n   |\n28 |   fn\
    \ max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n   |          \
    \                                                ----- expected `isize` because\
    \ of return type\n...\n61 | /     while !grid.iter().all(|r| r.iter().all(|x|\
    \ *x == 0)) {\n62 | |         t += 1;\n63 | |         for (j, row) in grid.iter().enumerate()\
    \ {\n64 | |             for (i, well) in row.iter().enumerate() {\n...  |\n86\
    \ | |     assert_eq!(candidate(vec![vec![1, 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n\
    87 | | }\n   | |__^ expected `isize`, found `()`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let (m, n) = (grid.len(), grid[0].len());\n    let mut\
    \ max_water = 0;\n    for i in 0..m {\n        let mut water = 0;\n        for\
    \ j in 0..n {\n            water += grid[i][j];\n            if water > capacity\
    \ {\n                max_water += water - capacity;\n                water = capacity;\n\
    \            }\n        }\n    }\n    max_water\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmpjt469_cs.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut time = 0;\n    // find the water level\n    let\
    \ water_level = grid.iter().map(|w| w.iter().sum::<isize>()).max().unwrap();\n\
    \    let mut bucket = 0;\n    // lower buckets and pour into the first well until\
    \ all wells are empty\n    for mut wells in grid.iter_mut() {\n        // if water-level\
    \ is zero, return\n        if water_level == 0 {\n            return time;\n \
    \       }\n        // lower the bucket until full\n        while bucket < capacity\
    \ {\n            // if the water-level is zero, break\n            if water_level\
    \ == 0 {\n                break;\n            }\n            // pour a single\
    \ unit of water from the well and increment the time\n            bucket += wells[0];\n\
    \            wells[0] = 0;\n            time += 1;\n        }\n        // move\
    \ the bucket to the left\n        for i in 1..wells.len() {\n            wells[i\
    \ - 1] = wells[i];\n        }\n        wells[wells.len() - 1] = bucket;\n    \
    \    bucket = 0;\n    }\n    time\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpkuxpsvli.rs:34:9\n\
    \   |\n34 |     for mut wells in grid.iter_mut() {\n   |         ----^^^^^\n \
    \  |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0596]: cannot borrow `grid` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmpkuxpsvli.rs:34:22\n   |\n28 | fn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n   |             ---- help: consider\
    \ changing this to be mutable: `mut grid`\n...\n34 |     for mut wells in grid.iter_mut()\
    \ {\n   |                      ^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0502]:\
    \ cannot borrow `*wells` as immutable because it is also borrowed as mutable\n\
    \  --> /tmp/tmpkuxpsvli.rs:54:15\n   |\n54 |         wells[wells.len() - 1] =\
    \ bucket;\n   |         ------^^^^^^^^^^^-----\n   |         |     |\n   |   \
    \      |     immutable borrow occurs here\n   |         mutable borrow occurs\
    \ here\n   |         mutable borrow later used here\n   |\nhelp: try adding a\
    \ local storing this...\n  --> /tmp/tmpkuxpsvli.rs:54:15\n   |\n54 |         wells[wells.len()\
    \ - 1] = bucket;\n   |               ^^^^^^^^^^^\nhelp: ...and then using that\
    \ local here\n  --> /tmp/tmpkuxpsvli.rs:54:9\n   |\n54 |         wells[wells.len()\
    \ - 1] = bucket;\n   |         ^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to\
    \ 2 previous errors; 1 warning emitted\n\nSome errors have detailed explanations:\
    \ E0502, E0596.\nFor more information about an error, try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut heights = vec![capacity; grid[0].len()];\n  \
    \  let mut result = 0;\n    for row in grid {\n        for (j, height) in row.iter().enumerate()\
    \ {\n            if *height == 1 {\n                heights[j] -= 1;\n       \
    \     }\n        }\n        for height in heights.iter() {\n            if *height\
    \ == 0 {\n                result += 1;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `6`', /tmp/tmp7pe8qev7.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut result = 0;\n    let\
    \ width = grid[0].len();\n    let mut fill = vec![capacity; width];\n    for row\
    \ in grid.iter_mut() {\n        for (col, cell) in row.iter_mut().enumerate()\
    \ {\n            if fill[col] == 0 {\n                result += 1;\n         \
    \       fill[col] = capacity;\n            }\n            fill[col] -= *cell;\n\
    \            *cell = 0;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `6`', /tmp/tmpe9oqxl2q.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let height = grid.len();\n    let width = grid[0].len();\n\
    \    let mut total = 0;\n    for y in 0..height {\n        total += grid[y].iter().sum::<isize>();\n\
    \    }\n    let mut empties = 0;\n    while empties < total {\n        let mut\
    \ clumps = 0;\n        let mut deltas = vec![];\n        for y in 0..height {\n\
    \            let mut count = 0;\n            for x in 0..width {\n           \
    \     if grid[y][x] > 0 {\n                    count += 1;\n                }\n\
    \            }\n            if count > 0 {\n                clumps += 1;\n   \
    \             deltas.push(count);\n            }\n        }\n        empties +=\
    \ clumps;\n        for d in deltas {\n            empties += (d / capacity) as\
    \ usize;\n        }\n        for y in 0..height {\n            for x in 0..width\
    \ {\n                if grid[y][x] > 0 {\n                    grid[y][x] -= capacity;\n\
    \                    if grid[y][x] < 0 {\n                        grid[y][x] =\
    \ 0;\n                    }\n                }\n            }\n        }\n   \
    \ }\n    empties\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2szqjmka.rs:53:24\n   |\n\
    53 |             empties += (d / capacity) as usize;\n   |                   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\nerror[E0277]:\
    \ cannot add-assign `usize` to `isize`\n  --> /tmp/tmp2szqjmka.rs:53:21\n   |\n\
    53 |             empties += (d / capacity) as usize;\n   |                   \
    \  ^^ no implementation for `isize += usize`\n   |\n   = help: the trait `AddAssign<usize>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n           \
    \  <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64\
    \ as AddAssign>\n             <i128 as AddAssign<&i128>>\n             <i128 as\
    \ AddAssign>\n             <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n\
    \           and 20 others\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut ans = 0;\n    while\
    \ !grid.iter().all(|row| row.iter().all(|&x| x == 0)) {\n        ans += grid.iter().filter(|row|\
    \ row.iter().any(|&x| x > 0)).count();\n        for row in &mut grid {\n     \
    \       for x in row {\n                *x = (*x - capacity).max(0);\n       \
    \     }\n        }\n    }\n    ans\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfvbkx32p.rs:39:5\n   |\n\
    28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n   |    \
    \                                                    ----- expected `isize` because\
    \ of return type\n...\n39 |     ans\n   |     ^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n39 |     ans.try_into().unwrap()\n   |        ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let n = grid.len();\n    let m = grid[0].len();\n   \
    \ let mut max_w = 0;\n    for i in 0..n {\n        let mut max_h = 0;\n      \
    \  for j in 0..m {\n            if grid[i][j] == 1 {\n                max_h +=\
    \ 1;\n            }\n        }\n        max_w = std::cmp::max(max_w, max_h);\n\
    \    }\n    // this is not needed, but to make it more clear\n    if max_w ==\
    \ 0 {\n        return 0;\n    }\n    let mut lo = 0;\n    let mut hi = max_w;\n\
    \    while lo < hi {\n        let mid = lo + (hi - lo) / 2;\n        let mut count\
    \ = 0;\n        for i in 0..n {\n            let mut j = 0;\n            while\
    \ j < m {\n                if grid[i][j] == 1 {\n                    let mut tmp\
    \ = mid;\n                    while j < m && grid[i][j] == 1 && tmp > 0 {\n  \
    \                      tmp -= 1;\n                        j += 1;\n          \
    \          }\n                    count += 1;\n                } else {\n    \
    \                j += 1;\n                }\n            }\n        }\n      \
    \  if count <= capacity {\n            hi = mid;\n        } else {\n         \
    \   lo = mid + 1;\n        }\n    }\n    lo\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpzzs63xkh.rs:76:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    // https://leetcode.com/problems/water-buckets/discuss/444447/Java-BFS-solution\n\
    \    let m = grid.len();\n    let n = grid[0].len();\n    let mut queue = VecDeque::new();\n\
    \    let mut visited = HashSet::new();\n    queue.push_back((0, 0, 0));\n    visited.insert((0,\
    \ 0, 0));\n    let mut ans = 0;\n    while !queue.is_empty() {\n        let mut\
    \ size = queue.len();\n        while size > 0 {\n            size -= 1;\n    \
    \        let (i, j, left) = queue.pop_front().unwrap();\n            if i == m\
    \ - 1 && j == n - 1 {\n                return ans;\n            }\n          \
    \  for (ni, nj) in vec![(i + 1, j), (i, j + 1)] {\n                if ni < m &&\
    \ nj < n {\n                    let new_left = left;\n                    let\
    \ water = grid[ni][nj];\n                    if new_left + water <= capacity {\n\
    \                        if !visited.contains(&(ni, nj, new_left + water)) {\n\
    \                            queue.push_back((ni, nj, new_left + water));\n  \
    \                          visited.insert((ni, nj, new_left + water));\n     \
    \                   }\n                    }\n                    let new_left\
    \ = left + water - capacity;\n                    if new_left > 0 {\n        \
    \                if !visited.contains(&(ni, nj, new_left)) {\n               \
    \             queue.push_back((ni, nj, new_left));\n                         \
    \   visited.insert((ni, nj, new_left));\n                        }\n         \
    \           }\n                }\n            }\n        }\n        ans += 1;\n\
    \    }\n    0\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `VecDeque`\n  -->\
    \ /tmp/tmp4vssig6s.rs:32:21\n   |\n32 |     let mut queue = VecDeque::new();\n\
    \   |                     ^^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::VecDeque;\n   |\n\n\
    error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp4vssig6s.rs:33:23\n\
    \   |\n33 |     let mut visited = HashSet::new();\n   |                      \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut water = 0;\n    let max_height = grid.iter().fold(0,\
    \ |acc, e| cmp::max(acc, e.iter().sum()));\n    let mut level = (max_height +\
    \ capacity - 1) / capacity;\n    while level > 0 {\n        let height = level\
    \ * capacity;\n        let mut filled = 0;\n        for row in grid.iter() {\n\
    \            let mut lowest = height;\n            for &cell in row.iter() {\n\
    \                lowest = cmp::min(lowest, height - cell);\n            }\n  \
    \          filled += lowest;\n        }\n        water += filled;\n        level\
    \ -= 1;\n    }\n    water\n}\n\nfn main() {\n    let candidate = max_fill;\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1,\
    \ 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0,\
    \ 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpnltsoj2t.rs:30:51\n   |\n30 |     let max_height = grid.iter().fold(0,\
    \ |acc, e| cmp::max(acc, e.iter().sum()));\n   |                             \
    \                      ^^^ use of undeclared crate or module `cmp`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `cmp`\n  --> /tmp/tmpnltsoj2t.rs:38:26\n\
    \   |\n38 |                 lowest = cmp::min(lowest, height - cell);\n   |  \
    \                        ^^^ use of undeclared crate or module `cmp`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut water = 0;\n    for wells in grid {\n       \
    \ for well in wells {\n            if well != 0 {\n                let partial\
    \ = well / capacity;\n                if well % capacity == 0 {\n            \
    \        water += partial;\n                } else {\n                    water\
    \ += partial + 1;\n                }\n            }\n        }\n    }\n    water\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmpjn8h6tra.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let (m, n) = (grid.len(), grid[0].len());\n    let mut\
    \ fill = 0;\n    // fill each row until each well has reached the capacity, or\
    \ until all \n    // wells are full.\n    while grid.iter().any(|row| row.iter().any(|&water|\
    \ water < capacity)) {\n        for row in &grid {\n            fill += capacity\
    \ - row.iter().min().unwrap();\n        }\n        fill += 1;\n    }\n    fill\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut water = 0;\n    let rows = grid.len();\n    for\
    \ row in grid {\n        for well in row {\n            water += well / capacity;\n\
    \            if well % capacity != 0 {\n                water += 1;\n        \
    \    }\n        }\n    }\n    water * rows\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt_2dx1ps.rs:39:13\n   |\n\
    39 |     water * rows\n   |             ^^^^ expected `isize`, found `usize`\n\
    \nerror[E0277]: cannot multiply `isize` by `usize`\n  --> /tmp/tmpt_2dx1ps.rs:39:11\n\
    \   |\n39 |     water * rows\n   |           ^ no implementation for `isize *\
    \ usize`\n   |\n   = help: the trait `Mul<usize>` is not implemented for `isize`\n\
    \   = help: the following other types implement trait `Mul<Rhs>`:\n          \
    \   <&'a f32 as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n             <&'a\
    \ i128 as Mul<i128>>\n             <&'a i16 as Mul<i16>>\n             <&'a i32\
    \ as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n\
    \             <&'a isize as Mul<isize>>\n           and 49 others\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut count = 0;\n    let rows = grid.len();\n    let\
    \ cols = grid[0].len();\n    let mut y = 0;\n    while y < rows {\n        let\
    \ mut x = 0;\n        while x < cols {\n            if grid[y][x] == 1 {\n   \
    \             count += 1;\n                let mut water = capacity;\n       \
    \         while water > 0 && x < cols {\n                    water -= grid[y][x];\n\
    \                    grid[y][x] = 0;\n                    x += 1;\n          \
    \      }\n            }\n            x += 1;\n        }\n        y += 1;\n   \
    \ }\n    count\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `grid` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp9xccs3vb.rs:41:21\n   |\n28 | fn max_fill(grid: Vec<Vec<isize>>,\
    \ capacity: isize) -> isize {\n   |             ---- help: consider changing this\
    \ to be mutable: `mut grid`\n...\n41 |                     grid[y][x] = 0;\n \
    \  |                     ^^^^ cannot borrow as mutable\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let (mut i, mut j) = (0, 0);\n\
    \    let (mut ret, mut step) = (0, 0);\n    loop {\n        // water remaining\n\
    \        let wr = capacity - j;\n        // fill next column\n        while i\
    \ < grid.len() && grid[i][0] == 0 {\n            i += 1;\n        }\n        if\
    \ i >= grid.len() {\n            return ret;\n        }\n        let h = grid[i][0];\n\
    \        // remaining capacity in this column\n        let rc = if wr > h { wr\
    \ - h } else { 0 };\n        // determine the number of units of water left in\
    \ this well\n        let mut d = h - j;\n        if rc > 0 {\n            d =\
    \ std::cmp::min(d, rc);\n        }\n        if d > 0 {\n            step += 1;\n\
    \            ret += d;\n            // reduce d from all wells in this column\n\
    \            for row in &mut grid {\n                row[0] -= d;\n          \
    \  }\n        }\n        // move right\n        j = rc;\n        if j == 0 {\n\
    \            // fill remaining capacity\n            j = capacity;\n         \
    \   step += 1;\n        }\n        // shift columns\n        for row in &mut grid\
    \ {\n            row.rotate_left(1);\n        }\n    }\n}\n\nfn main() {\n   \
    \ let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmp96__3k2t.rs:74:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut total_water = 0;\n    let mut well_fill = 0;\n\
    \    for row in grid {\n        let mut this_well_fill = 0;\n        for depth\
    \ in row {\n            if depth > 0 {\n                this_well_fill += 1;\n\
    \            }\n        }\n        total_water += this_well_fill;\n        well_fill\
    \ = well_fill.max(this_well_fill);\n    }\n    if well_fill > capacity {\n   \
    \     total_water - (well_fill - capacity) * grid.len() as isize\n    } else {\n\
    \        total_water\n    }\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `grid`\n   --> /tmp/tmplgntqur4.rs:42:48\n\
    \    |\n28  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |             ---- move occurs because `grid` has type `Vec<Vec<isize>>`,\
    \ which does not implement the `Copy` trait\n...\n31  |     for row in grid {\n\
    \    |                ---- `grid` moved due to this implicit call to `.into_iter()`\n\
    ...\n42  |         total_water - (well_fill - capacity) * grid.len() as isize\n\
    \    |                                                ^^^^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `grid`\nhelp: consider iterating over a slice of the `Vec<Vec<isize>>`'s\
    \ content to avoid moving into the `for` loop\n    |\n31  |     for row in &grid\
    \ {\n    |                +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    // Since the capacity of bucket is the same, we just\
    \ need to get the maximum\n    // height of the wells.\n    // e.g.\n    // [[0,0,1,0],\n\
    \    //  [0,1,0,0],\n    //  [1,1,1,1]]\n    // The maximum height is 2, we can\
    \ set the capacity of bucket to 2,\n    // and then we can fill the water row\
    \ by row.\n    let height = grid.iter().map(|r| r.iter().max().unwrap()).max().unwrap();\n\
    \    let mut sum = 0;\n    let max_height = capacity.min(*height);\n    for row\
    \ in grid {\n        let row_max = row.iter().max().unwrap();\n        if row_max\
    \ > &max_height {\n            // we can not fill the row without exceeding the\
    \ capacity\n            // so we need to lower the bucket\n            sum +=\
    \ 1;\n        }\n    }\n    sum\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `6`', /tmp/tmpq55n2dwu.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let m = grid.len();\n    let n = grid[0].len();\n   \
    \ let mut count = 0;\n    for i in 0..m {\n        let mut remaining = capacity;\n\
    \        for j in 0..n {\n            if grid[i][j] == 1 {\n                if\
    \ remaining > 0 {\n                    remaining -= 1;\n                } else\
    \ {\n                    count += 1;\n                    remaining = capacity\
    \ - 1;\n                }\n            }\n        }\n    }\n    count\n}\n\nfn\
    \ main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmpkqge0sld.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    use std::cmp::{max, min};\n    let nrows = grid.len();\n\
    \    let ncols = grid[0].len();\n    let mut buckets = 0;\n    let mut levels\
    \ = vec![0; ncols];\n    for row in &grid {\n        for (j, level) in row.iter().enumerate()\
    \ {\n            levels[j] = max(levels[j], *level);\n        }\n        for (j,\
    \ level) in row.iter().enumerate() {\n            if *level > 0 {\n          \
    \      let bucket = min(capacity, levels[j]);\n                buckets += bucket;\n\
    \                levels[j] -= bucket;\n            }\n        }\n    }\n    buckets\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmpxmw7c59i.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let n = grid.len();\n    let m = grid[0].len();\n   \
    \ let mut work = vec![vec![0; m]; n];\n    let mut max_fill = 0;\n    for row\
    \ in 0..n {\n        for col in 0..m {\n            if grid[row][col] == 1 {\n\
    \                let mut fill = 1;\n                let mut queue = vec![(row,\
    \ col)];\n                work[row][col] = 1;\n                while let Some((row,\
    \ col)) = queue.pop() {\n                    for &(dr, dc) in &[(0, -1), (0, 1),\
    \ (-1, 0), (1, 0)] {\n                        let (row, col) = (row + dr, col\
    \ + dc);\n                        if 0 <= row && row < n && 0 <= col && col <\
    \ m && grid[row][col] == 1 && work[row][col] == 0 {\n                        \
    \    work[row][col] = 1;\n                            fill += 1;\n           \
    \                 queue.push((row, col));\n                        }\n       \
    \             }\n                }\n                max_fill = std::cmp::max(max_fill,\
    \ fill);\n            }\n        }\n    }\n    max_fill / capacity\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp67neh62j.rs:40:58\n\
    \   |\n40 |                     for &(dr, dc) in &[(0, -1), (0, 1), (-1, 0), (1,\
    \ 0)] {\n   |                                                          ^^ the\
    \ trait `Neg` is not implemented for `usize`\n   |\n   = help: the following other\
    \ types implement trait `Neg`:\n             &f32\n             &f64\n       \
    \      &i128\n             &i16\n             &i32\n             &i64\n      \
    \       &i8\n             &isize\n           and 8 others\n\nerror[E0277]: the\
    \ trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp67neh62j.rs:40:44\n\
    \   |\n40 |                     for &(dr, dc) in &[(0, -1), (0, 1), (-1, 0), (1,\
    \ 0)] {\n   |                                            ^^ the trait `Neg` is\
    \ not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut count = 0;\n    let mut col_max = vec![0; grid[0].len()];\n\
    \    for row in grid {\n        for (i, &e) in row.iter().enumerate() {\n    \
    \        if e == 1 {\n                col_max[i] += 1;\n            }\n      \
    \  }\n    }\n    for &i in col_max.iter() {\n        let n = (i + capacity - 1)\
    \ / capacity;\n        count += n;\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `5`', /tmp/tmpm80tumdz.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut fill = 0;\n    for row in grid {\n        fill\
    \ += row.iter().filter(|&x| *x > 0).map(|x| x / capacity).sum::<isize>();\n  \
    \      fill += row.iter().filter(|&x| *x > 0).map(|x| x % capacity).max().unwrap_or(0);\n\
    \    }\n    fill\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmptxih942d.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    if grid.is_empty() || grid[0].is_empty() {\n        return\
    \ 0;\n    }\n    let mut water_count = 0;\n    let height = grid.len();\n    let\
    \ width = grid[0].len();\n    let mut buckets = vec![capacity; width];\n    for\
    \ r in 0..height {\n        for c in 0..width {\n            water_count += grid[r][c];\n\
    \            buckets[c] -= grid[r][c];\n        }\n        for c in 0..width {\n\
    \            if buckets[c] > 0 {\n                let mut left = c - 1;\n    \
    \            let mut right = c + 1;\n                while left >= 0 && right\
    \ < width {\n                    if buckets[left] > 0 && buckets[right] > 0 {\n\
    \                        buckets[left] -= 1;\n                        buckets[right]\
    \ -= 1;\n                        water_count -= 1;\n                    }\n  \
    \                  left -= 1;\n                    right += 1;\n             \
    \   }\n            }\n        }\n    }\n    water_count\n}\n\nfn main() {\n  \
    \  let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpm00ir4r6.rs:43:32\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max = 0;\n    for row in grid {\n        for\
    \ cell in row {\n            if cell > max {\n                max = cell;\n  \
    \          }\n        }\n    }\n    let mut ans = 0;\n    for _i in 0..max {\n\
    \        let mut filled = 0;\n        for row in grid {\n            for cell\
    \ in row {\n                if cell >= 1 {\n                    filled += 1;\n\
    \                    if cell >= capacity {\n                        ans += 1;\n\
    \                    }\n                }\n            }\n        }\n        if\
    \ filled == 0 {\n            break;\n        }\n    }\n    ans\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `grid`\n   --> /tmp/tmpdxezgbku.rs:40:20\n\
    \    |\n28  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |             ---- move occurs because `grid` has type `Vec<Vec<isize>>`,\
    \ which does not implement the `Copy` trait\n29  |     let mut max = 0;\n30  |\
    \     for row in grid {\n    |                ---- `grid` moved due to this implicit\
    \ call to `.into_iter()`\n...\n40  |         for row in grid {\n    |        \
    \            ^^^^ value used here after move\n    |\nnote: this function takes\
    \ ownership of the receiver `self`, which moves `grid`\nhelp: consider iterating\
    \ over a slice of the `Vec<Vec<isize>>`'s content to avoid moving into the `for`\
    \ loop\n    |\n30  |     for row in &grid {\n    |                +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let rows = grid.len();\n    let mut cols = 0;\n    let\
    \ mut res = 0;\n    if rows > 0 {\n        cols = grid[0].len();\n        let\
    \ mut sum_cols = vec![0; cols];\n        for row in grid {\n            let mut\
    \ sum_row = 0;\n            for (c, &col) in row.iter().enumerate() {\n      \
    \          sum_row += col;\n                sum_cols[c] += col;\n            }\n\
    \            res += sum_row / capacity;\n            if sum_row % capacity > 0\
    \ {\n                res += 1;\n            }\n        }\n        for col in sum_cols\
    \ {\n            res += col / capacity;\n            if col % capacity > 0 {\n\
    \                res += 1;\n            }\n        }\n    }\n    res\n}\n\nfn\
    \ main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `12`,\n right: `6`', /tmp/tmpmpyq2m6s.rs:58:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let n = grid.len();\n    let m = grid[0].len();\n   \
    \ let mut dp = vec![vec![0isize; m]; n];\n    for i in 0..n {\n        for j in\
    \ 0..m {\n            dp[i][j] = (if i > 0 { dp[i - 1][j] } else { 0 }) + grid[i][j];\n\
    \        }\n    }\n    let mut maxes = vec![];\n    for i in 0..n {\n        let\
    \ max = dp[i].iter().cloned().max().unwrap();\n        maxes.push(max);\n    }\n\
    \    let mut count = 0;\n    let mut depth = 0;\n    while maxes.iter().any(|&x|\
    \ x > depth) {\n        count += maxes.iter().filter(|&&x| x > depth).count();\n\
    \        depth += capacity;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkuqjhrv8.rs:48:5\n   |\n\
    28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n   |    \
    \                                                    ----- expected `isize` because\
    \ of return type\n...\n48 |     count\n   |     ^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n48 |     count.try_into().unwrap()\n   |\
    \          ++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut result = 0;\n    loop\
    \ {\n        let mut minimum = ::std::isize::MAX;\n        for row in &grid {\n\
    \            if let Some(min) = row.iter().max() {\n                if *min >\
    \ 0 && *min < minimum {\n                    minimum = *min;\n               \
    \ }\n            }\n        }\n        if minimum == ::std::isize::MAX {\n   \
    \         break;\n        }\n        for row in &mut grid {\n            for slot\
    \ in row {\n                if *slot > 0 {\n                    *slot -= minimum;\n\
    \                }\n            }\n        }\n        result += minimum;\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmpitbyube1.rs:57:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_depth = 0;\n    for w in grid {\n       \
    \ let mut depth = 0;\n        for &x in &w {\n            if x == 1 {\n      \
    \          depth += 1;\n            } else {\n                break;\n       \
    \     }\n        }\n        max_depth = max_depth.max(depth);\n    }\n    let\
    \ mut result = 0;\n    for _ in 0..max_depth {\n        result += 1;\n       \
    \ for w in &mut grid {\n            for x in w {\n                if *x > 0 {\n\
    \                    *x -= 1;\n                }\n            }\n        }\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `capacity`\n  --> /tmp/tmpa2925_b8.rs:28:36\n\
    \   |\n28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                    ^^^^^^^^ help: if this is intentional,\
    \ prefix it with an underscore: `_capacity`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0596]: cannot borrow `grid` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmpa2925_b8.rs:44:18\n   |\n28 | fn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n   |             ---- help: consider\
    \ changing this to be mutable: `mut grid`\n...\n44 |         for w in &mut grid\
    \ {\n   |                  ^^^^^^^^^ cannot borrow as mutable\n\nerror[E0382]:\
    \ borrow of moved value: `grid`\n   --> /tmp/tmpa2925_b8.rs:44:18\n    |\n28 \
    \ | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n    |    \
    \         ---- move occurs because `grid` has type `Vec<Vec<isize>>`, which does\
    \ not implement the `Copy` trait\n29  |     let mut max_depth = 0;\n30  |    \
    \ for w in grid {\n    |              ---- `grid` moved due to this implicit call\
    \ to `.into_iter()`\n...\n44  |         for w in &mut grid {\n    |          \
    \        ^^^^^^^^^ value borrowed here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `grid`\nhelp: consider iterating\
    \ over a slice of the `Vec<Vec<isize>>`'s content to avoid moving into the `for`\
    \ loop\n    |\n30  |     for w in &grid {\n    |              +\n\nerror: aborting\
    \ due to 2 previous errors; 1 warning emitted\n\nSome errors have detailed explanations:\
    \ E0382, E0596.\nFor more information about an error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let (rows, cols) = (grid.len(), grid[0].len());\n   \
    \ let mut res = 0;\n    for i in 0..rows {\n        for j in 0..cols {\n     \
    \       let k = grid[i][j];\n            if k == 0 { continue; }\n           \
    \ if k > capacity {\n                return -1;\n            }\n            if\
    \ k >= capacity || j == cols - 1 {\n                res += 1;\n            } else\
    \ {\n                let k1 = grid[i][j + 1];\n                if k1 == 0 {\n\
    \                    res += 1;\n                } else if k + k1 > capacity {\n\
    \                    res += 1;\n                }\n            }\n        }\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmprghgznj2.rs:56:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  for &fill in row {\n            max_fill = isize::max(max_fill, fill);\n  \
    \      }\n    }\n    let mut fill = 0;\n    let mut n_fillings = 0;\n    while\
    \ fill < max_fill {\n        fill += capacity;\n        n_fillings += 1;\n   \
    \ }\n    n_fillings\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptdsfi5e_.rs:31:13\n   |\n\
    31 |         for &fill in row {\n   |             ^^^^^    --- this expression\
    \ has type `Option<isize>`\n   |             |\n   |             expected `isize`,\
    \ found reference\n   |             help: you can probably remove the explicit\
    \ borrow: `fill`\n   |\n   = note:   expected type `isize`\n           found reference\
    \ `&_`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let m = grid.len();\n    let n = grid[0].len();\n   \
    \ let mut cnt = 0;\n    let mut height = vec![0; n];\n    for row in &grid {\n\
    \        for j in 0..n {\n            if row[j] == 1 {\n                height[j]\
    \ += 1;\n            } else {\n                height[j] = 0;\n            }\n\
    \        }\n        let need = max_fill_col(&height, capacity);\n        cnt +=\
    \ need;\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n   \
    \ assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1,\
    \ 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0,\
    \ 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max_fill_col` in this scope\n  -->\
    \ /tmp/tmprbdugq2g.rs:41:20\n   |\n41 |         let need = max_fill_col(&height,\
    \ capacity);\n   |                    ^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut result = 0;\n    for row in grid {\n        let\
    \ mut fill = 0;\n        for value in row {\n            if value == 1 {\n   \
    \             fill += 1;\n            } else if fill > 0 {\n                let\
    \ deficit = capacity - fill;\n                fill = if deficit < 0 {\n      \
    \              deficit\n                } else {\n                    0\n    \
    \            };\n            }\n        }\n        result += (fill + capacity\
    \ - 1) / capacity;\n    }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpisx7_408.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    // height of water in each well\n    let mut grid = grid;\n\
    \    let rows = grid.len();\n    let cols = grid[0].len();\n    let mut max_height\
    \ = 0;\n    for row in grid.iter_mut() {\n        for cell in row.iter_mut() {\n\
    \            max_height = max_height.max(*cell);\n        }\n    }\n    // fill\
    \ up the wells\n    let mut steps = 0;\n    for h in 0..max_height {\n       \
    \ for r in 0..rows {\n            for c in 0..cols {\n                if grid[r][c]\
    \ > 0 {\n                    steps += 1;\n                    grid[r][c] -= capacity;\n\
    \                }\n            }\n        }\n    }\n    steps\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmpum1afs37.rs:57:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut result = 0;\n    for row in &grid {\n       \
    \ let mut count = 0;\n        for &c in row {\n            if c == 1 {\n     \
    \           count += 1;\n            } else if count > 0 {\n                result\
    \ += (count + capacity - 1) / capacity;\n                count = 0;\n        \
    \    }\n        }\n        if count > 0 {\n            result += (count + capacity\
    \ - 1) / capacity;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut total = 0;\n    let mut last_row = None;\n  \
    \  for row in grid {\n        total += max_fill_row(row, capacity, last_row);\n\
    \        last_row = Some(row);\n    }\n    total\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max_fill_row` in this scope\n  -->\
    \ /tmp/tmpvbol1hxe.rs:32:18\n   |\n32 |         total += max_fill_row(row, capacity,\
    \ last_row);\n   |                  ^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let (height, width) = (grid.len(), grid[0].len());\n\
    \    let mut water_level = 0;\n    let mut turn = 0;\n    let mut need_to_fill\
    \ = vec![];\n    let mut priority_queue = BinaryHeap::new();\n    for row in grid\
    \ {\n        for &value in row.iter() {\n            if value == 1 {\n       \
    \         need_to_fill.push(1);\n            } else {\n                need_to_fill.push(0);\n\
    \            }\n        }\n    }\n    for i in 0..height {\n        for j in 0..width\
    \ {\n            priority_queue.push(Reverse((-grid[i][j], (i, j))));\n      \
    \  }\n    }\n    while need_to_fill.iter().sum::<isize>() > 0 {\n        let Reverse((_,\
    \ (i, j))) = priority_queue.pop().unwrap();\n        let mut water_to_add = capacity\
    \ - grid[i][j];\n        if water_to_add > 0 {\n            water_level += water_to_add;\n\
    \            grid[i][j] += water_to_add;\n            turn += 1;\n           \
    \ if i > 0 {\n                if need_to_fill[(i - 1) * width + j] > 0 {\n   \
    \                 priority_queue.push(Reverse((-grid[i - 1][j], (i - 1, j))));\n\
    \                }\n            }\n            if i < height - 1 {\n         \
    \       if need_to_fill[(i + 1) * width + j] > 0 {\n                    priority_queue.push(Reverse((-grid[i\
    \ + 1][j], (i + 1, j))));\n                }\n            }\n            if j\
    \ > 0 {\n                if need_to_fill[i * width + j - 1] > 0 {\n          \
    \          priority_queue.push(Reverse((-grid[i][j - 1], (i, j - 1))));\n    \
    \            }\n            }\n            if j < width - 1 {\n              \
    \  if need_to_fill[i * width + j + 1] > 0 {\n                    priority_queue.push(\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp2cl40p94.rs:82:3\n\
    \   |\n28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                                              - unclosed delimiter\n\
    ...\n48 |     while need_to_fill.iter().sum::<isize>() > 0 {\n   |           \
    \                                       - unclosed delimiter\n...\n51 |      \
    \   if water_to_add > 0 {\n   |                             - unclosed delimiter\n\
    ...\n70 |             if j < width - 1 {\n   |                              -\
    \ unclosed delimiter\n71 |                 if need_to_fill[i * width + j + 1]\
    \ > 0 {\n   |                                                        - this delimiter\
    \ might not be properly closed...\n72 |                     priority_queue.push(\n\
    73 | }\n   | - ...as it matches this but it has different indentation\n...\n82\
    \ | }\n   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp2cl40p94.rs:72:40\n\
    \   |\n28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                                              - closing delimiter\
    \ possibly meant for this\n...\n72 |                     priority_queue.push(\n\
    \   |                                        ^ unclosed delimiter\n73 | }\n  \
    \ | ^ mismatched closing delimiter\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `BinaryHeap`\n  --> /tmp/tmp2cl40p94.rs:33:30\n   |\n33 |  \
    \   let mut priority_queue = BinaryHeap::new();\n   |                        \
    \      ^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::BinaryHeap;\n   |\n\nerror[E0425]:\
    \ cannot find function, tuple struct or tuple variant `Reverse` in this scope\n\
    \  --> /tmp/tmp2cl40p94.rs:45:33\n   |\n45 |             priority_queue.push(Reverse((-grid[i][j],\
    \ (i, j))));\n   |                                 ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n\
    \   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in\
    \ this scope\n  --> /tmp/"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_well = grid.iter().map(|well| well.iter().sum::<isize>()).max().unwrap();\n\
    \    let mut max_water = max_well;\n    let row_len = grid[0].len();\n    let\
    \ mut water_grid = grid.clone();\n    let mut n_rounds = 0;\n    while max_water\
    \ > 0 {\n        let n_full_rows = max_water / row_len;\n        n_rounds += n_full_rows;\n\
    \        for r in 0..n_full_rows {\n            for c in 0..row_len {\n      \
    \          water_grid[r][c] -= 1;\n            }\n        }\n        let left_over\
    \ = max_water % row_len;\n        for c in 0..left_over {\n            water_grid[n_full_rows][c]\
    \ -= 1;\n        }\n        max_water = water_grid.iter().map(|well| well.iter().sum::<isize>()).max().unwrap();\n\
    \        if max_water == max_well {\n            break;\n        }\n    }\n  \
    \  n_rounds\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbuls7ieq.rs:35:39\n   |\n\
    35 |         let n_full_rows = max_water / row_len;\n   |                    \
    \                   ^^^^^^^ expected `isize`, found `usize`\n\nerror[E0277]: cannot\
    \ divide `isize` by `usize`\n  --> /tmp/tmpbuls7ieq.rs:35:37\n   |\n35 |     \
    \    let n_full_rows = max_water / row_len;\n   |                            \
    \         ^ no implementation for `isize / usize`\n   |\n   = help: the trait\
    \ `Div<usize>` is not implemented for `isize`\n   = help: the following other\
    \ types implement trait `Div<Rhs>`:\n             <&'a f32 as Div<f32>>\n    \
    \         <&'a f64 as Div<f64>>\n             <&'a i128 as Div<i128>>\n      \
    \       <&'a i16 as Div<i16>>\n             <&'a i32 as Div<i32>>\n          \
    \   <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n             <&'a\
    \ isize as Div<isize>>\n           and 54 others\n\nerror[E0277]: the type `[Vec<isize>]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpbuls7ieq.rs:39:17\n   |\n39 |  \
    \               water_grid[r][c] -= 1;\n   |                 ^^^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[Vec<isize>]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<Vec<isize>>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbuls7ieq.rs:42:37\n   |\n42 |         let left_over\
    \ = max_water % row_len;\n   |                                     ^^^^^^^ expected\
    \ `isize`, found `usize`\n\nerror[E0277]: cannot mod `isize` by `usize`\n  -->\
    \ /tmp/tmpbuls7ieq.rs:42:35\n   |\n42 |         let left_over = max_water % row_len;\n\
    \   |                                   ^ no implementation for `isize % usize`\n\
    \   |\n   = help: the trait `Rem<usize>` is not implemented for `isize`\n   =\
    \ help: the following other types implement trait `Rem<Rhs>`:\n             <&'a\
    \ f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n             <&'a i128\
    \ as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut total = 0;\n    for row in grid {\n        let\
    \ mut current = 0;\n        for element in row {\n            current += element;\n\
    \            if current == capacity {\n                total += 1;\n         \
    \       current = 0;\n            }\n        }\n        if current > 0 {\n   \
    \         total += 1;\n        }\n    }\n    total\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut result = 0;\n    for row in grid {\n        for\
    \ well in row {\n            if well == 1 {\n                result += capacity;\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `18`,\n right: `5`', /tmp/tmpcse2yhji.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    grid.iter().map(|row| (row.iter().filter(|&&x| x == 1).count()\
    \ as isize + capacity - 1) / capacity).sum()\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut result = 0;\n    for row in grid {\n        for\
    \ &water in row {\n            result += water as isize / capacity;\n        \
    \    if water as isize % capacity > 0 {\n                result += 1;\n      \
    \      }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5fsnpx5a.rs:31:13\n   |\n\
    31 |         for &water in row {\n   |             ^^^^^^    --- this expression\
    \ has type `Option<isize>`\n   |             |\n   |             expected `isize`,\
    \ found reference\n   |             help: you can probably remove the explicit\
    \ borrow: `water`\n   |\n   = note:   expected type `isize`\n           found\
    \ reference `&_`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    use std::cmp::{max, min};\n    let rows = grid.len();\n\
    \    let cols = grid[0].len();\n    let mut cells = vec![];\n    let mut drops\
    \ = 0;\n    let mut drops_per_cell = vec![];\n    for i in 0..rows {\n       \
    \ for j in 0..cols {\n            cells.push((i, j));\n            drops_per_cell.push(0);\n\
    \        }\n    }\n    while cells.len() > 0 {\n        let mut next_cells = vec![];\n\
    \        for &(i, j) in &cells {\n            if grid[i][j] == 1 {\n         \
    \       drops += 1;\n                drops_per_cell[i * cols + j] += 1;\n    \
    \            let new_water = min(capacity, grid[i][j]);\n                grid[i][j]\
    \ -= new_water;\n                if i > 0 {\n                    let above = &mut\
    \ grid[i - 1][j];\n                    *above = max(0, *above - new_water + drops_per_cell[i\
    \ * cols + j]);\n                    if *above > 0 {\n                       \
    \ next_cells.push((i - 1, j));\n                    }\n                }\n   \
    \             if i < rows - 1 {\n                    let below = &mut grid[i +\
    \ 1][j];\n                    *below = max(0, *below - new_water + drops_per_cell[i\
    \ * cols + j]);\n                    if *below > 0 {\n                       \
    \ next_cells.push((i + 1, j));\n                    }\n                }\n   \
    \             if j > 0 {\n                    let left = &mut grid[i][j - 1];\n\
    \                    *left = max(0, *left - new_water + drops_per_cell[i * cols\
    \ + j]);\n                    if *left > 0 {\n                        next_cells.push((i,\
    \ j - 1));\n                    }\n                }\n                if j < cols\
    \ - 1 {\n                    let right = &mut grid[i][j + 1];\n              \
    \      *right = max(0, *right - new_water + drops_per_cell[i * cols + j]);\n \
    \                   if *right >\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpk7vffyyp.rs:83:3\n\
    \   |\n28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                                              - unclosed delimiter\n\
    ...\n41 |     while cells.len() > 0 {\n   |                           - unclosed\
    \ delimiter\n42 |         let mut next_cells = vec![];\n43 |         for &(i,\
    \ j) in &cells {\n   |                               - unclosed delimiter\n44\
    \ |             if grid[i][j] == 1 {\n   |                                - unclosed\
    \ delimiter\n...\n70 |                 if j < cols - 1 {\n   |               \
    \                  - this delimiter might not be properly closed...\n...\n74 |\
    \ }\n   | - ...as it matches this but it has different indentation\n...\n83 |\
    \ }\n   |   ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmpk7vffyyp.rs:74:1\n\
    \   |\n74 | }\n   | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpk7vffyyp.rs:41:5\n   |\n28 |   fn max_fill(grid: Vec<Vec<isize>>,\
    \ capacity: isize) -> isize {\n   |                                          \
    \                ----- expected `isize` because of return type\n...\n41 | /  \
    \   while cells.len() > 0 {\n42 | |         let mut next_cells = vec![];\n43 |\
    \ |         for &(i, j) in &cells {\n44 | |             if grid[i][j] == 1 {\n\
    ...  |\n82 | |     assert_eq!(candidate(vec![vec![1, 1, 1, 1], vec![1, 1, 1, 1]],\
    \ 9), 2);\n83 | | }\n   | |__^ expected `isize`, found `()`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut flat = Vec::new();\n    for row in grid {\n \
    \       for el in row {\n            flat.push(el);\n        }\n    }\n    let\
    \ grid_length = flat.len();\n    let mut result = 0;\n    let mut start = 0;\n\
    \    let mut end = capacity - 1;\n    while end < grid_length {\n        if flat[start]\
    \ > 0 {\n            if flat[end] == 0 {\n                result += 1;\n     \
    \       }\n            flat[start] -= 1;\n            flat[end] += 1;\n      \
    \  }\n        start += 1;\n        end += 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqf00kjmf.rs:39:17\n   |\n\
    39 |     while end < grid_length {\n   |                 ^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n39 |     while end < grid_length.try_into().unwrap()\
    \ {\n   |                            ++++++++++++++++++++\n\nerror[E0277]: the\
    \ type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpqf00kjmf.rs:41:16\n\
    \   |\n41 |             if flat[end] == 0 {\n   |                ^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpqf00kjmf.rs:45:13\n   |\n45 |  \
    \           flat[end] += 1;\n   |             ^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut counts = vec![vec![0; grid[0].len()]; grid.len()];\n\
    \    let mut fill = 0;\n    let mut i = 0;\n    while i < grid.len() {\n     \
    \   let mut j = 0;\n        while j < grid[i].len() {\n            if grid[i][j]\
    \ == 1 {\n                if counts[i][j] == 0 {\n                    let mut\
    \ k = 0;\n                    while k < capacity && i + k < grid.len() {\n   \
    \                     counts[i + k][j] += 1;\n                        k += 1;\n\
    \                    }\n                    fill += 1;\n                }\n  \
    \          }\n            j += 1;\n        }\n        i += 1;\n    }\n    fill\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp148f62vr.rs:38:47\n   |\n\
    38 |                     while k < capacity && i + k < grid.len() {\n   |    \
    \                                           ^ expected `usize`, found `isize`\n\
    \nerror[E0277]: cannot add `isize` to `usize`\n  --> /tmp/tmp148f62vr.rs:38:45\n\
    \   |\n38 |                     while k < capacity && i + k < grid.len() {\n \
    \  |                                             ^ no implementation for `usize\
    \ + isize`\n   |\n   = help: the trait `Add<isize>` is not implemented for `usize`\n\
    \   = help: the following other types implement trait `Add<Rhs>`:\n          \
    \   <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a\
    \ i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n             <&'a i32\
    \ as Add<i32>>\n             <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n\
    \             <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp148f62vr.rs:39:36\n   |\n39 |              \
    \           counts[i + k][j] += 1;\n   |                                    ^\
    \ expected `usize`, found `isize`\n\nerror[E0277]: cannot add `isize` to `usize`\n\
    \  --> /tmp/tmp148f62vr.rs:39:34\n   |\n39 |                         counts[i\
    \ + k][j] += 1;\n   |                                  ^ no implementation for\
    \ `usize + isize`\n   |\n   = help: the trait `Add<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `Add<Rhs>`:\n\
    \             <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n    \
    \         <&'a i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n      \
    \       <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n          \
    \   <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n           and\
    \ 48 others\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut res = 0;\n    let h = grid.len();\n    let w\
    \ = grid[0].len();\n    for row in grid {\n        let mut cnt = 0;\n        for\
    \ c in row {\n            if c == 1 {\n                cnt += 1;\n           \
    \ } else if cnt > 0 {\n                res += cnt / capacity;\n              \
    \  if cnt % capacity > 0 {\n                    res += 1;\n                }\n\
    \                cnt = 0;\n            }\n        }\n        if cnt > 0 {\n  \
    \          res += cnt / capacity;\n            if cnt % capacity > 0 {\n     \
    \           res += 1;\n            }\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let rows = grid.len();\n    let cols = grid[0].len();\n\
    \    let mut result = 0;\n    for i in 0..rows {\n        let mut row_max = 0;\n\
    \        for j in 0..cols {\n            row_max = row_max.max(grid[i][j]);\n\
    \        }\n        if row_max > 0 {\n            for j in 0..cols {\n       \
    \         result += if grid[i][j] > 0 {\n                    row_max.min(capacity).min(grid[i][j])\n\
    \                } else {\n                    0\n                };\n       \
    \     }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmpjz1yim8i.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    let mut res = 0;\n    for\
    \ wells in grid {\n        max_fill = std::cmp::max(max_fill, wells.iter().sum::<isize>());\n\
    \        let mut cur_fill = 0;\n        for well in wells {\n            cur_fill\
    \ += well;\n            res += std::cmp::min(cur_fill, capacity);\n        }\n\
    \    }\n    let mut cur_fill = 0;\n    for col in 0..grid[0].len() {\n       \
    \ cur_fill = 0;\n        for row in 0..grid.len() {\n            cur_fill += grid[row][col];\n\
    \            res += std::cmp::min(cur_fill, capacity);\n        }\n    }\n   \
    \ res - max_fill\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "warning: value assigned to `cur_fill` is never read\n  --> /tmp/tmpdkvx3cvi.rs:39:13\n\
    \   |\n39 |     let mut cur_fill = 0;\n   |             ^^^^^^^^\n   |\n   = note:\
    \ `#[warn(unused_assignments)]` on by default\n   = help: maybe it is overwritten\
    \ before being read?\n\nerror[E0382]: borrow of moved value: `grid`\n   --> /tmp/tmpdkvx3cvi.rs:40:19\n\
    \    |\n28  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |             ---- move occurs because `grid` has type `Vec<Vec<isize>>`,\
    \ which does not implement the `Copy` trait\n...\n31  |     for wells in grid\
    \ {\n    |                  ---- `grid` moved due to this implicit call to `.into_iter()`\n\
    ...\n40  |     for col in 0..grid[0].len() {\n    |                   ^^^^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `grid`\nhelp: consider iterating over a slice of\
    \ the `Vec<Vec<isize>>`'s content to avoid moving into the `for` loop\n    |\n\
    31  |     for wells in &grid {\n    |                  +\n\nerror: aborting due\
    \ to previous error; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut result = 0;\n    for\
    \ line in grid.iter_mut() {\n        let (max, pos) = line.iter().enumerate().max_by_key(|(_,\
    \ x)| *x).unwrap();\n        for p in pos..line.len() {\n            line[p] =\
    \ 0;\n        }\n        result += 1;\n        if max > 0 {\n            for i\
    \ in pos..std::cmp::min(pos + capacity as usize, line.len()) {\n             \
    \   line[i] = max;\n            }\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw4cx84nh.rs:33:23\n   |\n\
    33 |         for p in pos..line.len() {\n   |                       ^^^^^^^^^^\
    \ expected `&isize`, found `usize`\n\nerror[E0277]: the trait bound `&isize: Step`\
    \ is not satisfied\n  --> /tmp/tmpw4cx84nh.rs:33:18\n   |\n33 |         for p\
    \ in pos..line.len() {\n   |                  ^^^^^^^^^^^^^^^ the trait `Step`\
    \ is not implemented for `&isize`\n   |\n   = help: the following other types\
    \ implement trait `Step`:\n             i128\n             i16\n             i32\n\
    \             i64\n             i8\n             isize\n             u128\n  \
    \           u16\n           and 4 others\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `std::ops::Range<&isize>`\n   = note: required\
    \ because of the requirements on the impl of `IntoIterator` for `std::ops::Range<&isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpw4cx84nh.rs:34:13\n\
    \   |\n34 |             line[p] = 0;\n   |             ^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw4cx84nh.rs:38:47\n\
    \   |\n38 |             for i in pos..std::cmp::min(pos + capacity as usize, line.len())\
    \ {\n   |                                               ^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw4cx84nh.rs:38:41\n\
    \   |\n38 |             for i in pos..std::cmp::min(pos + capacity as usize, line.len())\
    \ {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^^^\n  \
    \ |                                         |\n   |                          \
    \               expected `&isize`, found `isize`\n   |                       \
    \                  help: consider borrowing here: `&(pos + capacity as usize)`\n\
    \nerror[E0277]: cannot add `usize` to `&isi"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let (n, m) = (grid.len(), grid[0].len());\n    let mut\
    \ queue = VecDeque::new();\n    let mut dist = vec![vec![std::isize::MAX; m];\
    \ n];\n    let mut res = 0;\n    // enqueue all cells with water\n    for (i,\
    \ row) in grid.iter().enumerate() {\n        for (j, &c) in row.iter().enumerate()\
    \ {\n            if c == 1 {\n                queue.push_back((i, j));\n     \
    \           dist[i][j] = 0;\n            }\n        }\n    }\n    let ds = vec![-1,\
    \ 0, 1, 0, -1];\n    while let Some((i, j)) = queue.pop_front() {\n        //\
    \ enqueue all unvisited neighbors\n        for d in 0..4 {\n            let (ni,\
    \ nj) = (i as isize + ds[d], j as isize + ds[d + 1]);\n            if ni >= 0\
    \ && ni < n as isize && nj >= 0 && nj < m as isize &&\n                dist[ni\
    \ as usize][nj as usize] == std::isize::MAX\n            {\n                dist[ni\
    \ as usize][nj as usize] = dist[i][j] + 1;\n                queue.push_back((ni\
    \ as usize, nj as usize));\n            }\n        }\n        res = res.max(dist[i][j]);\n\
    \    }\n    res * capacity\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `VecDeque`\n  -->\
    \ /tmp/tmpkf0kmzvk.rs:30:21\n   |\n30 |     let mut queue = VecDeque::new();\n\
    \   |                     ^^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::VecDeque;\n   |\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut res = 0;\n    let rows\
    \ = grid.len();\n    let cols = grid[0].len();\n    while grid.iter().any(|row|\
    \ row.iter().any(|x| *x > 0)) {\n        // find top right entry\n        let\
    \ mut max_r = 0;\n        let mut max_c = 0;\n        for r in 0..rows {\n   \
    \         for c in 0..cols {\n                if grid[r][c] > grid[max_r][max_c]\
    \ {\n                    max_r = r;\n                    max_c = c;\n        \
    \        }\n            }\n        }\n        // fill up\n        let mut rem\
    \ = capacity;\n        let mut c = max_c;\n        while rem > 0 && c >= 0 {\n\
    \            if grid[max_r][c] > 0 {\n                if grid[max_r][c] >= rem\
    \ {\n                    grid[max_r][c] -= rem;\n                    rem = 0;\n\
    \                } else {\n                    rem -= grid[max_r][c];\n      \
    \              grid[max_r][c] = 0;\n                }\n            }\n       \
    \     c -= 1;\n        }\n        res += 1;\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpuzae27bo.rs:58:13\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let n = grid.len();\n    let m = grid[0].len();\n   \
    \ let mut count = 0;\n    for i in 0..n {\n        for j in 0..m {\n         \
    \   if grid[i][j] == 1 {\n                let cell = grid[i][j];\n           \
    \     let mut drop = capacity - cell;\n                for k in i+1..n {\n   \
    \                 if grid[k][j] == 1 {\n                        let cell = grid[k][j];\n\
    \                        let mut drop = capacity - cell;\n                   \
    \     if drop > 0 {\n                            count += 1;\n               \
    \             grid[k][j] += 1;\n                        }\n                  \
    \  }\n                }\n            }\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `drop`\n  --> /tmp/tmpvzgrddcj.rs:36:25\n   |\n\
    36 |                 let mut drop = capacity - cell;\n   |                   \
    \      ^^^^ help: if this is intentional, prefix it with an underscore: `_drop`\n\
    \   |\n   = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmpvzgrddcj.rs:36:21\n   |\n36 |   \
    \              let mut drop = capacity - cell;\n   |                     ----^^^^\n\
    \   |                     |\n   |                     help: remove this `mut`\n\
    \   |\n   = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does\
    \ not need to be mutable\n  --> /tmp/tmpvzgrddcj.rs:40:29\n   |\n40 |        \
    \                 let mut drop = capacity - cell;\n   |                      \
    \       ----^^^^\n   |                             |\n   |                   \
    \          help: remove this `mut`\n\nerror[E0596]: cannot borrow `grid` as mutable,\
    \ as it is not declared as mutable\n  --> /tmp/tmpvzgrddcj.rs:43:29\n   |\n28\
    \ | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n   |     \
    \        ---- help: consider changing this to be mutable: `mut grid`\n...\n43\
    \ |                             grid[k][j] += 1;\n   |                       \
    \      ^^^^ cannot borrow as mutable\n\nerror: aborting due to previous error;\
    \ 3 warnings emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let h = grid.len();\n    let w = grid[0].len();\n   \
    \ let mut result = 0;\n    let mut min_height = vec![];\n    for i in 0..w {\n\
    \        let mut min = h;\n        for j in 0..h {\n            if grid[j][i]\
    \ == 1 {\n                min = j;\n                break;\n            }\n  \
    \      }\n        min_height.push(min);\n    }\n    for j in 0..h {\n        let\
    \ mut i = 0;\n        while i < w {\n            if grid[j][i] == 1 {\n      \
    \          break;\n            }\n            i += 1;\n        }\n        while\
    \ i < w {\n            let mut filled = 0;\n            let mut max_height = j;\n\
    \            while i < w && filled < capacity {\n                if grid[j][i]\
    \ == 1 {\n                    break;\n                }\n                max_height\
    \ = min_height[i].min(max_height);\n                filled += 1;\n           \
    \     i += 1;\n            }\n            result += max_height - j;\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa_e4s31u.rs:65:5\n   |\n\
    28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n   |    \
    \                                                    ----- expected `isize` because\
    \ of return type\n...\n65 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n65 |     result.try_into().unwrap()\n   |\
    \           ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut result = 0;\n    for i in 0..grid.len() {\n \
    \       for j in 0..grid[i].len() {\n            if grid[i][j] == 1 {\n      \
    \          let pos = ((i as isize) * (grid[i].len() as isize) + (j as isize));\n\
    \                let max_fill = capacity - grid[i][j];\n                let mut\
    \ i = i + 1;\n                while i < grid.len() && max_fill > 0 {\n       \
    \             let fill = isize::min(max_fill, grid[i][j]);\n                 \
    \   max_fill -= fill;\n                    result += fill;\n                 \
    \   grid[i][j] -= fill;\n                    i += 1;\n                }\n    \
    \            if max_fill > 0 {\n                    for i in 0..grid.len() {\n\
    \                        if grid[i][j] == 1 {\n                            result\
    \ += max_fill;\n                            grid[i][j] -= max_fill;\n        \
    \                    break;\n                        }\n                    }\n\
    \                }\n            }\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "warning: unnecessary parentheses around assigned value\n  --> /tmp/tmpoied4o9u.rs:33:27\n\
    \   |\n33 |                 let pos = ((i as isize) * (grid[i].len() as isize)\
    \ + (j as isize));\n   |                           ^                         \
    \                             ^\n   |\n   = note: `#[warn(unused_parens)]` on\
    \ by default\nhelp: remove these parentheses\n   |\n33 -                 let pos\
    \ = ((i as isize) * (grid[i].len() as isize) + (j as isize));\n33 +          \
    \       let pos = (i as isize) * (grid[i].len() as isize) + (j as isize);\n  \
    \ | \n\nwarning: unused variable: `pos`\n  --> /tmp/tmpoied4o9u.rs:33:21\n   |\n\
    33 |                 let pos = ((i as isize) * (grid[i].len() as isize) + (j as\
    \ isize));\n   |                     ^^^ help: if this is intentional, prefix\
    \ it with an underscore: `_pos`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0384]: cannot assign twice to immutable variable `max_fill`\n\
    \  --> /tmp/tmpoied4o9u.rs:38:21\n   |\n34 |                 let max_fill = capacity\
    \ - grid[i][j];\n   |                     --------\n   |                     |\n\
    \   |                     first assignment to `max_fill`\n   |               \
    \      help: consider making this binding mutable: `mut max_fill`\n...\n38 | \
    \                    max_fill -= fill;\n   |                     ^^^^^^^^^^^^^^^^\
    \ cannot assign twice to immutable variable\n\nerror[E0596]: cannot borrow `grid`\
    \ as mutable, as it is not declared as mutable\n  --> /tmp/tmpoied4o9u.rs:40:21\n\
    \   |\n28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |             ---- help: consider changing this to be mutable: `mut grid`\n\
    ...\n40 |                     grid[i][j] -= fill;\n   |                     ^^^^\
    \ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `grid` as mutable, as\
    \ it is not declared as mutable\n  --> /tmp/tmpoied4o9u.rs:47:29\n   |\n28 | fn\
    \ max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n   |          \
    \   ---- help: consider changing this to be mutable: `mut grid`\n...\n47 |   \
    \                          grid[i][j] -= max_fill;\n   |  "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut result = 0;\n    let mut max_col = vec![0; grid[0].len()];\n\
    \    for row in grid {\n        for (i, cell) in row.iter().enumerate() {\n  \
    \          if *cell > 0 {\n                max_col[i] += 1;\n            }\n \
    \       }\n    }\n    let mut col = 0;\n    let mut level = 0;\n    while col\
    \ < max_col.len() {\n        if max_col[col] == 0 {\n            col += 1;\n \
    \           continue;\n        }\n        if max_col[col] == level {\n       \
    \     col += 1;\n            continue;\n        }\n        if max_col[col] > level\
    \ + capacity {\n            result += 1;\n            level += capacity;\n   \
    \     } else {\n            result += 1;\n            level = max_col[col];\n\
    \            col += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmpg1zzgh0x.rs:63:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    // TODO\n    unimplemented!();\n}\n\nfn main() {\n  \
    \  let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp3u592_o_.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let n = grid.len();\n    let m = grid[0].len();\n   \
    \ let mut max_row_water = vec![0; n];\n    let mut max_col_water = vec![0; m];\n\
    \    for i in 0..n {\n        let mut row_sum = 0;\n        for j in 0..m {\n\
    \            row_sum += grid[i][j];\n        }\n        max_row_water[i] = row_sum;\n\
    \    }\n    for j in 0..m {\n        let mut col_sum = 0;\n        for i in 0..n\
    \ {\n            col_sum += grid[i][j];\n        }\n        max_col_water[j] =\
    \ col_sum;\n    }\n    max_row_water.sort();\n    max_col_water.sort();\n    let\
    \ mut row_pairs = vec![];\n    let mut col_pairs = vec![];\n    let mut row_count\
    \ = 0;\n    let mut col_count = 0;\n    for row_pair in 0..(max_row_water.len()\
    \ - 1) {\n        if max_row_water[row_pair] == max_row_water[row_pair + 1] {\n\
    \            row_count += 1;\n        } else {\n            row_pairs.push(row_count);\n\
    \            row_count = 0;\n        }\n    }\n    for col_pair in 0..(max_col_water.len()\
    \ - 1) {\n        if max_col_water[col_pair] == max_col_water[col_pair + 1] {\n\
    \            col_count += 1;\n        } else {\n            col_pairs.push(col_count);\n\
    \            col_count = 0;\n        }\n    }\n    let mut max_row_pairs = 0;\n\
    \    let mut max_col_pairs = 0;\n    if !row_pairs.is_empty() {\n        max_row_pairs\
    \ = row_pairs.iter().max().unwrap();\n    }\n    if !col_pairs.is_empty() {\n\
    \        max_col_pairs = col_pairs.\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpwa1bwdck.rs:85:3\n\
    \   |\n28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                                              - unclosed delimiter\n\
    ...\n74 |     if !col_pairs.is_empty() {\n   |                              -\
    \ this delimiter might not be properly closed...\n75 |         max_col_pairs =\
    \ col_pairs.\n76 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n85 | }\n   |   ^\n\nerror: unexpected token: `}`\n  --> /tmp/tmpwa1bwdck.rs:76:1\n\
    \   |\n76 | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwa1bwdck.rs:72:25\n\
    \   |\n69 |     let mut max_row_pairs = 0;\n   |                             -\
    \ expected due to this value\n...\n72 |         max_row_pairs = row_pairs.iter().max().unwrap();\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer,\
    \ found `&{integer}`\n   |\nhelp: consider dereferencing the borrow\n   |\n72\
    \ |         max_row_pairs = *row_pairs.iter().max().unwrap();\n   |          \
    \               +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwa1bwdck.rs:75:25\n\
    \   |\n70 |     let mut max_col_pairs = 0;\n   |                             -\
    \ expected due to this value\n...\n75 |         max_col_pairs = col_pairs.\n \
    \  |                         ^^^^^^^^^ expected integer, found struct `Vec`\n\
    \   |\n   = note: expected type `{integer}`\n            found struct `Vec<{integer}>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwa1bwdck.rs:28:56\n   |\n28 |\
    \ fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n   |    --------\
    \                                            ^^^^^ expected `isize`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 5 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut count = 0;\n    loop\
    \ {\n        let mut filled = false;\n        for row in &mut grid {\n       \
    \     let mut water = 0;\n            for i in 0..row.len() {\n              \
    \  row[i] -= capacity;\n                if row[i] > 0 {\n                    water\
    \ += capacity;\n                    filled = true;\n                } else {\n\
    \                    water += row[i].abs();\n                    row[i] = 0;\n\
    \                }\n            }\n            count += water / capacity;\n  \
    \      }\n        if !filled { break; }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `11`,\n right: `5`', /tmp/tmp9p0hh3ed.rs:55:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let m = grid.len();\n    let n = grid[0].len();\n   \
    \ let mut row_fill = vec![0; m];\n    let mut col_fill = vec![0; n];\n    let\
    \ mut drop_count = 0;\n    for i in 0..m {\n        for j in 0..n {\n        \
    \    if grid[i][j] > 0 {\n                drop_count += 1;\n                row_fill[i]\
    \ += 1;\n                col_fill[j] += 1;\n            }\n        }\n    }\n\
    \    let row_count = row_fill.iter().filter(|&&c| c > 0).count();\n    let col_count\
    \ = col_fill.iter().filter(|&&c| c > 0).count();\n    if row_count == 0 || col_count\
    \ == 0 {\n        return 0;\n    }\n    let per_bucket = capacity as usize;\n\
    \    let min_rounds = (drop_count as f64 / (per_bucket as f64)).ceil() as isize;\n\
    \    let rows_per_round = (row_count as f64 / (min_rounds as f64)).ceil() as usize;\n\
    \    let cols_per_round = (col_count as f64 / (min_rounds as f64)).ceil() as usize;\n\
    \    let mut row_ptr = 0;\n    let mut col_ptr = 0;\n    let mut rows_dropped\
    \ = 0;\n    let mut cols_dropped = 0;\n    let mut fill_count = 0;\n    while\
    \ rows_dropped < row_count || cols_dropped < col_count {\n        fill_count +=\
    \ 1;\n        let row_target = min(row_count, rows_dropped + rows_per_round);\n\
    \        let col_target = min(col_count, cols_dropped + cols_per_round);\n   \
    \     for i in row_ptr..m {\n            if row_fill[i] > 0 {\n              \
    \  if row_target <= rows_dropped {\n                    break;\n             \
    \   }\n                rows_dropped += 1;\n                row_fill[i] = 0;\n\
    \            }\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpxuwz91bl.rs:78:3\n\
    \   |\n28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                                              - unclosed delimiter\n\
    ...\n57 |     while rows_dropped < row_count || cols_dropped < col_count {\n \
    \  |                                                                - unclosed\
    \ delimiter\n...\n61 |         for i in row_ptr..m {\n   |                   \
    \          - this delimiter might not be properly closed...\n...\n69 | }\n   |\
    \ - ...as it matches this but it has different indentation\n...\n78 | }\n   |\
    \   ^\n\nerror[E0425]: cannot find function `min` in this scope\n  --> /tmp/tmpxuwz91bl.rs:59:26\n\
    \   |\n59 |         let row_target = min(row_count, rows_dropped + rows_per_round);\n\
    \   |                          ^^^\n...\n71 | fn main() {\n   | --------- similarly\
    \ named function `main` defined here\n   |\nhelp: a function with a similar name\
    \ exists\n   |\n59 |         let row_target = main(row_count, rows_dropped + rows_per_round);\n\
    \   |                          ~~~~\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::min;\n   |\n\nerror[E0425]: cannot find function `min`\
    \ in this scope\n  --> /tmp/tmpxuwz91bl.rs:60:26\n   |\n60 |         let col_target\
    \ = min(col_count, cols_dropped + cols_per_round);\n   |                     \
    \     ^^^\n...\n71 | fn main() {\n   | --------- similarly named function `main`\
    \ defined here\n   |\nhelp: a function with a similar name exists\n   |\n60 |\
    \         let col_target = main(col_count, cols_dropped + cols_per_round);\n \
    \  |                          ~~~~\nhelp: consider importing this function\n \
    \  |\n1  | use std::cmp::min;\n   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxuwz91bl.rs:57:5\n\
    \   |\n28 |   fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \   |                                                          ----- expected\
    \ `isize` because of return type\n...\n57 | /     while rows_dropped < row_count\
    \ || cols_dropped < col_count {\n58 | |         fill_count += 1;\n59 | |     \
    \    let row_targe"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut filled = 0;\n    let mut rem = 0;\n    for row\
    \ in grid {\n        let sum = row.iter().sum::<isize>();\n        let inc = sum\
    \ + rem;\n        filled += inc / capacity;\n        rem = inc % capacity;\n \
    \   }\n    filled + rem\n}\n\nfn main() {\n    let candidate = max_fill;\n   \
    \ assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1,\
    \ 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0,\
    \ 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `8`,\n right: `2`', /tmp/tmpkt67lu3r.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max = 0;\n    for row in grid {\n        let\
    \ mut sum = 0;\n        for n in row {\n            sum += n;\n            max\
    \ = isize::max(max, sum);\n        }\n    }\n    (max + capacity - 1) / capacity\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmplbtmivh8.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    // take a column at a time and reduce it to capacity\
    \ where possible\n    let mut fills = 0;\n    for col in grid.iter().map(|row|\
    \ row.into_iter()) {\n        let mut col = col.collect::<Vec<_>>();\n       \
    \ let col_filled = col.iter().filter(|&v| *v == 1).count();\n        let mut col_filled\
    \ = col_filled as isize;\n        while col_filled > 0 {\n            col_filled\
    \ -= 1;\n            for r in 0..col.len() {\n                if col[r] == 1 {\n\
    \                    col[r] = 0;\n                    break;\n               \
    \ }\n            }\n            fills += 1;\n            for r in 0..col.len()\
    \ {\n                if col[r] == 1 {\n                    break;\n          \
    \      }\n                if col_filled > 0 {\n                    col[r] = 1;\n\
    \                    col_filled -= 1;\n                }\n            }\n    \
    \    }\n    }\n    fills\n}\n\nfn main() {\n    let candidate = max_fill;\n  \
    \  assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1,\
    \ 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0,\
    \ 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpxg5v9aug.rs:33:52\n\
    \   |\n33 |         let col_filled = col.iter().filter(|&v| *v == 1).count();\n\
    \   |                                                    ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0277]: can't compare `&isize`\
    \ with `{integer}`\n  --> /tmp/tmpxg5v9aug.rs:38:27\n   |\n38 |              \
    \   if col[r] == 1 {\n   |                           ^^ no implementation for\
    \ `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is\
    \ not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpxg5v9aug.rs:39:30\n   |\n39 |                     col[r] = 0;\n   |\
    \                     ------   ^\n   |                     |        |\n   |  \
    \                   |        expected `&isize`, found integer\n   |          \
    \           |        help: consider borrowing here: `&0`\n   |               \
    \      expected due to the type of this binding\n\nerror[E0277]: can't compare\
    \ `&isize` with `{integer}`\n  --> /tmp/tmpxg5v9aug.rs:45:27\n   |\n45 |     \
    \            if col[r] == 1 {\n   |                           ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/t"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_height = 0;\n    for row in grid {\n    \
    \    let water = row.iter().sum();\n        max_height = std::cmp::max(max_height,\
    \ water);\n    }\n    let rows = grid.len();\n    let columns = grid[0].len();\n\
    \    let mut step = 0;\n    while max_height > 0 {\n        let mut min_height\
    \ = std::isize::MAX;\n        for row in 0..rows {\n            for column in\
    \ 0..columns {\n                if grid[row][column] > 0 {\n                 \
    \   min_height = std::cmp::min(min_height, grid[row][column]);\n             \
    \   }\n            }\n        }\n        for row in 0..rows {\n            for\
    \ column in 0..columns {\n                if grid[row][column] > 0 {\n       \
    \             grid[row][column] -= min_height;\n                }\n          \
    \  }\n        }\n        step += min_height;\n        max_height -= min_height;\n\
    \    }\n    step\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `capacity`\n  --> /tmp/tmp0kjwfnei.rs:28:36\n\
    \   |\n28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                    ^^^^^^^^ help: if this is intentional,\
    \ prefix it with an underscore: `_capacity`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `grid`\n   --> /tmp/tmp0kjwfnei.rs:34:16\n\
    \    |\n28  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |             ---- move occurs because `grid` has type `Vec<Vec<isize>>`,\
    \ which does not implement the `Copy` trait\n29  |     let mut max_height = 0;\n\
    30  |     for row in grid {\n    |                ---- `grid` moved due to this\
    \ implicit call to `.into_iter()`\n...\n34  |     let rows = grid.len();\n   \
    \ |                ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `grid`\nhelp: consider\
    \ iterating over a slice of the `Vec<Vec<isize>>`'s content to avoid moving into\
    \ the `for` loop\n    |\n30  |     for row in &grid {\n    |                +\n\
    \nerror[E0596]: cannot borrow `grid` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmp0kjwfnei.rs:49:21\n   |\n28 | fn max_fill(grid: Vec<Vec<isize>>,\
    \ capacity: isize) -> isize {\n   |             ---- help: consider changing this\
    \ to be mutable: `mut grid`\n...\n49 |                     grid[row][column] -=\
    \ min_height;\n   |                     ^^^^ cannot borrow as mutable\n\nerror:\
    \ aborting due to 2 previous errors; 1 warning emitted\n\nSome errors have detailed\
    \ explanations: E0382, E0596.\nFor more information about an error, try `rustc\
    \ --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let n = grid.len();\n    let m = grid[0].len();\n   \
    \ let mut result = 0;\n    for j in 0..m {\n        let mut fill = 0;\n      \
    \  for i in 0..n {\n            if grid[i][j] == 1 {\n                fill +=\
    \ 1;\n            } else if fill > 0 {\n                result += 1;\n       \
    \         fill = 0;\n            }\n        }\n        if fill > 0 {\n       \
    \     result += 1;\n        }\n    }\n    if capacity == 1 {\n        result\n\
    \    } else {\n        result / capacity + if result % capacity == 0 { 0 } else\
    \ { 1 }\n    }\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `6`', /tmp/tmpuz95kz9c.rs:55:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let rows = grid.len();\n    let cols = grid[0].len();\n\
    \    let mut result = 0;\n    let mut rows_filled = vec![vec![false; cols]; rows];\n\
    \    for r in 0..rows {\n        for c in 0..cols {\n            if grid[r][c]\
    \ == 1 && !rows_filled[r][c] {\n                let mut total_filled = 0;\n  \
    \              let mut filled = vec![vec![false; cols]; rows];\n             \
    \   let mut queue = VecDeque::new();\n                queue.push_back((r, c));\n\
    \                while let Some((r, c)) = queue.pop_front() {\n              \
    \      if grid[r][c] == 1 && !filled[r][c] {\n                        filled[r][c]\
    \ = true;\n                        total_filled += 1;\n                      \
    \  if total_filled == capacity {\n                            result += 1;\n \
    \                           break;\n                        }\n              \
    \          if r > 0 {\n                            queue.push_back((r - 1, c));\n\
    \                        }\n                        if r < rows - 1 {\n      \
    \                      queue.push_back((r + 1, c));\n                        }\n\
    \                        if c > 0 {\n                            queue.push_back((r,\
    \ c - 1));\n                        }\n                        if c < cols - 1\
    \ {\n                            queue.push_back((r, c + 1));\n              \
    \          }\n                    }\n                }\n                for r\
    \ in 0..rows {\n                    for c in 0..cols {\n                     \
    \   if filled[r][c] {\n                            rows_filled[r][c] = true;\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `VecDeque`\n  -->\
    \ /tmp/tmp06x513o9.rs:38:33\n   |\n38 |                 let mut queue = VecDeque::new();\n\
    \   |                                 ^^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::VecDeque;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut result = 0;\n    let mut sum = 0;\n    let mut\
    \ count = vec![0; grid.len()];\n    for (i, row) in grid.iter().enumerate() {\n\
    \        for x in row {\n            sum += x;\n            count[i] += x;\n \
    \       }\n    }\n    let n = grid.len();\n    let m = grid[0].len();\n    if\
    \ sum == 0 {\n        return 0;\n    }\n    while count[0] > 0 {\n        result\
    \ += 1;\n        let mut prev = 0;\n        let mut max_index = 0;\n        for\
    \ (i, &c) in count.iter().enumerate() {\n            if c > prev {\n         \
    \       prev = c;\n                max_index = i;\n            }\n        }\n\
    \        let mut water = capacity;\n        for i in 0..max_index {\n        \
    \    let remove = std::cmp::min(water, count[i]);\n            count[i] -= remove;\n\
    \            water -= remove;\n        }\n        water = capacity;\n        for\
    \ i in (max_index + 1)..n {\n            let remove = std::cmp::min(water, count[i]);\n\
    \            count[i] -= remove;\n            water -= remove;\n        }\n  \
    \      for i in 0..n {\n            count[i] = std::cmp::min(count[i], m as isize);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmpph8cqa_6.rs:74:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let rows = grid.len();\n    let cols = grid[0].len();\n\
    \    let mut fill = vec![vec![0; cols]; rows];\n    let mut fill_count = 0;\n\
    \    for i in 0..rows {\n        for j in 0..cols {\n            if grid[i][j]\
    \ > 0 {\n                fill[i][j] = 1;\n                fill_count += 1;\n \
    \           }\n        }\n    }\n    let mut down_i = 0;\n    let mut down_j =\
    \ 0;\n    let mut up_i = rows - 1;\n    let mut up_j = cols - 1;\n    let mut\
    \ row_fill = 0;\n    let mut col_fill = 0;\n    let mut passes = 0;\n    let mut\
    \ passes_i = 0;\n    let mut passes_j = 0;\n    while fill_count > 0 {\n     \
    \   let mut fill_i = down_i;\n        let mut fill_j = down_j;\n        for i\
    \ in down_i..=up_i {\n            for j in down_j..=up_j {\n                if\
    \ fill[i][j] > 0 {\n                    fill_i = i;\n                    fill_j\
    \ = j;\n                    break;\n                }\n            }\n       \
    \     if fill_i < i {\n                break;\n            }\n        }\n    \
    \    passes += 1;\n        row_fill = 0;\n        col_fill = 0;\n        passes_i\
    \ = 0;\n        passes_j = 0;\n        while down_i <= fill_i && fill_count >\
    \ 0 {\n            let next_i = down_i + 1;\n            let row_remaining = std::cmp::min(capacity\
    \ - row_fill, grid[down_i][fill_j]);\n            row_fill += row_remaining;\n\
    \            fill[down_i][fill_j] -= row_remaining;\n            fill_count -=\
    \ row_remaining;\n            if fill[down_i][fill_j] == 0 {\n               \
    \ passes_i += 1;\n            }\n            if row_fill == capacity {\n     \
    \           down_i = next_i;\n                row_fill = 0;\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpzjti94kj.rs:91:3\n\
    \   |\n28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                                              - unclosed delimiter\n\
    ...\n50 |     while fill_count > 0 {\n   |                          - unclosed\
    \ delimiter\n...\n70 |         while down_i <= fill_i && fill_count > 0 {\n  \
    \ |                                                  - unclosed delimiter\n...\n\
    79 |             if row_fill == capacity {\n   |                             \
    \        - this delimiter might not be properly closed...\n...\n82 | }\n   | -\
    \ ...as it matches this but it has different indentation\n...\n91 | }\n   |  \
    \ ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzjti94kj.rs:50:5\n   |\n\
    28 |   fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n   |  \
    \                                                        ----- expected `isize`\
    \ because of return type\n...\n50 | /     while fill_count > 0 {\n51 | |     \
    \    let mut fill_i = down_i;\n52 | |         let mut fill_j = down_j;\n53 | |\
    \         for i in down_i..=up_i {\n...  |\n90 | |     assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n91 | | }\n   | |__^ expected `isize`,\
    \ found `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut reservoir = HashMap::new();\n    let mut height\
    \ = grid.len();\n    let mut width = grid[0].len();\n    for h in 0..height {\n\
    \        for w in 0..width {\n            reservoir.insert((h, w), 0);\n     \
    \   }\n    }\n    let mut round = 0;\n    let mut last_empty = 0;\n    let mut\
    \ cur_empty = 0;\n    let mut flow_count = 0;\n    while height > 0 {\n      \
    \  if let Some(count) = reservoir.values().filter(|&&v| v == 0).count() {\n  \
    \          cur_empty = count;\n        }\n        //println!(\"{}, {}\", last_empty,\
    \ cur_empty);\n        if last_empty == cur_empty {\n            //println!(\"\
    break\");\n            break;\n        }\n        last_empty = cur_empty;\n  \
    \      for h in 0..height {\n            for w in 0..width {\n               \
    \ if reservoir[&(h, w)] > 0 {\n                    reservoir.insert((h, w), reservoir[&(h,\
    \ w)] - 1);\n                    if h + 1 < height {\n                       \
    \ let mut insert_value = &reservoir[&(h, w)] + &reservoir[&(h + 1, w)];\n    \
    \                    insert_value = if insert_value > capacity { capacity } else\
    \ { insert_value };\n                        reservoir.insert((h + 1, w), insert_value);\n\
    \                    }\n                    if w + 1 < width {\n             \
    \           let mut insert_value = &reservoir[&(h, w)] + &reservoir[&(h, w + 1)];\n\
    \                        insert_value = if insert_value > capacity { capacity\
    \ } else { insert_value };\n                        reservoir.insert((h, w + 1),\
    \ insert_value);\n                    }\n                    flow_count += 1;\n\
    \                }\n            }\n        }\n        round += 1;\n    }\n   \
    \ flow_count\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmphuwwrvh5.rs:29:25\n   |\n29 |     let mut reservoir = HashMap::new();\n\
    \   |                         ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut res = 0;\n    let n = grid.len();\n    let m\
    \ = grid[0].len();\n    let mut max_row = vec![0; m];\n    let mut total = 0;\n\
    \    for i in 0..n {\n        let mut max_col = 0;\n        for j in 0..m {\n\
    \            if grid[i][j] > 0 {\n                total += 1;\n              \
    \  max_col = std::cmp::max(max_col, max_row[j]);\n            }\n        }\n \
    \       for j in 0..m {\n            if grid[i][j] > 0 {\n                max_row[j]\
    \ = max_col + 1;\n            }\n        }\n    }\n    let mut max_row = vec![0;\
    \ m];\n    for i in (0..n).rev() {\n        let mut max_col = 0;\n        for\
    \ j in (0..m).rev() {\n            if grid[i][j] > 0 {\n                max_col\
    \ = std::cmp::max(max_col, max_row[j]);\n            }\n        }\n        for\
    \ j in (0..m).rev() {\n            if grid[i][j] > 0 {\n                max_row[j]\
    \ = max_col + 1;\n            }\n        }\n    }\n    let mut max_row = vec![0;\
    \ m];\n    for i in 0..n {\n        let mut max_col = 0;\n        for j in (0..m).rev()\
    \ {\n            if grid[i][j] > 0 {\n                max_col = std::cmp::max(max_col,\
    \ max_row[j]);\n            }\n        }\n        for j in (0..m).rev() {\n  \
    \          if grid[i][j] > 0 {\n                max_row[j] = max_col + 1;\n  \
    \          }\n        }\n    }\n    let mut max_row = vec![0; m];\n    for i in\
    \ (0..n).rev() {\n        let mut max_col = 0;\n        for j in 0..m {\n    \
    \        if grid[i][j] > 0 {\n                max_col = std\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpoceshda0.rs:91:3\n\
    \   |\n28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                                              - unclosed delimiter\n\
    ...\n77 |     for i in (0..n).rev() {\n   |                           - unclosed\
    \ delimiter\n78 |         let mut max_col = 0;\n79 |         for j in 0..m {\n\
    \   |                       - unclosed delimiter\n80 |             if grid[i][j]\
    \ > 0 {\n   |                               - this delimiter might not be properly\
    \ closed...\n81 |                 max_col = std\n82 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n91 | }\n   |   ^\n\nerror[E0423]:\
    \ expected value, found crate `std`\n  --> /tmp/tmpoceshda0.rs:81:27\n   |\n81\
    \ |                 max_col = std\n   |                           ^^^ not a value\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpoceshda0.rs:77:5\n   |\n28 | \
    \  fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n   |      \
    \                                                    ----- expected `isize` because\
    \ of return type\n...\n77 | /     for i in (0..n).rev() {\n78 | |         let\
    \ mut max_col = 0;\n79 | |         for j in 0..m {\n80 | |             if grid[i][j]\
    \ > 0 {\n...  |\n90 | |     assert_eq!(candidate(vec![vec![1, 1, 1, 1], vec![1,\
    \ 1, 1, 1]], 9), 2);\n91 | | }\n   | |__^ expected `isize`, found `()`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0423.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut result = 0;\n    for col in 0..grid[0].len()\
    \ {\n        let mut current_fill = 0;\n        for row in 0..grid.len() {\n \
    \           if grid[row][col] == 1 {\n                current_fill += 1;\n   \
    \         } else {\n                if current_fill > 0 {\n                  \
    \  result += 1;\n                    if current_fill > capacity {\n          \
    \              result += current_fill - capacity;\n                    }\n   \
    \                 current_fill = 0;\n                }\n            }\n      \
    \  }\n        if current_fill > 0 {\n            result += 1;\n            if\
    \ current_fill > capacity {\n                result += current_fill - capacity;\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `5`', /tmp/tmpc3zt9ubl.rs:58:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut depth = 0;\n    let\
    \ mut is_all_empty = false;\n    while !is_all_empty {\n        let max_depth\
    \ = grid.iter().map(|row| row.iter().max().unwrap()).max().unwrap();\n       \
    \ if *max_depth <= depth {\n            break;\n        }\n        is_all_empty\
    \ = true;\n        for row in &mut grid {\n            for col in row {\n    \
    \            if *col > depth {\n                    *col -= capacity;\n      \
    \              is_all_empty = false;\n                }\n            }\n     \
    \   }\n        depth += capacity;\n    }\n    depth\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmpjrwjre4y.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_depth = 0;\n    for row in grid {\n     \
    \   for c in row {\n            if c > 0 {\n                max_depth += 1;\n\
    \            }\n        }\n    }\n    let mut min_drops = 0;\n    for depth in\
    \ 1..=max_depth {\n        let mut drops = 0;\n        for row in grid {\n   \
    \         let mut available = capacity;\n            for c in row {\n        \
    \        if c == depth {\n                    if available > 0 {\n           \
    \             available -= 1;\n                    } else {\n                \
    \        drops += 1;\n                        available = capacity - 1;\n    \
    \                }\n                }\n            }\n        }\n        min_drops\
    \ = min_drops.max(drops);\n    }\n    min_drops\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `grid`\n   --> /tmp/tmp0foe3ihu.rs:40:20\n\
    \    |\n28  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |             ---- move occurs because `grid` has type `Vec<Vec<isize>>`,\
    \ which does not implement the `Copy` trait\n29  |     let mut max_depth = 0;\n\
    30  |     for row in grid {\n    |                ---- `grid` moved due to this\
    \ implicit call to `.into_iter()`\n...\n40  |         for row in grid {\n    |\
    \                    ^^^^ value used here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `grid`\nhelp: consider iterating\
    \ over a slice of the `Vec<Vec<isize>>`'s content to avoid moving into the `for`\
    \ loop\n    |\n30  |     for row in &grid {\n    |                +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let r = grid.len();\n    let c = grid[0].len();\n   \
    \ let mut wells = vec![vec![0; c]; r];\n    let mut r_max = vec![0; r];\n    let\
    \ mut c_max = vec![0; c];\n    for i in 0..r {\n        for j in 0..c {\n    \
    \        wells[i][j] = grid[i][j];\n            r_max[i] = std::cmp::max(r_max[i],\
    \ wells[i][j]);\n            c_max[j] = std::cmp::max(c_max[j], wells[i][j]);\n\
    \        }\n    }\n    let mut count = 0;\n    for _ in 0..r * c {\n        let\
    \ mut change = false;\n        for i in 0..r {\n            for j in 0..c {\n\
    \                if wells[i][j] < r_max[i] && wells[i][j] < c_max[j] {\n     \
    \               wells[i][j] += 1;\n                    change = true;\n      \
    \          }\n            }\n        }\n        if !change {\n            break;\n\
    \        }\n        count += 1;\n    }\n    for i in 0..r {\n        for j in\
    \ 0..c {\n            if wells[i][j] < capacity {\n                count += capacity\
    \ - wells[i][j];\n            }\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmpptts6yce.rs:69:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let n = grid.len();\n    let m = grid[0].len();\n   \
    \ let mut res = 0;\n    for i in 0..n {\n        res += grid[i].iter().sum::<isize>()\
    \ / capacity;\n    }\n    let mut col_max = vec![0; m];\n    for i in 0..n {\n\
    \        for j in 0..m {\n            col_max[j] = max(col_max[j], grid[i][j]);\n\
    \        }\n    }\n    for j in 0..m {\n        res += col_max[j] / capacity;\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmph0a2qqla.rs:38:26\n\
    \   |\n38 |             col_max[j] = max(col_max[j], grid[i][j]);\n   |      \
    \                    ^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut counter = 0;\n    let mut max_fill = 0;\n   \
    \ for row in grid {\n        for item in row {\n            if item == 1 {\n \
    \               max_fill += 1;\n            }\n        }\n    }\n    for row in\
    \ grid {\n        for item in row {\n            if item == 1 {\n            \
    \    counter += 1;\n                if counter == max_fill {\n               \
    \     return capacity;\n                }\n            }\n        }\n    }\n \
    \   capacity\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0382]: use of moved value: `grid`\n   --> /tmp/tmpe3qk8qtf.rs:38:16\n\
    \    |\n28  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |             ---- move occurs because `grid` has type `Vec<Vec<isize>>`,\
    \ which does not implement the `Copy` trait\n...\n31  |     for row in grid {\n\
    \    |                ---- `grid` moved due to this implicit call to `.into_iter()`\n\
    ...\n38  |     for row in grid {\n    |                ^^^^ value used here after\
    \ move\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `grid`\nhelp: consider iterating over a slice of the `Vec<Vec<isize>>`'s\
    \ content to avoid moving into the `for` loop\n    |\n31  |     for row in &grid\
    \ {\n    |                +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let (rows, cols) = (grid.len(), grid[0].len());\n   \
    \ let mut count = 0;\n    for col in 0..cols {\n        let mut filled = 0;\n\
    \        for row in 0..rows {\n            if grid[row][col] == 1 {\n        \
    \        filled += 1;\n            }\n        }\n        count += filled / capacity;\n\
    \        if filled % capacity > 0 {\n            count += 1;\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `5`', /tmp/tmpga2hcqps.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut rounds = 0;\n    for row in &grid {\n       \
    \ for i in 0..row.len() {\n            if row[i] == 1 {\n                let mut\
    \ buckets = 0;\n                let mut j = i;\n                while j < row.len()\
    \ && buckets < capacity {\n                    if row[j] == 1 {\n            \
    \            buckets += 1;\n                    }\n                    j += 1;\n\
    \                }\n                rounds += 1;\n                i = j - 1;\n\
    \            }\n        }\n    }\n    rounds\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "warning: value assigned to `i` is never read\n  --> /tmp/tmp0f7qcn18.rs:42:17\n\
    \   |\n42 |                 i = j - 1;\n   |                 ^\n   |\n   = note:\
    \ `#[warn(unused_assignments)]` on by default\n   = help: maybe it is overwritten\
    \ before being read?\n\nerror[E0384]: cannot assign twice to immutable variable\
    \ `i`\n  --> /tmp/tmp0f7qcn18.rs:42:17\n   |\n31 |         for i in 0..row.len()\
    \ {\n   |             -\n   |             |\n   |             first assignment\
    \ to `i`\n   |             help: consider making this binding mutable: `mut i`\n\
    ...\n42 |                 i = j - 1;\n   |                 ^^^^^^^^^ cannot assign\
    \ twice to immutable variable\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    // 0. Stabilize the grid: remove trailing rows of 0s\
    \ and cols of 0s.\n    let mut res = 0;\n    let mut grid = grid;\n    let mut\
    \ is_stable = false;\n    while !is_stable {\n        is_stable = true;\n    \
    \    for (i, row) in grid.iter().enumerate() {\n            if row.iter().all(|x|\
    \ *x == 0) {\n                grid.remove(i);\n                is_stable = false;\n\
    \                break;\n            }\n        }\n        for j in (0..grid[0].len()).rev()\
    \ {\n            if grid.iter().all(|row| row[j] == 0) {\n                for\
    \ row in grid.iter_mut() {\n                    row.remove(j);\n             \
    \   }\n                is_stable = false;\n                break;\n          \
    \  }\n        }\n    }\n    // 1. Find the lowest row (with the most water)\n\
    \    let mut lowest_row = None;\n    let mut lowest_row_water = 0;\n    for (i,\
    \ row) in grid.iter().enumerate() {\n        let row_water = row.iter().sum();\n\
    \        if row_water > lowest_row_water {\n            lowest_row = Some(i);\n\
    \            lowest_row_water = row_water;\n        }\n    }\n    // 2. Fill the\
    \ row\n    if let Some(lowest_row) = lowest_row {\n        let row = &grid[lowest_row];\n\
    \        let mut idx = 0;\n        let mut removed = 0;\n        while removed\
    \ < row.len() {\n            // 2.a. Find the next water puddle (of 1s).\n   \
    \         let mut next_water = None;\n            for (i, cell) in row.iter().enumerate()\
    \ {\n                if *cell == 1 {\n                    next_water = Some(i);\n\
    \                    break;\n                }\n            }\n            //\
    \ 2.b. Fill the puddle.\n            if let Some(water) = next_water {\n     \
    \           idx = water;\n                // 2.b.i. Remove water from the row.\n\
    \                let max_fill = capacity\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpuogaylij.rs:90:3\n\
    \   |\n28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                                              - unclosed delimiter\n\
    ...\n63 |     if let Some(lowest_row) = lowest_row {\n   |                   \
    \                       - unclosed delimiter\n...\n67 |         while removed\
    \ < row.len() {\n   |                                   - unclosed delimiter\n\
    ...\n77 |             if let Some(water) = next_water {\n   |                \
    \                             - this delimiter might not be properly closed...\n\
    ...\n81 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    90 | }\n   |   ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpuogaylij.rs:80:40\n\
    \   |\n80 |                 let max_fill = capacity\n   |                    \
    \                    ^ help: add `;` here\n81 | }\n   | - unexpected token\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpuogaylij.rs:67:9\n   |\n28 |   fn\
    \ max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n   |          \
    \                                                ----- expected `isize` because\
    \ of return type\n...\n67 | /         while removed < row.len() {\n68 | |    \
    \         // 2.a. Find the next water puddle (of 1s).\n69 | |             let\
    \ mut next_water = None;\n70 | |             for (i, cell) in row.iter().enumerate()\
    \ {\n...  |\n89 | |     assert_eq!(candidate(vec![vec![1, 1, 1, 1], vec![1, 1,\
    \ 1, 1]], 9), 2);\n90 | | }\n   | |__^ expected `isize`, found `()`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut row_min = isize::MAX;\n    let mut col_min =\
    \ vec![isize::MAX; grid[0].len()];\n    for r in 0..grid.len() {\n        for\
    \ c in 0..grid[0].len() {\n            row_min = isize::min(row_min, grid[r][c]);\n\
    \            col_min[c] = isize::min(col_min[c], grid[r][c]);\n        }\n   \
    \ }\n    let mut steps = 0;\n    for r in 0..grid.len() {\n        for c in 0..grid[0].len()\
    \ {\n            steps += grid[r][c] - row_min - col_min[c];\n        }\n    }\n\
    \    steps * capacity\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `18`,\n right: `5`', /tmp/tmpgojqt7dr.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let (rows, cols) = (grid.len(), grid[0].len());\n   \
    \ let mut grid = grid;\n    let mut fill_count = 0;\n    for col in 0..cols {\n\
    \        for row in 0..rows {\n            let water = grid[row][col];\n     \
    \       fill_count += (water + capacity - 1) / capacity;\n            grid[row][col]\
    \ = 0;\n        }\n    }\n    fill_count\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmpxokjt0e3.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut result = 0;\n    for row in grid {\n        let\
    \ mut open = false;\n        let mut water = 0;\n        for (idx, cell) in row.iter().enumerate()\
    \ {\n            if *cell == 1 {\n                if open {\n                \
    \    let room = capacity - water;\n                    if room > 0 {\n       \
    \                 result += room;\n                        water = capacity;\n\
    \                    }\n                } else {\n                    open = true;\n\
    \                    water = 1;\n                }\n            } else if open\
    \ {\n                water -= 1;\n                if water == 0 {\n          \
    \          open = false;\n                }\n            }\n        }\n      \
    \  if water > 0 {\n            result += capacity - water;\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `6`', /tmp/tmpptzzq611.rs:61:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    use std::cmp::max;\n    let n = grid.len();\n    let\
    \ m = grid[0].len();\n    let mut fill = vec![vec![false; m]; n];\n    let mut\
    \ res = 0;\n    for i in 0..n {\n        for j in 0..m {\n            if grid[i][j]\
    \ == 1 {\n                res += 1;\n                let mut empty = capacity;\n\
    \                for k in 0..=i {\n                    for l in 0..=j {\n    \
    \                    if grid[k][l] == 1 {\n                            if fill[k][l]\
    \ { empty += 1; }\n                            else {\n                      \
    \          empty -= 1;\n                                if empty == 0 { break;\
    \ }\n                            }\n                        }\n              \
    \      }\n                    if empty == 0 { break; }\n                }\n  \
    \              if empty > 0 {\n                    res += 1;\n               \
    \     for k in 0..=i {\n                        for l in 0..=j {\n           \
    \                 if grid[k][l] == 1 {\n                                fill[k][l]\
    \ = true;\n                            }\n                        }\n        \
    \            }\n                }\n            }\n        }\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `18`,\n right: `5`', /tmp/tmpzduozsve.rs:70:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let m = grid.len();\n    let n = grid[0].len();\n   \
    \ let mut ans = 0;\n    for i in 0..m {\n        for j in 0..n {\n           \
    \ if grid[i][j] > 0 {\n                ans += grid[i][j] / capacity;\n       \
    \         if grid[i][j] % capacity > 0 {\n                    ans += 1;\n    \
    \            }\n            }\n        }\n    }\n    ans\n}\n\nfn main() {\n \
    \   let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmppqmn0n8f.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let row_count = grid.len();\n    let col_count = grid[0].len();\n\
    \    let mut total = 0isize;\n    for row in grid {\n        for unit in row {\n\
    \            total += unit;\n        }\n    }\n    let total_fill = total / capacity;\n\
    \    let target_per_row = total_fill / row_count as isize;\n    let extra = total_fill\
    \ % row_count as isize;\n    let mut bucket_count = 0isize;\n    for row in grid\
    \ {\n        let mut target = target_per_row;\n        if extra > 0 {\n      \
    \      target += 1;\n            extra -= 1;\n        }\n        let mut fill\
    \ = 0isize;\n        for unit in row {\n            fill += unit;\n          \
    \  if fill >= target {\n                fill = 0;\n                bucket_count\
    \ += 1;\n            }\n        }\n        if fill > 0 {\n            bucket_count\
    \ += 1;\n        }\n    }\n    bucket_count\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `col_count`\n  --> /tmp/tmpcsp1h7ty.rs:30:9\n\
    \   |\n30 |     let col_count = grid[0].len();\n   |         ^^^^^^^^^ help: if\
    \ this is intentional, prefix it with an underscore: `_col_count`\n   |\n   =\
    \ note: `#[warn(unused_variables)]` on by default\n\nerror[E0382]: use of moved\
    \ value: `grid`\n   --> /tmp/tmpcsp1h7ty.rs:41:16\n    |\n28  | fn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    |             ---- move occurs\
    \ because `grid` has type `Vec<Vec<isize>>`, which does not implement the `Copy`\
    \ trait\n...\n32  |     for row in grid {\n    |                ---- `grid` moved\
    \ due to this implicit call to `.into_iter()`\n...\n41  |     for row in grid\
    \ {\n    |                ^^^^ value used here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `grid`\nhelp: consider iterating\
    \ over a slice of the `Vec<Vec<isize>>`'s content to avoid moving into the `for`\
    \ loop\n    |\n32  |     for row in &grid {\n    |                +\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `extra`\n  --> /tmp/tmpcsp1h7ty.rs:45:13\n\
    \   |\n39 |     let extra = total_fill % row_count as isize;\n   |         -----\n\
    \   |         |\n   |         first assignment to `extra`\n   |         help:\
    \ consider making this binding mutable: `mut extra`\n...\n45 |             extra\
    \ -= 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\
    \nerror: aborting due to 2 previous errors; 1 warning emitted\n\nSome errors have\
    \ detailed explanations: E0382, E0384.\nFor more information about an error, try\
    \ `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut fill_count = 0;\n    for i in 0..grid.len() {\n\
    \        for j in 0..grid[i].len() {\n            if grid[i][j] == 1 {\n     \
    \           fill_count += 1;\n                let water = min(capacity, grid[i].iter().sum());\n\
    \                for k in 0..grid[i].len() {\n                    grid[i][k] -=\
    \ water;\n                }\n            }\n        }\n    }\n    fill_count\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `min` in this scope\n  --> /tmp/tmpw3l_hu2d.rs:34:29\n\
    \   |\n34 |                 let water = min(capacity, grid[i].iter().sum());\n\
    \   |                             ^^^\n...\n44 | fn main() {\n   | --------- similarly\
    \ named function `main` defined here\n   |\nhelp: a function with a similar name\
    \ exists\n   |\n34 |                 let water = main(capacity, grid[i].iter().sum());\n\
    \   |                             ~~~~\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::min;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let rows = grid.len();\n    let cols = grid[0].len();\n\
    \    let mut fill = 0;\n    for i in 0..rows {\n        for j in 0..cols {\n \
    \           if grid[i][j] == 1 {\n                fill += 1;\n            }\n\
    \        }\n    }\n    let num_bins = fill / capacity;\n    if num_bins == 0 {\n\
    \        return 0;\n    }\n    let bin_size = fill / num_bins;\n    let mut filled\
    \ = vec![vec![0; cols]; rows];\n    for i in 0..rows {\n        for j in 0..cols\
    \ {\n            filled[i][j] = grid[i][j];\n        }\n    }\n    let mut times\
    \ = 0;\n    while times < rows {\n        let mut done = false;\n        for i\
    \ in 0..rows {\n            let mut num_filled = 0;\n            for j in 0..cols\
    \ {\n                if filled[i][j] == 1 {\n                    num_filled +=\
    \ 1;\n                }\n            }\n            if num_filled > bin_size {\n\
    \                done = true;\n                filled[i] = vec![0; cols];\n  \
    \          }\n        }\n        if !done {\n            break;\n        }\n \
    \       times += 1;\n    }\n    return num_bins * times;\n}\n\nfn main() {\n \
    \   let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0s9c3w9z.rs:70:23\n   |\n\
    70 |     return num_bins * times;\n   |                       ^^^^^ expected `isize`,\
    \ found `usize`\n\nerror[E0277]: cannot multiply `isize` by `usize`\n  --> /tmp/tmp0s9c3w9z.rs:70:21\n\
    \   |\n70 |     return num_bins * times;\n   |                     ^ no implementation\
    \ for `isize * usize`\n   |\n   = help: the trait `Mul<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Mul<Rhs>`:\n\
    \             <&'a f32 as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n    \
    \         <&'a i128 as Mul<i128>>\n             <&'a i16 as Mul<i16>>\n      \
    \       <&'a i32 as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n          \
    \   <&'a i8 as Mul<i8>>\n             <&'a isize as Mul<isize>>\n           and\
    \ 49 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut drops = 0;\n    for mut row in grid {\n     \
    \   for j in 0..row.len() {\n            if row[j] == 0 {\n                continue;\n\
    \            }\n            drops += 1;\n            let mut j = j;\n        \
    \    while j < row.len() && row[j] > 0 {\n                row[j] -= 1;\n     \
    \           j += 1;\n            }\n        }\n    }\n    drops\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmpt_0ap5i7.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let n = grid.len();\n    let m = grid[0].len();\n   \
    \ let mut g = vec![vec![0_isize; m]; n];\n    let mut times = 0;\n    for i in\
    \ 0..n {\n        for j in 0..m {\n            if grid[i][j] == 1 {\n        \
    \        g[i][j] = capacity;\n                times += 1;\n            }\n   \
    \     }\n    }\n    let mut ne = 0;\n    let mut st = 0;\n    let mut rs = 0;\n\
    \    let mut co = 0;\n    for i in 0..n {\n        for j in 0..m {\n         \
    \   if g[i][j] > 0 {\n                ne += 1;\n                st += g[i][j];\n\
    \                rs += i as isize;\n                co += j as isize;\n      \
    \      }\n        }\n    }\n    let row = (rs / ne) as usize;\n    let col = (co\
    \ / ne) as usize;\n    let q = (st / ne) as usize;\n    if ne == 0 {\n       \
    \ return 0;\n    }\n    let mut p = vec![vec![0_isize; m]; n];\n    let mut u\
    \ = vec![vec![false; m]; n];\n    for i in 0..n {\n        for j in 0..m {\n \
    \           if g[i][j] > 0 {\n                p[i][j] = 1;\n            }\n  \
    \      }\n    }\n    let mut dfs = |i: usize, j: usize| {\n        if i < 0 ||\
    \ i >= n || j < 0 || j >= m || u[i][j] || p[i][j] == 0 {\n            return;\n\
    \        }\n        u[i][j] = true;\n        dfs(i - 1, j);\n        dfs(i + 1,\
    \ j);\n        dfs(i, j - 1);\n        dfs(i, j + 1);\n    };\n    dfs(row, col);\n\
    \    let mut p1 = vec![vec![0_isize; m]; n];\n    let mut times =\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmppd967xpy.rs:83:1\n\
    \   |\n83 | }\n   | ^ expected expression\n\nerror[E0425]: cannot find function\
    \ `dfs` in this scope\n  --> /tmp/tmppd967xpy.rs:75:9\n   |\n75 |         dfs(i\
    \ - 1, j);\n   |         ^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `dfs` in this scope\n  --> /tmp/tmppd967xpy.rs:76:9\n   |\n76 |   \
    \      dfs(i + 1, j);\n   |         ^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `dfs` in this scope\n  --> /tmp/tmppd967xpy.rs:77:9\n \
    \  |\n77 |         dfs(i, j - 1);\n   |         ^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `dfs` in this scope\n  --> /tmp/tmppd967xpy.rs:78:9\n\
    \   |\n78 |         dfs(i, j + 1);\n   |         ^^^ not found in this scope\n\
    \nerror: aborting due to 5 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    use std::cmp::min;\n    let rows = grid.len();\n    let\
    \ cols = grid[0].len();\n    let mut fill_count = 0;\n    for row in grid {\n\
    \        for &water in row {\n            fill_count += min(water, capacity);\n\
    \        }\n    }\n    let mut max_water = 0;\n    for i in 0..rows {\n      \
    \  for j in 0..cols {\n            max_water = max_water.max(grid[i][j]);\n  \
    \      }\n    }\n    let mut min_capacity = capacity;\n    for i in 0..rows {\n\
    \        let mut capacity = capacity;\n        for j in 0..cols {\n          \
    \  capacity = min(capacity, grid[i][j]);\n        }\n        min_capacity = min(min_capacity,\
    \ capacity);\n    }\n    let mut row_capacity = capacity;\n    for i in 0..rows\
    \ {\n        for j in 0..cols {\n            row_capacity = min(row_capacity,\
    \ grid[i][j]);\n        }\n        fill_count += row_capacity;\n        row_capacity\
    \ = capacity;\n    }\n    let mut col_capacity = capacity;\n    for j in 0..cols\
    \ {\n        for i in 0..rows {\n            col_capacity = min(col_capacity,\
    \ grid[i][j]);\n        }\n        fill_count += col_capacity;\n        col_capacity\
    \ = capacity;\n    }\n    fill_count += max_water - min_capacity;\n    fill_count\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpeinq70sq.rs:34:13\n   |\n\
    34 |         for &water in row {\n   |             ^^^^^^    --- this expression\
    \ has type `Option<isize>`\n   |             |\n   |             expected `isize`,\
    \ found reference\n   |             help: you can probably remove the explicit\
    \ borrow: `water`\n   |\n   = note:   expected type `isize`\n           found\
    \ reference `&_`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let n = grid.len();\n    let m = grid[0].len();\n   \
    \ let mut acc = vec![vec![0; m]; n];\n    for i in 0..n {\n        for j in 0..m\
    \ {\n            acc[i][j] = grid[i][j] + if i > 0 { acc[i - 1][j] } else { 0\
    \ };\n        }\n    }\n    let mut max = 0;\n    for i in 0..n {\n        for\
    \ j in i..n {\n            let mut cnt = 0;\n            for k in 0..m {\n   \
    \             cnt += acc[j][k] - if i > 0 { acc[i - 1][k] } else { 0 };\n    \
    \            if cnt > capacity {\n                    break;\n               \
    \ }\n            }\n            if cnt <= capacity {\n                max = max.max(j\
    \ - i + 1);\n            }\n        }\n    }\n    let mut res = 0;\n    for i\
    \ in 0..n {\n        res += n - max;\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprm26cnh0.rs:56:5\n   |\n\
    28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n   |    \
    \                                                    ----- expected `isize` because\
    \ of return type\n...\n56 |     res\n   |     ^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n56 |     res.try_into().unwrap()\n   |        ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let height = grid.len();\n    let width = grid[0].len();\n\
    \    let mut fill_matrix = vec![vec![0isize; width]; height];\n    let mut max_fill\
    \ = 0;\n    for i in 0..height {\n        for j in 0..width {\n            max_fill\
    \ = fill_matrix[i][j] = grid[i][j] + max_fill;\n        }\n    }\n    let mut\
    \ wells_to_fill = 0;\n    for i in 0..height {\n        for j in 0..width {\n\
    \            let cell_fill = fill_matrix[i][j];\n            if cell_fill > 0\
    \ {\n                wells_to_fill += 1;\n                let mut cell_fill =\
    \ cell_fill;\n                let mut k = i + 1;\n                while k < height\
    \ && cell_fill > 0 {\n                    cell_fill = fill_matrix[k][j].min(cell_fill);\n\
    \                    fill_matrix[k][j] -= cell_fill;\n                    k +=\
    \ 1;\n                }\n            }\n        }\n    }\n    wells_to_fill\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw7t0y6s2.rs:35:24\n   |\n\
    32 |     let mut max_fill = 0;\n   |                        - expected due to\
    \ this value\n...\n35 |             max_fill = fill_matrix[i][j] = grid[i][j]\
    \ + max_fill;\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `()`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let n = grid.len();\n    let m = grid[0].len();\n   \
    \ let mut result = 0;\n    for i in 0..n {\n        let mut max_fill = 0;\n  \
    \      for j in 0..m {\n            max_fill = max(max_fill, grid[i][j]);\n  \
    \      }\n        result += max_fill;\n        for j in 0..m {\n            grid[i][j]\
    \ = max_fill - grid[i][j];\n        }\n    }\n    for j in 0..m {\n        let\
    \ mut max_fill = 0;\n        for i in 0..n {\n            max_fill = max(max_fill,\
    \ grid[i][j]);\n        }\n        result += max_fill;\n        for i in 0..n\
    \ {\n            grid[i][j] = max_fill - grid[i][j];\n        }\n    }\n    result\
    \ + n*m\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpzzv2mu19.rs:35:24\n\
    \   |\n35 |             max_fill = max(max_fill, grid[i][j]);\n   |          \
    \              ^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]: cannot find function\
    \ `max` in this scope\n  --> /tmp/tmpzzv2mu19.rs:45:24\n   |\n45 |           \
    \  max_fill = max(max_fill, grid[i][j]);\n   |                        ^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this function\n   |\n1 \
    \ | use std::cmp::max;\n   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzzv2mu19.rs:52:14\n\
    \   |\n52 |     result + n*m\n   |              ^^^ expected `isize`, found `usize`\n\
    \nerror[E0277]: cannot add `usize` to `isize`\n  --> /tmp/tmpzzv2mu19.rs:52:12\n\
    \   |\n52 |     result + n*m\n   |            ^ no implementation for `isize +\
    \ usize`\n   |\n   = help: the trait `Add<usize>` is not implemented for `isize`\n\
    \   = help: the following other types implement trait `Add<Rhs>`:\n          \
    \   <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a\
    \ i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n             <&'a i32\
    \ as Add<i32>>\n             <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n\
    \             <&'a isize as Add<isize>>\n           and 48 others\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut well = grid;\n    let mut count = 0;\n    let\
    \ columns = well[0].len();\n    for _ in 0..columns {\n        for j in 0..well.len()\
    \ {\n            let mut i = 0;\n            while i < well[j].len() && well[j][i]\
    \ == 0 {\n                i += 1;\n            }\n            if i == well[j].len()\
    \ {\n                break;\n            }\n            well[j][i] = 0;\n    \
    \        let mut remaining = capacity - 1;\n            while remaining > 0 {\n\
    \                i += 1;\n                if i == well[j].len() {\n          \
    \          count += 1;\n                    break;\n                }\n      \
    \          if well[j][i] == 1 {\n                    well[j][i] = 0;\n       \
    \             remaining -= 1;\n                }\n            }\n        }\n \
    \   }\n    count\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `6`', /tmp/tmpzq_3_e6z.rs:61:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let n = grid.len();\n    let m = grid[0].len();\n   \
    \ let mut ans = 0;\n    for i in 0..n {\n        for j in 0..m {\n           \
    \ if grid[i][j] == 1 {\n                ans += 1;\n                let mut stack\
    \ = vec![(i, j)];\n                while let Some((i, j)) = stack.pop() {\n  \
    \                  if i as isize - 1 >= 0 {\n                        let mut fill\
    \ = grid[i - 1][j];\n                        if fill + grid[i][j] > capacity {\n\
    \                            fill = capacity - grid[i][j];\n                 \
    \       }\n                        grid[i - 1][j] -= fill;\n                 \
    \       grid[i][j] += fill;\n                        if grid[i - 1][j] == 0 {\n\
    \                            stack.push((i - 1, j));\n                       \
    \ }\n                    }\n                    if i + 1 < n {\n             \
    \           let mut fill = grid[i + 1][j];\n                        if fill +\
    \ grid[i][j] > capacity {\n                            fill = capacity - grid[i][j];\n\
    \                        }\n                        grid[i + 1][j] -= fill;\n\
    \                        grid[i][j] += fill;\n                        if grid[i\
    \ + 1][j] == 0 {\n                            stack.push((i + 1, j));\n      \
    \                  }\n                    }\n                    if j as isize\
    \ - 1 >= 0 {\n                        let mut fill = grid[i][j - 1];\n       \
    \                 if fill + grid[i][j] > capacity {\n                        \
    \    fill = capacity - grid[i][j];\n                        }\n              \
    \          grid[i][j - 1] -= fill;\n                        grid[i][j] += fill;\n\
    \                        if grid[i][j - 1] == 0 {\n                          \
    \  stack.push((i, j - 1));\n                        }\n                    }\n\
    \                    if j + 1 < m {\n                        let mut fill = grid[i][j\
    \ + 1];\n                        if fill + grid[i][j] > capacity {\n         \
    \                   fill = capacity - grid[i][j];\n                        }\n\
    \                        grid[i][j + 1] -= fill;\n                        grid[i][j]\
    \ += fill;\n                        if grid\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp5aiqxy1s.rs:88:3\n\
    \   |\n28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                                              - unclosed delimiter\n\
    ...\n32 |     for i in 0..n {\n   |                   - unclosed delimiter\n33\
    \ |         for j in 0..m {\n   |                       - unclosed delimiter\n\
    34 |             if grid[i][j] == 1 {\n   |                                - unclosed\
    \ delimiter\n...\n37 |                 while let Some((i, j)) = stack.pop() {\n\
    \   |                                                      - unclosed delimiter\n\
    ...\n71 |                     if j + 1 < m {\n   |                           \
    \       - this delimiter might not be properly closed...\n...\n79 | }\n   | -\
    \ ...as it matches this but it has different indentation\n...\n88 | }\n   |  \
    \ ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmp5aiqxy1s.rs:79:1\n   |\n\
    78 |                         if grid\n   |                         -- this `if`\
    \ expression has a condition, but no block\n79 | }\n   | ^ expected `{`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5aiqxy1s.rs:32:5\n   |\n28 |   fn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n   |                         \
    \                                 ----- expected `isize` because of return type\n\
    ...\n32 | /     for i in 0..n {\n33 | |         for j in 0..m {\n34 | |      \
    \       if grid[i][j] == 1 {\n35 | |                 ans += 1;\n...  |\n87 | |\
    \     assert_eq!(candidate(vec![vec![1, 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n\
    88 | | }\n   | |__^ expected `isize`, found `()`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    // TODO\n    0\n}\n\nfn main() {\n    let candidate =\
    \ max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `6`', /tmp/tmp14n88gpk.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let n = grid.len();\n    let m = grid[0].len();\n   \
    \ let mut fill_grid = vec![vec![0; m]; n];\n    for i in 0..n {\n        for j\
    \ in 0..m {\n            fill_grid[i][j] = grid[i][j] * capacity;\n        }\n\
    \    }\n    let mut sum = 0;\n    for i in 0..n {\n        for j in 0..m {\n \
    \           if fill_grid[i][j] > 0 {\n                let val = fill_grid[i][j];\n\
    \                sum += val;\n                if i + 1 < n {\n               \
    \     fill_grid[i + 1][j] += val;\n                }\n                if j + 1\
    \ < m {\n                    fill_grid[i][j + 1] += val;\n                }\n\
    \            }\n        }\n    }\n    sum\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `28`,\n right: `6`', /tmp/tmpawx7yci0.rs:57:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let (rows, cols) = (grid.len(), grid[0].len());\n   \
    \ let mut heights = vec![0; cols];\n    let mut levels = vec![0; cols];\n    let\
    \ mut low = 0;\n    let mut high = capacity;\n    let mut ans = 0;\n    while\
    \ low <= high {\n        let mid = low + (high - low) / 2;\n        let mut ok\
    \ = true;\n        for col in 0..cols {\n            heights[col] = 0;\n     \
    \       levels[col] = mid;\n        }\n        for row in 0..rows {\n        \
    \    let mut bucket = capacity;\n            for col in 0..cols {\n          \
    \      let height = heights[col];\n                if grid[row][col] == 1 {\n\
    \                    heights[col] += 1;\n                } else {\n          \
    \          heights[col] = 0;\n                }\n                if levels[col]\
    \ >= height {\n                    levels[col] -= height;\n                } else\
    \ {\n                    ok = false;\n                    break;\n           \
    \     }\n                if levels[col] < bucket {\n                    bucket\
    \ = levels[col];\n                }\n            }\n            if !ok {\n   \
    \             break;\n            }\n            for col in 0..cols {\n      \
    \          levels[col] = std::cmp::min(bucket, levels[col]);\n            }\n\
    \        }\n        if ok {\n            ans = mid;\n            low = mid + 1;\n\
    \        } else {\n            high = mid - 1;\n        }\n    }\n    ans\n}\n\
    \nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `6`', /tmp/tmpgopjvy43.rs:80:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    // The number of buckets required is the sum of water\
    \ in each row,\n    // and the minimum number of buckets required to empty a row\
    \ is\n    // the number of water units in that row over the capacity of a bucket.\n\
    \    grid.iter().map(|row| row.iter().sum::<isize>()).sum::<isize>() -\n    grid.iter().map(|row|\
    \ row.iter().sum::<isize>() / capacity +\n        if row.iter().sum::<isize>()\
    \ % capacity == 0 { 0 } else { 1 }).sum::<isize>()\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `6`', /tmp/tmpvlld4wk0.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let (mut filled, mut count) = (capacity, 0);\n    for\
    \ row in grid {\n        for &unit in &row {\n            if unit > filled {\n\
    \                count += 1;\n                filled = capacity;\n           \
    \ }\n            filled -= unit;\n        }\n        if filled < capacity {\n\
    \            count += 1;\n            filled = capacity;\n        }\n    }\n \
    \   count\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut iter = std::iter::from_fn(||\
    \ {\n        let max = grid.iter().fold(0, |max, &row| max.max(row.iter().sum()));\n\
    \        if max == 0 { None } else { Some(max) }\n    });\n    let mut result\
    \ = 0;\n    while let Some(max) = iter.next() {\n        let mut count = max /\
    \ capacity;\n        result += count;\n        for row in &mut grid {\n      \
    \      for cell in row {\n                if *cell > 0 {\n                   \
    \ if *cell > capacity {\n                        *cell -= capacity;\n        \
    \            } else {\n                        *cell = 0;\n                  \
    \  }\n                }\n            }\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0507]: cannot move out of a shared reference\n  --> /tmp/tmp0qxj4xs5.rs:31:45\n\
    \   |\n31 |         let max = grid.iter().fold(0, |max, &row| max.max(row.iter().sum()));\n\
    \   |                                             ^---\n   |                 \
    \                            ||\n   |                                        \
    \     |data moved here\n   |                                             |move\
    \ occurs because `row` has type `Vec<isize>`, which does not implement the `Copy`\
    \ trait\n   |                                             help: consider removing\
    \ the `&`: `row`\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmp0qxj4xs5.rs:36:13\n\
    \   |\n36 |         let mut count = max / capacity;\n   |             ----^^^^^\n\
    \   |             |\n   |             help: remove this `mut`\n   |\n   = note:\
    \ `#[warn(unused_mut)]` on by default\n\nerror[E0502]: cannot borrow `grid` as\
    \ mutable because it is also borrowed as immutable\n  --> /tmp/tmp0qxj4xs5.rs:38:20\n\
    \   |\n30 |     let mut iter = std::iter::from_fn(|| {\n   |                 \
    \                      -- immutable borrow occurs here\n31 |         let max =\
    \ grid.iter().fold(0, |max, &row| max.max(row.iter().sum()));\n   |          \
    \         ---- first borrow occurs due to use of `grid` in closure\n...\n35 |\
    \     while let Some(max) = iter.next() {\n   |                           -----------\
    \ immutable borrow later used here\n...\n38 |         for row in &mut grid {\n\
    \   |                    ^^^^^^^^^ mutable borrow occurs here\n\nerror: aborting\
    \ due to 2 previous errors; 1 warning emitted\n\nSome errors have detailed explanations:\
    \ E0502, E0507.\nFor more information about an error, try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    0\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `6`', /tmp/tmpbi39lcrk.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut r = 0;\n    for row in grid {\n        let mut\
    \ drop = capacity;\n        for cell in row {\n            drop -= cell;\n   \
    \         if drop < 0 {\n                drop = capacity - cell;\n           \
    \     r += 1;\n            }\n        }\n        if drop < capacity {\n      \
    \      r += 1;\n        }\n    }\n    r\n}\n\nfn main() {\n    let candidate =\
    \ max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let n = grid.len();\n    let m = grid[0].len();\n   \
    \ let mut fill_time = 0;\n    let mut to_fill = vec![vec![0; m]; n];\n    for\
    \ i in 0..n {\n        for j in 0..m {\n            if grid[i][j] > 0 {\n    \
    \            to_fill[i][j] = grid[i][j];\n            }\n        }\n    }\n  \
    \  while true {\n        let mut not_empty = false;\n        for i in 0..n {\n\
    \            for j in 0..m {\n                if to_fill[i][j] > 0 {\n       \
    \             not_empty = true;\n                    let to_transfer = to_fill[i][j].min(capacity);\n\
    \                    if i > 0 {\n                        to_fill[i - 1][j] +=\
    \ to_transfer;\n                    }\n                    if i < n - 1 {\n  \
    \                      to_fill[i + 1][j] += to_transfer;\n                   \
    \ }\n                    if j > 0 {\n                        to_fill[i][j - 1]\
    \ += to_transfer;\n                    }\n                    if j < m - 1 {\n\
    \                        to_fill[i][j + 1] += to_transfer;\n                 \
    \   }\n                    to_fill[i][j] -= to_transfer;\n                }\n\
    \            }\n        }\n        if not_empty {\n            fill_time += 1;\n\
    \        } else {\n            break;\n        }\n    }\n    fill_time\n}\n\n\
    fn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut res = 0;\n    for row in &grid {\n        let\
    \ mut sum = 0;\n        for c in row {\n            sum += c;\n        }\n   \
    \     if sum == 0 {\n            continue;\n        }\n        res += sum / capacity;\n\
    \        if sum % capacity > 0 {\n            res += 1;\n        }\n    }\n  \
    \  res\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    use std::cmp::max;\n    // calculate the max height of\
    \ each column\n    let max_height = grid.iter().fold(vec![0; grid[0].len()], |mut\
    \ max_height, row| {\n        for (height, water) in max_height.iter_mut().zip(row.iter())\
    \ {\n            *height = max(*height, *water);\n        }\n        max_height\n\
    \    });\n    // calculate the max bucket drops needed to empty each well\n  \
    \  let max_drops = grid.iter().map(|row| {\n        let max_water = row.iter().max().unwrap();\n\
    \        max_water / capacity + max_water % capacity\n    }).sum();\n    // calculate\
    \ the max bucket drops needed to fill each well\n    let max_drops = max_height.iter().fold(max_drops,\
    \ |max_drops, height| {\n        max_drops + height / capacity + height % capacity\n\
    \    });\n    max_drops\n}\n\nfn main() {\n    let candidate = max_fill;\n   \
    \ assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1,\
    \ 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0,\
    \ 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `6`', /tmp/tmpnaz85moi.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let n = grid.len();\n    let m = grid[0].len();\n   \
    \ let mut pqueue = BinaryHeap::new();\n    for i in 0..n {\n        let mut max\
    \ = 0;\n        for j in 0..m {\n            max = max.max(grid[i][j]);\n    \
    \    }\n        if max > 0 {\n            pqueue.push(State { row: i, level: max,\
    \ count: 0 });\n        }\n    }\n    let mut ret = 0;\n    while let Some(s)\
    \ = pqueue.pop() {\n        if s.count > ret {\n            ret = s.count;\n \
    \       }\n        let mut need = s.level;\n        for i in 0..n {\n        \
    \    if i == s.row {\n                continue;\n            }\n            for\
    \ j in 0..m {\n                if grid[i][j] < need {\n                    need\
    \ -= grid[i][j];\n                    grid[i][j] = 0;\n                } else\
    \ {\n                    grid[i][j] -= need;\n                    break;\n   \
    \             }\n            }\n        }\n        if need > 0 {\n           \
    \ let mut need = s.level;\n            for i in 0..n {\n                if i ==\
    \ s.row {\n                    continue;\n                }\n                for\
    \ j in 0..m {\n                    if grid[i][j] < need {\n                  \
    \      need -= grid[i][j];\n                        grid[i][j] = 0;\n        \
    \            } else {\n                        grid[i][j] -= need;\n         \
    \               break;\n                    }\n                }\n           \
    \ }\n            if need > 0 {\n                let mut need = s.level;\n    \
    \            for i in 0..n {\n                    if i == s.row {\n          \
    \              continue;\n                    }\n                    for j in\
    \ 0..m {\n                        if grid[i][j] < need {\n                   \
    \         need -= grid[i][j];\n                            grid[i][j] = 0;\n \
    \                       } else {\n                            grid[i][j] -= need;\n\
    \                            break;\n                        }\n             \
    \       }\n                }\n                if need > 0 {\n                \
    \    ret += (need + capacity - 1) / capacity;\n               \n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmptz7apeps.rs:105:3\n\
    \    |\n28  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |                                                              - unclosed\
    \ delimiter\n...\n42  |     while let Some(s) = pqueue.pop() {\n    |        \
    \                              - unclosed delimiter\n...\n61  |         if need\
    \ > 0 {\n    |                     - unclosed delimiter\n...\n77  |          \
    \   if need > 0 {\n    |                         - unclosed delimiter\n...\n93\
    \  |                 if need > 0 {\n    |                             - this delimiter\
    \ might not be properly closed...\n...\n96  | }\n    | - ...as it matches this\
    \ but it has different indentation\n...\n105 | }\n    |   ^\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `BinaryHeap`\n  --> /tmp/tmptz7apeps.rs:31:22\n\
    \   |\n31 |     let mut pqueue = BinaryHeap::new();\n   |                    \
    \  ^^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::BinaryHeap;\n   |\n\nerror[E0422]: cannot find\
    \ struct, variant or union type `State` in this scope\n  --> /tmp/tmptz7apeps.rs:38:25\n\
    \   |\n38 |             pqueue.push(State { row: i, level: max, count: 0 });\n\
    \   |                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n   --> /tmp/tmptz7apeps.rs:42:5\n    |\n28  |   fn max_fill(grid: Vec<Vec<isize>>,\
    \ capacity: isize) -> isize {\n    |                                         \
    \                 ----- expected `isize` because of return type\n...\n42  | /\
    \     while let Some(s) = pqueue.pop() {\n43  | |         if s.count > ret {\n\
    44  | |             ret = s.count;\n45  | |         }\n...   |\n104 | |     assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n105 | | }\n    | |__^ expected `isize`,\
    \ found `()`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0422, E0433.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max = 0;\n    for row in grid {\n        for\
    \ &water in row {\n            if water > max {\n                max = water;\n\
    \            }\n        }\n    }\n    let mut buckets = vec![0; max as usize];\n\
    \    for row in grid {\n        for &water in row {\n            if water > 0\
    \ {\n                buckets[(water - 1) as usize] += 1;\n            }\n    \
    \    }\n    }\n    buckets.iter().fold(0, |acc, x| acc + (x + capacity - 1) /\
    \ capacity)\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj_ss5omz.rs:31:13\n   |\n\
    31 |         for &water in row {\n   |             ^^^^^^    --- this expression\
    \ has type `Option<isize>`\n   |             |\n   |             expected `isize`,\
    \ found reference\n   |             help: you can probably remove the explicit\
    \ borrow: `water`\n   |\n   = note:   expected type `isize`\n           found\
    \ reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj_ss5omz.rs:39:13\n\
    \   |\n39 |         for &water in row {\n   |             ^^^^^^    --- this expression\
    \ has type `Option<isize>`\n   |             |\n   |             expected `isize`,\
    \ found reference\n   |             help: you can probably remove the explicit\
    \ borrow: `water`\n   |\n   = note:   expected type `isize`\n           found\
    \ reference `&_`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let n = grid.len();\n    let m = grid[0].len();\n   \
    \ let mut count = 0;\n    for i in 0..n {\n        let mut cur = 0;\n        for\
    \ j in 0..m {\n            cur += grid[i][j];\n            if cur >= capacity\
    \ {\n                count += 1;\n                cur = 0;\n            }\n  \
    \      }\n        if cur > 0 {\n            count += 1;\n        }\n    }\n  \
    \  count\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    if grid.is_empty() || grid[0].is_empty() {\n        return\
    \ 0;\n    }\n    let (m, n) = (grid.len(), grid[0].len());\n    let mut dp = vec![vec![0;\
    \ n]; m];\n    for i in 0..m {\n        for j in 0..n {\n            if grid[i][j]\
    \ == 1 {\n                if i == 0 {\n                    dp[i][j] = capacity;\n\
    \                } else {\n                    dp[i][j] = dp[i - 1][j] + capacity;\n\
    \                }\n            }\n        }\n    }\n    // find the min of the\
    \ last row\n    let mut min = dp[m - 1][0];\n    for i in 1..n {\n        min\
    \ = min.min(dp[m - 1][i]);\n    }\n    // fill the upper rows\n    for i in (0..m\
    \ - 1).rev() {\n        for j in 0..n {\n            if dp[i][j] != 0 {\n    \
    \            dp[i][j] = dp[i][j].min(min);\n            }\n        }\n       \
    \ // update the min\n        min = dp[i][0];\n        for j in 1..n {\n      \
    \      min = min.min(dp[i][j]);\n        }\n    }\n    min\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `6`', /tmp/tmpxkjvjjxo.rs:68:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let n = grid.len();\n    let m = grid[0].len();\n   \
    \ let mut res = 0;\n    let mut visit = vec![vec![false; m]; n];\n    let mut\
    \ stack = Vec::new();\n    for i in 0..n {\n        for j in 0..m {\n        \
    \    if grid[i][j] == 1 && !visit[i][j] {\n                stack.push((i, j));\n\
    \                visit[i][j] = true;\n                let mut cur_fill = 1;\n\
    \                while let Some((i, j)) = stack.pop() {\n                    if\
    \ j + 1 < m && grid[i][j + 1] == 1 && !visit[i][j + 1] {\n                   \
    \     stack.push((i, j + 1));\n                        visit[i][j + 1] = true;\n\
    \                        cur_fill += 1;\n                    }\n             \
    \       if j > 0 && grid[i][j - 1] == 1 && !visit[i][j - 1] {\n              \
    \          stack.push((i, j - 1));\n                        visit[i][j - 1] =\
    \ true;\n                        cur_fill += 1;\n                    }\n     \
    \               if i + 1 < n && grid[i + 1][j] == 1 && !visit[i + 1][j] {\n  \
    \                      stack.push((i + 1, j));\n                        visit[i\
    \ + 1][j] = true;\n                        cur_fill += 1;\n                  \
    \  }\n                    if i > 0 && grid[i - 1][j] == 1 && !visit[i - 1][j]\
    \ {\n                        stack.push((i - 1, j));\n                       \
    \ visit[i - 1][j] = true;\n                        cur_fill += 1;\n          \
    \          }\n                }\n                res += (cur_fill + capacity -\
    \ 1) / capacity;\n            }\n        }\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `2`', /tmp/tmp_ltkd_z9.rs:75:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    // let h = grid.len();\n    // let w = grid[0].len();\n\
    \    let mut result = 0;\n    for row in grid {\n        let mut row_sum = 0;\n\
    \        for &c in &row {\n            row_sum += c;\n        }\n        result\
    \ += (row_sum + capacity - 1) / capacity;\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    // count full wells\n    let mut full_count = 0;\n  \
    \  for row in &grid {\n        for &v in row {\n            if v == 1 {\n    \
    \            full_count += 1;\n            }\n        }\n    }\n    // number\
    \ of lowers\n    let mut lowers = 0;\n    // fill wells until full count == 0\n\
    \    while full_count > 0 {\n        for row in &grid {\n            for &v in\
    \ row {\n                if v == 1 {\n                    lowers += 1;\n     \
    \               full_count -= 1;\n                }\n            }\n        }\n\
    \    }\n    lowers\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmpievkg1yn.rs:57:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut height: isize = 0;\n    for x in grid.iter()\
    \ {\n        let mut temp = 0;\n        for y in x.iter() {\n            if *y\
    \ == 1 {\n                temp += 1;\n            }\n        }\n        if temp\
    \ > height {\n            height = temp;\n        }\n    }\n    height * capacity\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmp2miwd18a.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut result = 0;\n    let max_height = grid.iter().fold(0,\
    \ |prev, curr| cmp::max(prev, curr.iter().max().unwrap()));\n    for _ in 0..max_height\
    \ {\n        for row in &grid {\n            let mut filled = 0;\n           \
    \ for cell in row {\n                if *cell == 0 {\n                    filled\
    \ += 1;\n                } else {\n                    break;\n              \
    \  }\n            }\n            result += filled / capacity;\n        }\n   \
    \     // Subtract 1 from the first cell of each row.\n        grid.iter_mut().for_each(|row|\
    \ row[0] -= 1);\n    }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpi2hsn7cl.rs:30:55\n   |\n30 |     let max_height = grid.iter().fold(0,\
    \ |prev, curr| cmp::max(prev, curr.iter().max().unwrap()));\n   |            \
    \                                           ^^^ use of undeclared crate or module\
    \ `cmp`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut wells = grid.iter().map(|v| v.iter().map(|n|\
    \ n / capacity).sum::<isize>()).sum::<isize>();\n    let mut total = wells;\n\
    \    let mut height = grid.len();\n    while wells > 0 {\n        wells = 0;\n\
    \        for well in grid.iter() {\n            let mut last = well[0];\n    \
    \        for n in well.iter() {\n                if *n == last {\n           \
    \         last += 1;\n                } else {\n                    wells += last;\n\
    \                    break;\n                }\n            }\n        }\n   \
    \     total += wells * height;\n        height -= 1;\n    }\n    total\n}\n\n\
    fn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptlh8jc2m.rs:45:26\n   |\n\
    45 |         total += wells * height;\n   |                          ^^^^^^ expected\
    \ `isize`, found `usize`\n\nerror[E0277]: cannot multiply `isize` by `usize`\n\
    \  --> /tmp/tmptlh8jc2m.rs:45:24\n   |\n45 |         total += wells * height;\n\
    \   |                        ^ no implementation for `isize * usize`\n   |\n \
    \  = help: the trait `Mul<usize>` is not implemented for `isize`\n   = help: the\
    \ following other types implement trait `Mul<Rhs>`:\n             <&'a f32 as\
    \ Mul<f32>>\n             <&'a f64 as Mul<f64>>\n             <&'a i128 as Mul<i128>>\n\
    \             <&'a i16 as Mul<i16>>\n             <&'a i32 as Mul<i32>>\n    \
    \         <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n          \
    \   <&'a isize as Mul<isize>>\n           and 49 others\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    use std::cmp::max;\n    let mut result = 0;\n    let\
    \ height = grid.len();\n    let width = grid[0].len();\n    for column in 0..width\
    \ {\n        let mut free = capacity;\n        for row in 0..height {\n      \
    \      free -= grid[row][column];\n            if free < 0 {\n               \
    \ result += -free;\n                free = 0;\n            }\n        }\n    }\n\
    \    for row in 0..height {\n        let mut free = capacity;\n        for column\
    \ in 0..width {\n            free -= grid[row][column];\n            if free <\
    \ 0 {\n                result += -free;\n                free = 0;\n         \
    \   }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `6`', /tmp/tmpgx1g5kle.rs:58:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let r = grid.len();\n    let c = grid[0].len();\n   \
    \ let mut grid = grid;\n    let mut result = 0;\n    for i in 0..r {\n       \
    \ for j in 0..c {\n            if grid[i][j] == 1 {\n                result +=\
    \ 1;\n                let (_, water) = fill(i, j, &mut grid, capacity);\n    \
    \            result += water;\n            }\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `fill` in this scope\n  --> /tmp/tmpyd3vkbrl.rs:37:34\n\
    \   |\n37 |                 let (_, water) = fill(i, j, &mut grid, capacity);\n\
    \   |                                  ^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut queue = VecDeque::new();\n    let mut grid =\
    \ grid;\n    let mut well_count = 0;\n    let mut drop_count = 0;\n    let row_count\
    \ = grid.len();\n    let col_count = grid[0].len();\n    // find the number of\
    \ wells\n    for row in 0..row_count {\n        for col in 0..col_count {\n  \
    \          if grid[row][col] > 0 {\n                queue.push_back((row, col));\n\
    \                well_count += 1;\n            }\n        }\n    }\n    // go\
    \ through all wells and perform bucket drops\n    while !queue.is_empty() {\n\
    \        for _ in 0..well_count {\n            let (row, col) = queue.pop_front().unwrap();\n\
    \            let mut fill = capacity - grid[row][col];\n            if fill >\
    \ 0 {\n                // fill the current well\n                grid[row][col]\
    \ = capacity;\n                if row > 0 && grid[row - 1][col] > 0 {\n      \
    \              // fill the well on top\n                    let top_fill = capacity\
    \ - grid[row - 1][col];\n                    grid[row - 1][col] += min(fill, top_fill);\n\
    \                    fill -= min(fill, top_fill);\n                }\n       \
    \         if row < row_count - 1 && grid[row + 1][col] > 0 {\n               \
    \     // fill the well on bottom\n                    let bottom_fill = capacity\
    \ - grid[row + 1][col];\n                    grid[row + 1][col] += min(fill, bottom_fill);\n\
    \                    fill -= min(fill, bottom_fill);\n                }\n    \
    \            if col > 0 && grid[row][col - 1] > 0 {\n                    // fill\
    \ the well on left\n                    let left_fill = capacity - grid[row][col\
    \ - 1];\n                    grid[row][col - 1] += min(fill, left_fill);\n   \
    \                 fill -= min(fill, left_fill);\n                }\n         \
    \       if col < col_count - 1 && grid[row][col + 1] > 0 {\n                 \
    \   // fill the well on right\n                    let right_fill = capacity -\
    \ grid[row][col + 1];\n                    grid[row\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpmz96cdmu.rs:83:3\n\
    \   |\n28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                                              - unclosed delimiter\n\
    ...\n45 |     while !queue.is_empty() {\n   |                             - unclosed\
    \ delimiter\n46 |         for _ in 0..well_count {\n   |                     \
    \           - unclosed delimiter\n...\n49 |             if fill > 0 {\n   |  \
    \                       - unclosed delimiter\n...\n70 |                 if col\
    \ < col_count - 1 && grid[row][col + 1] > 0 {\n   |                          \
    \                                        - this delimiter might not be properly\
    \ closed...\n...\n74 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n83 | }\n   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpmz96cdmu.rs:73:25\n\
    \   |\n28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                                              - closing delimiter\
    \ possibly meant for this\n...\n73 |                     grid[row\n   |      \
    \                   ^ unclosed delimiter\n74 | }\n   | ^ mismatched closing delimiter\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `VecDeque`\n  --> /tmp/tmpmz96cdmu.rs:29:21\n\
    \   |\n29 |     let mut queue = VecDeque::new();\n   |                     ^^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::VecDeque;\n   |\n\nerror[E0425]: cannot find function\
    \ `min` in this scope\n  --> /tmp/tmpmz96cdmu.rs:55:43\n   |\n55 |           \
    \          grid[row - 1][col] += min(fill, top_fill);\n   |                  \
    \                         ^^^\n...\n76 | fn main() {\n   | --------- similarly\
    \ named function `main` defined here\n   |\nhelp: a function with a similar name\
    \ exists\n   |\n55 |                     grid[row - 1][col] += main(fill, top_fill);\n\
    \   |                                           ~~~~\nhelp: consider importing\
    \ this function\n   |\n1  | use std::cmp::min;\n   |\n\nerror[E0425]: cannot fin"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut capacity = capacity;\n    let mut n_moves = 0;\n\
    \    for row in grid {\n        let mut n_empty = 0;\n        for &c in &row {\n\
    \            if c == 0 {\n                n_empty += 1;\n            } else {\n\
    \                capacity -= c;\n                if capacity < 0 {\n         \
    \           capacity = 0;\n                }\n            }\n        }\n     \
    \   if capacity == 0 {\n            n_moves += n_empty;\n        }\n    }\n  \
    \  n_moves\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `5`', /tmp/tmps7iwypvx.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut count = 0;\n    for row in grid {\n        let\
    \ mut level = 0;\n        for col in row {\n            level += col;\n      \
    \      if level == capacity {\n                count += 1;\n                level\
    \ = 0;\n            }\n        }\n        if level > 0 {\n            count +=\
    \ 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let rows = grid.len();\n    let cols = grid[0].len();\n\
    \    let mut level = 0;\n    for row in 0..rows {\n        for col in 0..cols\
    \ {\n            if grid[row][col] == 1 {\n                grid[row][col] = capacity;\n\
    \            }\n        }\n    }\n    while true {\n        let mut has_new_water\
    \ = false;\n        for row in 0..rows {\n            for col in 0..cols {\n \
    \               if grid[row][col] >= 0 {\n                    continue;\n    \
    \            }\n                for &(dr, dc) in &[(-1, 0), (1, 0), (0, -1), (0,\
    \ 1)] {\n                    let nr = row as isize + dr;\n                   \
    \ let nc = col as isize + dc;\n                    if nr < 0 || nr >= rows as\
    \ isize || nc < 0 || nc >= cols as isize {\n                        continue;\n\
    \                    }\n                    if grid[nr as usize][nc as usize]\
    \ > 0 {\n                        has_new_water = true;\n                     \
    \   grid[nr as usize][nc as usize] -= 1;\n                        grid[row][col]\
    \ += 1;\n                    }\n                }\n            }\n        }\n\
    \        if !has_new_water {\n            break;\n        }\n        level +=\
    \ 1;\n    }\n    level\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "warning: denote infinite loops with `loop { ... }`\n  --> /tmp/tmpyzky4_7y.rs:39:5\n\
    \   |\n39 |     while true {\n   |     ^^^^^^^^^^ help: use `loop`\n   |\n   =\
    \ note: `#[warn(while_true)]` on by default\n\nerror[E0596]: cannot borrow `grid`\
    \ as mutable, as it is not declared as mutable\n  --> /tmp/tmpyzky4_7y.rs:35:17\n\
    \   |\n28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |             ---- help: consider changing this to be mutable: `mut grid`\n\
    ...\n35 |                 grid[row][col] = capacity;\n   |                 ^^^^\
    \ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `grid` as mutable, as\
    \ it is not declared as mutable\n  --> /tmp/tmpyzky4_7y.rs:54:25\n   |\n28 | fn\
    \ max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n   |          \
    \   ---- help: consider changing this to be mutable: `mut grid`\n...\n54 |   \
    \                      grid[nr as usize][nc as usize] -= 1;\n   |            \
    \             ^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `grid`\
    \ as mutable, as it is not declared as mutable\n  --> /tmp/tmpyzky4_7y.rs:55:25\n\
    \   |\n28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |             ---- help: consider changing this to be mutable: `mut grid`\n\
    ...\n55 |                         grid[row][col] += 1;\n   |                 \
    \        ^^^^ cannot borrow as mutable\n\nerror: aborting due to 3 previous errors;\
    \ 1 warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max = 0;\n    for row in grid {\n        for\
    \ col in row {\n            if col > max {\n                max = col;\n     \
    \       }\n        }\n    }\n    max / capacity + if max % capacity > 0 { 1 }\
    \ else { 0 }\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmpf078lggl.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let max_length = grid.iter().map(|x| x.len()).max().unwrap();\n\
    \    let last_row = grid.len() - 1;\n    let col_mask = (1 << max_length) - 1;\n\
    \    let mut dp = vec![vec![-1; max_length]; grid.len()];\n    dp[last_row][0]\
    \ = grid[last_row][0];\n    for row in (0..last_row).rev() {\n        let mut\
    \ column = 0;\n        let mut next_column = 0;\n        let mut next_dp = vec![-1;\
    \ max_length];\n        while column < max_length {\n            next_column =\
    \ column + 1;\n            while next_column < max_length && (dp[row + 1][next_column]\
    \ == -1 || dp[row + 1][next_column] < dp[row + 1][column]) {\n               \
    \ next_column += 1;\n            }\n            let mut next_col_mask = 0;\n \
    \           for i in column..next_column {\n                next_col_mask |= 1\
    \ << i;\n            }\n            for &c in &[0, col_mask & !next_col_mask]\
    \ {\n                let mut val = c;\n                let mut count = 0;\n  \
    \              for i in column..next_column {\n                    let filled\
    \ = (val & 1) as isize * capacity;\n                    let water = grid[row][i]\
    \ - filled;\n                    if water > 0 {\n                        count\
    \ += 1;\n                    }\n                    val >>= 1;\n             \
    \   }\n                let current = dp[row + 1][column] + count;\n          \
    \      if next_dp[column] == -1 || next_dp[column] > current {\n             \
    \       next_dp[column] = current;\n                }\n            }\n       \
    \     column = next_column;\n        }\n        dp[row] = next_dp;\n    }\n  \
    \  dp[0][0]\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmp6c_7at85.rs:72:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut times = 0;\n    let mut grid = grid;\n    loop\
    \ {\n        // Fill the wells.\n        let mut filled = vec![0; grid.len()];\n\
    \        let mut free = 0;\n        for i in 0..grid.len() {\n            // Find\
    \ the first filled well.\n            let mut max_fill = 0;\n            for j\
    \ in 0..grid[i].len() {\n                max_fill += grid[i][j];\n           \
    \     if grid[i][j] > 0 {\n                    break;\n                }\n   \
    \         }\n            // Fill the well from the beginning.\n            if\
    \ max_fill > 0 {\n                let t = max_fill.min(capacity - free);\n   \
    \             for j in 0..grid[i].len() {\n                    if grid[i][j] >=\
    \ t {\n                        grid[i][j] -= t;\n                        filled[i]\
    \ += t;\n                        free = 0;\n                        break;\n \
    \                   } else {\n                        free += grid[i][j];\n  \
    \                      filled[i] += grid[i][j];\n                        grid[i][j]\
    \ = 0;\n                    }\n                }\n            }\n        }\n \
    \       // Check if we are done.\n        let mut not_done = false;\n        for\
    \ i in 0..grid.len() {\n            for j in 0..grid[i].len() {\n            \
    \    if grid[i][j] > 0 {\n                    not_done = true;\n             \
    \       break;\n                }\n            }\n            if not_done {\n\
    \                break;\n            }\n        }\n        if !not_done {\n  \
    \          break;\n        }\n        // Empty the buckets.\n        times +=\
    \ 1;\n        let mut free = capacity;\n        for i in 0..grid.len() {\n   \
    \         free -= filled[i];\n            if free < 0 {\n                break;\n\
    \            }\n        }\n        if free < 0 {\n            break;\n       \
    \ }\n    }\n    times\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmploqvb18q.rs:95:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let (m, n) = (grid.len(), grid[0].len());\n    let mut\
    \ total = 0;\n    for i in 0..m {\n        for j in 0..n {\n            total\
    \ += grid[i][j];\n        }\n    }\n    let mut dp = vec![vec![total; n]; m];\n\
    \    for i in 0..m {\n        for j in 0..n {\n            dp[i][j] = std::cmp::min(capacity,\
    \ grid[i][j] + dp[i][j - 1]);\n        }\n    }\n    for i in (0..m).rev() {\n\
    \        for j in (0..n).rev() {\n            dp[i][j] = std::cmp::min(dp[i][j],\
    \ capacity + dp[i + 1][j]);\n        }\n    }\n    dp[0][0]\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp_2snxj9h.rs:39:67\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let m = grid.len();\n    let n = grid[0].len();\n   \
    \ let mut count = 0;\n    let mut row_min = vec![capacity; n];\n    for i in 0..m\
    \ {\n        let mut row_max = vec![0; n];\n        for j in 0..n {\n        \
    \    if grid[i][j] == 1 {\n                row_max[j] = capacity;\n          \
    \  } else {\n                if j > 0 {\n                    row_max[j] = std::cmp::min(row_max[j\
    \ - 1] + 1, capacity);\n                } else {\n                    row_max[j]\
    \ = 1;\n                }\n            }\n        }\n        for j in (0..n).rev()\
    \ {\n            if grid[i][j] == 1 {\n                row_max[j] = capacity;\n\
    \            } else {\n                if j < n - 1 {\n                    row_max[j]\
    \ = std::cmp::min(row_max[j + 1] + 1, row_max[j]);\n                } else {\n\
    \                    row_max[j] = 1;\n                }\n            }\n     \
    \   }\n        for j in 0..n {\n            row_min[j] = std::cmp::min(row_min[j],\
    \ row_max[j]);\n            count += row_min[j];\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `12`,\n right: `6`', /tmp/tmpko8c1_o9.rs:67:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    // Each bucket's capacity minus how much water is already\
    \ in the well.\n    let mut fill = capacity - grid[0][0];\n    for i in 1..grid.len()\
    \ {\n        for j in 0..grid[i].len() {\n            if grid[i][j] == 0 {\n \
    \               // Count how many consecutive wells are not filled,\n        \
    \        // and fill as many as possible with the bucket.\n                let\
    \ mut count = 1;\n                while j + count < grid[i].len() && grid[i][j\
    \ + count] == 0 {\n                    count += 1;\n                }\n      \
    \          let to_fill = count.min(fill as usize);\n                // Mark the\
    \ wells as filled.\n                for k in 0..to_fill {\n                  \
    \  grid[i][j + k] = 1;\n                }\n                // Subtract the filled\
    \ wells from the bucket capacity.\n                fill -= to_fill as isize;\n\
    \                // If filled all wells, we need a new bucket.\n             \
    \   if to_fill == count {\n                    fill = capacity;\n            \
    \    }\n                // Jump over the filled wells.\n                j += to_fill;\n\
    \            }\n        }\n    }\n    fill.max(0)\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "warning: value assigned to `j` is never read\n  --> /tmp/tmp76uchvin.rs:52:17\n\
    \   |\n52 |                 j += to_fill;\n   |                 ^\n   |\n   =\
    \ note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is overwritten\
    \ before being read?\n\nerror[E0596]: cannot borrow `grid` as mutable, as it is\
    \ not declared as mutable\n  --> /tmp/tmp76uchvin.rs:43:21\n   |\n28 | fn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n   |             ---- help: consider\
    \ changing this to be mutable: `mut grid`\n...\n43 |                     grid[i][j\
    \ + k] = 1;\n   |                     ^^^^ cannot borrow as mutable\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `j`\n  --> /tmp/tmp76uchvin.rs:52:17\n\
    \   |\n32 |         for j in 0..grid[i].len() {\n   |             -\n   |    \
    \         |\n   |             first assignment to `j`\n   |             help:\
    \ consider making this binding mutable: `mut j`\n...\n52 |                 j +=\
    \ to_fill;\n   |                 ^^^^^^^^^^^^ cannot assign twice to immutable\
    \ variable\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\n\
    Some errors have detailed explanations: E0384, E0596.\nFor more information about\
    \ an error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut wells = vec![0; grid.len()];\n    for row in\
    \ &grid {\n        for (i, &cell) in row.iter().enumerate() {\n            wells[i]\
    \ += cell;\n        }\n    }\n    let mut operations = 0;\n    for &well in &wells\
    \ {\n        let (mut well, mut capacity) = (well, capacity);\n        while well\
    \ > 0 {\n            let (top, bottom) = (well.min(capacity), capacity - well.min(capacity));\n\
    \            operations += top + bottom;\n            well -= capacity;\n    \
    \        capacity = capacity.min(well);\n        }\n    }\n    operations\n}\n\
    \nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 3 but the index\
    \ is 3', /tmp/tmpzttsnnk0.rs:32:13\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut count = 0;\n    let\
    \ mut rows = grid.len();\n    let mut cols = 0;\n    for i in 0..rows {\n    \
    \    cols = std::cmp::max(cols, grid[i].len());\n    }\n    for row in 0..rows\
    \ {\n        for col in 0..cols {\n            if grid[row][col] == 1 {\n    \
    \            while grid[row][col] > 0 {\n                    grid[row][col] -=\
    \ capacity;\n                    count += 1;\n                }\n            }\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmp4vgvfc5k.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut total = 0;\n    let mut total_of_remainders =\
    \ 0;\n    for row in grid {\n        let row_total = row.iter().sum();\n     \
    \   total += row_total / capacity;\n        let remainder = row_total % capacity;\n\
    \        if remainder > total_of_remainders {\n            total_of_remainders\
    \ = remainder;\n        }\n    }\n    total + total_of_remainders\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpx2j6sl4m.rs:32:13\n\
    \   |\n32 |         let row_total = row.iter().sum();\n   |             ^^^^^^^^^\
    \ consider giving `row_total` a type\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let (r, c) = (grid.len(), grid[0].len());\n    let mut\
    \ water_level = vec![vec![0; c]; r];\n    let mut answer = 0;\n    for row in\
    \ grid {\n        let sum = row.iter().sum::<isize>();\n        if sum == 0 {\n\
    \            answer += 1;\n        } else {\n            let mut current_capacity\
    \ = capacity;\n            for (i, &j) in row.iter().enumerate() {\n         \
    \       if j > 0 {\n                    current_capacity -= j;\n             \
    \       water_level[i][j as usize] = 1;\n                }\n                if\
    \ current_capacity < 0 {\n                    return -1;\n                }\n\
    \            }\n            answer += 1;\n        }\n    }\n    answer\n}\n\n\
    fn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-1`,\n right: `6`', /tmp/tmpwmhlrffd.rs:55:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let mut bucket = 0;\n    let\
    \ mut bucket_cap = capacity;\n    for i in 0..grid.len() {\n        for j in 0..grid[i].len()\
    \ {\n            if grid[i][j] == 1 {\n                if bucket_cap == capacity\
    \ {\n                    bucket += 1;\n                    bucket_cap = 0;\n \
    \               }\n                bucket_cap += 1;\n                grid[i][j]\
    \ = 0;\n            }\n        }\n    }\n    bucket\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `2`', /tmp/tmpwduh02yi.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut well = grid;\n    let mut iterations = 0;\n \
    \   loop {\n        if well.iter().all(|row| row.iter().all(|&v| v == 0)) {\n\
    \            break;\n        }\n        let mut row_num = 0;\n        let mut\
    \ max_water = 0;\n        for row in well.iter() {\n            let mut water\
    \ = 0;\n            for &v in row.iter() {\n                if v == 1 {\n    \
    \                water += 1;\n                }\n            }\n            if\
    \ water > max_water {\n                max_water = water;\n                row_num\
    \ = max_water;\n            }\n        }\n        let row = &mut well[row_num];\n\
    \        for v in row.iter_mut() {\n            if *v == 1 {\n               \
    \ *v = 0;\n            }\n        }\n        for i in 1..=capacity {\n       \
    \     if row_num + i < well.len() {\n                for v in well[row_num + i].iter_mut()\
    \ {\n                    if *v == 1 {\n                        *v = 0;\n     \
    \               }\n                }\n            }\n            if row_num -\
    \ i >= 0 {\n                for v in well[row_num - i].iter_mut() {\n        \
    \            if *v == 1 {\n                        *v = 0;\n                 \
    \   }\n                }\n            }\n        }\n        iterations += 1;\n\
    \    }\n    iterations\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0_l4x8cm.rs:56:26\n   |\n\
    56 |             if row_num + i < well.len() {\n   |                         \
    \ ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add `isize` to `usize`\n\
    \  --> /tmp/tmp0_l4x8cm.rs:56:24\n   |\n56 |             if row_num + i < well.len()\
    \ {\n   |                        ^ no implementation for `usize + isize`\n   |\n\
    \   = help: the trait `Add<isize>` is not implemented for `usize`\n   = help:\
    \ the following other types implement trait `Add<Rhs>`:\n             <&'a f32\
    \ as Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a i128 as\
    \ Add<i128>>\n             <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n\
    \             <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n      \
    \       <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0_l4x8cm.rs:57:41\n   |\n57 |                 for v in\
    \ well[row_num + i].iter_mut() {\n   |                                       \
    \  ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add `isize` to `usize`\n\
    \  --> /tmp/tmp0_l4x8cm.rs:57:39\n   |\n57 |                 for v in well[row_num\
    \ + i].iter_mut() {\n   |                                       ^ no implementation\
    \ for `usize + isize`\n   |\n   = help: the trait `Add<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `Add<Rhs>`:\n\
    \             <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n    \
    \         <&'a i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n      \
    \       <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n          \
    \   <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n           and\
    \ 48 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0_l4x8cm.rs:63:26\n\
    \   |\n63 |             if row_num - i >= 0 {\n   |                          ^\
    \ expected `usize`, found `isize`\n\nerror[E0277]: cannot subtract `isize` from\
    \ `usize`\n  --> /tmp/tmp0_l4x8cm.rs:63:24\n   |\n63 |             if row_num\
    \ - i >= 0 {\n   |                        ^ no implementation f"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    // a 3D array where arr[i][j][k] = true iff k+1 water\
    \ can be filled in i-th row\n    // from j-th position\n    let mut dp = vec![vec![vec![false;\
    \ capacity as usize]; grid[0].len()]; grid.len()];\n    for i in 0..grid.len()\
    \ {\n        for j in 0..grid[0].len() {\n            if grid[i][j] == 1 {\n \
    \               dp[i][j][0] = true;\n            }\n        }\n    }\n    for\
    \ i in 0..grid.len() {\n        for k in 1..capacity {\n            for j in 0..grid[0].len()\
    \ {\n                dp[i][j][k as usize] = j > 0 && dp[i][j-1][k as usize]\n\
    \                    || j < grid[0].len()-1 && dp[i][j+1][k as usize]\n      \
    \              || i > 0 && dp[i-1][j][k as usize]\n                    || i <\
    \ grid.len()-1 && dp[i+1][j][k as usize]\n                    || i > 0 && j >\
    \ 0 && dp[i-1][j-1][k as usize]\n                    || i > 0 && j < grid[0].len()-1\
    \ && dp[i-1][j+1][k as usize]\n                    || i < grid.len()-1 && j >\
    \ 0 && dp[i+1][j-1][k as usize]\n                    || i < grid.len()-1 && j\
    \ < grid[0].len()-1 && dp[i+1][j+1][k as usize];\n            }\n        }\n \
    \   }\n    let mut count = 0;\n    let mut any_water = true;\n    while any_water\
    \ {\n        any_water = false;\n        count += 1;\n        let mut filled =\
    \ vec![vec![false; grid[0].len()]; grid.len()];\n        for i in 0..grid.len()\
    \ {\n            for j in 0..grid[0].len() {\n\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp7d1qdjft.rs:71:3\n\
    \   |\n28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                                              - unclosed delimiter\n\
    ...\n55 |     while any_water {\n   |                     - unclosed delimiter\n\
    ...\n59 |         for i in 0..grid.len() {\n   |                             \
    \   - unclosed delimiter\n60 |             for j in 0..grid[0].len() {\n   | \
    \                                      - this delimiter might not be properly\
    \ closed...\n61 | \n62 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n71 | }\n   |   ^\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp7d1qdjft.rs:55:5\n   |\n28 |   fn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n   |                                                    \
    \      ----- expected `isize` because of return type\n...\n55 | /     while any_water\
    \ {\n56 | |         any_water = false;\n57 | |         count += 1;\n58 | |   \
    \      let mut filled = vec![vec![false; grid[0].len()]; grid.len()];\n...  |\n\
    70 | |     assert_eq!(candidate(vec![vec![1, 1, 1, 1], vec![1, 1, 1, 1]], 9),\
    \ 2);\n71 | | }\n   | |__^ expected `isize`, found `()`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let m = grid.len();\n    let n = grid[0].len();\n   \
    \ let mut count = 0;\n    let mut prev_fill = 0;\n    let mut fill = grid[0].iter().sum();\n\
    \    while fill != prev_fill {\n        prev_fill = fill;\n        let mut fill_row\
    \ = vec![0; n];\n        for (i, row) in grid.iter().enumerate() {\n         \
    \   for (j, &well) in row.iter().enumerate() {\n                let mut water\
    \ = well - fill_row[j];\n                if water > 0 {\n                    let\
    \ fill = min(water, capacity);\n                    water -= fill;\n         \
    \           count += fill;\n                    fill_row[j] += fill;\n       \
    \             if i < m - 1 {\n                        grid[i + 1][j] += water;\n\
    \                    }\n                }\n            }\n        }\n        fill\
    \ = grid[m - 1].iter().sum();\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `min` in this scope\n  --> /tmp/tmp0b89x6ct.rs:41:32\n\
    \   |\n41 |                     let fill = min(water, capacity);\n   |       \
    \                         ^^^\n...\n56 | fn main() {\n   | --------- similarly\
    \ named function `main` defined here\n   |\nhelp: a function with a similar name\
    \ exists\n   |\n41 |                     let fill = main(water, capacity);\n \
    \  |                                ~~~~\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::min;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max = std::isize::MIN;\n    for row in grid {\n\
    \        let mut total = 0;\n        for &x in row.iter() {\n            total\
    \ += x;\n        }\n        max = max.max(total);\n    }\n    max / capacity +\
    \ if max % capacity == 0 { 0 } else { 1 }\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpernbo716.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut count = 0;\n    let mut max_depth = 0;\n    for\
    \ x in 0..grid.len() {\n        for y in 0..grid[x].len() {\n            if grid[x][y]\
    \ == 1 {\n                max_depth = max_depth.max(y);\n            }\n     \
    \   }\n    }\n    let mut water_levels = vec![vec![0; max_depth as usize + 1];\
    \ grid.len()];\n    let mut water_level = 0;\n    while water_level <= max_depth\
    \ {\n        for x in 0..grid.len() {\n            for y in 0..grid[x].len() {\n\
    \                if grid[x][y] == 1 {\n                    if water_levels[x][y]\
    \ == 0 {\n                        count += 1;\n                    }\n       \
    \             water_levels[x][y] += 1;\n                    water_levels[x][y]\
    \ = water_levels[x][y].min(capacity);\n                }\n            }\n    \
    \    }\n        water_level += 1;\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmpyvuxb4yc.rs:60:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let (rows, cols) = (grid.len(), grid[0].len());\n   \
    \ let mut result = 0;\n    let mut row_maxes = vec![0; rows];\n    let mut col_maxes\
    \ = vec![0; cols];\n    for row in 0..rows {\n        for col in 0..cols {\n \
    \           let val = grid[row][col];\n            row_maxes[row] = row_maxes[row].max(val);\n\
    \            col_maxes[col] = col_maxes[col].max(val);\n        }\n    }\n   \
    \ for row in 0..rows {\n        for col in 0..cols {\n            result += max(\n\
    \                row_maxes[row].max(col_maxes[col]) - grid[row][col],\n      \
    \          0,\n            );\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpc2n9v82n.rs:42:23\n\
    \   |\n42 |             result += max(\n   |                       ^^^ not found\
    \ in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use\
    \ std::cmp::max;\n   |\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let (rows, cols) = (grid.len(), grid[0].len());\n   \
    \ // fill the map: min(prev row, prev col)\n    let mut map = grid.clone();\n\
    \    for row in 0..rows {\n        for col in 0..cols {\n            if map[row][col]\
    \ == 0 {\n                map[row][col] = cols as isize;\n            } else {\n\
    \                let prev_row = if row > 0 { map[row - 1][col] } else { cols as\
    \ isize };\n                let prev_col = if col > 0 { map[row][col - 1] } else\
    \ { cols as isize };\n                map[row][col] = std::cmp::min(prev_row,\
    \ prev_col) + 1;\n            }\n        }\n    }\n    // try to fill from the\
    \ last row \n    let mut count = 0;\n    for col in 0..cols {\n        let mut\
    \ last_fill = -1;\n        for row in (0..rows).rev() {\n            if map[row][col]\
    \ == last_fill {\n                break;\n            }\n            if map[row][col]\
    \ < capacity {\n                count += 1;\n                last_fill = map[row][col];\n\
    \            }\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `6`', /tmp/tmpw5cxid60.rs:62:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut filled = 0;\n    let mut current = vec![0; grid[0].len()];\n\
    \    for i in 0..grid.len() {\n        for j in 0..grid[i].len() {\n         \
    \   if grid[i][j] == 1 {\n                current[j] += 1;\n            } else\
    \ {\n                filled += 1;\n            }\n        }\n        let less\
    \ = current.iter().filter(|&&x| x < capacity).count();\n        if less > 0 {\n\
    \            return filled + max_fill(\n                grid.iter().map(|row|\
    \ {\n                    row.iter().enumerate().map(|(j, &cell)| {\n         \
    \               if cell == 1 && current[j] > capacity {\n                    \
    \        current[j] -= 1;\n                            1\n                   \
    \     } else {\n                            0\n                        }\n   \
    \                 }).collect()\n                }).collect(),\n              \
    \  capacity\n            );\n        }\n    }\n    filled\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    use std::cmp::min;\n    let mut grid = grid;\n    let\
    \ mut filled = 0;\n    for row in grid.iter_mut() {\n        let water = capacity\
    \ - row.iter().sum::<isize>();\n        filled += water;\n        for cell in\
    \ row.iter_mut() {\n            *cell = min(*cell + water, capacity);\n      \
    \  }\n    }\n    filled\n}\n\nfn main() {\n    let candidate = max_fill;\n   \
    \ assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1,\
    \ 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0,\
    \ 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-3`,\n right: `6`', /tmp/tmpk8vcmlq7.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut result = 0;\n    for x in 0..grid.len() {\n \
    \       let mut x_fill = 0;\n        for y in 0..grid[x].len() {\n           \
    \ if grid[x][y] > 0 {\n                x_fill += 1;\n            }\n        }\n\
    \        if x_fill > 0 {\n            let mut y_fill = 0;\n            for x_\
    \ in 0..grid.len() {\n                if grid[x_][x] > 0 {\n                 \
    \   y_fill += 1;\n                }\n            }\n            result += std::cmp::max(x_fill,\
    \ y_fill);\n        }\n    }\n    result * capacity\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `6`', /tmp/tmpozcvw511.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut grid = grid;\n    let m = grid.len();\n    let\
    \ n = grid[0].len();\n    let mut count = 0;\n    let mut last_total = m * n;\n\
    \    loop {\n        // fill first column\n        for i in 0..m {\n         \
    \   if grid[i][0] == 1 {\n                grid[i][0] = 0;\n                count\
    \ += 1;\n            }\n        }\n        // fill last column\n        for i\
    \ in 0..m {\n            if grid[i][n - 1] == 1 {\n                grid[i][n -\
    \ 1] = 0;\n                count += 1;\n            }\n        }\n        // fill\
    \ first row\n        for j in 0..n {\n            if grid[0][j] == 1 {\n     \
    \           grid[0][j] = 0;\n                count += 1;\n            }\n    \
    \    }\n        // fill last row\n        for j in 0..n {\n            if grid[m\
    \ - 1][j] == 1 {\n                grid[m - 1][j] = 0;\n                count +=\
    \ 1;\n            }\n        }\n        // fill interior\n        for i in 1..m\
    \ - 1 {\n            for j in 1..n - 1 {\n                if grid[i][j] == 1 {\n\
    \                    grid[i][j] = 0;\n                    count += 1;\n      \
    \          }\n            }\n        }\n        let total = grid.iter().fold(0,\
    \ |acc, v| acc + v.iter().sum::<isize>());\n        if total == 0 {\n        \
    \    break;\n        }\n        if total == last_total {\n            // cannot\
    \ fill anymore\n            count = -1;\n            break;\n        }\n     \
    \   last_total = total;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsn0mg1w1.rs:76:21\n   |\n\
    76 |         if total == last_total {\n   |                     ^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n76 |         if total ==\
    \ last_total.try_into().unwrap() {\n   |                               ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsn0mg1w1.rs:81:22\n   |\n33 |\
    \     let mut last_total = m * n;\n   |                          ----- expected\
    \ due to this value\n...\n81 |         last_total = total;\n   |             \
    \         ^^^^^ expected `usize`, found `isize`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let m = grid.len();\n    let n = grid[0].len();\n   \
    \ let mut result = 0;\n    let mut i = 0;\n    while i < m {\n        if grid[i].iter().sum::<isize>()\
    \ < n as isize {\n            // if the water level is less than the number of\
    \ wells on this row,\n            // we need to fill this level\n            result\
    \ += 1;\n            // fill each well one by one\n            for j in 0..n {\n\
    \                if grid[i][j] == 1 {\n                    grid[i][j] = capacity;\n\
    \                }\n            }\n        } else {\n            // if this level\
    \ is full, we need to update the water level of each well\n            for j in\
    \ 0..n {\n                if grid[i][j] != 0 {\n                    grid[i][j]\
    \ -= 1;\n                }\n            }\n            i += 1;\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `grid` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpl4x3iq7v.rs:41:21\n   |\n28 | fn max_fill(grid: Vec<Vec<isize>>,\
    \ capacity: isize) -> isize {\n   |             ---- help: consider changing this\
    \ to be mutable: `mut grid`\n...\n41 |                     grid[i][j] = capacity;\n\
    \   |                     ^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot\
    \ borrow `grid` as mutable, as it is not declared as mutable\n  --> /tmp/tmpl4x3iq7v.rs:48:21\n\
    \   |\n28 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |             ---- help: consider changing this to be mutable: `mut grid`\n\
    ...\n48 |                     grid[i][j] -= 1;\n   |                     ^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let n = grid.len();\n    let m = grid[0].len();\n   \
    \ let mut left = vec![0; m];\n    let mut right = vec![m - 1; m];\n    let mut\
    \ height = vec![0; m];\n    let mut ans = 0;\n    for i in 0..n {\n        for\
    \ j in 0..m {\n            if grid[i][j] == 1 {\n                height[j] +=\
    \ 1;\n            } else {\n                height[j] = 0;\n            }\n  \
    \      }\n        let mut cur = 0;\n        while cur < m {\n            while\
    \ cur < m && height[cur] == 0 {\n                cur += 1;\n            }\n  \
    \          if cur == m {\n                break;\n            }\n            let\
    \ left_most = cur;\n            while cur < m && height[cur] != 0 {\n        \
    \        cur += 1;\n            }\n            let right_most = cur - 1;\n   \
    \         let mut cur_h = height[left_most];\n            for j in left_most..=right_most\
    \ {\n                left[j] = left_most;\n                cur_h = std::cmp::min(cur_h,\
    \ height[j]);\n            }\n            cur_h = height[right_most];\n      \
    \      for j in (left_most..=right_most).rev() {\n                right[j] = right_most;\n\
    \                cur_h = std::cmp::min(cur_h, height[j]);\n            }\n   \
    \         for j in left_most..=right_most {\n                ans += std::cmp::min(capacity,\n\
    \                                     cur_h - std::cmp::max(height[j], std::cmp::max(height[left[j]],\
    \ height[right[j]])));\n            }\n        }\n    }\n    ans\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-1`,\n right: `6`', /tmp/tmp9m_0dep_.rs:77:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    if capacity < 1 {\n        return 0;\n    }\n    let\
    \ mut count = 0;\n    for row in grid {\n        for j in 0..row.len() {\n   \
    \         if row[j] > 0 {\n                let amt = if row[j] > capacity { capacity\
    \ } else { row[j] };\n                count += amt;\n                row[j] -=\
    \ amt;\n            }\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `row` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpmeg8g_t2.rs:38:17\n   |\n33 |     for row in grid {\n\
    \   |         --- help: consider changing this to be mutable: `mut row`\n...\n\
    38 |                 row[j] -= amt;\n   |                 ^^^ cannot borrow as\
    \ mutable\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let n = grid.len();\n    let m = grid[0].len();\n   \
    \ let mut total = 0;\n    let mut l = vec![vec![0isize; m]; n];\n    let mut r\
    \ = vec![vec![0isize; m]; n];\n    let mut t = vec![vec![0isize; m]; n];\n   \
    \ let mut b = vec![vec![0isize; m]; n];\n    for i in 0..n {\n        for j in\
    \ 0..m {\n            l[i][j] = if j == 0 { 0 } else { l[i][j - 1] };\n      \
    \      if grid[i][j] == 1 {\n                l[i][j] += 1;\n            }\n  \
    \      }\n    }\n    for i in 0..n {\n        for j in (0..m).rev() {\n      \
    \      r[i][j] = if j == m - 1 { 0 } else { r[i][j + 1] };\n            if grid[i][j]\
    \ == 1 {\n                r[i][j] += 1;\n            }\n        }\n    }\n   \
    \ for j in 0..m {\n        for i in 0..n {\n            t[i][j] = if i == 0 {\
    \ 0 } else { t[i - 1][j] };\n            if grid[i][j] == 1 {\n              \
    \  t[i][j] += 1;\n            }\n        }\n    }\n    for j in 0..m {\n     \
    \   for i in (0..n).rev() {\n            b[i][j] = if i == n - 1 { 0 } else {\
    \ b[i + 1][j] };\n            if grid[i][j] == 1 {\n                b[i][j] +=\
    \ 1;\n            }\n        }\n    }\n    for i in 0..n {\n        for j in 0..m\
    \ {\n            let count = l[i][j] + r[i][j] + t[i][j] + b[i][j];\n        \
    \    total += count / (capacity + 1);\n        }\n    }\n    total\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `24`,\n right: `6`', /tmp/tmp04wh8qz3.rs:79:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let n = grid.len();\n    let mut max_height = 0;\n  \
    \  for row in grid {\n        for &col in row.iter() {\n            max_height\
    \ = max(max_height, col);\n        }\n    }\n    max_height\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpoifybi8a.rs:33:26\n\
    \   |\n33 |             max_height = max(max_height, col);\n   |             \
    \             ^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut filled = 0;\n    for row in grid {\n        filled\
    \ += row.iter().filter(|&&x| x == 1).count() as isize;\n    }\n    if filled ==\
    \ 0 {\n        return 0;\n    }\n    let max_column = grid[0].len();\n    let\
    \ mut result = 0;\n    for i in 0..max_column {\n        let mut num_filled =\
    \ 0;\n        for j in 0..grid.len() {\n            num_filled += if grid[j][i]\
    \ == 1 { capacity } else { 0 };\n        }\n        result += num_filled / capacity;\n\
    \        if (num_filled % capacity) > 0 {\n            result += 1;\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `grid`\n   --> /tmp/tmpac9uzgza.rs:36:22\n\
    \    |\n28  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |             ---- move occurs because `grid` has type `Vec<Vec<isize>>`,\
    \ which does not implement the `Copy` trait\n29  |     let mut filled = 0;\n30\
    \  |     for row in grid {\n    |                ---- `grid` moved due to this\
    \ implicit call to `.into_iter()`\n...\n36  |     let max_column = grid[0].len();\n\
    \    |                      ^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `grid`\nhelp:\
    \ consider iterating over a slice of the `Vec<Vec<isize>>`'s content to avoid\
    \ moving into the `for` loop\n    |\n30  |     for row in &grid {\n    |     \
    \           +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    if grid.is_empty() || grid[0].is_empty() {\n        return\
    \ 0;\n    }\n    let mut ans = 0;\n    let row_max = grid.iter().map(|r| r.iter().sum::<isize>()).max().unwrap();\n\
    \    ans += row_max / capacity;\n    let col_max = (0..grid[0].len()).map(|i|\
    \ grid.iter().map(|r| r[i]).sum::<isize>()).max().unwrap();\n    ans += col_max\
    \ / capacity;\n    if row_max % capacity + col_max % capacity > capacity {\n \
    \       ans += 1;\n    }\n    ans\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmpnrj3kbrq.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    if grid.is_empty() || grid[0].is_empty() {\n        return\
    \ 0;\n    }\n    let mut best = vec![0; grid[0].len()];\n    let mut fill = 0;\n\
    \    for row in &grid {\n        fill = min(fill + row.iter().sum::<isize>(),\
    \ capacity);\n        for (i, &cell) in row.iter().enumerate() {\n           \
    \ best[i] = max(best[i], fill - cell);\n        }\n    }\n    best.into_iter().sum()\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `min` in this scope\n  --> /tmp/tmptfokawzk.rs:35:16\n\
    \   |\n35 |         fill = min(fill + row.iter().sum::<isize>(), capacity);\n\
    \   |                ^^^\n...\n43 | fn main() {\n   | --------- similarly named\
    \ function `main` defined here\n   |\nhelp: a function with a similar name exists\n\
    \   |\n35 |         fill = main(fill + row.iter().sum::<isize>(), capacity);\n\
    \   |                ~~~~\nhelp: consider importing this function\n   |\n1  |\
    \ use std::cmp::min;\n   |\n\nerror[E0425]: cannot find function `max` in this\
    \ scope\n  --> /tmp/tmptfokawzk.rs:37:23\n   |\n37 |             best[i] = max(best[i],\
    \ fill - cell);\n   |                       ^^^ not found in this scope\n   |\n\
    help: consider importing this function\n   |\n1  | use std::cmp::max;\n   |\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let n = grid.len();\n    let m = grid[0].len();\n   \
    \ let mut count = 0;\n    let mut current = vec![vec![0; m]; n];\n    let mut\
    \ prev = vec![vec![0; m]; n];\n    for j in 0..m {\n        for i in 0..n {\n\
    \            current[i][j] = grid[i][j];\n            if grid[i][j] == 1 {\n \
    \               count += 1;\n            }\n        }\n    }\n    let mut result\
    \ = 0;\n    for t in 0..count {\n        for j in 0..m {\n            for i in\
    \ 0..n {\n                if current[i][j] == 1 {\n                    if i >\
    \ 0 && prev[i - 1][j] < capacity {\n                        current[i - 1][j]\
    \ = 1;\n                    }\n                    if i < n - 1 && prev[i + 1][j]\
    \ < capacity {\n                        current[i + 1][j] = 1;\n             \
    \       }\n                    if j > 0 && prev[i][j - 1] < capacity {\n     \
    \                   current[i][j - 1] = 1;\n                    }\n          \
    \          if j < m - 1 && prev[i][j + 1] < capacity {\n                     \
    \   current[i][j + 1] = 1;\n                    }\n                }\n       \
    \     }\n        }\n        prev = current.clone();\n        result += 1;\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmphjhypoae.rs:71:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let m = grid.len();\n    let n = grid[0].len();\n   \
    \ let mut water = vec![vec![0; n]; m];\n    let mut max_fill = 0;\n    for i in\
    \ 0..m {\n        for j in 0..n {\n            if grid[i][j] == 1 {\n        \
    \        water[i][j] = capacity;\n                max_fill += capacity;\n    \
    \        }\n        }\n    }\n    for j in 1..n {\n        if water[0][j] > 0\
    \ {\n            water[0][j - 1] += water[0][j];\n            water[0][j] = 0;\n\
    \        }\n    }\n    for i in 1..m {\n        if water[i][0] > 0 {\n       \
    \     water[i - 1][0] += water[i][0];\n            water[i][0] = 0;\n        }\n\
    \    }\n    for i in 1..m {\n        for j in 1..n {\n            if water[i][j]\
    \ > 0 {\n                let min = std::cmp::min(water[i - 1][j], water[i][j -\
    \ 1]);\n                water[i - 1][j] -= min;\n                water[i][j -\
    \ 1] -= min;\n                water[i][j] += min;\n            }\n        }\n\
    \    }\n    max_fill - water.iter().map(|row| row.iter().sum::<isize>()).sum::<isize>()\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmp611dtije.rs:68:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut max_fill = 0;\n    for row in grid {\n      \
    \  for cell in row {\n            max_fill = max_fill.max(cell);\n        }\n\
    \    }\n    max_fill.min(capacity)\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmp6mfoh0pm.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut ret = 0;\n    for mut row in grid {\n       \
    \ // find next 1\n        let mut last_pos = None;\n        for i in 0..row.len()\
    \ {\n            if row[i] == 1 {\n                let pos = last_pos.map(|x|\
    \ x - i).unwrap_or(0);\n                if pos <= capacity {\n               \
    \     ret += 1;\n                    last_pos = Some(i);\n                } else\
    \ {\n                    break;\n                }\n            }\n        }\n\
    \    }\n    ret\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0271]: type mismatch resolving `<usize as Sub>::Output == isize`\n\
    \  --> /tmp/tmphdqm4jdt.rs:35:46\n   |\n35 |                 let pos = last_pos.map(|x|\
    \ x - i).unwrap_or(0);\n   |                                              ^ expected\
    \ `usize`, found `isize`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0271`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let n = grid.len();\n    let m = grid[0].len();\n   \
    \ let mut mf = 0;\n    for j in 0..m {\n        let mut h = 0;\n        for i\
    \ in 0..n {\n            if grid[i][j] == 1 {\n                h += 1;\n     \
    \       }\n        }\n        mf = std::cmp::max(mf, h);\n    }\n    let mut ans\
    \ = 0;\n    while mf > 0 {\n        let mut h = 0;\n        for j in 0..m {\n\
    \            if grid[h][j] == 1 {\n                grid[h][j] = 0;\n         \
    \   } else {\n                h += 1;\n            }\n        }\n        ans +=\
    \ 1;\n        mf -= capacity;\n    }\n    ans\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `grid` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpt0ykxpv5.rs:46:17\n   |\n28 | fn max_fill(grid: Vec<Vec<isize>>,\
    \ capacity: isize) -> isize {\n   |             ---- help: consider changing this\
    \ to be mutable: `mut grid`\n...\n46 |                 grid[h][j] = 0;\n   | \
    \                ^^^^ cannot borrow as mutable\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n///\
    \ bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid :\
    \ [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output:\
    \ 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity\
    \ : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have the same length\n\
    /// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j]\
    \ -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid: Vec<Vec<isize>>, capacity:\
    \ isize) -> isize {\n    let mut counter = 0;\n    let r = grid.len();\n    let\
    \ c = grid[0].len();\n    for i in 0..r {\n        let mut level = 0;\n      \
    \  for j in 0..c {\n            if grid[i][j] == 1 {\n                level +=\
    \ 1;\n            } else {\n                level = 0;\n            }\n      \
    \      if level == capacity {\n                counter += 1;\n               \
    \ level = 0;\n            }\n        }\n    }\n    counter\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `5`', /tmp/tmpdqbi2wni.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
