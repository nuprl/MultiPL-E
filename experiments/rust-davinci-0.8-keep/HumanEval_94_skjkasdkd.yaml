name: HumanEval_94_skjkasdkd
language: rust
prompt: "/// You are given a list of integers.\n/// You need to find the largest prime\
  \ value and return the sum of its digits.\n/// Examples:\n/// For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]\
  \ the output should be 10\n/// For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]\
  \ the output should be 25\n/// For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]\
  \ the output should be 13\n/// For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the\
  \ output should be 11\n/// For lst = [0,81,12,3,1,21] the output should be 3\n///\
  \ For lst = [0,8,1,2,1,7] the output should be 7\nfn skjkasdkd(lst: Vec<isize>)\
  \ -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0,\
  \ 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n\
  \    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4,\
  \ 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109,\
  \ 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724,\
  \ 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0,\
  \ 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n\
  \    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191,\
  \ 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n\
  }\n"
completions: ['    return 0;', "    let mut largest_prime = 0;\n    for n in lst {\n\
    \        if prime::is_prime(n) && n > largest_prime {\n            largest_prime\
    \ = n;\n        }\n    }\n    digits(largest_prime).iter().fold(0, |acc, d| acc\
    \ + d)", '    lst.iter().fold(0, |acc, x| acc + x)', "    let mut last_value =\
    \ 1;\n    for value in lst {\n        last_value *= value;\n    }\n    let mut\
    \ largest_prime = last_value;\n    for value in 2..last_value {\n        if last_value\
    \ % value == 0 {\n            let is_prime = (2..value).all(|x| value % x != 0);\n\
    \            if is_prime {\n                largest_prime = value;\n         \
    \   }\n        }\n    }\n    let mut sum = 0;\n    for value in largest_prime.to_string().chars()\
    \ {\n        sum += value.to_digit(10).unwrap() as isize;\n    }\n    sum", " \
    \   let mut x: isize = 0;\n    let mut y: isize = 0;\n    for z in lst {\n   \
    \     if z > x {\n            x = z;\n        }\n    }\n    while x > 0 {\n  \
    \      if is_prime(x) {\n            let mut digit: isize = x % 10;\n        \
    \    while x > 0 {\n                x = x / 10;\n                y = y + digit;\n\
    \                digit = x % 10;\n            }\n            break;\n        }\n\
    \        x = x - 1;\n    }\n    y", "    let mut lst = lst;\n    lst.sort();\n\
    \    lst.reverse();\n    for x in lst {\n        let x1 = x as f64;\n        let\
    \ mut check = true;\n        for i in 2..((x1.sqrt()) as usize) {\n          \
    \  if x % i == 0 {\n                check = false;\n                break;\n \
    \           }\n        }\n        if check {\n            let mut sum = 0;\n \
    \           let x2 = x;\n            while x2 != 0 {\n                sum += x2\
    \ % 10;\n                x2 /= 10;\n            }\n            return sum;\n \
    \       }\n    }\n    return 0;", "    let mut lst = lst;\n    lst.sort();\n \
    \   let mut last_number = 0;\n    for number in lst.iter().rev() {\n        if\
    \ *number > last_number {\n            last_number = *number;\n        }\n   \
    \ }\n    let mut prime_number = false;\n    for number in (2..last_number + 1).rev()\
    \ {\n        if last_number % number == 0 {\n            prime_number = true;\n\
    \            last_number = number;\n            break;\n        }\n    }\n   \
    \ if prime_number {\n        let mut num = 0;\n        while last_number > 0 {\n\
    \            num += last_number % 10;\n            last_number /= 10;\n      \
    \  }\n        return num;\n    }\n    return last_number;", "    let mut primes:\
    \ Vec<isize> = vec![];\n    for item in lst {\n        if is_prime(item) {\n \
    \           primes.push(item);\n        }\n    }\n    println!(\"{:?}\", primes);\n\
    \    if primes.len() == 0 {\n        return 0;\n    }\n    let mut largest = primes[0];\n\
    \    for item in primes {\n        if item > largest {\n            largest =\
    \ item;\n        }\n    }\n    println!(\"{:?}\", largest);\n    let mut nums:\
    \ Vec<isize> = vec![];\n    while largest > 0 {\n        nums.push(largest % 10);\n\
    \        largest /= 10;\n    }\n    let mut total = 0;\n    for item in nums {\n\
    \        total += item;\n    }\n    return total;", "    let mut max = -1;\n \
    \   for n in lst {\n        if n > max && n.is_prime() {\n            max = n;\n\
    \        }\n    }\n    if max == -1 {\n        return 0;\n    }\n    let mut sum\
    \ = 0;\n    let mut copy = max;\n    while copy > 0 {\n        sum += copy % 10;\n\
    \        copy /= 10;\n    }\n    sum", "    let mut sums: Vec<isize> = vec![];\n\
    \    let mut i = 0;\n    while i < lst.len() {\n        let mut current = lst[i];\n\
    \        let mut sum = 0;\n        while current != 0 {\n            sum += current\
    \ % 10;\n            current /= 10;\n        }\n        sums.push(sum);\n    \
    \    i += 1;\n    }\n    let mut res = 0;\n    i = 0;\n    while i < sums.len()\
    \ {\n        if is_prime(sums[i]) {\n            res = sums[i];\n        }\n \
    \       i += 1;\n    }\n    res", "    let mut sum = 0;\n    let mut largest =\
    \ 0;\n    let mut num = 0;\n    for i in lst {\n        if is_prime(i) {\n   \
    \         num = i;\n            let s = num.to_string();\n            for x in\
    \ s.chars() {\n                let y = x.to_digit(10).unwrap();\n            \
    \    sum += y as isize;\n            }\n            if sum > largest {\n     \
    \           largest = sum;\n            }\n            sum = 0;\n        }\n \
    \   }\n    largest", "    let mut largest = 0;\n    for value in lst {\n     \
    \   if value > largest && is_prime(value) {\n            largest = value;\n  \
    \      }\n    }\n    sum_digits(largest)", "    let mut lst: Vec<isize> = lst;\n\
    \    let mut x: isize = 0;\n    while x < lst.len() {\n        let mut y: isize\
    \ = 2;\n        while y < lst[x] {\n            if lst[x] % y == 0 {\n       \
    \         lst[x] = y;\n                break;\n            }\n            y +=\
    \ 1;\n        }\n        x += 1;\n    }\n    lst.sort();\n    let mut a: isize\
    \ = lst[lst.len() - 1];\n    let mut r: isize = 0;\n    while a > 0 {\n      \
    \  r += a % 10;\n        a /= 10;\n    }\n    r", "    let mut primes: Vec<isize>\
    \ = vec![];\n    for x in &lst {\n        if is_prime(*x) {\n            primes.push(*x);\n\
    \        }\n    }\n    let largest_prime = *primes.iter().max().unwrap();\n  \
    \  sum_digits(largest_prime)", "    let mut lst = lst;\n    lst.sort();\n    lst.reverse();\n\
    \    for i in lst {\n        if is_prime(i) {\n            return sum_digits(i);\n\
    \        }\n    }\n    return 0;", "  let mut last = 0;\n  for a in lst {\n  \
    \  if is_prime(a) {\n      last = a;\n    }\n  }\n  let mut sum = 0;\n  let mut\
    \ str = last.to_string();\n  while str.len() > 0 {\n    let mut num = str.parse::<isize>().unwrap();\n\
    \    sum += num;\n    str = str.split_off(1);\n  }\n  sum", "    let mut largest\
    \ = 0;\n    for element in lst {\n        if element >= largest && is_prime(element)\
    \ {\n            largest = element;\n        }\n    }\n    let largest_string\
    \ = largest.to_string();\n    let mut result = 0;\n    for (i, _) in largest_string.chars().enumerate()\
    \ {\n        let s: String = largest_string.chars().skip(i).take(1).collect();\n\
    \        result += s.parse::<isize>().unwrap();\n    }\n    result", '  unimplemented!()',
  "    let mut max: isize = 0;\n    for i in lst {\n        if is_prime(i) && i >\
    \ max {\n            max = i;\n        }\n    }\n    let mut output: isize = 0;\n\
    \    let mut d: isize = max;\n    while d > 0 {\n        output += d % 10;\n \
    \       d /= 10;\n    }\n    output", "    use std::cmp::max;\n    let mut largest_prime\
    \ = 0;\n    for x in lst {\n        let mut is_prime = true;\n        for y in\
    \ 2..x {\n            if x % y == 0 {\n                is_prime = false;\n   \
    \             break;\n            }\n        }\n        if is_prime {\n      \
    \      largest_prime = max(largest_prime, x);\n        }\n    }\n    let mut sum\
    \ = 0;\n    for x in largest_prime.to_string().chars() {\n        sum += x.to_digit(10).unwrap()\
    \ as isize;\n    }\n    sum", "    let mut max = 0;\n    for num in lst {\n  \
    \      if num > 1 {\n            if is_prime(num) {\n                if num >\
    \ max {\n                    max = num;\n                }\n            }\n  \
    \      }\n    }\n    let mut sum = 0;\n    while max > 0 {\n        sum += max\
    \ % 10;\n        max /= 10;\n    }\n    sum", "    let max_prime: isize = *lst.iter().filter(|v|\
    \ is_prime(*v)).max().unwrap();\n    let mut sum: isize = 0;\n    while max_prime\
    \ > 0 {\n        sum += max_prime % 10;\n        max_prime /= 10;\n    }\n   \
    \ sum", "    for j in (2..100000).rev() {\n        if lst.iter().filter(|&x| *x\
    \ % j == 0).count() >= 2 {\n            let mut sum = 0;\n            let mut\
    \ j_str = j.to_string();\n            while !j_str.is_empty() {\n            \
    \    sum += j_str.chars().next().unwrap().to_digit(10).unwrap();\n           \
    \     j_str.remove(0);\n            }\n            return sum;\n        }\n  \
    \  }\n    0", "    let mut primes: HashSet<isize> = HashSet::new();\n    let mut\
    \ is_prime = vec![true; 1000];\n    let mut prime_sum: isize = 0;\n    for i in\
    \ 0..lst.len() {\n        if lst[i] <= 0 {\n            is_prime[0] = false;\n\
    \            is_prime[1] = false;\n        }\n        for j in 2..lst[i] {\n \
    \           if lst[i] % j == 0 {\n                is_prime[j as usize] = false;\n\
    \            }\n        }\n    }\n    for i in 0..is_prime.len() {\n        if\
    \ is_prime[i] {\n            primes.insert(i as isize);\n        }\n    }\n  \
    \  println!(\"{:?}\", primes);\n    let mut max_prime: isize = 0;\n    for i in\
    \ 0..lst.len() {\n        if primes.contains(&lst[i]) {\n            if lst[i]\
    \ > max_prime {\n                max_prime = lst[i];\n            }\n        }\n\
    \    }\n    let mut digits: Vec<char> = Vec::new();\n    digits.append(&mut max_prime.to_string().chars().collect());\n\
    \    for i in 0..digits.len() {\n        prime_sum += digits[i].to_digit(10).unwrap()\
    \ as isize;\n    }\n    prime_sum", "    let mut res = 0;\n    let mut biggest\
    \ = 0;\n    let mut num = 0;\n    for i in 0..lst.len() {\n        num = lst[i];\n\
    \        let mut prime = true;\n        for x in 2..num {\n            if num\
    \ % x == 0 {\n                prime = false;\n                break;\n       \
    \     }\n        }\n        if prime && num > biggest {\n            biggest =\
    \ num;\n        }\n    }\n    while biggest > 0 {\n        res += biggest % 10;\n\
    \        biggest /= 10;\n    }\n    res", "    let mut lst = lst;\n    lst.sort();\n\
    \    let lst_len = lst.len();\n    let last_val = lst[lst_len - 1];\n    let primes\
    \ = primes_between(last_val as usize, 0);\n    for p in primes.iter().rev() {\n\
    \        for val in lst.iter() {\n            if *val == *p as isize {\n     \
    \           let mut result = 0;\n                for c in p.to_string().chars()\
    \ {\n                    result += c.to_digit(10).unwrap() as isize;\n       \
    \         }\n                return result;\n            }\n        }\n    }\n\
    \    0", "    let mut largest_prime = 0;\n    for i in lst {\n        let p =\
    \ if i < 0 { -i } else { i };\n        if is_prime(p) && largest_prime < p {\n\
    \            largest_prime = p;\n        }\n    }\n    largest_prime", "    let\
    \ mut ret = 0;\n    let mut max = 0;\n    for i in lst {\n        if is_prime(i)\
    \ {\n            if i > max {\n                max = i;\n            }\n     \
    \   }\n    }\n    while max > 0 {\n        ret += max % 10;\n        max /= 10;\n\
    \    }\n    ret", "    let mut max = 0;\n    for &i in &lst {\n        if is_prime(i)\
    \ && i > max {\n            max = i;\n        }\n    }\n    let mut result = 0;\n\
    \    while max > 0 {\n        result += max % 10;\n        max /= 10;\n    }\n\
    \    result", "    let primes: Vec<usize> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23,\
    \ 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107,\
    \ 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193,\
    \ 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281,\
    \ 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383,\
    \ 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479,\
    \ 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593,\
    \ 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683,\
    \ 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809,\
    \ 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911,\
    \ 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];\n    let mut largest_prime\
    \ = 1;\n    for i in lst {\n        let tmp = *primes.iter().find(|&n| n >= i\
    \ as usize).unwrap();\n        if tmp > largest_prime {\n            largest_prime\
    \ = tmp;\n        }\n    }\n    println!(\"{}\", largest_prime);\n   ", "    let\
    \ mut mp: HashMap<isize, isize> = HashMap::new();\n    let mut lst1: Vec<isize>\
    \ = vec![];\n    let mut i = 0;\n    while i < lst.len() {\n        if lst[i]\
    \ != 0 {\n            mp.insert(lst[i], i);\n            lst1.push(lst[i]);\n\
    \        }\n        i += 1;\n    }\n    lst1.sort();\n    let mut lst2: Vec<isize>\
    \ = vec![];\n    i = 0;\n    while i < lst1.len() {\n        if mp.contains_key(&lst1[i])\
    \ {\n            if is_prime(lst1[i]) {\n                lst2.push(lst1[i]);\n\
    \            }\n        }\n        i += 1;\n    }\n    let mut ret: isize = 0;\n\
    \    if lst2.len() > 0 {\n        let mut max = lst2[0];\n        i = 1;\n   \
    \     while i < lst2.len() {\n            if lst2[i] > max {\n               \
    \ max = lst2[i];\n            }\n            i += 1;\n        }\n        ret =\
    \ max;\n    }\n    i = 0;\n    while i < ret.to_string().len() {\n        ret\
    \ += ret.to_string().chars().nth(i).unwrap().to_digit(10).unwrap() as isize;\n\
    \        i += 1;\n    }\n    ret", "    let mut largest = 0;\n    for num in lst\
    \ {\n        if is_prime(num) && num > largest {\n            largest = num;\n\
    \        }\n    }\n    if largest == 0 {\n        return 0;\n    }\n    largest.to_string().chars().map(|x|\
    \ x.to_digit(10).unwrap() as isize).sum()", '    lst.iter().filter(|&x| x.is_prime()).max().unwrap_or(&0).to_digit_sum()',
  "    let mut x = lst.iter().max_by_key(|&x| x).unwrap().clone();\n    for n in lst.iter()\
    \ {\n        if n > &x && is_prime(*n) {\n            x = *n;\n        }\n   \
    \ }\n    let mut sum = 0;\n    while x > 0 {\n        sum += x % 10;\n       \
    \ x /= 10;\n    }\n    sum", "    let mut prime_numbers = Vec::new();\n    let\
    \ mut vector = lst.clone();\n    vector.sort();\n    vector.dedup();\n    for\
    \ i in &vector {\n        let mut count = 0;\n        for j in 1..*i + 1 {\n \
    \           if i % j == 0 {\n                count += 1;\n            }\n    \
    \    }\n        if count == 2 {\n            prime_numbers.push(*i);\n       \
    \ }\n    }\n    prime_numbers.sort();\n    prime_numbers.reverse();\n    let mut\
    \ sum = 0;\n    for c in prime_numbers[0].to_string().chars() {\n        sum +=\
    \ c.to_digit(10).unwrap();\n    }\n    sum", "    let largest_prime: isize = lst.iter().filter(|x|\
    \ is_prime(*x)).max().unwrap();\n    let digits: Vec<isize> = largest_prime.to_string().chars().map(|x|\
    \ x.to_digit(10).unwrap() as isize).collect();\n    digits.iter().sum()", "  \
    \  let mut a = 0;\n    let mut r = 0;\n    for i in lst {\n        if is_prime(i)\
    \ {\n            let mut s = i;\n            while s > 0 {\n                r\
    \ += s % 10;\n                s /= 10;\n            }\n            if r > a {\n\
    \                a = r;\n            }\n            r = 0;\n        }\n    }\n\
    \    a", "    let mut largest_prime = 0;\n    for i in lst {\n        if is_prime(i)\
    \ && i > largest_prime {\n            largest_prime = i;\n        }\n    }\n \
    \   return sum_of_digits(largest_prime);", "    // let mut lst = lst;\n    let\
    \ mut max = 0;\n    // while lst.len() > 0 {\n    //     let curr = lst.pop().unwrap();\n\
    \    //     if curr.is_prime() {\n    //         if curr > max {\n    //     \
    \        max = curr;\n    //         }\n    //     }\n    // }\n    max", "  \
    \  let mut biggest_prime = 0;\n    for val in lst {\n        if is_prime(val)\
    \ && val > biggest_prime {\n            biggest_prime = val;\n        }\n    }\n\
    \    sum_digits(biggest_prime)", "    let mut sum = 0;\n    let mut vals = HashSet::new();\n\
    \    for v in lst {\n        if vals.contains(&v) {\n            continue;\n \
    \       }\n        vals.insert(v);\n        let mut i = 1;\n        while i <=\
    \ v / 2 {\n            if v % i == 0 {\n                sum += i % 10;\n     \
    \       }\n            i += 1;\n        }\n    }\n    sum", "    let prime = lst.iter().fold(0,\
    \ |max, x| x.max(max));\n    let prime = prime as usize;\n    let mut sum = 0;\n\
    \    let mut n = prime;\n    while n != 0 {\n        sum += n % 10;\n        n\
    \ /= 10;\n    }\n    sum as isize", "    let largest_prime = lst.iter().fold(0,\
    \ |acc, &x| match x {\n        x if x > acc && x.is_prime() => x,\n        _ =>\
    \ acc,\n    });\n    largest_prime.to_string().chars().map(|x| x.to_digit(10).unwrap()\
    \ as isize).sum()", "    // find the largest prime value and return the sum of\
    \ its digits\n    unimplemented!();", "    let mut lp: isize = 0;\n    for x in\
    \ lst {\n        let mut y = x;\n        let mut z = 0;\n        while y > 0 {\n\
    \            z += 1;\n            y /= 10;\n        }\n        let mut c = 0;\n\
    \        for q in 1..z + 1 {\n            if x % q == 0 {\n                c +=\
    \ 1;\n            }\n        }\n        if c == 2 {\n            lp = x;\n   \
    \     }\n    }\n    let mut c = 0;\n    let mut d = lp;\n    while d > 0 {\n \
    \       c += 1;\n        d /= 10;\n    }\n    let mut z = 0;\n    for q in 1..c\
    \ + 1 {\n        z += lp % 10;\n        lp /= 10;\n    }\n    z", "    let primes:\
    \ Vec<isize> = vec![];\n    let mut result: isize = 0;\n    let mut lst_iter =\
    \ lst.iter();\n    let mut temp: isize = 0;\n    let mut next_value: Option<&isize>\
    \ = lst_iter.next();\n    while let Some(n) = next_value {\n        temp = *n;\n\
    \        let mut found_prime = false;\n        for p in primes.iter() {\n    \
    \        if temp % p == 0 {\n                found_prime = true;\n           \
    \     break;\n            }\n        }\n        if !found_prime {\n          \
    \  let mut i = 2;\n            while i * i <= temp {\n                if temp\
    \ % i == 0 {\n                    found_prime = true;\n                    break;\n\
    \                }\n                i += 1;\n            }\n        }\n      \
    \  if !found_prime {\n            primes.push(temp);\n        }\n        next_value\
    \ = lst_iter.next();\n    }\n    if primes.len() > 0 {\n        primes.sort();\n\
    \        let largest = primes.pop().unwrap();\n        let mut digits = Vec::new();\n\
    \        while largest > 0 {\n            digits.push(largest % 10);\n       \
    \     largest /= 10;\n        }\n        for d in digits.iter() {\n          \
    \  result += d;\n        }\n    }\n    result", "  let new_lst = lst.iter().map(|x|\
    \ *x).filter(|x| *x > 1).collect::<Vec<isize>>();\n  if new_lst.len() == 0 {\n\
    \    return 1;\n  }\n  let mut max = 0;\n  for num in new_lst {\n    if num >\
    \ max {\n      max = num;\n    }\n  }\n  let is_prime = |num: &isize| -> bool\
    \ {\n    let upper = (num / 2) + 1;\n    for i in 2..upper {\n      if num % i\
    \ == 0 {\n        return false;\n      }\n    }\n    return true;\n  };\n  if\
    \ is_prime(&max) {\n    let mut sum = 0;\n    let mut num = max;\n    while num\
    \ > 0 {\n      sum += num % 10;\n      num /= 10;\n    }\n    return sum;\n  }\n\
    \  while !is_prime(&max) {\n    max -= 1;\n  }\n  let mut sum = 0;\n  let mut\
    \ num = max;\n  while num > 0 {\n    sum += num % 10;\n    num /= 10;\n  }\n \
    \ return sum;", "    let largest_prime = lst.iter().filter(|&&x| is_prime(x as\
    \ u32)).max().unwrap();\n    largest_prime.to_string().chars().map(|x| x.to_digit(10).unwrap()\
    \ as isize).sum()", '    lst.iter().filter(|&n| is_prime(*n)).map(|n| n.to_string()).max().unwrap().chars().map(|c|
    c.to_digit(10).unwrap() as isize).sum()', "    let result = lst.iter().filter(|&n|\
    \ is_prime(*n)).max().unwrap();\n    let digits: Vec<_> = result.to_string().chars().map(|d|\
    \ d.to_digit(10).unwrap() as isize).collect();\n    digits.iter().sum()", "  \
    \  // The lst of numbers, 1 is considered a prime number.\n    let mut lst = lst;\n\
    \    lst.sort();\n    let mut working_list = lst.clone();\n    let mut primes:\
    \ Vec<isize> = Vec::new();\n    for i in 0..lst.len() {\n        // If the value\
    \ is a prime number...\n        if is_prime(lst[i]) {\n            // Get rid\
    \ of all values that are evenly divisible by that number.\n            working_list\
    \ = working_list.into_iter().filter(|&x| x % lst[i] != 0).collect();\n       \
    \     // Add that value to the list of primes.\n            primes.push(lst[i]);\n\
    \        }\n    }\n    working_list.sort();\n    // Add to the list of primes\
    \ all the values that didn't get filtered out.\n    primes.append(&mut working_list);\n\
    \    // Return the sum of the digits of the largest prime number.\n    primes.last().unwrap().to_string().chars().into_iter().fold(0,\
    \ |sum, x| sum + x.to_digit(10).unwrap() as isize)", "    let mut r = 0;\n   \
    \ for v in lst {\n        r = *(&(*(&v)) + r);\n    }\n    r", "    let mut sum_prime\
    \ = 0;\n    let mut max_prime = 2;\n    for i in lst {\n        if is_prime(i)\
    \ {\n            sum_prime += sum_digits(i);\n            if i > max_prime {\n\
    \                max_prime = i;\n            }\n        }\n    }\n    max_prime",
  "    let primes = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137,\
    \ 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227,\
    \ 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313,\
    \ 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419,\
    \ 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509,\
    \ 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617,\
    \ 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727,\
    \ 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829,\
    \ 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947,\
    \ 953, 967, 971, 977, 983, 991, 997];\n    let mut largest_prime = 0;\n    for\
    \ number in lst {\n        let mut prime = true;\n        for prime_number in\
    \ primes.iter() {\n            if number % prime_number == 0 {\n             \
    \   prime = false;\n                break;\n            }\n        }\n       \
    \ if prime && number > largest_prime {\n            largest_prime = number;\n\
    \        }", "    let mut z = lst.iter().cloned().fold(0, |max, x| std::cmp::max(max,\
    \ x));\n    let z2 = z.to_string();\n    for (idx, _) in z2.chars().enumerate()\
    \ {\n        if z % 10 == 0 {\n            z = z / 10;\n        } else {\n   \
    \         return z2.chars().take(idx + 1).fold(0, |acc, x| acc + x.to_digit(10).unwrap()\
    \ as isize);\n        }\n    }\n    0", "    let mut largest_prime = 0;\n    for\
    \ i in 0..lst.len() {\n        let mut prime = true;\n        for j in 0..i {\n\
    \            if lst[i] % lst[j] == 0 {\n                prime = false;\n     \
    \           break;\n            }\n        }\n        if prime && lst[i] > largest_prime\
    \ {\n            largest_prime = lst[i];\n        }\n    }\n    let mut sum_digits\
    \ = 0;\n    let mut n = largest_prime;\n    while n > 0 {\n        sum_digits\
    \ += n % 10;\n        n /= 10;\n    }\n    sum_digits", "    let mut primes =\
    \ vec![];\n    for i in lst {\n        if i != 0 && i != 1 {\n            let\
    \ mut divisors = 2;\n            let mut prime = true;\n            while divisors\
    \ < i {\n                if i % divisors == 0 {\n                    prime = false;\n\
    \                    break;\n                }\n                divisors += 1;\n\
    \            }\n            if prime {\n                primes.push(i);\n    \
    \        }\n        }\n    }\n    if primes.len() > 0 {\n        primes.sort();\n\
    \        let biggest_prime = primes[primes.len() - 1];\n        let mut mut_biggest_prime\
    \ = biggest_prime;\n        let mut sum = 0;\n        while mut_biggest_prime\
    \ != 0 {\n            sum += mut_biggest_prime % 10;\n            mut_biggest_prime\
    \ /= 10;\n        }\n        sum\n    } else {\n        0\n    }", "    let mut\
    \ max: isize = 0;\n    for x in lst {\n        if is_prime(x) && x > max {\n \
    \           max = x;\n        }\n    }\n    let digits: Vec<isize> = max.to_string().chars().map(|x|\
    \ x.to_digit(10).unwrap() as isize).collect();\n    let mut sum: isize = 0;\n\
    \    for x in digits {\n        sum += x;\n    }\n    sum", "    if lst.is_empty()\
    \ {\n        return 0;\n    }\n    let mut primes: Vec<isize> = vec![];\n    let\
    \ mut non_primes: Vec<isize> = vec![];\n    for x in lst {\n        if is_prime(x)\
    \ {\n            primes.push(x);\n        } else {\n            non_primes.push(x);\n\
    \        }\n    }\n    if primes.is_empty() {\n        return 0;\n    }\n    let\
    \ mut max_p = primes[0];\n    for x in primes {\n        if x > max_p {\n    \
    \        max_p = x;\n        }\n    }\n    let mut ans = 0;\n    let mut x = max_p;\n\
    \    while x > 0 {\n        ans += x % 10;\n        x /= 10;\n    }\n    ans",
  "    let mut largest = 0;\n    for i in lst {\n        if is_prime(i) && i > largest\
    \ {\n            largest = i;\n        }\n    }\n    let mut n = largest;\n  \
    \  let mut total = 0;\n    while n > 0 {\n        total += n % 10;\n        n\
    \ /= 10;\n    }\n    total", "    let mut prime = 0;\n    for num in lst {\n \
    \       if is_prime(num) && num > prime {\n            prime = num;\n        }\n\
    \    }\n    return digits(prime).iter().fold(0, |acc, x| acc + x);", "    let\
    \ mut largest = 0;\n    for i in lst {\n        if i > largest && is_prime(i)\
    \ {\n            largest = i;\n        }\n    }\n    let mut v = Vec::new();\n\
    \    let mut p = largest;\n    while p > 0 {\n        v.push(p % 10);\n      \
    \  p /= 10;\n    }\n    let mut t = 0;\n    for i in v {\n        t += i;\n  \
    \  }\n    t", "    let mut max_prime = 0;\n    for i in lst {\n        if is_prime(i)\
    \ && i > max_prime {\n            max_prime = i;\n        }\n    }\n    return\
    \ sum_digits(max_prime);", "    let mut primes: Vec<isize> = vec![];\n    for\
    \ x in lst {\n        if is_prime(x) {\n            primes.push(x);\n        }\n\
    \    }\n    let large_prime = primes.last().unwrap();\n    let mut digits: Vec<isize>\
    \ = vec![];\n    let mut digit_sum = 0;\n    while *large_prime > 0 {\n      \
    \  digits.push(large_prime % 10);\n        digit_sum += digits.last().unwrap();\n\
    \        *large_prime /= 10;\n    }\n    digit_sum", "    use std::cmp::Reverse;\n\
    \    let mut v = Vec::new();\n    for i in lst {\n        let mut n = i;\n   \
    \     let mut k = 1;\n        while n > 1 {\n            let mut p = 0;\n    \
    \        while n % primes_list[p] != 0 {\n                p += 1;\n          \
    \  }\n            n /= primes_list[p];\n            k *= primes_list[p];\n   \
    \     }\n        v.push(k);\n    }\n    v.sort_by_key(|&x| Reverse(x));\n    let\
    \ mut s = 0;\n    while v[0] != 0 {\n        s += v[0] % 10;\n        v[0] /=\
    \ 10;\n    }\n    s", "    let mut primes = vec![];\n    lst.iter().for_each(|&n|\
    \ {\n        if n.is_prime() {\n            primes.push(n);\n        }\n    });\n\
    \    primes.sort();\n    let mut sum = 0;\n    let prime = primes.pop().unwrap();\n\
    \    let mut prime_digits = prime.to_string();\n    prime_digits.chars().for_each(|c|\
    \ {\n        let d = c.to_digit(10).unwrap();\n        sum += d as isize;\n  \
    \  });\n    sum", "    let mut primes: Vec<isize> = vec![];\n    let mut max_prime\
    \ = 0;\n    for i in &lst {\n        if is_prime(*i) {\n            primes.push(*i);\n\
    \            if max_prime < *i {\n                max_prime = *i;\n          \
    \  }\n        }\n    }\n    let mut digits: Vec<isize> = vec![];\n    while max_prime\
    \ != 0 {\n        digits.push(max_prime % 10);\n        max_prime /= 10;\n   \
    \ }\n    digits.iter().sum()", "  let mut primes = Vec::new();\n  for i in lst\
    \ {\n    if is_prime(i) {\n      primes.push(i);\n    }\n  }\n  match primes.iter().max()\
    \ {\n    Some(x) => {\n      let mut sum = 0;\n      for i in x.to_string().chars()\
    \ {\n        sum += i.to_digit(10).unwrap() as isize;\n      }\n      sum\n  \
    \  }\n    None => 0,\n  }", "    println!(\"{:?}\", lst);\n    let mut input =\
    \ lst.clone();\n    input.sort();\n    let mut sum = 0;\n    for i in input.iter().rev()\
    \ {\n        if i != &0 {\n            if is_prime(*i) {\n                sum\
    \ += i.to_string().chars().map(|x| x.to_digit(10).unwrap()).sum::<u32>() as isize;\n\
    \                return sum;\n            }\n        }\n    }\n    sum", "   \
    \ for n in 1..lst.len() {\n        let mut tmp = lst.clone();\n        tmp.drain(lst.len()\
    \ - n..);\n        let sum = tmp.iter().sum::<isize>();\n        if kata::prime_stream()\n\
    \            .take_while(|&x| x < sum)\n            .map(|n| n.to_string())\n\
    \            .collect::<String>()\n            .chars()\n            .map(|d|\
    \ d.to_digit(10).unwrap() as isize)\n            .sum::<isize>()\n           \
    \ == sum\n        {\n            return sum;\n        }\n    }\n    0", "    let\
    \ mut primes: Vec<isize> = vec![];\n    let len = lst.len();\n    for i in 0..len\
    \ {\n        let mut flag = true;\n        for j in 2..lst[i] {\n            if\
    \ lst[i] % j == 0 {\n                flag = false;\n                break;\n \
    \           }\n        }\n        if flag {\n            primes.push(lst[i]);\n\
    \        }\n    }\n    let mut max = 0;\n    for i in 0..primes.len() {\n    \
    \    if primes[i] > max {\n            max = primes[i];\n        }\n    }\n  \
    \  let mut summ = 0;\n    while max != 0 {\n        summ += max % 10;\n      \
    \  max /= 10;\n    }\n    summ", "    let mut p = prime_factors(lst.iter().product());\n\
    \    p.sort();\n    p.reverse();\n    let mut r: Vec<isize> = vec![];\n    for\
    \ i in p {\n        let n = prime_factors(i);\n        if n.len() == 1 {\n   \
    \         r.push(i);\n        }\n    }\n    r.last().unwrap().to_string().chars().map(|i|\
    \ i.to_digit(10).unwrap() as isize).sum()", '    lst.iter().filter(|&x| x.is_prime()).max().unwrap().to_digit_sum()',
  '    lst.iter().map(|i| is_prime(*i)).max().unwrap()', "    let mut prime_sum =\
    \ 0;\n    for x in lst {\n        if is_prime(x) {\n            for i in x.to_string().chars()\
    \ {\n                prime_sum += i.to_digit(10).unwrap() as isize;\n        \
    \    }\n        }\n    }\n    prime_sum", "    let mut x = 1;\n    for e in lst\
    \ {\n        x = is_prime(e, x);\n    }\n    let mut sum = 0;\n    while x > 0\
    \ {\n        sum += x % 10;\n        x /= 10;\n    }\n    sum", "    // This is\
    \ your job. :)\n    let mut pos = 0;\n    let mut l = lst.len();\n    while l\
    \ > 1 {\n        if lst[pos] % 2 == 0 || lst[pos] % 3 == 0 || lst[pos] % 5 ==\
    \ 0 {\n            l -= 1;\n            let mut i = pos;\n            while i\
    \ < lst.len()-1 {\n                lst[i] = lst[i+1];\n                i += 1;\n\
    \            }\n        } else {\n            pos += 1;\n        }\n    }\n  \
    \  let mut i = lst[pos] as isize;\n    let mut sum = 0;\n    while i > 0 {\n \
    \       sum += i % 10;\n        i /= 10;\n    }\n    sum", "    let mut largest\
    \ = 0;\n    for i in lst {\n        if i > largest && is_prime(i) {\n        \
    \    largest = i;\n        }\n    }\n    largest\n        .to_string()\n     \
    \   .chars()\n        .map(|x| x.to_digit(10).unwrap() as isize)\n        .sum()",
  "  let mut max = 0;\n  for i in lst {\n    if (i > max) && is_prime(i) {\n     \
    \ max = i;\n    }\n  }\n  let mut sum = 0;\n  for c in max.to_string().chars()\
    \ {\n    sum += c.to_digit(10).unwrap();\n  }\n  sum", "    let mut primes = vec![];\n\
    \    for i in lst {\n        if i > 0 {\n            let mut x = i;\n        \
    \    for p in 2..i {\n                if x % p == 0 {\n                    x /=\
    \ p;\n                    primes.push(p);\n                }\n            }\n\
    \            primes.push(x);\n        }\n    }\n    let sum: isize = primes.iter().fold(0,\
    \ |acc, x| {\n        let mut y = *x;\n        let mut digits: Vec<_> = Vec::new();\n\
    \        while y > 0 {\n            digits.push(y % 10);\n            y /= 10;\n\
    \        }\n        acc + digits.iter().fold(0, |acc, x| acc + x)\n    });\n \
    \   sum", "    let mut i = 0;\n    while i < lst.len() {\n        if is_prime(lst[i])\
    \ {\n            return sum_of_digits(lst[i]);\n        }\n        i += 1;\n \
    \   }\n    0", "  let mut largest_prime = 0;\n  for x in lst {\n    if is_prime(x)\
    \ && x > largest_prime {\n      largest_prime = x;\n    }\n  }\n  digits_of(largest_prime).iter().fold(0,\
    \ |acc, i| acc + i)", "    let mut max_prime = 0;\n    for &i in &lst {\n    \
    \    if is_prime(i) && i > max_prime {\n            max_prime = i;\n        }\n\
    \    }\n    max_prime\n        .to_string()\n        .chars()\n        .map(|c|\
    \ c.to_digit(10).unwrap() as isize)\n        .sum()", '    unimplemented!();',
  "    let mut primes = Vec::new();\n    for x in lst {\n        let mut ok = true;\n\
    \        for y in 2..x {\n            if x % y == 0 {\n                ok = false;\n\
    \                break;\n            }\n        }\n        if ok {\n         \
    \   primes.push(x);\n        }\n    }\n    let mut big = 0;\n    for x in primes\
    \ {\n        if x > big {\n            big = x;\n        }\n    }\n    println!(\"\
    {}\", big);\n    let mut sum = 0;\n    let mut x = big;\n    while x != 0 {\n\
    \        sum += x % 10;\n        x /= 10;\n    }\n    sum", "  let mut max_prime\
    \ = 0;\n  for i in lst {\n    let mut is_prime = true;\n    for j in 2..i {\n\
    \      if i % j == 0 {\n        is_prime = false;\n        break;\n      }\n \
    \   }\n    if is_prime && i > max_prime {\n      max_prime = i;\n    }\n  }\n\
    \  let mut digits = vec![];\n  let mut remain = max_prime;\n  while remain > 0\
    \ {\n    digits.push(remain % 10);\n    remain /= 10;\n  }\n  digits.iter().sum()",
  "    let mut primes: Vec<isize> = Vec::new();\n    let mut max_prime = -1;\n   \
    \ let mut max_sum = -1;\n    for item in lst {\n        let mut is_prime = true;\n\
    \        if item == 0 || item == 1 {\n            is_prime = false;\n        }\n\
    \        for prime in primes.iter() {\n            if item % prime == 0 {\n  \
    \              is_prime = false;\n                break;\n            }\n    \
    \    }\n        if is_prime {\n            primes.push(item);\n            let\
    \ mut sum = 0;\n            let mut tmp = item;\n            while tmp > 0 {\n\
    \                sum += tmp % 10;\n                tmp /= 10;\n            }\n\
    \            if sum > max_sum {\n                max_sum = sum;\n            \
    \    max_prime = item;\n            }\n        }\n    }\n    return max_prime;",
  "    let mut vec: Vec<isize> = Vec::new();\n    for n in lst {\n        if n % 2\
    \ != 0 {\n            vec.push(n);\n        }\n    }\n    let mut max = -1;\n\
    \    for n in vec {\n        if is_prime(n) {\n            if n > max {\n    \
    \            max = n;\n            }\n        }\n    }\n    let mut sum = 0;\n\
    \    while max > 0 {\n        sum += max % 10;\n        max /= 10;\n    }\n  \
    \  sum", "    let mut prime = 0;\n    for num in lst {\n        if is_prime(num)\
    \ && num > prime {\n            prime = num;\n        }\n    }\n    return sum_digits(prime);",
  "    let mut primes = vec![];\n    for x in lst {\n        if is_prime(x) {\n  \
    \          primes.push(x);\n        }\n    }\n    let mut biggest_prime = 0;\n\
    \    for p in primes {\n        if p > biggest_prime {\n            biggest_prime\
    \ = p;\n        }\n    }\n    return sum_digits(biggest_prime);", "    let sum:\
    \ isize = lst.iter().map(|n| n.abs()).sum();\n    let sum = sum.to_string();\n\
    \    let sum: Vec<u32> = sum.chars().map(|x| x.to_digit(10).unwrap()).collect();\n\
    \    let sum: isize = sum.iter().sum();\n    return sum;", '    lst.iter().filter(|&x|
    is_prime(*x)).max().unwrap().to_string().chars().map(|x| x.to_digit(10).unwrap()
    as isize).sum()', "    let mut max_prime: isize = 0;\n    for value in lst {\n\
    \        if (value > 0) && (value > max_prime) && is_prime(value) {\n        \
    \    max_prime = value;\n        }\n    }\n    sum_digits(max_prime)", "    let\
    \ mut primes: Vec<_> = lst.into_iter().collect();\n    primes.sort();\n    primes.dedup();\n\
    \    primes.reverse();\n    println!(\"{:?}\", primes);\n    let mut res = vec![];\n\
    \    for _ in 0..primes.len() {\n        let mut tmp = vec![];\n        for _\
    \ in 0..primes.len() {\n            tmp.push(false);\n        }\n        res.push(tmp);\n\
    \    }\n    for i in 0..primes.len() {\n        res[i][i] = true;\n    }\n   \
    \ for (i, &row) in primes.iter().enumerate() {\n        for (j, &col) in primes.iter().enumerate()\
    \ {\n            if (row > col) && (row % col == 0) {\n                res[i][j]\
    \ = true;\n            }\n        }\n    }\n    for row in 0..primes.len() {\n\
    \        for col in 0..primes.len() {\n            if (res[row][col]) {\n    \
    \            res[row][col] = false;\n                for idx in 0..primes.len()\
    \ {\n                    if res[idx][col] {\n                        res[idx][row]\
    \ = true;\n                    }\n                }\n            }\n        }\n\
    \    }\n    let mut res2 = vec![];\n    for (i, row) in res.iter().enumerate()\
    \ {\n        if row.iter().any(|&x| x == false) {\n            res2.push(primes[i]);\n\
    \        }\n    }\n    res2.sort();\n    res2.dedup();\n    res2.reverse();\n\
    \    println!(\"{:?}\", res2);\n    let mut sum = 0;\n    for &c in res2[0].to_string().chars()\
    \ {\n        sum += c.to_digit(10).unwrap();\n    }\n    sum", "    let mut lst2\
    \ = lst.clone();\n    lst2.sort();\n    let mut primes: Vec<isize> = Vec::new();\n\
    \    let mut i = 0;\n    for num in lst2.iter() {\n        if !is_prime(num) {\n\
    \            i += 1;\n        } else {\n            primes.push(*num);\n     \
    \   }\n    }\n    if primes.len() == 0 {\n        primes.push(0);\n    }\n   \
    \ primes.sort();\n    let mut arr = vec![0; primes.len()];\n    for i in 0..primes.len()\
    \ {\n        let mut n = primes[i];\n        while n > 0 {\n            arr[i]\
    \ += n % 10;\n            n /= 10;\n        }\n    }\n    let mut i = 0;\n   \
    \ let mut max = 0;\n    for number in arr.iter() {\n        if number > &max {\n\
    \            max = *number;\n            i = number;\n        }\n    }\n    i",
  "    let mut max = 0;\n    for n in lst {\n        if n > max && n.is_prime() {\n\
    \            max = n;\n        }\n    }\n    let mut tmp = max;\n    let mut sum\
    \ = 0;\n    while tmp > 0 {\n        sum += tmp % 10;\n        tmp /= 10;\n  \
    \  }\n    sum", "    let mut ans = 0;\n    for i in lst {\n        ans = std::cmp::max(ans,\
    \ i);\n    }\n    for i in 2..ans {\n        if is_prime(i) {\n            ans\
    \ = i;\n        }\n    }\n    let mut ret = 0;\n    for i in ans.to_string().chars()\
    \ {\n        ret += i.to_digit(10).unwrap() as isize;\n    }\n    ret", "    let\
    \ mut prime = vec![];\n    let mut sum = 0;\n    for i in lst {\n        if is_prime(i)\
    \ {\n            prime.push(i);\n        }\n    }\n    let a = prime.iter().max().unwrap();\n\
    \    while *a != 0 {\n        sum += *a % 10;\n        *a /= 10;\n    }\n    sum",
  '    unimplemented!()', '    lst.iter().filter(|&x| x.is_prime()).max().map_or(0,
    |x| x.digits().sum())', "    let mut lst = lst;\n    lst.sort();\n    lst.dedup();\n\
    \    let mut largest = 0;\n    for i in lst {\n        if is_prime(i) {\n    \
    \        if i > largest {\n                largest = i;\n            }\n     \
    \   }\n    }\n    largest", "    // The largest prime factor of an integer can\
    \ only be up to the square root of that number\n    // So we only need to go up\
    \ to the square root of the largest number\n    let sqrt = lst.iter().max().unwrap().sqrt();\n\
    \    // We'll store the largest prime here\n    let mut largest = 0;\n    // We\
    \ loop through the list of numbers\n    for i in lst {\n        // If we've found\
    \ a new largest number\n        if i > largest {\n            // We'll assume\
    \ that it's the largest prime number\n            largest = i;\n            //\
    \ Now we check if it's a prime number\n            if !is_prime(i) {\n       \
    \         // If it's not prime, we'll start looking for the next largest prime\
    \ number\n                largest = find_next_prime(i);\n            }\n     \
    \   }\n    }\n    // Finally, we add all the digits of the largest prime\n   \
    \ add_digits(largest)", "    let mut max_prime = 0;\n    for n in lst {\n    \
    \    let mut is_prime = true;\n        for d in 2..n {\n            if n % d ==\
    \ 0 {\n                is_prime = false;\n                break;\n           \
    \ }\n        }\n        if is_prime && n > max_prime {\n            max_prime\
    \ = n;\n        }\n    }\n    max_prime.to_string().chars().map(|c| c.to_digit(10).unwrap()\
    \ as isize).sum()", "    let mut primes = Vec::new();\n    for i in lst {\n  \
    \      if is_prime(i) {\n            primes.push(i);\n        }\n    }\n    let\
    \ mut max = 0;\n    for i in primes {\n        if i > max {\n            max =\
    \ i;\n        }\n    }\n    // convert to a vector of ints\n    let mut max_vec\
    \ = Vec::new();\n    let mut val = max;\n    while val > 0 {\n        max_vec.push(val\
    \ % 10);\n        val = val / 10;\n    }\n    max_vec.iter().sum()", "    let\
    \ mut largest = 0;\n    for val in lst {\n        if val > largest && is_prime(val)\
    \ {\n            largest = val;\n        }\n    }\n    let mut sum = 0;\n    for\
    \ digit in largest.to_string().chars() {\n        sum += digit.to_digit(10).unwrap()\
    \ as isize;\n    }\n    sum", '    lst.iter().map(|x| max_prime_sum(*x)).sum()',
  "    let primes = find_primes(lst);\n    let mut max = 0;\n    for p in primes {\n\
    \        if p > max {\n            max = p;\n        }\n    }\n    let mut tmp\
    \ = max;\n    let mut res = 0;\n    while tmp > 0 {\n        res += tmp % 10;\n\
    \        tmp /= 10;\n    }\n    res", "    let mut lst = lst;\n    lst.sort();\n\
    \    let mut highest = 0;\n    let mut cur = 0;\n    while let Some(x) = lst.pop()\
    \ {\n        if x > highest {\n            cur = x;\n            highest = x;\n\
    \        }\n    }\n    digits(cur)", "    let largest_prime = lst.iter().filter(|&x|\
    \ is_prime(*x)).max().unwrap();\n    println!(\"largest prime: {}\", largest_prime);\n\
    \    let sum_of_digits = largest_prime.to_string().chars().map(|x| x.to_digit(10).unwrap()).sum();\n\
    \    sum_of_digits as isize", "    let mut p = 0;\n    for i in lst {\n      \
    \  if i > p && is_prime(i) {\n            p = i;\n        }\n    }\n    return\
    \ digits_sum(p);", "    let mut max = 0;\n    for n in lst {\n        if n > max\
    \ && n.is_prime() {\n            max = n;\n        }\n    }\n    max.digits().sum()",
  "    let m = lst.iter().fold(0, |acc, &x| if acc < x { x } else { acc });\n    let\
    \ primes = get_prime_sum_digits(m as usize);\n    let mut res = 0;\n    for &x\
    \ in lst.iter() {\n        res += primes[x as usize];\n    }\n    res", '  return
    0;', "    let mut result = 0;\n    let mut max = 0;\n    for i in lst {\n    \
    \    if prime_num(i) && i > max {\n            max = i;\n        }\n    }\n  \
    \  while max > 0 {\n        result += max % 10;\n        max /= 10;\n    }\n \
    \   result", "    let mut v: Vec<isize> = lst.iter().map(|&x| x).collect();\n\
    \    let mut max = v[0];\n    for i in 0..v.len() {\n        if v[i] > max {\n\
    \            max = v[i];\n        }\n    }\n    if max == 0 {\n        return\
    \ 0;\n    }\n    let mut i = 2;\n    let mut res = Vec::new();\n    while i *\
    \ i <= max {\n        if max % i == 0 {\n            while max % i == 0 {\n  \
    \              max /= i;\n            }\n            res.push(i);\n        }\n\
    \        i += 1;\n    }\n    if max > 1 {\n        res.push(max);\n    }\n   \
    \ let mut sum = 0;\n    for c in res.iter() {\n        for i in 0..v.len() {\n\
    \            if v[i] % c == 0 {\n                v[i] /= c;\n            }\n \
    \       }\n    }\n    for c in v.iter() {\n        sum += c;\n    }\n    sum",
  "    let mut largest = 0;\n    for i in lst {\n        if is_prime(i) && i > largest\
    \ {\n            largest = i;\n        }\n    }\n    let mut sum = 0;\n    while\
    \ largest > 0 {\n        sum += largest % 10;\n        largest /= 10;\n    }\n\
    \    sum", '    unimplemented!()', "    let mut prime_candidate = -1;\n    for\
    \ n in lst {\n        if n < 0 {\n            continue;\n        }\n        if\
    \ n > prime_candidate && is_prime(n) {\n            prime_candidate = n;\n   \
    \     }\n    }\n    if prime_candidate == -1 {\n        0\n    } else {\n    \
    \    get_digits_sum(prime_candidate)\n    }", "    let mut largest_prime = 0;\n\
    \    for i in lst {\n        if get_prime(i) {\n            if i > largest_prime\
    \ {\n                largest_prime = i;\n            }\n        }\n    }\n   \
    \ let mut sum = 0;\n    let mut n = largest_prime;\n    while n > 0 {\n      \
    \  sum += n % 10;\n        n /= 10;\n    }\n    sum", "    let (g, _) = lst.iter().fold((0,\
    \ 0), |(acc, prev), next| {\n        if acc > next {\n            (acc, next)\n\
    \        } else {\n            (next, next)\n        }\n    });\n    g", "   \
    \ let mut max = 0;\n    for item in lst {\n        if item > max && is_prime(item)\
    \ {\n            max = item;\n        }\n    }\n    let mut sum = 0;\n    for\
    \ s in max.to_string().chars() {\n        sum += s.to_digit(10).unwrap() as isize;\n\
    \    }\n    sum", "    let mut array = lst.clone();\n    array.sort();\n    let\
    \ array = array.iter().rev().collect::<Vec<&isize>>();\n    let mut max = 0;\n\
    \    for i in array {\n        if is_prime(*i) && i > &max {\n            max\
    \ = *i;\n        }\n    }\n    let mut sum = 0;\n    while max != 0 {\n      \
    \  sum += max % 10;\n        max /= 10;\n    }\n    sum", "    let mut list =\
    \ lst.clone();\n    list.sort();\n    let mut n = 0;\n    let mut m = list.len()\
    \ - 1;\n    while n <= m {\n        if list[n] != 0 {\n            n += 1;\n \
    \       } else if list[m] != 0 {\n            m -= 1;\n        } else {\n    \
    \        list[n] = list[m];\n            list[m] = 0;\n            n += 1;\n \
    \           m -= 1;\n        }\n    }\n    list.pop();\n    let mut last = list.len()\
    \ - 1;\n    for i in 0..list.len() - 1 {\n        if list[i] > list[last] {\n\
    \            last = i;\n        }\n    }\n    list[last]", "    let mut primes:\
    \ Vec<isize> = Vec::new();\n    let mut result: isize = 0;\n    let mut i: isize\
    \ = 0;\n    while i < lst.len() as isize {\n        let mut is_prime: bool = true;\n\
    \        let mut j: isize = 2;\n        let sqrt_i: isize = (i as f64).sqrt()\
    \ as isize;\n        if lst[i as usize] == 1 {\n            is_prime = false;\n\
    \        }\n        while j <= sqrt_i {\n            if lst[i as usize] % j ==\
    \ 0 {\n                is_prime = false;\n                break;\n           \
    \ }\n            j += 1;\n        }\n        if is_prime {\n            primes.push(lst[i\
    \ as usize]);\n        }\n        i += 1;\n    }\n    if primes.len() > 0 {\n\
    \        result = primes.iter().max().unwrap().to_string().chars().map(|x| x.to_digit(10).unwrap()\
    \ as isize).sum();\n    }\n    result", "    let mut largest_prime = 0;\n    for\
    \ i in lst {\n        if primes::is_prime(i) {\n            if i > largest_prime\
    \ {\n                largest_prime = i;\n            }\n        }\n    }\n   \
    \ let mut sum = 0;\n    for d in largest_prime.to_string().chars() {\n       \
    \ sum += d.to_digit(10).unwrap() as isize;\n    }\n    sum", "    let mut result\
    \ = 0;\n    let mut cnt = 0;\n    for i in 0..lst.len() {\n        if lst[i] %\
    \ 2 == 0 {\n            result += lst[i];\n            if cnt == 0 {\n       \
    \         cnt = 1;\n            }\n        }\n    }\n    if cnt == 0 {\n     \
    \   for i in 0..lst.len() {\n            result += lst[i];\n        }\n    }\n\
    \    result", "    if lst.is_empty() {\n        return 0;\n    }\n    let mut\
    \ lst: Vec<isize> = lst.iter().map(|x| x.clone()).collect();\n    let mut max\
    \ = -1;\n    let mut imax = -1;\n    for (i, num) in lst.iter().enumerate() {\n\
    \        if max < *num {\n            max = *num;\n            imax = i;\n   \
    \     }\n    }\n    let mut ind: Vec<usize> = vec![];\n    for (i, num) in lst.iter().enumerate()\
    \ {\n        if i != imax && *num % max == 0 {\n            ind.push(i);\n   \
    \     }\n    }\n    for i in ind.iter().rev() {\n        lst.remove(*i);\n   \
    \ }\n    lst.remove(imax);\n    max", "    let mut lst: Vec<isize> = lst;\n  \
    \  lst.sort();\n    lst.dedup();\n    lst.reverse();\n    let mut largest_prime:\
    \ isize = 0;\n    for i in lst {\n        if is_prime(i) {\n            largest_prime\
    \ = i;\n            break;\n        }\n    }\n    sum_digits(largest_prime)",
  "    let mut result = 0;\n    let mut max = lst[0];\n    for i in lst {\n      \
    \  if is_prime(i) && i > max {\n            max = i;\n        }\n    }\n    while\
    \ max > 0 {\n        result += max % 10;\n        max /= 10;\n    }\n    result",
  "    let mut s: isize = 0;\n    let mut v: Vec<isize> = vec![];\n    let mut o:\
    \ isize = 1;\n    let mut i: isize = 1;\n    while o != 0 {\n        o = 0;\n\
    \        for x in &lst {\n            if x % i == 0 {\n                o += 1;\n\
    \            }\n        }\n        if o < 2 {\n            v.push(i);\n      \
    \  }\n        i += 1;\n    }\n    for x in v {\n        if x == 2 || x == 3 ||\
    \ x == 5 || x == 7 {\n            s += x;\n        }\n    }\n    s", '    0',
  '    return (lst.iter().filter(|&x| x.is_prime()).max().unwrap() as usize).digits().sum();',
  "    let mut max = 0;\n    for x in lst {\n        if is_prime(x) && x > max {\n\
    \            max = x;\n        }\n    }\n    dbg!(max);\n    max.to_string()\n\
    \        .chars()\n        .map(|c| c.to_digit(10).unwrap() as isize)\n      \
    \  .sum()", "    let mut largest_prime = 2;\n    for i in lst {\n        let is_prime\
    \ = (2..i).all(|n| i % n != 0);\n        if is_prime && i > largest_prime {\n\
    \            largest_prime = i;\n        }\n    }\n    let mut result = 0;\n \
    \   for c in largest_prime.to_string().chars() {\n        result += c.to_digit(10).unwrap();\n\
    \    }\n    result", "    // Get largest prime\n    let mut primes: Vec<isize>\
    \ = (2..1000000)\n        .filter(|&x| !(2..x).any(|z| x % z == 0))\n        .collect();\n\
    \    primes.sort();\n    primes.reverse();\n    let max_prime = primes\n     \
    \   .iter()\n        .filter(|&&p| p <= *lst.iter().max().unwrap())\n        .next()\n\
    \        .unwrap();\n    // Sum digits\n    max_prime.to_string()\n        .chars()\n\
    \        .map(|c| c.to_digit(10).unwrap() as isize)\n        .sum()", "    let\
    \ mut lst2 = lst.clone();\n    lst2.sort();\n    let l = lst2.len();\n    let\
    \ mut ans = 0;\n    if lst2[l - 1] > lst2[l - 2] {\n        ans = lst2[l - 1];\n\
    \    } else {\n        ans = lst2[l - 2];\n    }\n    let mut digits = 0;\n  \
    \  while ans != 0 {\n        ans /= 10;\n        digits += 1;\n    }\n    let\
    \ mut ans2 = 0;\n    for i in 0..digits {\n        ans2 += (lst2[l - 1] % 10).abs();\n\
    \        lst2[l - 1] /= 10;\n    }\n    return ans2;", "    let mut mx = 0;\n\
    \    for i in lst {\n        let t = max_prime_of(i);\n        mx = if t > mx\
    \ {\n            t\n        } else {\n            mx\n        };\n    }\n    mx",
  "    // First find the largest prime\n    let mut largest = 0;\n    for num in lst\
    \ {\n        if is_prime(num) && num > largest {\n            largest = num;\n\
    \        }\n    }\n    // I tried getting the digits in reverse to break out of\
    \ the loop faster, but it didn't seem to save time.\n    let mut digits = Vec::new();\n\
    \    let mut num = largest;\n    while num > 0 {\n        digits.push(num % 10);\n\
    \        num /= 10;\n    }\n    // Now sum the digits\n    let mut total = 0;\n\
    \    for digit in digits {\n        total += digit;\n    }\n    return total;",
  "    let mut s: isize = 0;\n    let mut prim = 0;\n    let mut i = 0;\n    for &e\
    \ in lst.iter() {\n        if is_prime(e) {\n            if e > prim {\n     \
    \           prim = e;\n            }\n        }\n    }\n    while prim > 0 {\n\
    \        s += prim % 10;\n        prim /= 10;\n    }\n    s", "    let mut sum\
    \ = 0;\n    let mut mx = 0;\n    for i in lst {\n        if is_prime(i) {\n  \
    \          mx = std::cmp::max(mx, i);\n        }\n    }\n    println!(\"the largest\
    \ prime is {}\", mx);\n    while mx > 0 {\n        sum += mx % 10;\n        mx\
    \ /= 10;\n    }\n    sum", "    if lst.is_empty() {\n        return 0;\n    }\n\
    \    let mut cur = lst[0];\n    let mut max = cur;\n    for i in 1..lst.len()\
    \ {\n        if lst[i] > max {\n            max = lst[i];\n        }\n    }\n\
    \    let mut i = max;\n    loop {\n        if is_prime(i) {\n            cur =\
    \ i;\n            break;\n        }\n        i -= 1;\n    }\n    let mut result\
    \ = 0;\n    while cur > 0 {\n        result += cur % 10;\n        cur /= 10;\n\
    \    }\n    result", "    // First find the largest prime in the list\n    let\
    \ mut largest_prime: isize = 0;\n    for i in lst {\n        if is_prime(i) &&\
    \ i > largest_prime {\n            largest_prime = i;\n        }\n    }\n    //\
    \ Now find the sum of the digits of the largest prime\n    let mut total = 0;\n\
    \    let mut x = largest_prime;\n    while x > 0 {\n        total += x % 10;\n\
    \        x /= 10;\n    }\n    total", "    let mut lst_nums = lst.clone();\n \
    \   let mut primes = Vec::new();\n    let mut sum_prime = 0;\n    for num in lst_nums\
    \ {\n        if is_prime(num) {\n            primes.push(num);\n        }\n  \
    \  }\n    let mut max_prime = primes[0];\n    for prime in primes {\n        if\
    \ prime > max_prime {\n            max_prime = prime;\n        }\n    }\n    while\
    \ max_prime != 0 {\n        sum_prime += max_prime % 10;\n        max_prime /=\
    \ 10;\n    }\n    sum_prime", "    let biggest_prime: isize = lst.iter().filter(|x|\
    \ x > &&0).filter(|x| x.is_prime()).max().unwrap();\n    // With this I am assuming\
    \ that the list contains at least 1 prime.\n    // This is not the case, but I\
    \ don't know how to deal with this yet.\n    // WIP\n    let mut digits: Vec<isize>\
    \ = biggest_prime.to_string().chars().map(|x| x.to_digit(10).unwrap() as isize).collect();\n\
    \    // This is not so nice, but it is working.\n    // WIP\n    digits.iter().sum()",
  '    lst.iter().map(|x| (2..*x).fold(1, |acc, i| if acc > 1 && acc % i == 0 { *x
    / i } else {acc})).max().unwrap()', "    // Do some shit here!\n    0", "    let\
    \ mut sieve = vec![true; 1000];\n    let mut prime_sum = 0;\n    sieve[0] = false;\n\
    \    sieve[1] = false;\n    for i in 2..sieve.len() {\n        if sieve[i] {\n\
    \            let mut j = i * i;\n            while j < sieve.len() {\n       \
    \         sieve[j] = false;\n                j += i;\n            }\n        }\n\
    \    }\n    for val in lst {\n        if sieve[val as usize] {\n            prime_sum\
    \ += sum_of_digits(val);\n        }\n    }\n    prime_sum", "    let mut lst:\
    \ Vec<isize> = lst;\n    let mut sum: isize = 0;\n    lst.sort();\n    let mut\
    \ len: usize = lst.len();\n    while len > 0 {\n        let mut n: isize = lst[len\
    \ - 1];\n        if is_prime(n) {\n            let mut temp = n;\n           \
    \ while temp > 0 {\n                sum += temp % 10;\n                temp /=\
    \ 10;\n            }\n            return sum;\n        }\n        len -= 1;\n\
    \    }\n    sum", "    let mut lst: Vec<isize> = lst;\n    lst.sort();\n    lst.reverse();\n\
    \    let mut largest_prime: Option<isize> = None;\n    for i in lst {\n      \
    \  if is_prime(i) {\n            largest_prime = Some(i);\n            break;\n\
    \        }\n    }\n    if let Some(x) = largest_prime {\n        x.to_string()\n\
    \            .chars()\n            .map(|x| x.to_digit(10).unwrap() as isize)\n\
    \            .sum()\n    } else {\n        0\n    }", "    let mut sss = lst.iter().filter(|&x|\
    \ is_prime(*x)).max().unwrap().to_string();\n    let mut k = 0;\n    while sss.len()\
    \ > 0 {\n        k += sss.pop().unwrap() as isize - '0' as isize;\n    }\n   \
    \ k", "    let primes = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,\
    \ 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131,\
    \ 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223,\
    \ 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311,\
    \ 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409,\
    \ 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503,\
    \ 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613,\
    \ 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719,\
    \ 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827,\
    \ 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941,\
    \ 947, 953, 967, 971, 977, 983, 991, 997];\n    let mut max_prime = -1;\n    for\
    \ num in lst {\n        if primes.contains(&num) {\n            if num > max_prime\
    \ {\n                max_prime = num;\n            }\n        }\n    }\n    if\
    \ max_prime == -1 {\n        0\n    } else {\n        max_prime.to_string().chars().",
  "    let mut largest_prime = -1;\n    for x in lst {\n        let mut is_prime =\
    \ true;\n        for y in 2..x / 2 {\n            if x % y == 0 {\n          \
    \      is_prime = false;\n                break;\n            }\n        }\n \
    \       if is_prime && x > largest_prime {\n            largest_prime = x;\n \
    \       }\n    }\n    largest_prime", "    let mut largest_prime = 0;\n    let\
    \ mut largest_prime_length = 0;\n    let mut largest_prime_length_index = 0;\n\
    \    let mut largest_prime_index = 0;\n    for i in 0..lst.len() {\n        let\
    \ check_number = lst[i];\n        if check_number == 2 {\n            largest_prime\
    \ = check_number;\n            largest_prime_length = 1;\n            largest_prime_length_index\
    \ = i;\n            largest_prime_index = 0;\n        } else if check_number >\
    \ 2 {\n            let mut length = 0;\n            let mut current_prime = 0;\n\
    \            let mut current_prime_index = 0;\n            for j in 1..check_number\
    \ + 1 {\n                if check_number % j == 0 {\n                    length\
    \ += 1;\n                    current_prime = j;\n                    current_prime_index\
    \ = j - 1;\n                }\n            }\n            if length == 2 {\n \
    \               if current_prime_index > largest_prime_length_index {\n      \
    \              largest_prime = current_prime;\n                    largest_prime_length\
    \ = length;\n                    largest_prime_length_index = current_prime_index;\n\
    \                    largest_prime_index = i;\n                }\n           \
    \ }\n        }\n    }\n    println!(\"{}-{}-{}-{}\", largest_prime, largest_prime_length,\
    \ largest_prime_length_index, largest_prime_index);\n    let mut largest_prime_string\
    \ = largest_prime.to_string();\n    let mut largest_prime_chars: Vec<char> = largest_prime_string.chars().collect();\n\
    \    let mut sum = 0;\n    for i in 0..largest_prime_chars.len() {\n        sum\
    \ += largest_prime_chars[i].to_digit(10).unwrap() as isize;\n    }\n    return\
    \ sum;", "    let mut cur: isize = 0;\n    let mut primes: Vec<isize> = Vec::new();\n\
    \    for i in lst {\n        if is_prime(i) {\n            primes.push(i);\n \
    \       }\n    }\n    let mut max: isize = 0;\n    for i in primes {\n       \
    \ if i > max {\n            max = i;\n        }\n    }\n    for i in max.to_string().chars()\
    \ {\n        cur += i.to_digit(10).unwrap() as isize;\n    }\n    cur", "    let\
    \ mut largest_prime: isize = 0;\n    for x in lst {\n        let mut temp = x;\n\
    \        let mut prime = true;\n        let mut counter = 2;\n        while counter\
    \ < temp {\n            if temp % counter == 0 {\n                prime = false;\n\
    \                break;\n            }\n            counter += 1;\n        }\n\
    \        if prime && temp > largest_prime {\n            largest_prime = temp;\n\
    \        }\n    }\n    let mut ret = 0;\n    let mut temp = largest_prime;\n \
    \   while temp != 0 {\n        ret += temp % 10;\n        temp /= 10;\n    }\n\
    \    ret", "    let mut a: Vec<isize> = Vec::new();\n    for i in lst {\n    \
    \    if primes::is_prime(i) {\n            a.push(i);\n        }\n    }\n    let\
    \ mut max = 0;\n    for &i in a.iter() {\n        if i > max {\n            max\
    \ = i;\n        }\n    }\n    max", "    let mut result = 0;\n    let len = lst.len();\n\
    \    let mut first_num = 0;\n    let mut last_num = 0;\n    let mut i = 0;\n \
    \   let mut a = 0;\n    let mut b = 0;\n    let mut c = 0;\n    let mut d = 0;\n\
    \    let mut e = 0;\n    let mut f = 0;\n    let mut g = 0;\n    let mut h = 0;\n\
    \    let mut j = 0;\n    let mut k = 0;\n    let mut l = 0;\n    let mut m = 0;\n\
    \    let mut n = 0;\n    let mut o = 0;\n    let mut p = 0;\n    let mut q = 0;\n\
    \    let mut r = 0;\n    let mut s = 0;\n    let mut t = 0;\n    let mut u = 0;\n\
    \    let mut v = 0;\n    let mut w = 0;\n    let mut x = 0;\n    let mut y = 0;\n\
    \    let mut z = 0;\n    //find largets prime\n    while i < len {\n        a\
    \ = lst[i];\n        b = a / 1000;\n        c = a / 100 - 10 * b;\n        d =\
    \ a / 10 - 100 * b - 10 * c;\n        e = a - 1000 * b - 100 * c - 10 * d;\n \
    \       f = lst[i + 1];\n        g = f / 1000;\n        h = f / 100 - 10 * g;\n\
    \        j = f / 10 - 100 * g - 10 * h;\n        k = f - 1000 * g - 100 * h -\
    \ 10 * j;\n        l = lst[i + 2];\n        m = l / 1000;\n        n = l / 100\
    \ - 10 * m;\n        o = l / 10 - 100 * m - 10 * n;\n        p = l - 1000 * m\
    \ - 100 * n - 10 * o;\n        q = lst[i + 3];\n        r = q / 1000;\n      \
    \  s = q / 100 - 10 * r;\n        t = q / 10 - 100 * r - 10 * s;\n        u =\
    \ q - 1000 * r - 100 *", '    unimplemented!();', "    let mut lst_set = lst.clone();\n\
    \    lst_set.sort();\n    lst_set.dedup();\n    let mut lst_prime = Vec::new();\n\
    \    for &i in &lst_set {\n        if !(i < 2) && check_prime(&i) {\n        \
    \    lst_prime.push(i);\n        }\n    }\n    if !lst_prime.is_empty() {\n  \
    \      let mut max = lst_prime[0];\n        for &i in &lst_prime {\n         \
    \   if i > max {\n                max = i;\n            }\n        }\n       \
    \ let mut str_max = max.to_string();\n        let mut max_sum = 0;\n        for\
    \ c in str_max.chars() {\n            let c_int = c.to_digit(10).unwrap();\n \
    \           max_sum += c_int as isize;\n        }\n        return max_sum;\n \
    \   }\n    else {\n        return 0;\n    }", "    let mut res = 0;\n    let primes\
    \ = make_primes(200000);\n    let mut lst = lst;\n    lst.sort();\n    let mut\
    \ cur = lst.pop().unwrap();\n    for i in lst.iter().rev() {\n        if i * i\
    \ < cur {\n            return sum_digits(cur as usize);\n        }\n        for\
    \ j in primes.iter() {\n            if i % j == 0 && cur % j == 0 {\n        \
    \        cur /= j;\n                break;\n            }\n        }\n    }\n\
    \    return sum_digits(cur as usize);", "    let lst: Vec<usize> = lst.iter().map(|x|\
    \ *x as usize).collect();\n    let mut primes: Vec<usize> = vec![];\n    let mut\
    \ numbers: Vec<usize> = vec![];\n    for i in lst {\n        if is_prime(i) {\n\
    \            primes.push(i);\n        } else {\n            numbers.push(i);\n\
    \        }\n    }\n    let mut max_prime = 0;\n    let mut max_number = 0;\n \
    \   for i in &primes {\n        if i > &max_prime {\n            max_prime = *i;\n\
    \        }\n    }\n    for i in &numbers {\n        if i > &max_number {\n   \
    \         max_number = *i;\n        }\n    }\n    if max_prime > max_number {\n\
    \        let mut sum = 0;\n        for i in max_prime.to_string().chars() {\n\
    \            sum += i.to_digit(10).unwrap() as usize;\n        }\n        sum\
    \ as isize\n    } else {\n        let mut sum = 0;\n        for i in max_number.to_string().chars()\
    \ {\n            sum += i.to_digit(10).unwrap() as usize;\n        }\n       \
    \ sum as isize\n    }", "    let mut prime = 0;\n    for i in lst {\n        if\
    \ i > prime && is_prime(i) {\n            prime = i;\n        }\n    }\n    sum_digits(prime)",
  "    let mut lst = lst;\n    lst.sort();\n    let lst = lst.iter().rev().filter(|&x|\
    \ is_prime(*x));\n    let lst = lst.collect::<Vec<_>>();\n    let mut lst = lst.iter().next().unwrap().to_string();\n\
    \    lst.chars().filter_map(|x| x.to_digit(10)).sum()", "    let mut biggest_prime\
    \ = 1;\n    for v in lst {\n        let mut vcopy = v;\n        if vcopy < 0 {\n\
    \            vcopy = vcopy * -1;\n        }\n        if !is_prime(vcopy) {\n \
    \           continue;\n        }\n        if vcopy > biggest_prime {\n       \
    \     biggest_prime = vcopy;\n        }\n    }\n    let mut sum = 0;\n    let\
    \ mut v = biggest_prime;\n    while v > 0 {\n        sum += v % 10;\n        v\
    \ = v / 10;\n    }\n    sum", "    let prime = lst.iter().filter(|&&x| x.is_prime()).max().unwrap();\n\
    \    prime.to_string().chars().map(|c| c.to_digit(10).unwrap() as isize).sum()",
  "    let mut prime = 2;\n    for i in lst {\n        if is_prime(i) && i > prime\
    \ {\n            prime = i;\n        }\n    }\n    let mut sum = 0;\n    while\
    \ prime > 0 {\n        sum += prime % 10;\n        prime /= 10;\n    }\n    sum",
  '  0', "    let mut current_prime: isize = 0;\n    for item in lst {\n        if\
    \ is_prime(item) {\n            if item > current_prime {\n                current_prime\
    \ = item;\n            }\n        }\n    }\n    current_prime", "  let mut primes\
    \ = vec![];\n  for i in lst {\n    if is_prime(i) {\n      primes.push(i);\n \
    \   }\n  }\n  let mut sum = 0;\n  for i in primes.last().unwrap().to_string().chars()\
    \ {\n    sum += i.to_digit(10).unwrap();\n  }\n  sum", "    let l = lst.iter().max().unwrap();\n\
    \    *l.to_string().chars().map(|x| x.to_digit(10).unwrap()).sum::<u32>() as isize",
  "    let mut result = 0;\n    for x in lst {\n        if is_prime(x) {\n       \
    \     result = x;\n        }\n    }\n    let mut digits = Vec::new();\n    while\
    \ result != 0 {\n        digits.push(result % 10);\n        result /= 10;\n  \
    \  }\n    digits.iter().fold(0, |a,b| a + b)", "    let mut lst_prime = vec![];\n\
    \    let mut result = 0;\n    let mut ints = lst.clone();\n    ints.sort();\n\
    \    ints.dedup();\n    for a in ints {\n        let mut i = 2;\n        while\
    \ i <= a / 2 {\n            if a % i == 0 {\n                i = a;\n        \
    \    }\n            i += 1;\n        }\n        if i == a {\n            lst_prime.push(a);\n\
    \        }\n    }\n    if lst_prime.len() != 0 {\n        let max = lst_prime.iter().max().unwrap();\n\
    \        for n in max.to_string().chars() {\n            result += n.to_digit(10).unwrap()\
    \ as isize;\n        }\n    }\n    result", "    let mut lst = lst;\n    lst.sort();\n\
    \    lst.reverse();\n    for a in lst {\n        let z = a;\n        if is_prime(z)\
    \ {\n            return sum_digits(z);\n        }\n    }\n    0", "    let mut\
    \ v = lst.iter().filter(|&&x| x > 0).fold(vec![0], |mut a, &x| {\n        a.push(x);\n\
    \        a\n    });\n    v.sort();\n    let l = v.len();\n    let mut i = l -\
    \ 1;\n    while i > 0 {\n        let p = v[i];\n        let mut j = 2;\n     \
    \   while j < p {\n            if p % j == 0 {\n                break;\n     \
    \       }\n            j += 1;\n        }\n        if j == p {\n            break;\n\
    \        }\n        i -= 1;\n    }\n    let mut sum = 0;\n    let mut x = v[i];\n\
    \    while x > 0 {\n        sum += x % 10;\n        x /= 10;\n    }\n    sum",
  '    unimplemented!()', "    let mut max: isize = 0;\n    for n in lst {\n     \
    \   let mut res = n;\n        while res % 2 == 0 {\n            res /= 2;\n  \
    \      }\n        for i in (3..=res).step_by(2) {\n            while res % i ==\
    \ 0 {\n                res /= i;\n            }\n        }\n        if res > max\
    \ {\n            max = res;\n        }\n    }\n    let mut sum = 0;\n    while\
    \ max > 0 {\n        sum += max % 10;\n        max /= 10;\n    }\n    sum", " \
    \   // n is a prime number iff (n > 1) && (n % i != 0) for all i in 1..n\n   \
    \ if lst.iter().any(|n| *n <= 1) {\n        return 0;\n    }\n    let mut primes:\
    \ Vec<_> = lst.iter().filter(|n| {\n        (2..*n).all(|i| *n % i != 0)\n   \
    \ }).collect();\n    primes.sort();\n    let last = primes.pop().unwrap();\n \
    \   let mut sum = 0;\n    while *last != 0 {\n        sum += last % 10;\n    \
    \    *last /= 10;\n    }\n    sum", "    let mut prime_numbers: Vec<isize> = Vec::new();\n\
    \    let mut prime_sum: isize = 0;\n    let nums = lst.len();\n    for i in 1..nums\
    \ {\n        if lst[i] < 2 {\n            continue;\n        }\n        if lst[i]\
    \ % 2 == 0 {\n            continue;\n        }\n        let mut j = 3;\n     \
    \   while j < (lst[i] as f64).sqrt() as isize {\n            if lst[i] % j ==\
    \ 0 {\n                continue;\n            }\n            j += 2;\n       \
    \ }\n        prime_numbers.push(lst[i]);\n    }\n    for i in prime_numbers {\n\
    \        let mut j = i;\n        let mut digit_counter = 1;\n        while j >=\
    \ 10 {\n            j /= 10;\n            digit_counter += 1;\n        }\n   \
    \     let mut j = i;\n        let mut k = 1;\n        let mut digit_sum = 0;\n\
    \        while j >= 10 {\n            digit_sum += (j % 10) * k;\n           \
    \ j /= 10;\n            k *= 10;\n        }\n        digit_sum += j * k;\n   \
    \     if digit_sum == i {\n            continue;\n        }\n        if digit_counter\
    \ % 2 == 0 {\n            prime_sum += i;\n        }\n    }\n    prime_sum", '    0',
  '    lst.iter().filter(|i| i % *i == 0).sum()', "    let mut l = lst;\n    let mut\
    \ max = 0;\n    let mut current = 0;\n    let mut i = 0;\n    while i < l.len()\
    \ {\n        if l[i] > max {\n            if prime(&l[i]) {\n                max\
    \ = l[i];\n                current = max;\n            }\n        }\n        i\
    \ += 1;\n    }\n    while current >= 10 {\n        max += current % 10;\n    \
    \    current /= 10;\n    }\n    max + current", "    let mut primes = vec![];\n\
    \    let mut i = 0;\n    while i < lst.len() {\n        let mut j = 2;\n     \
    \   while j <= lst[i] / 2 {\n            if lst[i] % j == 0 {\n              \
    \  break;\n            }\n            j += 1;\n        }\n        if j > lst[i]\
    \ / 2 {\n            primes.push(lst[i]);\n        }\n        i += 1;\n    }\n\
    \    let max = primes.iter().max().unwrap();\n    let max = max.to_string();\n\
    \    let mut sum = 0;\n    for c in max.chars() {\n        sum += c.to_digit(10).unwrap();\n\
    \    }\n    sum", '  lst.iter().map(|x| (*x as f64).sqrt() as isize).sum()', " \
    \   // let lst = vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2,\
    \ 32, 324, 4, 3];\n    let mut max = 0;\n    for v in lst {\n        if is_prime(v)\
    \ {\n            if v > max {\n                max = v;\n            }\n     \
    \   }\n    }\n    return sum_digits(max);", "    let mut max = 0;\n    for i in\
    \ lst {\n        if is_prime(i) && i > max {\n            max = i;\n        }\n\
    \    }\n    println!(\"Max: {}\", max);\n    let mut sum = 0;\n    let max_str\
    \ = max.to_string();\n    for c in max_str.chars() {\n        sum += c.to_digit(10).unwrap()\
    \ as isize;\n    }\n    println!(\"Sum: {}\", sum);\n    sum", '  unimplemented!();',
  '    0', "    let max_prime = *lst.iter().filter(|&x| is_prime(*x)).max().unwrap();\n\
    \    println!(\"{}\", max_prime);\n    let s = max_prime.to_string();\n    s.chars().filter_map(|x|\
    \ x.to_digit(10)).sum()", "    let mut largest_prime: isize = 0;\n    for i in\
    \ lst {\n        if is_prime(i) && i > largest_prime {\n            largest_prime\
    \ = i;\n        }\n    }\n    let largest_prime_string = largest_prime.to_string();\n\
    \    let mut sum = 0;\n    for i in largest_prime_string.chars() {\n        sum\
    \ += i.to_digit(10).unwrap() as isize;\n    }\n    sum", "    let mut primes =\
    \ HashSet::new();\n    let mut max = 0;\n    for i in lst {\n        if !primes.contains(&i)\
    \ {\n            if i > max {\n                max = i;\n            }\n     \
    \       let mut prime = true;\n            for p in primes.iter() {\n        \
    \        if i % p == 0 {\n                    prime = false;\n               \
    \     break;\n                }\n            }\n            if prime {\n     \
    \           primes.insert(i);\n            }\n        }\n    }\n    let mut r:\
    \ isize = 0;\n    let mut _i = max;\n    while _i != 0 {\n        r += _i % 10;\n\
    \        _i /= 10;\n    }\n    r", "    if lst.len() == 0 {\n        return 0;\n\
    \    }\n    let mut lst = lst;\n    lst.sort();\n    let lst = lst;\n    let mut\
    \ current = lst[lst.len() - 1];\n    loop {\n        if factors(&current).len()\
    \ == 1 {\n            break;\n        }\n        current -= 1;\n    }\n    let\
    \ mut sum = 0;\n    let mut current = current;\n    loop {\n        if current\
    \ == 0 {\n            break;\n        }\n        sum += current % 10;\n      \
    \  current /= 10;\n    }\n    sum", "    let mut primes: Vec<isize> = vec![];\n\
    \    let mut prime_factors: Vec<isize> = vec![];\n    for i in lst {\n       \
    \ if i == 0 {\n            continue;\n        }\n        if prime_factors.contains(&i)\
    \ {\n            continue;\n        }\n        if i.is_prime() {\n           \
    \ primes.push(i);\n            prime_factors.push(i);\n            continue;\n\
    \        }\n        let mut j = 2;\n        while j < i {\n            if i %\
    \ j == 0 {\n                if j.is_prime() {\n                    primes.push(j);\n\
    \                    prime_factors.push(j);\n                }\n             \
    \   break;\n            }\n            j += 1;\n        }\n    }\n    let max\
    \ = primes.iter().max().unwrap();\n    let mut max_str = max.to_string();\n  \
    \  let mut sum = 0;\n    while max_str.len() > 0 {\n        let (last, rest) =\
    \ max_str.split_at(max_str.len() - 1);\n        max_str = rest.to_string();\n\
    \        let num = last.parse::<isize>().unwrap();\n        sum += num;\n    }\n\
    \    sum", "    let mut max_prime = 0;\n    for x in lst {\n        if prime(x)\
    \ && x > max_prime {\n            max_prime = x;\n        }\n    }\n    let mut\
    \ result = 0;\n    let mut x = max_prime;\n    while x > 0 {\n        result +=\
    \ x % 10;\n        x /= 10;\n    }\n    result", "    let mut primes = Vec::new();\n\
    \    for &el in &lst {\n        if el > 1 {\n            let mut is_prime = true;\n\
    \            for &p in &primes {\n                if el % p == 0 {\n         \
    \           is_prime = false;\n                    break;\n                }\n\
    \            }\n            if is_prime {\n                primes.push(el);\n\
    \            }\n        }\n    }\n    primes.sort();\n    println!(\"{:?}\", primes);\n\
    \    let biggest_prime = primes.last().unwrap();\n    println!(\"{:?}\", biggest_prime);\n\
    \    let mut biggest_prime_str = biggest_prime.to_string();\n    println!(\"{:?}\"\
    , biggest_prime_str);\n    let mut biggest_prime_chars: Vec<char> = biggest_prime_str.chars().collect();\n\
    \    println!(\"{:?}\", biggest_prime_chars);\n    let mut biggest_prime_chars_as_string:\
    \ Vec<String> = biggest_prime_chars.iter().map(|c| c.to_string()).collect();\n\
    \    println!(\"{:?}\", biggest_prime_chars_as_string);\n    let mut biggest_prime_chars_as_int:\
    \ Vec<isize> = biggest_prime_chars_as_string.iter().map(|c| c.parse::<isize>().unwrap()).collect();\n\
    \    println!(\"{:?}\", biggest_prime_chars_as_int);\n    let sum = biggest_prime_chars_as_int.iter().sum();\n\
    \    println!(\"{:?}\", sum);\n    return sum;", "    let mut primes: Vec<isize>\
    \ = vec![];\n    let mut sum: isize = 0;\n    let mut lst_max: isize = 0;\n  \
    \  for num in lst {\n        if num > lst_max {\n            lst_max = num;\n\
    \        }\n    }\n    for n in 1..lst_max {\n        let mut is_prime = true;\n\
    \        for num in 2..n {\n            if n % num == 0 {\n                is_prime\
    \ = false;\n                break;\n            }\n        }\n        if is_prime\
    \ {\n            primes.push(n);\n        }\n    }\n    primes.sort();\n    let\
    \ mut x: isize = 0;\n    let mut final_prime: isize = 0;\n    for num in lst {\n\
    \        if num > final_prime {\n            x = num;\n        }\n    }\n    for\
    \ prime in primes {\n        if prime == x {\n            final_prime = prime;\n\
    \            break;\n        }\n    }\n    while final_prime > 0 {\n        sum\
    \ += final_prime % 10;\n        final_prime /= 10;\n    }\n    sum", "    let\
    \ mut primes: Vec<isize> = vec![];\n    let mut s: isize = 0;\n    for n in lst\
    \ {\n        let is_prime = (2..n).all(|i| n % i != 0);\n        if is_prime {\n\
    \            primes.push(n);\n        }\n    }\n    if primes.len() == 0 {\n \
    \       return 0;\n    }\n    let mut largest_prime = primes[0];\n    for p in\
    \ primes {\n        if p > largest_prime {\n            largest_prime = p;\n \
    \       }\n    }\n    let digits: Vec<_> = largest_prime.to_string().chars().map(|d|\
    \ d.to_digit(10).unwrap() as isize).collect();\n    for d in digits {\n      \
    \  s += d;\n    }\n    s", "    let mut primes: Vec<isize> = Vec::new();\n   \
    \ for num in lst {\n        let mut check = num;\n        while check > 0 {\n\
    \            if primes::is_prime(check) {\n                let mut p = check;\n\
    \                let mut count = 0;\n                while p > 0 {\n         \
    \           count += p % 10;\n                    p /= 10;\n                }\n\
    \                return count;\n            }\n            check -= 1;\n     \
    \   }\n    }\n    0", "    let mut lst = lst;\n    lst.sort();\n    let num =\
    \ lst.last().unwrap();\n    let mut sum = 0;\n    for i in num.to_string().chars()\
    \ {\n        sum += i.to_digit(10).unwrap();\n    }\n    sum", "    // let mut\
    \ a: Vec<isize> = vec![];\n    // for i in lst {\n    //     a.push(i);\n    //\
    \ }\n    // let mut done = false;\n    // while !done {\n    //     done = true;\n\
    \    //     let mut b: Vec<isize> = vec![];\n    //     for i in a {\n    // \
    \        for j in a {\n    //             if i == j {\n    //                \
    \ continue;\n    //             }\n    //             if i % j == 0 {\n    //\
    \                 done = false;\n    //                 continue;\n    //    \
    \         }\n    //             b.push(i);\n    //         }\n    //     }\n \
    \   //     a = b;\n    // }\n    // let mut result = isize::min_value();\n   \
    \ // for i in a {\n    //     if i > result {\n    //         result = i;\n  \
    \  //     }\n    // }\n    // result\n    0", "    let mut primes = Vec::new();\n\
    \    for i in &lst {\n        if is_prime(*i) {\n            primes.push(*i);\n\
    \        }\n    }\n    let mut max = 0;\n    for i in &primes {\n        if *i\
    \ > max {\n            max = *i;\n        }\n    }\n    let mut sum = 0;\n   \
    \ while max != 0 {\n        sum += max % 10;\n        max /= 10;\n    }\n    sum"]
stop_tokens:
- "\n}"
