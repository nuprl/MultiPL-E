name: HumanEval_18_how_many_times
language: rust
results:
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ substring.len() == 0 {\n        return 0;\n    }\n    let mut count = 0;\n \
    \   let mut index = string.find(&substring).unwrap();\n    loop {\n        count\
    \ += 1;\n        index = string.find(&substring).unwrap();\n        let string\
    \ = &string[index + substring.len()..];\n        if !string.contains(&substring)\
    \ {\n            break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmpjvpjwjr3.rs:13:45\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpp7mhp1os.rs:9:3\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    0\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpjw2_8rn8.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ substring.len() == 0 {\n        return 0;\n    }\n    let mut c = 0;\n    let\
    \ s = string.as_str();\n    let mut i = 0;\n    while i < s.len() {\n        if\
    \ &s[i..i + substring.len()] == substring.as_str() {\n            c += 1;\n  \
    \          i += substring.len();\n        } else {\n            i += 1;\n    \
    \    }\n    }\n    c\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'byte index 10 is out of bounds of `cacacacac`',\
    \ library/core/src/str/mod.rs:107:9\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    let mut index = 0;\n    while index < string.len() {\n \
    \       let search_string = string.get(index..).unwrap();\n        if search_string.starts_with(&substring)\
    \ {\n            count += 1;\n            index += substring.len();\n        }\
    \ else {\n            index += 1;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp1xevf72x.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut times = 0;\n    let mut last_match = 0;\n    for (i, c) in string.chars().enumerate()\
    \ {\n        if c == substring.chars().nth(last_match).unwrap() {\n          \
    \  last_match += 1;\n            if last_match == substring.len() {\n        \
    \        times += 1;\n                last_match = 0;\n            }\n       \
    \ } else {\n            last_match = 0;\n        }\n    }\n    times\n}\n\nfn\
    \ main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpif69psrz.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.matches(&substring).count()\
    \ as isize\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpxmcjn21i.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    let substring_length = substring.len();\n    for i in 0..(string.len()\
    \ - substring_length + 1) {\n        if string[i..(i + substring_length)] == substring\
    \ {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpulukqh_v.rs:11:18\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpqejfny9g.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ string.len() == 0 || substring.len() == 0 {\n        return 0;\n    }\n    let\
    \ mut count = 0;\n    let mut index = 0;\n    while index != -1 {\n        index\
    \ = string.find(&substring).unwrap_or(-1);\n        count += 1;\n        string\
    \ = string.split_off(index + substring.len());\n    }\n    count - 1\n}\n\nfn\
    \ main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpttdng1kb.rs:15:51\n\
    \   |\n15 |         index = string.find(&substring).unwrap_or(-1);\n   |     \
    \                                              ^^\n   |                      \
    \                             |\n   |                                        \
    \           cannot apply unary operator `-`\n   |                            \
    \                       help: you may have meant the maximum value of `usize`:\
    \ `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpttdng1kb.rs:14:20\n\
    \   |\n14 |     while index != -1 {\n   |                    ^^ the trait `Neg`\
    \ is not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0600.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut sub_index = 0;\n    let mut count = 0;\n    for (index, char) in string.chars().enumerate()\
    \ {\n        if substring.chars().nth(sub_index) == Some(char) {\n           \
    \ sub_index += 1;\n            if sub_index == substring.len() {\n           \
    \     count += 1;\n                sub_index = 0;\n            }\n        } else\
    \ {\n            sub_index = 0;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp5vf3yjle.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    let search_string = string.as_str();\n    let search_substring\
    \ = substring.as_str();\n    let sub_len = search_substring.len();\n    let len\
    \ = search_string.len();\n    for i in 0..len {\n        let remaining_string\
    \ = &search_string[i..];\n        if remaining_string.len() >= sub_len {\n   \
    \         if remaining_string.starts_with(search_substring) {\n              \
    \  count += 1;\n            }\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ haystack = string.as_str();\n    let needle = substring.as_str();\n    if needle.len()\
    \ == 0 {\n        return 0;\n    }\n    let mut slice = haystack;\n    let mut\
    \ count = 0;\n    while let Some(offset) = slice.find(needle) {\n        count\
    \ += 1;\n        slice = &slice[offset + needle.len()..];\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp31gbgj2l.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp1u468hm5.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ string.len() < substring.len() {\n        return 0;\n    }\n    let mut count\
    \ = 0;\n    let mut offset = 0;\n    while offset < string.len() {\n        if\
    \ let Some(i) = string[offset..].find(&substring) {\n            count += 1;\n\
    \            offset += i + substring.len();\n        } else {\n            break;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpvhv1o86e.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let\
    \ mut cnt = 0;\n  let mut start = 0;\n  while start + substring.len() <= string.len()\
    \ {\n    if &string[start..start + substring.len()] == substring {\n      cnt\
    \ += 1;\n      start += substring.len();\n    } else {\n      start += 1;\n  \
    \  }\n  }\n  cnt\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpbnv2l35f.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut times: isize = 0;\n    let slen = string.len();\n    let sublen = substring.len();\n\
    \    let mut i = 0;\n    while i < slen {\n        let mut matched = true;\n \
    \       for j in 0..sublen {\n            if i + j >= slen || string.chars().nth(i\
    \ + j).unwrap() != substring.chars().nth(j).unwrap() {\n                matched\
    \ = false;\n                break;\n            }\n        }\n        if matched\
    \ {\n            times += 1;\n            i += sublen;\n        } else {\n   \
    \         i += 1;\n        }\n    }\n    times\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpennyxc9w.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    //\
    \ your code here\n    unimplemented!()\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpj66j8yu3.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    //\
    \ Place your code here\n    0\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp0n8toen7.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ string_len = string.len();\n    let substring_len = substring.len();\n    let\
    \ mut string_index = 0;\n    let mut substring_index = 0;\n    let mut count =\
    \ 0;\n\n    for _ in 0..string_len {\n        if string.chars().nth(string_index)\
    \ == substring.chars().nth(substring_index) {\n            substring_index +=\
    \ 1;\n            if substring_index == substring_len {\n                count\
    \ += 1;\n                substring_index = 0;\n            }\n        } else {\n\
    \            substring_index = 0;\n        }\n        string_index += 1;\n   \
    \ }\n\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpfop88jgy.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ string.is_empty() || substring.is_empty() {\n        return 0;\n    }\n\n  \
    \  let mut count = 0;\n    let mut index = 0;\n    let mut index_len = substring.len();\n\
    \    let len = string.len();\n\n    while index < len {\n        if &string[index..index\
    \ + index_len] == substring {\n            count += 1;\n            index = index\
    \ + index_len;\n        } else {\n            index += 1;\n        }\n    }\n\n\
    \    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'byte index 10 is out of bounds of `cacacacac`',\
    \ library/core/src/str/mod.rs:107:9\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut counter = 0;\n    let mut index = 0;\n    let string = string.as_str();\n\
    \    let substring = substring.as_str();\n    let mut search_index = string.find(substring);\n\
    \    while search_index.is_some() {\n        counter += 1;\n        index = search_index.unwrap()\
    \ + 1;\n        search_index = string[index..].find(substring);\n    }\n    counter\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut how_many = 0;\n    let mut loc = 0;\n    let rsubstring = substring.as_bytes();\n\
    \    let rstring = string.as_bytes();\n    let substring_len = substring.len();\n\
    \    while loc < string.len() {\n        if &rstring[loc..(loc + substring_len)]\
    \ == rsubstring {\n            how_many += 1;\n            loc += substring_len;\n\
    \        } else {\n            loc += 1;\n        }\n    }\n    how_many\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 10 out of range for slice of\
    \ length 9', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ string.len() == 0 || substring.len() == 0 {\n        return 0;\n    }\n    let\
    \ pattern = substring.as_bytes();\n    let mut count = 0;\n    let mut found =\
    \ string.find(substring.as_str());\n    while found.is_some() {\n        count\
    \ += 1;\n        found = string[found.unwrap() + 1..].find(substring.as_str());\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    let mut offset = 0;\n    while let Some(index) = string[offset..].find(&substring)\
    \ {\n        count += 1;\n        offset += index + substring.len();\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpiuwzcjql.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmparz37w9q.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ string.len() < substring.len() {\n        return 0;\n    }\n    let mut count\
    \ = 0;\n    let mut i = 0;\n    while i < string.len() - substring.len() + 1 {\n\
    \        if &string[i..i + substring.len()] == substring {\n            count\
    \ += 1;\n            i += substring.len();\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmppeckmyfl.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    match\
    \ substring.len() {\n        0 => 0,\n        _ => {\n            let mut count\
    \ = 0;\n            let mut string_iter = string.chars();\n            let mut\
    \ string_slice = &string_iter.as_str()[..];\n            let substring_char =\
    \ substring.chars().next().unwrap();\n            while let Some(index) = string_slice.find(substring_char)\
    \ {\n                count += 1;\n                let mut string_slices = string_slice.split_at(index\
    \ + 1);\n                string_slice = string_slices.1;\n            }\n    \
    \        count\n        }\n    }\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `4`', /tmp/tmp4x9e7n2e.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut n = 0;\n    let mut i = 0;\n    let s = substring.len();\n    while i <\
    \ string.len() {\n        if string[i..i + s] == substring {\n            n +=\
    \ 1;\n            i += s;\n        } else {\n            i += 1;\n        }\n\
    \    }\n    n\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'byte index 10 is out of bounds of `cacacacac`',\
    \ library/core/src/str/mod.rs:107:9\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ string.is_empty() || substring.is_empty() {\n        return 0;\n    }\n\n  \
    \  let len = substring.len();\n    let mut result = 0;\n    let mut start = 0;\n\
    \    while start < string.len() {\n        let new_start = string[start..].find(&substring);\n\
    \        if new_start.is_none() {\n            break;\n        }\n        result\
    \ += 1;\n        start += new_start.unwrap() + len;\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpyf71tvec.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut times: isize = 0;\n    let mut start_index: usize = 0;\n    let mut index:\
    \ usize = 0;\n    let mut j: usize = 0;\n    for i in string.chars() {\n     \
    \   if index >= substring.len() {\n            break;\n        }\n        if i\
    \ == substring.chars().nth(index).unwrap() {\n            if index == 0 {\n  \
    \              start_index = j;\n            }\n            index += 1;\n    \
    \    } else {\n            index = 0;\n        }\n        j += 1;\n    }\n   \
    \ if index == substring.len() {\n        times += 1;\n    }\n    start_index +=\
    \ 1;\n    times += how_many_times(string[start_index..].to_string(), substring);\n\
    \    times\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'byte index 1 is out of bounds of ``', library/core/src/str/mod.rs:107:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut matches = 0;\n    let mut offset = 0;\n    let mut string = string;\n  \
    \  while string.len() > 0 {\n        let found = string.find(&substring);\n  \
    \      match found {\n            Some(pos) => {\n                matches += 1;\n\
    \                offset += pos + substring.len();\n                string = string[pos\
    \ + substring.len()..].to_string();\n            }\n            None => return\
    \ matches,\n        }\n    }\n    matches\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp0xx36o6a.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    let mut last_index = 0;\n    let mut substring_count = 0;\n\
    \    while last_index < string.len() {\n        let index = string.find(&substring[substring_count..],\
    \ last_index).unwrap_or(string.len());\n        if index < string.len() {\n  \
    \          if substring_count == 0 {\n                count += 1;\n          \
    \  }\n            substring_count += 1;\n            if substring_count == substring.len()\
    \ {\n                substring_count = 0;\n            }\n            last_index\
    \ = index + 1;\n        } else {\n            break;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmp6a5ft9co.rs:13:28\n     |\n13   |         let index = string.find(&substring[substring_count..],\
    \ last_index).unwrap_or(string.len());\n     |                            ^^^^\
    \ -----------------------------  ---------- supplied 2 arguments\n     |     \
    \                       |\n     |                            expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    let mut last_index = 0;\n    while let Some(index) = string[last_index..].find(&substring)\
    \ {\n        last_index = index + substring.len();\n        count += 1;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ c_string = CString::new(string).unwrap();\n    let c_substring = CString::new(substring).unwrap();\n\
    \    unsafe { how_many_times_c(c_string.as_ptr(), c_substring.as_ptr()) }\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `CString`\n   -->\
    \ /tmp/tmpj7tfgmoq.rs:9:20\n    |\n9   |       let c_string = CString::new(string).unwrap();\n\
    \    |                      ^^^^^^^\n    |\nhelp: a struct with a similar name\
    \ exists\n    |\n9   |     let c_string = String::new(string).unwrap();\n    |\
    \                    ~~~~~~\nhelp: consider importing this type alias\n    |\n\
    1   | use std::ffi::CString;\n    |\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `CString`\n   --> /tmp/tmpj7tfgmoq.rs:10:23\n    |\n10  |  \
    \     let c_substring = CString::new(substring).unwrap();\n    |             \
    \            ^^^^^^^\n    |\nhelp: a struct with a similar name exists\n    |\n\
    10  |     let c_substring = String::new(substring).unwrap();\n    |          \
    \             ~~~~~~\nhelp: consider importing this type alias\n    |\n1   | use\
    \ std::ffi::CString;\n    |\n\nerror[E0425]: cannot find function `how_many_times_c`\
    \ in this scope\n  --> /tmp/tmpj7tfgmoq.rs:11:14\n   |\n11 |     unsafe { how_many_times_c(c_string.as_ptr(),\
    \ c_substring.as_ptr()) }\n   |              ^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0425, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmppj13_bvt.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ s = &string;\n    let ss = &substring;\n    let mut n = 0;\n    for i in 0..string.len()\
    \ {\n        for j in i..string.len() {\n            if s[i..j+1] == ss {\n  \
    \              n += 1;\n            }\n        }\n    }\n    n\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `str` with `&String`\n  --> /tmp/tmpwjdb3bns.rs:14:26\n\
    \   |\n14 |             if s[i..j+1] == ss {\n   |                          ^^\
    \ no implementation for `str == &String`\n   |\n   = help: the trait `PartialEq<&String>`\
    \ is not implemented for `str`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    0\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpikfwn3pk.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ string_slice = string.as_str();\n    let substring_slice = substring.as_str();\n\
    \    if string_slice.len() < substring_slice.len() {\n        return 0;\n    }\n\
    \    let mut count = 0;\n    let mut offset = 0;\n    loop {\n        match string_slice[offset..].find(substring_slice)\
    \ {\n            Some(i) => {\n                count += 1;\n                offset\
    \ += i + substring_slice.len();\n            }\n            None => break,\n \
    \       }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpb_5x9yir.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp4vrd6d3f.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    -1\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-1`,\n right: `0`', /tmp/tmp3ahe0zxy.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpr66at6n4.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    //\
    \ TODO: Implement this function\n    0\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpcfb0l7np.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    use\
    \ std::cmp::min;\n    let string_len = string.len();\n    let substring_len =\
    \ substring.len();\n    let (mut count, mut i) = (0, 0);\n    let (mut j, mut\
    \ k) = (substring_len, substring_len);\n    let chars_substring = substring.as_bytes();\n\
    \    let chars_string = string.as_bytes();\n    while j <= string_len {\n    \
    \    if chars_string[i..j] == chars_substring[0..k] {\n            count += 1;\n\
    \            j += min(substring_len, string_len - j);\n            i += substring_len;\n\
    \        } else {\n            j += 1;\n            i += 1;\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp3z0ay8n_.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ s_len = string.len();\n    let sub_len = substring.len();\n    let mut times\
    \ = 0;\n    for i in 0..s_len {\n        if i + sub_len > s_len {\n          \
    \  break;\n        }\n\n        let substr = &string[i..i + sub_len];\n      \
    \  if substr == substring {\n            times += 1;\n        }\n    }\n    times\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    for i in 0..string.len() {\n        if &string[i..=i + substring.len()\
    \ - 1] == substring {\n            count += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'byte index 10 is out of bounds of `cacacacac`',\
    \ library/core/src/str/mod.rs:107:9\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut s = string.clone();\n    let sub_len = substring.len();\n    let mut count\
    \ = 0;\n    while s.contains(&substring) {\n        s = s.chars().skip(sub_len).collect();\n\
    \        count += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `4`', /tmp/tmp4v69g2he.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    for i in 0..string.len() {\n        let sub = &string[i..];\n\
    \        for j in 0..sub.len() {\n            if sub[j..].starts_with(&substring)\
    \ {\n                count += 1;\n            }\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `4`', /tmp/tmpw0_bjkqk.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    string.matches(&substring).count()\
    \ as isize\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpasr4rw5g.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ re = Regex::new(&substring).unwrap();\n    re.find_iter(&string).count() as\
    \ isize\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpujsc5miv.rs:9:14\n\
    \  |\n9 |     let re = Regex::new(&substring).unwrap();\n  |              ^^^^^\
    \ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    let mut remain = &string[..];\n    while let Some(pos) =\
    \ remain.find(&substring) {\n        count += 1;\n        remain = &remain[pos\
    \ + substring.len()..];\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpzvvicjte.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    0\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp0ignxhe3.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ substring.len() == 0 {\n        return 0;\n    }\n    let mut n = 0;\n    let\
    \ mut l = 0;\n    let string_len = string.len();\n    let substring_len = substring.len();\n\
    \    while l < string_len {\n        let substr = &string[l..l + substring_len];\n\
    \        if substr == substring {\n            n += 1;\n            l += substring_len;\n\
    \        } else {\n            l += 1;\n        }\n    }\n    n\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'byte index 10 is out of bounds of `cacacacac`',\
    \ library/core/src/str/mod.rs:107:9\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut start = 0;\n    let mut count = 0;\n    let s = &*string;\n    let ss =\
    \ &*substring;\n    while start < s.len() {\n        let index = s[start..].find(ss);\n\
    \        if index.is_none() {\n            break;\n        }\n        count +=\
    \ 1;\n        start += index.unwrap() + ss.len();\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpysncfrey.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    let mut found = 0;\n    for idx in 0..string.len() {\n \
    \       if substring.len() + idx <= string.len() {\n            let sub = string[idx..substring.len()\
    \ + idx].to_string();\n            if sub == substring {\n                count\
    \ += 1;\n            }\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    let mut idx = 0;\n    let len = substring.len();\n    while\
    \ idx <= string.len() - len {\n        let this_substring = string.get(idx..idx\
    \ + len).unwrap().to_string();\n        if this_substring == substring {\n   \
    \         count += 1;\n            idx += len;\n        } else {\n           \
    \ idx += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp8awf7415.rs:12:18\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    let mut i = 0;\n    let string = string.into_bytes();\n\
    \    let substring = substring.into_bytes();\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while i + substring_len <= string_len\
    \ {\n        let sliced = &string[i..i + substring_len];\n        if sliced ==\
    \ &substring[..] {\n            count += 1;\n            i += substring_len;\n\
    \        } else {\n            i += 1;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpplg4kioc.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    //\
    \ let mut count = 0;\n    // let mut pattern = substring.chars();\n    // let\
    \ mut pattern_front = pattern.next();\n    //\n    // for character in string.chars()\
    \ {\n    //     if character == pattern_front.unwrap() {\n    //         count\
    \ += 1;\n    //         pattern_front = pattern.next();\n    //     }\n    //\
    \ }\n    // count\n    panic!(\"replace this panic with your solution\");\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'replace this panic with your solution', /tmp/tmpkb16ci5t.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    let mut pos = 0;\n    while pos < string.len() {\n     \
    \   let next_pos = string.find(&substring, pos);\n        if next_pos == None\
    \ {\n            break;\n        }\n        count += 1;\n        pos = next_pos.unwrap()\
    \ + 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmptgn0vnjj.rs:12:31\n     |\n12   |         let next_pos = string.find(&substring,\
    \ pos);\n     |                               ^^^^ ----------  --- supplied 2\
    \ arguments\n     |                               |\n     |                  \
    \             expected 1 argument\n     |\nnote: associated function defined here\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ n = string.len();\n    let m = substring.len();\n    if n == 0 || m == 0 ||\
    \ m > n {\n        return 0;\n    }\n    let mut count = 0;\n    let mut pos =\
    \ 0;\n    let s = string.as_bytes();\n    let mut i = 0;\n    while i < n {\n\
    \        if s[i] == substring.as_bytes()[pos] {\n            pos += 1;\n     \
    \       if pos == m {\n                count += 1;\n                pos = 0;\n\
    \            }\n        } else {\n            pos = 0;\n        }\n        i +=\
    \ 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpvo4teh4t.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut result = 0;\n    let mut start_index = 0;\n    loop {\n        let index\
    \ = string.get(start_index..).unwrap().find(&substring);\n        if index.is_none()\
    \ {\n            break;\n        } else {\n            let index = index.unwrap();\n\
    \            start_index += index + substring.len();\n            result += 1;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpdweq1i5b.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ substring.len() > string.len() {\n        return 0;\n    }\n    let mut count\
    \ = 0;\n    let mut index = 0;\n    while index < string.len() {\n        if &string[index..index\
    \ + substring.len()] == substring {\n            count += 1;\n            index\
    \ += substring.len();\n        } else {\n            index += 1;\n        }\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'byte index 10 is out of bounds of `cacacacac`',\
    \ library/core/src/str/mod.rs:107:9\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ string = string.into_bytes();\n    let substring = substring.into_bytes();\n\
    \    if substring.len() == 0 {\n        return 0;\n    }\n    let mut n: isize\
    \ = 0;\n    let mut i: usize = 0;\n    while i < string.len() {\n        let mut\
    \ j: usize = 0;\n        while i + j < string.len() && string[i + j] == substring[j]\
    \ {\n            j += 1;\n            if j == substring.len() {\n            \
    \    n += 1;\n                break;\n            }\n        }\n        i += 1;\n\
    \    }\n    n\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ string.is_empty() || substring.is_empty() {\n        return 0;\n    }\n\n  \
    \  let mut result = 0;\n    let mut i = 0;\n    let mut string_vec: Vec<char>\
    \ = string.chars().collect();\n    let mut substring_vec: Vec<char> = substring.chars().collect();\n\
    \n    while i < string_vec.len() {\n        let char = string_vec[i];\n      \
    \  if char == substring_vec[0] {\n            let mut found = true;\n        \
    \    for j in 0..substring_vec.len() {\n                if i + j >= string_vec.len()\
    \ || string_vec[i + j] != substring_vec[j] {\n                    found = false;\n\
    \                    break;\n                }\n            }\n            if\
    \ found {\n                result += 1;\n                i += substring_vec.len()\
    \ - 1;\n            }\n        }\n        i += 1;\n    }\n\n    result\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpkqxiolgf.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    let s = string.as_bytes();\n    let sub = substring.as_bytes();\n\
    \    for i in 0..(s.len() - sub.len() + 1) {\n        if &s[i..(i + sub.len())]\
    \ == sub {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpysf23f6n.rs:12:18\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    let mut start = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    while start <= string_len - substring_len\
    \ {\n        let s = &string[start..string_len];\n        if s.starts_with(&substring)\
    \ {\n            count += 1;\n            start += substring_len;\n        } else\
    \ {\n            start += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpu_ddqun4.rs:13:20\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut i = 0;\n    let mut count = 0;\n    while i < string.len() {\n        if\
    \ let Some(pos) = string[i..].find(&substring) {\n            i += pos + substring.len();\n\
    \            count += 1;\n        } else {\n            break;\n        }\n  \
    \  }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpz5qc0lzt.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ pattern = string.as_str();\n    let to_find = substring.as_str();\n    let mut\
    \ times_found = 0;\n    let mut start_idx = 0;\n    while let Some(idx) = pattern.find(to_find)\
    \ {\n        times_found += 1;\n        start_idx = idx + 1;\n    }\n    times_found\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    //\
    \ Implement how_many_times() here\n    0\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp6jrvcxw3.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut counter = 0;\n    let mut current_index = 0;\n    loop {\n        match\
    \ string[current_index..].find(&substring) {\n            Some(0) => {\n     \
    \           counter += 1;\n                current_index += 1;\n            }\n\
    \            Some(n) => {\n                counter += 1;\n                current_index\
    \ += n + 1;\n            }\n            None => {\n                break;\n  \
    \          }\n        }\n    }\n    counter\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut counter = 0;\n    for i in 0..string.len() {\n        let (first, end) =\
    \ string.split_at(i);\n        let (_, rest) = end.split_at(substring.len());\n\
    \        if first.ends_with(&substring) {\n            counter += 1;\n       \
    \ }\n        if !end.is_empty() {\n            string = format!(\"{}{}\", first,\
    \ rest);\n        }\n    }\n    counter\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `string`\n  --> /tmp/tmpifpdj0ar.rs:17:13\n\
    \   |\n8  | fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                   ------ help: consider making this binding mutable: `mut\
    \ string`\n...\n17 |             string = format!(\"{}{}\", first, rest);\n  \
    \ |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpg7m0rl_a.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut result = 0;\n    let mut start_index = 0;\n    let substring_length = substring.len();\n\
    \    let string_length = string.len();\n    while (start_index + substring_length)\
    \ <= string_length {\n        if &string[start_index..start_index + substring_length]\
    \ == substring {\n            result += 1;\n        }\n        start_index +=\
    \ 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ len = substring.len();\n    let count = string.matches(&substring).count();\n\
    \    if count > 0 {\n        let mut i = 0;\n        let mut ocur = 0;\n     \
    \   while i < len {\n            ocur += string.matches(&substring[i..]).count();\n\
    \            i += 1;\n        }\n        return (count - ocur) as isize;\n   \
    \ }\n    return 0;\n}\n\nfn main() {\n    let candidate = how_many_times;\n  \
    \  assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpv366orz1.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ base = substring.chars().count();\n    if string.chars().count() < base {\n\
    \        return 0;\n    }\n    let mut c = 0;\n    let mut substring_iter = substring.chars();\n\
    \    let mut count = 0;\n    for s in string.chars() {\n        if s == substring_iter.next().unwrap()\
    \ {\n            count += 1;\n            if count == base {\n               \
    \ c += 1;\n                count = 0;\n                substring_iter = substring.chars();\n\
    \            }\n        } else {\n            count = 0;\n            substring_iter\
    \ = substring.chars();\n        }\n    }\n    c\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpxwqauakm.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ string.len() == 0 || substring.len() == 0 {\n        return 0;\n    }\n    let\
    \ mut index = 0;\n    let mut matches = 0;\n    loop {\n        index = string.find(substring.as_str(),\
    \ index).unwrap_or(string.len());\n        if index >= string.len() {\n      \
    \      break;\n        }\n        matches += 1;\n        index += 1;\n    }\n\
    \    matches\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpeiuaz1rk.rs:15:24\n     |\n15   |         index = string.find(substring.as_str(),\
    \ index).unwrap_or(string.len());\n     |                        ^^^^ ------------------\
    \  ----- supplied 2 arguments\n     |                        |\n     |       \
    \                 expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    for i in 0..(string.len() - substring.len() + 1) {\n   \
    \     if string[i..i + substring.len()] == substring {\n            count += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpnq9bl7bd.rs:10:18\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    let mut index = 0;\n    while index <= string.len() - substring.len()\
    \ {\n        if substring == string[index..index + substring.len()].to_string()\
    \ {\n            count += 1;\n            index += substring.len();\n        }\
    \ else {\n            index += 1;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpspr76jz9.rs:11:20\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let\
    \ mut count = 0;\n  let mut idx = 0;\n  let string_arr: Vec<char> = string.chars().collect();\n\
    \  let substring_arr: Vec<char> = substring.chars().collect();\n  for c in string_arr\
    \ {\n    if c == substring_arr[idx] {\n      idx += 1;\n      if idx == substring_arr.len()\
    \ {\n        count += 1;\n        idx = 0;\n      }\n    } else {\n      idx =\
    \ 0;\n    }\n  }\n  count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp2fl5a3sx.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut cnt = 0;\n    let mut last_index = 0;\n    while let Some(index) = string[last_index..].find(&substring)\
    \ {\n        cnt += 1;\n        last_index = index + 1;\n    }\n    cnt\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ string.len() == 0 || substring.len() == 0 {\n        return 0;\n    }\n    let\
    \ mut count = 0;\n    let string_size = string.len();\n    let substring_size\
    \ = substring.len();\n    let string_bytes = string.as_bytes();\n    let substring_bytes\
    \ = substring.as_bytes();\n    for i in 0..string_size {\n        if i + substring_size\
    \ > string_size {\n            break;\n        }\n        let mut equal = true;\n\
    \        for j in 0..substring_size {\n            if string_bytes[i + j] != substring_bytes[j]\
    \ {\n                equal = false;\n                break;\n            }\n \
    \       }\n        if equal {\n            count += 1;\n        }\n    }\n   \
    \ count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    let mut index = 0;\n    let slen = string.len();\n    let\
    \ sslen = substring.len();\n    while index < slen {\n        let mut found =\
    \ true;\n        for i in 0..sslen {\n            if index + i < slen && string.as_bytes()[index\
    \ + i] != substring.as_bytes()[i] {\n                found = false;\n        \
    \        break;\n            }\n        }\n        if found {\n            count\
    \ += 1;\n            index += sslen;\n        } else {\n            index += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpwx1b6vh8.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut k = 0;\n    let mut count = 0;\n    let string = string.as_bytes();\n  \
    \  let substring = substring.as_bytes();\n    while k < string.len() {\n     \
    \   if &string[k..k + substring.len()] == substring {\n            count += 1;\n\
    \            k += substring.len();\n        } else {\n            k += 1;\n  \
    \      }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'range end index 10 out of range for slice of\
    \ length 9', library/core/src/slice/index.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ string.is_empty() || substring.is_empty() {\n        return 0;\n    }\n\n  \
    \  let mut i = 0;\n    let mut count = 0;\n    while i < string.len() {\n    \
    \    if &string[i..i + substring.len()] == substring {\n            count += 1;\n\
    \            i += substring.len();\n        } else {\n            i += 1;\n  \
    \      }\n    }\n\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'byte index 10 is out of bounds of `cacacacac`',\
    \ library/core/src/str/mod.rs:107:9\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    //\
    \ TODO\n    0\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp6k1atvtz.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmppz7q50u4.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut number = 0;\n    let string_length = string.len();\n    let substring_length\
    \ = substring.len();\n    for i in 0..string_length {\n        if i + substring_length\
    \ > string_length {\n            break;\n        }\n        if string[i..i + substring_length]\
    \ == substring {\n            number += 1;\n        }\n    }\n    number\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    let s_len = string.len();\n    let ss_len = substring.len();\n\
    \    if s_len == 0 || ss_len == 0 || s_len < ss_len {\n        return count;\n\
    \    }\n    let mut start = 0;\n    loop {\n        let found = string.find(&substring,\
    \ start);\n        if found.is_none() {\n            break;\n        }\n     \
    \   count += 1;\n        start = found.unwrap() + 1;\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmp6m5xmbgc.rs:17:28\n     |\n17   |         let found = string.find(&substring,\
    \ start);\n     |                            ^^^^ ----------  ----- supplied 2\
    \ arguments\n     |                            |\n     |                     \
    \       expected 1 argument\n     |\nnote: associated function defined here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    0\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpfw8kuz17.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ string.is_empty() || substring.is_empty() {\n        return 0;\n    }\n\n  \
    \  let mut n: isize = 0;\n    let mut i: usize = 0;\n    while i < string.len()\
    \ {\n        if &string[i..i + substring.len()] == substring {\n            n\
    \ += 1;\n            i += substring.len();\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    n\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'byte index 10 is out of bounds of `cacacacac`',\
    \ library/core/src/str/mod.rs:107:9\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ how_many = if substring.len() == 0 {\n        string.len() + 1\n    } else {\n\
    \        string.match_indices(&substring).count()\n    };\n    how_many as isize\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpjoh0om1z.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    let mut next_char = 0;\n    for i in 0..string.len() {\n\
    \        if string.chars().nth(i) == substring.chars().nth(next_char) {\n    \
    \        next_char += 1;\n            if next_char == substring.len() {\n    \
    \            count += 1;\n                next_char = 0;\n            }\n    \
    \    } else {\n            next_char = 0;\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpt7i08zl_.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpja5a_9s2.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ ns = string.len();\n    let ss = substring.len();\n    if ss > ns {\n      \
    \  return 0;\n    }\n    let mut count = 0;\n    let mut i = 0;\n    while i <\
    \ ns {\n        let curr = &string[i..i + ss];\n        if curr == substring {\n\
    \            count += 1;\n            i += ss;\n        } else {\n           \
    \ i += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'byte index 10 is out of bounds of `cacacacac`',\
    \ library/core/src/str/mod.rs:107:9\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ str_length = string.len();\n    let sub_length = substring.len();\n    let mut\
    \ occurrences = 0;\n    let mut index = 0;\n    while index < str_length {\n \
    \       let mut substr_index = 0;\n        let mut inner_index = index;\n    \
    \    while inner_index < str_length && substr_index < sub_length {\n         \
    \   if string.chars().nth(inner_index).unwrap() == substring.chars().nth(substr_index).unwrap()\
    \ {\n                substr_index += 1;\n            } else {\n              \
    \  break;\n            }\n            inner_index += 1;\n        }\n        if\
    \ substr_index == sub_length {\n            occurrences += 1;\n        }\n   \
    \     index += 1;\n    }\n    occurrences\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut sum = 0;\n    let mut curr_index = 0;\n    let mut string_array = string.chars().collect::<Vec<char>>();\n\
    \    let substring_array = substring.chars().collect::<Vec<char>>();\n    while\
    \ curr_index < string_array.len() {\n        if string_array[curr_index] == substring_array[0]\
    \ {\n            if match_substring(&string_array, curr_index, &substring_array)\
    \ {\n                sum += 1;\n                curr_index += substring_array.len();\n\
    \            } else {\n                curr_index += 1;\n            }\n     \
    \   } else {\n            curr_index += 1;\n        }\n    }\n    sum\n}\n\nfn\
    \ main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `match_substring` in this scope\n  -->\
    \ /tmp/tmp3c96ekg3.rs:15:16\n   |\n15 |             if match_substring(&string_array,\
    \ curr_index, &substring_array) {\n   |                ^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    0\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmphi8m9dz4.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpagv9ff8e.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ str_len = string.len();\n    let sub_len = substring.len();\n    let mut result\
    \ = 0;\n    let mut i = 0;\n    while i < str_len - sub_len + 1 {\n        let\
    \ j = i + sub_len;\n        if &string[i..j] == substring {\n            result\
    \ += 1;\n            i += sub_len;\n        } else {\n            i += 1;\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmptul0ni5_.rs:13:15\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    let mut idx = 0;\n    for _ in 0..string.len() {\n     \
    \   if &string[idx..] == substring {\n            count += 1;\n            idx\
    \ += substring.len();\n        } else {\n            idx += 1;\n        }\n  \
    \  }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpwf1ekaep.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut n = 0;\n    let mut i = 0;\n    while let Some(j) = string[i..].find(&substring)\
    \ {\n        n += 1;\n        i = i + j + substring.len();\n    }\n    n\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpkx1sy9fs.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ size_substring = substring.len();\n    let len = string.len();\n    if size_substring\
    \ > len {\n        return 0;\n    }\n\n    let mut count = 0;\n    let iter =\
    \ string.match_indices(&substring).map(|(index, _)| index);\n    for index in\
    \ iter {\n        count += 1;\n        let index = index + size_substring;\n \
    \       if index >= len {\n            break;\n        }\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpes3lt7cg.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ substring.len() == 0 {\n        return 0;\n    }\n    let mut count = 0;\n \
    \   let mut last_i = 0;\n    for i in 0..string.len() {\n        if &string[i..(i\
    \ + substring.len())] == substring {\n            count += 1;\n            last_i\
    \ = i;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'byte index 10 is out of bounds of `cacacacac`',\
    \ library/core/src/str/mod.rs:107:9\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    //\
    \ Convert strings to strings slice\n    let string_slice = string.as_str();\n\
    \    let substring_slice = substring.as_str();\n\n    // Find indexes of substring\
    \ in string\n    let mut res = 0;\n    for i in 0..string_slice.len() {\n    \
    \    if &string_slice[i..].starts_with(substring_slice) {\n            res +=\
    \ 1;\n        }\n    }\n\n    res\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3aywj7om.rs:16:12\n   |\n\
    16 |         if &string_slice[i..].starts_with(substring_slice) {\n   |      \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found\
    \ `&bool`\n   |\nhelp: consider removing the borrow\n   |\n16 -         if &string_slice[i..].starts_with(substring_slice)\
    \ {\n16 +         if string_slice[i..].starts_with(substring_slice) {\n   | \n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ substring.len() > string.len() {\n        return 0;\n    }\n    if substring.len()\
    \ == 0 {\n        return 0;\n    }\n    let mut count = 0;\n    let slice = &string[..];\n\
    \    let substring_as_slice = &substring[..];\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        if &slice[index..(index + substring.len())]\
    \ == substring_as_slice {\n            count += 1;\n            index += substring.len();\n\
    \        } else {\n            index += 1;\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'byte index 10 is out of bounds of `cacacacac`',\
    \ library/core/src/str/mod.rs:107:9\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ substring.len() == 0 {\n        return 0;\n    }\n    let s = string.as_bytes();\n\
    \    let mut i = 0;\n    let len = s.len();\n    let sub_len = substring.len();\n\
    \    let mut count = 0;\n    while i + sub_len <= len {\n        if &s[i..i +\
    \ sub_len] == substring.as_bytes() {\n            count += 1;\n            i +=\
    \ sub_len;\n        } else {\n            i += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp6tihi6wq.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ length_of_string = string.len();\n    let length_of_substring = substring.len();\n\
    \    let mut times = 0;\n    let mut start = 0;\n    while start < length_of_string\
    \ {\n        let substring_from_string = &string[start..start + length_of_substring];\n\
    \        if substring_from_string == substring {\n            times += 1;\n  \
    \          start += length_of_substring;\n        } else {\n            start\
    \ += 1;\n        }\n    }\n    times\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'byte index 10 is out of bounds of `cacacacac`',\
    \ library/core/src/str/mod.rs:107:9\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut cnt = 0;\n    let string_len = string.len();\n    let substring_len = substring.len();\n\
    \    let mut i = 0;\n    let mut j = 0;\n    let mut j_count = 0;\n    for i in\
    \ 0..string_len {\n        if string.as_bytes()[i] == substring.as_bytes()[j]\
    \ {\n            if j_count == 0 {\n                j_count = 1;\n           \
    \ }\n            j = j + 1;\n            if j == substring_len {\n           \
    \     cnt = cnt + 1;\n                j = 0;\n                j_count = 0;\n \
    \           }\n        } else {\n            if j_count == 1 {\n             \
    \   i = i - 1;\n            }\n            j = 0;\n            j_count = 0;\n\
    \        }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `i`\n  --> /tmp/tmpix6xd8rq.rs:12:13\n   |\n\
    12 |     let mut i = 0;\n   |             ^ help: if this is intentional, prefix\
    \ it with an underscore: `_i`\n   |\n   = note: `#[warn(unused_variables)]` on\
    \ by default\n\nwarning: value assigned to `i` is never read\n  --> /tmp/tmpix6xd8rq.rs:28:17\n\
    \   |\n28 |                 i = i - 1;\n   |                 ^\n   |\n   = note:\
    \ `#[warn(unused_assignments)]` on by default\n   = help: maybe it is overwritten\
    \ before being read?\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmpix6xd8rq.rs:12:9\n\
    \   |\n12 |     let mut i = 0;\n   |         ----^\n   |         |\n   |     \
    \    help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\
    \nerror[E0384]: cannot assign twice to immutable variable `i`\n  --> /tmp/tmpix6xd8rq.rs:28:17\n\
    \   |\n15 |     for i in 0..string_len {\n   |         -\n   |         |\n   |\
    \         first assignment to `i`\n   |         help: consider making this binding\
    \ mutable: `mut i`\n...\n28 |                 i = i - 1;\n   |               \
    \  ^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due\
    \ to previous error; 3 warnings emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ string.len() == 0 || substring.len() == 0 {\n        return 0;\n    }\n    let\
    \ string = string.as_str();\n    let substring = substring.as_str();\n    let\
    \ mut count = 0;\n    let mut index = 0;\n    while index != -1 {\n        index\
    \ = string.find(substring).unwrap_or(-1);\n        if index == -1 {\n        \
    \    break;\n        }\n        count += 1;\n        index += 1;\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpn78uhf0u.rs:17:50\n\
    \   |\n17 |         index = string.find(substring).unwrap_or(-1);\n   |      \
    \                                            ^^\n   |                        \
    \                          |\n   |                                           \
    \       cannot apply unary operator `-`\n   |                                \
    \                  help: you may have meant the maximum value of `usize`: `usize::MAX`\n\
    \   |\n   = note: unsigned values cannot be negated\n\nerror[E0277]: the trait\
    \ bound `usize: Neg` is not satisfied\n  --> /tmp/tmpn78uhf0u.rs:16:20\n   |\n\
    16 |     while index != -1 {\n   |                    ^^ the trait `Neg` is not\
    \ implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0600]: cannot apply unary\
    \ operator `-` to type `usize`\n  --> /tmp/tmpn78uhf0u.rs:18:21\n   |\n18 |  \
    \       if index == -1 {\n   |                     ^^\n   |                  \
    \   |\n   |                     cannot apply unary operator `-`\n   |        \
    \             help: you may have meant the maximum value of `usize`: `usize::MAX`\n\
    \   |\n   = note: unsigned values cannot be negated\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0600.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    match\
    \ string.find(&substring) {\n        None => 0,\n        Some(index) => {\n  \
    \          how_many_times(string[index + substring.len()..].to_string(), substring)\
    \ + 1\n        }\n    }\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpb4cvyc0k.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    0\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp00qs_yp9.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmppod5voj2.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ string.len() < substring.len() {\n        return 0;\n    }\n    if string.len()\
    \ == substring.len() {\n        if string == substring {\n            return 1;\n\
    \        } else {\n            return 0;\n        }\n    }\n    let mut result\
    \ = 0;\n    let mut index = 0;\n    while index < string.len() - substring.len()\
    \ + 1 {\n        if string[index..index + substring.len()] == substring {\n  \
    \          result += 1;\n            index += substring.len();\n        } else\
    \ {\n            index += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpazepj540.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ string.len() < substring.len() {\n        return 0;\n    }\n\n    let mut count\
    \ = 0;\n    let string = string.as_bytes();\n    let substring = substring.as_bytes();\n\
    \n    for i in 0..(string.len() - substring.len() + 1) {\n        if &string[i..(i\
    \ + substring.len())] == substring {\n            count += 1;\n        }\n   \
    \ }\n\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ count = string.matches(&substring).count();\n    count as isize\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpg8u38i3o.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ string.len() == 0 || substring.len() == 0 {\n        return 0;\n    }\n    if\
    \ substring.len() > string.len() {\n        return 0;\n    }\n    let chars =\
    \ string.chars().collect::<Vec<char>>();\n    let subchars = substring.chars().collect::<Vec<char>>();\n\
    \    let mut index = 0;\n    let mut how_many = 0;\n    while index < chars.len()\
    \ {\n        let sub_index = 0;\n        let mut original_index = index;\n   \
    \     loop {\n            if sub_index == subchars.len() {\n                how_many\
    \ += 1;\n                break;\n            }\n            if original_index\
    \ == chars.len() {\n                break;\n            }\n            if chars[original_index]\
    \ == subchars[sub_index] {\n                original_index += 1;\n           \
    \     sub_index += 1;\n            } else {\n                break;\n        \
    \    }\n        }\n        index += 1;\n    }\n    how_many\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign twice to immutable variable `sub_index`\n \
    \ --> /tmp/tmpte0trguf.rs:32:17\n   |\n20 |         let sub_index = 0;\n   | \
    \            ---------\n   |             |\n   |             first assignment\
    \ to `sub_index`\n   |             help: consider making this binding mutable:\
    \ `mut sub_index`\n...\n32 |                 sub_index += 1;\n   |           \
    \      ^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    let string = string.into_bytes();\n    let substring = substring.into_bytes();\n\
    \    let sublen = substring.len();\n    let mut index = 0;\n    while index <\
    \ string.len() {\n        if string[index] == substring[0] {\n            let\
    \ mut i = 1;\n            while i < sublen && (index + i) < string.len() && string[index\
    \ + i] == substring[i] {\n                i += 1;\n            }\n           \
    \ if i == sublen {\n                count += 1;\n                index += i;\n\
    \            } else {\n                index += 1;\n            }\n        } else\
    \ {\n            index += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpzi0xla8e.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    let mut i = 0;\n    let mut remaining = string.clone();\n\
    \    let mut haystack = &remaining[..];\n    let needle = &substring[..];\n  \
    \  while i != -1 {\n        i = haystack.find(needle).unwrap_or(-1);\n       \
    \ if i == -1 {\n            break;\n        }\n        count += 1;\n        remaining\
    \ = &remaining[i+needle.len()..];\n        haystack = &remaining[..];\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmp3rs3ubwn.rs:15:45\n\
    \   |\n15 |         i = haystack.find(needle).unwrap_or(-1);\n   |           \
    \                                  ^^\n   |                                  \
    \           |\n   |                                             cannot apply unary\
    \ operator `-`\n   |                                             help: you may\
    \ have meant the maximum value of `usize`: `usize::MAX`\n   |\n   = note: unsigned\
    \ values cannot be negated\n\nerror[E0277]: the trait bound `usize: Neg` is not\
    \ satisfied\n  --> /tmp/tmp3rs3ubwn.rs:14:16\n   |\n14 |     while i != -1 {\n\
    \   |                ^^ the trait `Neg` is not implemented for `usize`\n   |\n\
    \   = help: the following other types implement trait `Neg`:\n             &f32\n\
    \             &f64\n             &i128\n             &i16\n             &i32\n\
    \             &i64\n             &i8\n             &isize\n           and 8 others\n\
    \nerror[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmp3rs3ubwn.rs:16:17\n\
    \   |\n16 |         if i == -1 {\n   |                 ^^\n   |              \
    \   |\n   |                 cannot apply unary operator `-`\n   |            \
    \     help: you may have meant the maximum value of `usize`: `usize::MAX`\n  \
    \ |\n   = note: unsigned values cannot be negated\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3rs3ubwn.rs:20:21\n   |\n11 |     let mut remaining = string.clone();\n\
    \   |                         -------------- expected due to this value\n...\n\
    20 |         remaining = &remaining[i+needle.len()..];\n   |                 \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n   |\n\
    help: try using a conversion method\n   |\n20 |         remaining = (&remaining[i+needle.len()..]).to_string();\n\
    \   |                     +                            +++++++++++++\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0600.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ s = string.as_bytes();\n    let sub = substring.as_bytes();\n    let mut count\
    \ = 0;\n    for i in 0..(s.len() - sub.len() + 1) {\n        let mut found = true;\n\
    \        for j in 0..sub.len() {\n            if s[i + j] != sub[j] {\n      \
    \          found = false;\n                break;\n            }\n        }\n\
    \        if found {\n            count += 1;\n        }\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpqtt90aj0.rs:12:18\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    let mut start_index = 0;\n    let haystack = string.as_str();\n\
    \    let needle = substring.as_str();\n    let mut index = match haystack.find(needle)\
    \ {\n        Some(index) => index,\n        None => -1,\n    };\n    while index\
    \ != -1 {\n        count += 1;\n        start_index = index + 1;\n        index\
    \ = match haystack[start_index..].find(needle) {\n            Some(index) => index,\n\
    \            None => -1,\n        };\n    }\n    count\n}\n\nfn main() {\n   \
    \ let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"\
    ), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpb8mxlmbe.rs:15:17\n\
    \   |\n15 |         None => -1,\n   |                 ^^ the trait `Neg` is not\
    \ implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0600]: cannot apply unary\
    \ operator `-` to type `usize`\n  --> /tmp/tmpb8mxlmbe.rs:17:20\n   |\n17 |  \
    \   while index != -1 {\n   |                    ^^\n   |                    |\n\
    \   |                    cannot apply unary operator `-`\n   |               \
    \     help: you may have meant the maximum value of `usize`: `usize::MAX`\n  \
    \ |\n   = note: unsigned values cannot be negated\n\nerror[E0600]: cannot apply\
    \ unary operator `-` to type `usize`\n  --> /tmp/tmpb8mxlmbe.rs:22:21\n   |\n\
    22 |             None => -1,\n   |                     ^^\n   |              \
    \       |\n   |                     cannot apply unary operator `-`\n   |    \
    \                 help: you may have meant the maximum value of `usize`: `usize::MAX`\n\
    \   |\n   = note: unsigned values cannot be negated\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0600.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ string.len() == 0 || substring.len() == 0 {\n        return 0;\n    }\n    let\
    \ mut i = 0;\n    let mut count = 0;\n    loop {\n        match string[i..].find(&substring)\
    \ {\n            Some(idx) => {\n                count += 1;\n               \
    \ i += idx + substring.len();\n            }\n            None => {\n        \
    \        break;\n            }\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmplx_o6izs.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    let mut offset = 0;\n    while let Some(i) = string[offset..].find(&substring)\
    \ {\n        count += 1;\n        offset = i + 1;\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    //\
    \ TODO\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpmmfzd_8r.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    //\
    \ unimplemented!();\n    let mut count: isize = 0;\n    let string_len = string.len();\n\
    \    let sub_len = substring.len();\n    for i in 0..(string_len - sub_len + 1)\
    \ {\n        if string[i..i + sub_len] == substring {\n            count += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp8y02q07_.rs:13:18\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    let pattern = substring.as_bytes();\n    let mut window\
    \ = string.as_bytes();\n    loop {\n        match window.windows(pattern.len()).next()\
    \ {\n            Some(w) => {\n                if w == pattern {\n           \
    \         count += 1;\n                    window = &window[1..];\n          \
    \      } else {\n                    window = &window[1..];\n                }\n\
    \            }\n            None => break,\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ substring.len() > string.len() {\n        return 0;\n    }\n    let mut count\
    \ = 0;\n    let mut rest = string;\n    while let Some(found) = rest.find(&substring)\
    \ {\n        count += 1;\n        rest = String::from(&rest[found + substring.len()..]);\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp9dd3s_e9.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ string.is_empty() || substring.is_empty() {\n        return 0;\n    }\n\n  \
    \  let mut count = 0;\n    let mut pos = 0;\n    let str_len = string.len();\n\
    \    let sub_len = substring.len();\n\n    while pos < str_len {\n        if let\
    \ Some(index) = string[pos..].find(&substring) {\n            count += 1;\n  \
    \          pos += index + sub_len;\n        } else {\n            break;\n   \
    \     }\n    }\n\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpicuqg6z0.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ string.len() < substring.len() {\n        return 0;\n    }\n\n    let str_vec:\
    \ Vec<char> = string.chars().collect();\n    let sub_vec: Vec<char> = substring.chars().collect();\n\
    \n    let mut counter = 0;\n    let mut sub_i = 0;\n    for i in 0..str_vec.len()\
    \ {\n        if sub_i == sub_vec.len() {\n            sub_i = 0;\n           \
    \ counter += 1;\n        }\n\n        if str_vec[i] == sub_vec[sub_i] {\n    \
    \        sub_i += 1;\n        } else {\n            sub_i = 0;\n        }\n  \
    \  }\n\n    if sub_i == sub_vec.len() {\n        counter += 1;\n    }\n\n    counter\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpzxp64mmo.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ len = substring.len();\n    let count = string.matches(&substring).count();\n\
    \    if count == 0 {\n        return 0;\n    }\n    return len as isize * count\
    \ as isize - ((count - 1) as isize * count as isize) / 2;\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-2`,\n right: `4`', /tmp/tmp0jrgvh7p.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ ss: Vec<char> = substring.chars().collect();\n    let s: Vec<char> = string.chars().collect();\n\
    \    let mut count = 0;\n    for i in 0..s.len() - ss.len() + 1 {\n        let\
    \ mut is_valid = true;\n        for j in 0..ss.len() {\n            if s[i + j]\
    \ != ss[j] {\n                is_valid = false;\n                break;\n    \
    \        }\n        }\n        if is_valid {\n            count += 1;\n      \
    \  }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpoecew1hj.rs:12:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    //\
    \ Note that using `string.find(&substring)` doesn't work, because that returns\n\
    \    // an optional containing either Some(index) or None.\n    if !string.contains(&substring)\
    \ {\n        return 0;\n    }\n\n    let mut string = string;\n    let mut count\
    \ = 0;\n    while let Some(index) = string.find(&substring) {\n        count +=\
    \ 1;\n        string = string[index + substring.len()..].to_string();\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpjstnghw8.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ index = 0;\n    let mut counter = 0;\n    for _ in 0..(string.len() - substring.len())\
    \ {\n        if string[index..index + substring.len()] == substring {\n      \
    \      counter += 1;\n        }\n    }\n    counter\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp01qu2q8a.rs:11:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  if string.len()\
    \ == 0 || substring.len() == 0 {\n    return 0;\n  }\n  if string.len() < substring.len()\
    \ {\n    return 0;\n  }\n  let mut count = 0;\n  let string = string.as_bytes();\n\
    \  let substring = substring.as_bytes();\n  let mut i = 0;\n  while i < string.len()\
    \ {\n    if string[i] == substring[0] {\n      let mut k = 0;\n      while k <\
    \ substring.len() && i + k < string.len() && string[i + k] == substring[k] {\n\
    \        k += 1;\n      }\n      if k == substring.len() {\n        count += 1;\n\
    \        i += k - 1;\n      }\n    }\n    i += 1;\n  }\n  count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpj18my84c.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ substring.len() == 0 {\n        return 0;\n    }\n    let mut i = 0;\n    let\
    \ mut n = 0;\n    while let Some(index) = string[i..].find(&substring) {\n   \
    \     i += index + substring.len();\n        n += 1;\n    }\n    n\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpzwjs7k71.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut res = 0;\n    for i in 0..(string.len() - substring.len() + 1) {\n     \
    \   let substring_at_i = &string[i..(i + substring.len())];\n        if substring_at_i\
    \ == substring {\n            res += 1;\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpbqlszq1p.rs:10:18\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ count = string.matches(&substring).count();\n    if substring.len() == 0 {\n\
    \        return 0;\n    }\n    count as isize\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp57255khh.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    let mut index = 0;\n    loop {\n        match string[index..].find(&substring)\
    \ {\n            Some(found_index) => {\n                index += found_index\
    \ + substring.len();\n                count += 1;\n            }\n           \
    \ None => break,\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpjrl5x42q.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ substring.len() > string.len() {\n        return 0;\n    }\n    let mut count\
    \ = 0;\n    let string = string.as_bytes();\n    let substring = substring.as_bytes();\n\
    \    for i in 0..(string.len() - substring.len() + 1) {\n        if substring\
    \ == &string[i..(i + substring.len())] {\n            count += 1;\n        }\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    let mut index = 0;\n    while index < string.len() {\n \
    \       index = string.index_of(&substring, index).map_or(string.len(), |i| i\
    \ + 1);\n        count += 1;\n    }\n    count - 1\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `index_of` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmplkumpl7q.rs:12:24\n   |\n12 |         index = string.index_of(&substring,\
    \ index).map_or(string.len(), |i| i + 1);\n   |                        ^^^^^^^^\
    \ method not found in `String`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    let mut start = 0;\n    while start < string.len() {\n \
    \       if let Some(index) = string[start..].find(&substring) {\n            count\
    \ += 1;\n            start += index + substring.len();\n        } else {\n   \
    \         break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmppuch9s8j.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut result = 0;\n    let mut last_index = -1;\n    let string = string.as_str();\n\
    \    let substring = substring.as_str();\n    let mut continue_search = true;\n\
    \    while continue_search {\n        let index = string.find(substring);\n  \
    \      match index {\n            Some(index) => {\n                if index >\
    \ last_index {\n                    result += 1;\n                    last_index\
    \ = index;\n                }\n            }\n            None => continue_search\
    \ = false,\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp9bx03az5.rs:10:26\n\
    \   |\n10 |     let mut last_index = -1;\n   |                          ^^ the\
    \ trait `Neg` is not implemented for `usize`\n   |\n   = help: the following other\
    \ types implement trait `Neg`:\n             &f32\n             &f64\n       \
    \      &i128\n             &i16\n             &i32\n             &i64\n      \
    \       &i8\n             &isize\n           and 8 others\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    0\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp34439qq5.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut index = 0;\n    let mut count = 0;\n    let mut string = string;\n    let\
    \ substring_len = substring.len();\n    while index < string.len() {\n       \
    \ if let Some(i) = string.find(&substring) {\n            string = string.chars().skip(i\
    \ + substring_len).collect();\n            count += 1;\n        } else {\n   \
    \         break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpjrp31b6f.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    return\
    \ 0;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpbfp7cipe.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ s: Vec<char> = string.chars().collect();\n    let sub: Vec<char> = substring.chars().collect();\n\
    \    let mut count = 0;\n    let mut j = 0;\n    for i in 0..s.len() {\n     \
    \   if s[i] == sub[j] {\n            j += 1;\n            if j == sub.len() {\n\
    \                count += 1;\n                j = 0;\n            }\n        }\
    \ else {\n            j = 0;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpy2elhed8.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut substring_index = 0;\n    let mut string_index = 0;\n    let mut count =\
    \ 0;\n\n    for _ in 0..string.len() {\n        if substring_index == substring.len()\
    \ {\n            count += 1;\n            substring_index = 0;\n        }\n  \
    \      if substring.chars().nth(substring_index) == string.chars().nth(string_index)\
    \ {\n            substring_index += 1;\n        }\n        string_index += 1;\n\
    \    }\n\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n \
    \   assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpqc8itnip.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  if string.len()\
    \ < substring.len() {\n    return 0;\n  }\n  let times = string.len() - substring.len()\
    \ + 1;\n  if times <= 0 {\n    return 0;\n  }\n  let mut count = 0;\n  for i in\
    \ 0..times {\n    if string[i..i + substring.len()] == substring {\n      count\
    \ += 1;\n    }\n  }\n  count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    //\
    \ @todo\n    return 0;\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp26efe4ml.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut result = 0;\n    let str_len = string.len();\n    let sub_len = substring.len();\n\
    \    let mut current_substr = String::from(\"\");\n    let mut i = 0;\n    let\
    \ mut j = 0;\n    while i < str_len {\n        if string.chars().nth(i).unwrap()\
    \ == substring.chars().nth(j).unwrap() {\n            current_substr.push(string.chars().nth(i).unwrap());\n\
    \            if j == sub_len - 1 {\n                if current_substr == substring\
    \ {\n                    result += 1;\n                }\n                j =\
    \ 0;\n                current_substr = String::from(\"\");\n            } else\
    \ {\n                j += 1;\n            }\n        } else {\n            j =\
    \ 0;\n            current_substr = String::from(\"\");\n        }\n        i +=\
    \ 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpruwo3nju.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    how_many_times_two(string,\
    \ substring)\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `how_many_times_two` in this scope\n\
    \ --> /tmp/tmp4_rjjuln.rs:9:5\n  |\n9 |     how_many_times_two(string, substring)\n\
    \  |     ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    let mut found_idx = string.find(&substring);\n    while\
    \ found_idx.is_some() {\n        count += 1;\n        let idx = found_idx.unwrap();\n\
    \        found_idx = string.find(&substring);\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    let string_length = string.len();\n    let mut index = 0;\n\
    \    let substring_length = substring.len();\n    while index < string_length\
    \ {\n        if string[index..(index + substring_length)] == substring {\n   \
    \         count += 1;\n            index += substring_length;\n        } else\
    \ {\n            index += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'byte index 10 is out of bounds of `cacacacac`',\
    \ library/core/src/str/mod.rs:107:9\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ string.len() == 0 || substring.len() == 0 {\n        return 0;\n    }\n    let\
    \ mut times = 0;\n    let mut pos = 0;\n    while pos < string.len() {\n     \
    \   let mut new_pos = pos;\n        while new_pos < string.len() && string.as_bytes()[new_pos]\
    \ == substring.as_bytes()[new_pos - pos] {\n            new_pos += 1;\n      \
    \  }\n        if new_pos - pos == substring.len() {\n            times += 1;\n\
    \        }\n        pos += 1;\n    }\n    times\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 1 but the index\
    \ is 1', /tmp/tmpe4n0o23c.rs:16:71\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpo48hns_m.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    let mut i = 0;\n    while i < string.len() {\n        let\
    \ found = string[i..].find(&substring);\n        if found.is_none() {\n      \
    \      break;\n        }\n        count += 1;\n        i += found.unwrap() + substring.len();\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp3n3y7uzg.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut counter = 0;\n    let mut index = 0;\n    let string_chars: Vec<char> =\
    \ string.chars().collect();\n    let substring_chars: Vec<char> = substring.chars().collect();\n\
    \    while index < string_chars.len() {\n        let mut found = true;\n     \
    \   for (j, c) in substring_chars.iter().enumerate() {\n            if index +\
    \ j >= string_chars.len() || string_chars[index + j] != *c {\n               \
    \ found = false;\n                break;\n            }\n        }\n        if\
    \ found {\n            counter += 1;\n            index += substring_chars.len();\n\
    \        } else {\n            index += 1;\n        }\n    }\n    counter\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmphr1md36j.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ string.len() < substring.len() {\n        return 0;\n    }\n\n    let mut string_chars\
    \ = string.chars();\n    let mut substring_chars = substring.chars();\n    let\
    \ mut previous_match_count = 0;\n    let mut count = 0;\n\n    loop {\n      \
    \  match string_chars.next() {\n            Some(s) => {\n                match\
    \ substring_chars.next() {\n                    Some(b) => {\n               \
    \         if s == b {\n                            if previous_match_count ==\
    \ 0 {\n                                count += 1;\n                         \
    \   }\n                            previous_match_count += 1;\n              \
    \          } else {\n                            previous_match_count = 0;\n \
    \                           substring_chars = substring.chars();\n           \
    \             }\n                    }\n                    None => {\n      \
    \                  substring_chars = substring.chars();\n                    \
    \    previous_match_count = 0;\n                    }\n                }\n   \
    \         }\n            None => {\n                break;\n            }\n  \
    \      }\n    }\n\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpg6i6es5u.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    //\
    \ this will be the return value of the function\n    let mut return_value: isize\
    \ = 0;\n    let length_of_substring = substring.len();\n    // starting index\
    \ of original string\n    let mut current_index: usize = 0;\n    loop {\n    \
    \    let result = match string[current_index..].find(&substring) {\n         \
    \   Some(val) => val,\n            None => break,\n        };\n        current_index\
    \ += result;\n        return_value += 1;\n        current_index += length_of_substring;\n\
    \    }\n    return_value\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp46ehk0cc.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    for i in 0..string.len() {\n        if &string[i..i + substring.len()]\
    \ == substring {\n            count += 1;\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'byte index 10 is out of bounds of `cacacacac`',\
    \ library/core/src/str/mod.rs:107:9\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ substring_size = substring.len();\n    if substring_size > string.len() {\n\
    \        return 0;\n    }\n    let substring_char_counts = create_char_count_map(&substring);\n\
    \    let mut running_char_counts = create_char_count_map(&string[0..substring_size]);\n\
    \    let mut count = 0;\n    if is_substring_present(substring_char_counts, running_char_counts)\
    \ {\n        count += 1;\n    }\n    for i in 0..(string.len() - substring_size)\
    \ {\n        let removed_char = string.chars().nth(i).unwrap();\n        let added_char\
    \ = string.chars().nth(i + substring_size).unwrap();\n        running_char_counts.entry(removed_char).and_modify(|e|\
    \ *e -= 1);\n        running_char_counts.entry(added_char).and_modify(|e| *e +=\
    \ 1);\n        if is_substring_present(substring_char_counts, running_char_counts)\
    \ {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `create_char_count_map` in this scope\n\
    \  --> /tmp/tmpdlc_t8x0.rs:13:33\n   |\n13 |     let substring_char_counts = create_char_count_map(&substring);\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `create_char_count_map` in this\
    \ scope\n  --> /tmp/tmpdlc_t8x0.rs:14:35\n   |\n14 |     let mut running_char_counts\
    \ = create_char_count_map(&string[0..substring_size]);\n   |                 \
    \                  ^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_substring_present` in this scope\n  --> /tmp/tmpdlc_t8x0.rs:16:8\n\
    \   |\n16 |     if is_substring_present(substring_char_counts, running_char_counts)\
    \ {\n   |        ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_substring_present` in this scope\n  --> /tmp/tmpdlc_t8x0.rs:24:12\n\
    \   |\n24 |         if is_substring_present(substring_char_counts, running_char_counts)\
    \ {\n   |            ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ n = string.len();\n    let m = substring.len();\n    if m > n {\n        return\
    \ 0;\n    }\n    let mut cnt = 0;\n    for i in 0..n {\n        if string[i..].starts_with(&substring)\
    \ {\n            cnt += 1;\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut index = 0;\n    let mut result = 0;\n    let mut remaining = string;\n \
    \   while let Some(pos) = remaining.find(&substring) {\n        index += pos;\n\
    \        result += 1;\n        remaining = remaining[pos+1..].to_string();\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    let len = substring.len();\n    for i in 0..string.len()\
    \ {\n        if substring == &string[i..i + len] {\n            count += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'byte index 10 is out of bounds of `cacacacac`',\
    \ library/core/src/str/mod.rs:107:9\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpcfxivoax.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ length = substring.len();\n    if length > string.len() {\n        return 0;\n\
    \    }\n    let mut count = 0;\n    let mut start = 0;\n    while start + length\
    \ <= string.len() {\n        let sub = &string[start..start + length];\n     \
    \   if sub == substring {\n            count += 1;\n        }\n        start +=\
    \ 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    0\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp8m99xm6x.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ length = substring.len();\n    let mut times = 0;\n    for index in 0..string.len()\
    \ {\n        if string[index..].starts_with(&substring) {\n            times +=\
    \ 1;\n        }\n    }\n    times\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ c = string.chars().into_iter().peekable();\n    let mut count = 0;\n    let\
    \ sl = substring.len();\n    let mut start = 0;\n    loop {\n        let found\
    \ = c.clone().skip(start).collect::<String>().find(&substring);\n        if found.is_none()\
    \ {\n            break;\n        }\n        count += 1;\n        start = found.unwrap()\
    \ + sl;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut result = 0;\n    let mut start_idx = 0;\n    let mut current_idx = 0;\n\
    \    while current_idx < string.len() {\n        if substring.len() + current_idx\
    \ > string.len() {\n            break;\n        }\n        let this_slice = &string[current_idx..(substring.len()\
    \ + current_idx)];\n        if substring == this_slice {\n            start_idx\
    \ = current_idx + substring.len();\n            result += 1;\n        }\n    \
    \    current_idx += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    let mut pos = 0;\n    while pos < string.len() {\n     \
    \   pos = string[pos..].find(substring.as_str()).unwrap_or(string.len());\n  \
    \      count += 1;\n        pos += substring.len();\n    }\n    count\n}\n\nfn\
    \ main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut counter = 0;\n    let mut sub_i = 0;\n    let mut char_i = 0;\n    let sub_length\
    \ = substring.len();\n    let sub_chars = substring.chars();\n    let string_chars\
    \ = string.chars();\n    let string_length = string.len();\n    for character\
    \ in string_chars {\n        if sub_i == sub_length {\n            counter +=\
    \ 1;\n            sub_i = 0;\n            char_i = char_i - sub_length + 1;\n\
    \        }\n        if character == sub_chars.nth(sub_i).unwrap() {\n        \
    \    sub_i += 1;\n        } else {\n            sub_i = 0;\n        }\n      \
    \  char_i += 1;\n        if char_i == string_length {\n            if sub_i ==\
    \ sub_length {\n                counter += 1;\n            }\n            break;\n\
    \        }\n    }\n    counter\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `sub_chars` as mutable, as it is not declared\
    \ as mutable\n  --> /tmp/tmpsyxiatl2.rs:22:25\n   |\n13 |     let sub_chars =\
    \ substring.chars();\n   |         --------- help: consider changing this to be\
    \ mutable: `mut sub_chars`\n...\n22 |         if character == sub_chars.nth(sub_i).unwrap()\
    \ {\n   |                         ^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    let mut index = 0;\n    let string = string.as_str();\n\
    \    let substring = substring.as_str();\n    let len = substring.len();\n   \
    \ loop {\n        match string[index..].find(substring) {\n            Some(i)\
    \ => {\n                count += 1;\n                index += i + len;\n     \
    \       }\n            None => break,\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpx4p0hbjs.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    let mut base = 0;\n    let base_len = substring.len();\n\
    \    let string_len = string.len();\n    let string = string.as_bytes();\n   \
    \ let substring = substring.as_bytes();\n    while base < string_len {\n     \
    \   if string[base] == substring[0] {\n            if string_len - base < base_len\
    \ {\n                break;\n            }\n            let mut found = true;\n\
    \            for i in 0..base_len {\n                if string[base + i] != substring[i]\
    \ {\n                    found = false;\n                    break;\n        \
    \        }\n            }\n            if found {\n                count += 1;\n\
    \                base += base_len;\n            } else {\n                base\
    \ += 1;\n            }\n        } else {\n            base += 1;\n        }\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpy7jkd5hf.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut number = 0;\n    for i in 0..string.len() - substring.len() + 1 {\n    \
    \    let substr = &string[i..i + substring.len()];\n        if substr == substring\
    \ {\n            number += 1;\n        }\n    }\n    number\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpjojikecf.rs:10:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut count = 0;\n    let mut offset = 0;\n    let str_size = string.len();\n\
    \    let sub_size = substring.len();\n    if (sub_size == 0) {\n        return\
    \ 0;\n    }\n    while offset < str_size {\n        if string[offset..].starts_with(&substring)\
    \ {\n            count += 1;\n            offset += sub_size;\n        } else\
    \ {\n            offset += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpstqfv6sb.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    0\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp8jbpw0qg.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  if substring.len()\
    \ == 0 {\n    return 0;\n  }\n  let mut count = 0;\n  let mut tail = 0;\n  while\
    \ let Some(head) = string[tail..].find(&substring) {\n    count += 1;\n    tail\
    \ += head + substring.len();\n  }\n  count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpj198qqtl.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ string.len() == 0 || substring.len() == 0 {\n        return 0;\n    }\n    let\
    \ mut string = string.into_bytes();\n    let substring = substring.into_bytes();\n\
    \    let mut times = 0;\n    let mut current_position = 0;\n    while let Some(index)\
    \ = string[current_position..].windows(substring.len()).position(|s| s == &substring)\
    \ {\n        current_position += index + substring.len();\n        times += 1;\n\
    \    }\n    times\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpeqy8pu52.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ length = substring.len();\n    let s: Vec<_> = string.chars().collect();\n \
    \   let sub: Vec<_> = substring.chars().collect();\n    let mut occurrences =\
    \ 0;\n    let mut j = 0;\n    for i in 0..s.len() {\n        if j == length {\n\
    \            occurrences += 1;\n            j = 0;\n        }\n        if i ==\
    \ s.len() - 1 {\n            break;\n        }\n        if s[i] == sub[j] {\n\
    \            j += 1;\n        } else {\n            j = 0;\n        }\n    }\n\
    \    occurrences\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmp467r8iwi.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp51u2ekso.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ string.len() == 0 || substring.len() == 0 {\n        return 0;\n    }\n    let\
    \ string = string.into_bytes();\n    let substring = substring.into_bytes();\n\
    \    let n = string.len();\n    let m = substring.len();\n    let mut i = 0;\n\
    \    let mut res = 0;\n    while i + m <= n {\n        if &string[i..i + m] ==\
    \ &substring[..] {\n            res += 1;\n            i += m;\n        } else\
    \ {\n            i += 1;\n        }\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpuxge7smp.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ pattern = Regex::new(&substring).unwrap();\n    let result = pattern.find_iter(&string).count();\n\
    \    result as isize\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpx_6f1wty.rs:9:19\n\
    \  |\n9 |     let pattern = Regex::new(&substring).unwrap();\n  |            \
    \       ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  if substring.len()\
    \ == 0 {\n    return 0;\n  }\n  let mut counter = 0;\n  let mut start_index =\
    \ 0;\n  let mut len = substring.len();\n  while start_index + len <= string.len()\
    \ {\n    let stop_index = start_index + len;\n    if string[start_index..stop_index]\
    \ == substring {\n      counter += 1;\n      start_index += 1;\n    } else {\n\
    \      start_index += 1;\n    }\n  }\n  counter\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut n: isize = 0;\n    let mut i: usize = 0;\n    while i < string.len() {\n\
    \        if string[i..].starts_with(&substring) {\n            n += 1;\n     \
    \       i += substring.len();\n        } else {\n            i += 1;\n       \
    \ }\n    }\n    n\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpo65y6nga.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ string_bytes = string.as_bytes();\n    let substring_bytes = substring.as_bytes();\n\
    \    let mut number_of_times = 0;\n    let substring_length = substring_bytes.len();\n\
    \    let mut j = 0;\n    for i in 0..string_bytes.len() {\n        if string_bytes[i]\
    \ == substring_bytes[j] {\n            j += 1;\n            if j == substring_length\
    \ {\n                number_of_times += 1;\n                j = 0;\n         \
    \   }\n        } else {\n            j = 0;\n        }\n    }\n    number_of_times\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpms4fyvqi.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut counter = 0;\n    let mut index = 0;\n    let substring_length = substring.len();\n\
    \    while let Some(i) = string[index..].find(&substring) {\n        counter +=\
    \ 1;\n        index = i + substring_length;\n    }\n    counter\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ string.is_empty() || substring.is_empty() {\n        return 0;\n    }\n\n  \
    \  let mut times = 0;\n    let mut last_index = 0;\n    while let Some(index)\
    \ = string[last_index..].find(&substring) {\n        last_index += index + substring.len();\n\
    \        times += 1;\n    }\n\n    times\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpjaxo_8n9.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    0\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpq1vyfwny.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ string.is_empty() || substring.is_empty() {\n        return 0;\n    }\n\n  \
    \  let chars: Vec<char> = string.chars().collect();\n    let subchars: Vec<char>\
    \ = substring.chars().collect();\n\n    let mut count = 0;\n    let mut start\
    \ = 0;\n    let sublen = subchars.len();\n    let strlen = chars.len();\n\n  \
    \  loop {\n        let mut x = start;\n        let mut i = 0;\n        while x\
    \ < strlen && i < sublen && chars[x] == subchars[i] {\n            x += 1;\n \
    \           i += 1;\n        }\n\n        if i == sublen {\n            count\
    \ += 1;\n            start = x - i + 1;\n        } else {\n            start +=\
    \ 1;\n        }\n\n        if start >= strlen {\n            break;\n        }\n\
    \    }\n\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n \
    \   assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ substring.len() > string.len() {\n        return 0;\n    }\n    let mut times\
    \ = 0;\n    let mut substring_index = 0;\n    for ch in string.chars() {\n   \
    \     if ch == substring.chars().nth(substring_index).unwrap() {\n           \
    \ substring_index += 1;\n            if substring_index == substring.len() {\n\
    \                times += 1;\n                substring_index = 0;\n         \
    \   }\n        } else {\n            substring_index = 0;\n        }\n    }\n\
    \    times\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpn6ct_82x.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ n = string.len();\n    let sub_n = substring.len();\n    let mut times = 0;\n\
    \    for i in 0..n {\n        if i + sub_n > n {\n            break;\n       \
    \ }\n        if &string[i..i + sub_n] == substring {\n            times += 1;\n\
    \        }\n    }\n    times\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ string.len() < substring.len() {\n        return 0;\n    }\n\n    let chars\
    \ = string.chars().collect::<Vec<char>>();\n    let mut sub_char = Vec::new();\n\
    \    let mut counter = 0;\n\n    for i in 0..substring.len() {\n        sub_char.push(substring.chars().nth(i).unwrap());\n\
    \    }\n\n    for i in 0..(chars.len() - substring.len() + 1) {\n        if &chars[i..(i\
    \ + substring.len())] == &sub_char[..] {\n            counter += 1;\n        }\n\
    \    }\n\n    counter\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ string.len() < substring.len() {\n        return 0;\n    }\n    let mut result\
    \ = 0;\n    let mut i = 0;\n    while i <= string.len() - substring.len() {\n\
    \        if &string[i..i + substring.len()] == substring {\n            result\
    \ += 1;\n            i += substring.len();\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpe3w2_sb6.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut num_times: isize = 0;\n    let mut remaining_str = string;\n    while remaining_str.len()\
    \ >= substring.len() {\n        let found_at = remaining_str.find(&substring);\n\
    \        match found_at {\n            Some(index) => {\n                num_times\
    \ += 1;\n                let at_index = remaining_str.len() - index;\n       \
    \         remaining_str = remaining_str[at_index..].to_string();\n           \
    \ }\n            None => break,\n        }\n    }\n    num_times\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp4ekl0tof.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut i = 0;\n    let mut count = 0;\n    while i + substring.len() <= string.len()\
    \ {\n        if &string[i..i + substring.len()] == substring {\n            count\
    \ += 1;\n            i += substring.len();\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpc6d_mgay.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    //\
    \ Write your code here\n    let mut count = 0;\n    let mut start = 0;\n    let\
    \ mut end = substring.len();\n    let mut sub_string = substring.clone();\n  \
    \  let mut last_index = 0;\n    while end <= string.len() {\n        let mut new_substring\
    \ = sub_string.clone();\n        if string.contains(&new_substring) {\n      \
    \      count += 1;\n            last_index = string.find(&new_substring).unwrap();\n\
    \            start = last_index + 1;\n            end = start + substring.len();\n\
    \            sub_string = string[start..end].to_string();\n        } else {\n\
    \            start += 1;\n            end += 1;\n            sub_string = string[start..end].to_string();\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    if\
    \ substring.len() > string.len() {\n        return 0;\n    }\n    let mut count\
    \ = 0;\n    let mut index = 0;\n    while index < string.len() {\n        let\
    \ slice = &string[index..];\n        let index_of_substring = slice.find(&substring);\n\
    \        if index_of_substring == None {\n            break;\n        }\n    \
    \    index += index_of_substring.unwrap() + substring.len();\n        count +=\
    \ 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp2tcqpnqh.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    let\
    \ mut i = 0;\n    let mut cnt = 0;\n    while i <= string.len() - substring.len()\
    \ {\n        let (a, b) = string.split_at(i);\n        let c = a.split_at(i +\
    \ substring.len()).1;\n        if b == substring {\n            cnt += 1;\n  \
    \          i += substring.len();\n        } else {\n            i += 1;\n    \
    \    }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpg7pizx9z.rs:11:16\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  return\
    \ 0;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp7wiy9juy.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfn how_many_times(string: String, substring: String) -> isize {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpbsaxy8c2.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
