name: HumanEval_59_largest_prime_factor
language: rust
prompt: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
  /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
  /// 2\nfn largest_prime_factor(n: isize) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
  \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n  \
  \  assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
completions: ["    let mut n = n;\n    let mut k = 2;\n    while k * k <= n {\n  \
    \      if n % k == 0 {\n            n /= k;\n        } else {\n            k +=\
    \ 1;\n        }\n    }\n    n", "    for i in (2..=n).rev() {\n        if n %\
    \ i == 0 && is_prime(i) {\n            return i;\n        }\n    }\n    return\
    \ 0;", "    let mut largest_factor = 1;\n    let mut i = 2;\n    while i * i <=\
    \ n {\n        if n % i == 0 {\n            largest_factor = i;\n            n\
    \ /= i;\n        } else {\n            i += 1;\n        }\n    }\n    return if\
    \ n > largest_factor { n } else { largest_factor };", "    let mut n = n;\n  \
    \  let mut largest_factor = 2;\n    while n > 1 {\n        if n % largest_factor\
    \ == 0 {\n            n /= largest_factor;\n        } else {\n            largest_factor\
    \ += 1;\n        }\n    }\n    largest_factor", "    assert!(n > 1);\n    let\
    \ factors = prime_factors(n);\n    *factors.iter().max().unwrap()", "    for i\
    \ in (2..n).rev() {\n        if is_prime(i) && n % i == 0 {\n            return\
    \ i;\n        }\n    }\n    panic!(\"Something went wrong.\");", "    let mut\
    \ result = 2;\n    let mut input = n;\n    while input > 1 {\n        if is_prime(input)\
    \ {\n            result = input;\n            break;\n        }\n        for i\
    \ in 2..input + 1 {\n            if is_prime(i) && input % i == 0 {\n        \
    \        result = i;\n                input = input / i;\n                break;\n\
    \            }\n        }\n    }\n    result", "    if is_prime(n) {\n       \
    \ return n;\n    }\n    for i in 2..n {\n        if n % i == 0 {\n           \
    \ return largest_prime_factor(n / i);\n        }\n    }\n    panic!(\"largest_prime_factor\
    \ precondition failed\");", "    let mut i = 2;\n    let mut prime_factors = vec![];\n\
    \    while i * i <= n {\n        if n % i == 0 {\n            prime_factors.push(i);\n\
    \            n /= i;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    if n > 1 {\n        prime_factors.push(n);\n    }\n    prime_factors.pop().unwrap()",
  "    let mut prime = 2;\n    let mut k = n;\n    let sqr_k = (k as f64).sqrt().ceil()\
    \ as isize;\n    while prime <= sqr_k {\n        if k % prime == 0 {\n       \
    \     k /= prime;\n        } else {\n            prime += 1;\n        }\n    }\n\
    \    k", "    let mut v = Vec::new();\n    let mut remainder = n;\n    let mut\
    \ i = 2;\n    while remainder != 1 {\n        while remainder % i == 0 {\n   \
    \         v.push(i);\n            remainder /= i;\n        }\n        i += 1;\n\
    \    }\n    v.iter().max().unwrap().clone()", "    let mut result = 1;\n    let\
    \ mut d = 2;\n    while d * d <= n {\n        if n % d == 0 {\n            result\
    \ = d;\n            n /= d;\n        } else {\n            d += 1;\n        }\n\
    \    }\n    result", "    let mut factors = prime_factors(n);\n    factors.sort();\n\
    \    factors.last().unwrap().clone()", "    let mut i = 2;\n    let mut result\
    \ = n;\n    while i <= result {\n        if result % i == 0 {\n            result\
    \ /= i;\n        } else {\n            i += 1;\n        }\n    }\n    result",
  "    let mut c = n;\n    let mut i = 2;\n    while i <= c {\n        if c % i ==\
    \ 0 {\n            c /= i;\n        } else {\n            i += 1;\n        }\n\
    \    }\n    i", "    let mut largest = 1;\n    for i in 2..n {\n        if n %\
    \ i == 0 && is_prime(i) {\n            largest = i;\n        }\n    }\n    largest",
  "    let mut factor: isize = 2;\n    let mut n = n;\n    while n > 1 {\n       \
    \ if n % factor == 0 {\n            n /= factor;\n        } else {\n         \
    \   factor += 1;\n        }\n    }\n    factor", "    let mut n = n;\n    let\
    \ mut i = 2;\n    while i < n {\n        if n % i == 0 {\n            n /= i;\n\
    \        } else {\n            i += 1;\n        }\n    }\n    n", "    let mut\
    \ largest_prime = 2;\n    let mut current = n;\n    while current > 1 {\n    \
    \    if current % largest_prime == 0 {\n            current /= largest_prime;\n\
    \        } else {\n            largest_prime += 1;\n        }\n    }\n    largest_prime",
  "    let mut remainder = n;\n    let mut factor = 2;\n    while remainder > 1 {\n\
    \        if remainder % factor == 0 {\n            remainder /= factor;\n    \
    \    } else {\n            factor += 1;\n        }\n    }\n    factor", "    let\
    \ mut result = 1;\n    let mut m = n;\n    while m % 2 == 0 {\n        result\
    \ = 2;\n        m /= 2;\n    }\n    let mut p = 3;\n    while m > 1 {\n      \
    \  while m % p == 0 {\n            result = p;\n            m /= p;\n        }\n\
    \        p += 2;\n    }\n    result", "    for i in (1..n).rev() {\n        if\
    \ n % i == 0 && is_prime(i) {\n            return i;\n        }\n    }\n    return\
    \ 0;", "    let mut n = n;\n    let mut largest_prime = 1;\n    let mut i = 2;\n\
    \    while i <= n {\n        if n % i == 0 {\n            n /= i;\n          \
    \  largest_prime = i;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    largest_prime", "    if is_prime(n) {\n        return n;\n    }\n    if n\
    \ % 2 == 0 {\n        return largest_prime_factor(n / 2);\n    }\n    let mut\
    \ f = 3;\n    while n % f != 0 {\n        f += 2;\n    }\n    return largest_prime_factor(n\
    \ / f);", "    let mut result = n;\n    let mut d = 2;\n    while d * d <= result\
    \ {\n        if result % d == 0 {\n            result /= d;\n        } else {\n\
    \            d += 1;\n        }\n    }\n    result", "    let mut last_factor\
    \ = 1;\n    let mut number = n;\n    // While the factor is less than the number,\
    \ try dividing it.\n    for i in 2..number {\n        if number % i == 0 {\n \
    \           last_factor = i;\n            number /= i;\n            while number\
    \ % i == 0 {\n                number /= i;\n            }\n        }\n    }\n\
    \    if number == 1 {\n        last_factor\n    } else {\n        number\n   \
    \ }", "    let mut x = n / 2;\n    let mut y = n;\n    let mut last_y = y;\n \
    \   let mut prime_factors = Vec::new();\n    let mut prime_factor = 2;\n    while\
    \ y > x {\n        if y % x == 0 {\n            if prime_factor == x {\n     \
    \           prime_factors.push(x);\n                prime_factor = 2;\n      \
    \      }\n            last_y = y;\n            y = y / x;\n        } else {\n\
    \            prime_factor = x;\n            x -= 1;\n        }\n    }\n    if\
    \ prime_factor == y {\n        prime_factors.push(y);\n    } else {\n        prime_factors.push(last_y);\n\
    \    }\n    prime_factors.pop().unwrap()", "    let mut largest = 0;\n    let\
    \ mut divisor = 2;\n    let mut remainder = n;\n    while remainder > 1 {\n  \
    \      while remainder % divisor == 0 {\n            largest = divisor;\n    \
    \        remainder /= divisor;\n        }\n        divisor += 1;\n    }\n    largest",
  "    // Start with 2 and repeatedly divide out factors of 2, then try 3, 5, 7,\n\
    \    // etc.\n    let mut f = 2;\n    let mut n = n;\n    while n > 1 {\n    \
    \    if n % f == 0 {\n            n /= f;\n        } else {\n            f +=\
    \ 1;\n        }\n    }\n    f", "    let mut f = 2;\n    let mut n = n;\n    while\
    \ n % f == 0 {\n        n /= f;\n    }\n    for f in (3..).step_by(2) {\n    \
    \    while n % f == 0 {\n            n /= f;\n        }\n        if n == 1 {\n\
    \            return f;\n        }\n    }\n    unreachable!()", "    let mut n\
    \ = n;\n    for i in 2..(n as f64).sqrt() as isize + 1 {\n        while n % i\
    \ == 0 {\n            n /= i;\n        }\n    }\n    if n > 1 {\n        n\n \
    \   } else {\n        n / 2\n    }", "    let mut largest_prime = 2;\n    let\
    \ mut current = n;\n    while current % 2 == 0 {\n        current /= 2;\n    }\n\
    \    for i in (3..).step_by(2) {\n        while current % i == 0 {\n         \
    \   largest_prime = i;\n            current /= i;\n        }\n    }\n    largest_prime",
  "    if n % 2 == 0 {\n        return n / 2;\n    }\n\n    let mut n = n;\n    let\
    \ mut i = 3;\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i;\n        } else {\n            i += 2;\n        }\n    }\n    n", "    let\
    \ mut i = 2;\n    let mut n = n;\n    while i * i <= n {\n        if n % i ==\
    \ 0 {\n            n /= i;\n        } else {\n            i += 1;\n        }\n\
    \    }\n    n", "    let mut n = n;\n    let mut p = 2;\n    while n > 1 {\n \
    \       if n % p == 0 {\n            n /= p;\n        } else {\n            p\
    \ += 1;\n        }\n    }\n    p", "    let mut m = n;\n    let mut i = 2;\n \
    \   while i <= m {\n        if m % i == 0 {\n            m /= i;\n        } else\
    \ {\n            i += 1;\n        }\n    }\n    i", "    let mut prime_factor\
    \ = 2;\n    let mut number = n;\n    while prime_factor * prime_factor <= number\
    \ {\n        while number % prime_factor == 0 {\n            number /= prime_factor;\n\
    \        }\n        prime_factor += 1;\n    }\n    number", "    let mut n = n;\n\
    \    let mut p = 2;\n    while n > 1 {\n        if n % p == 0 {\n            n\
    \ /= p;\n        } else {\n            p += 1;\n        }\n    }\n    p", "  \
    \  let mut max_prime = 2;\n    let mut n = n;\n    while n > max_prime {\n   \
    \     if n % max_prime == 0 {\n            n /= max_prime;\n        } else {\n\
    \            max_prime += 1;\n        }\n    }\n    max_prime", "    let mut n\
    \ = n;\n    let mut factor = 2;\n    while n > 1 {\n        if n % factor == 0\
    \ {\n            n /= factor;\n        } else {\n            factor += 1;\n  \
    \      }\n    }\n    factor", "    let mut n = n;\n    let mut factor = 2;\n \
    \   while n > 1 {\n        if n % factor == 0 {\n            n /= factor;\n  \
    \      } else {\n            factor += 1;\n        }\n    }\n    factor", "  \
    \  let limit = isqrt(n);\n    let mut result = 1;\n    for i in 2..=limit {\n\
    \        if n % i == 0 {\n            let mut j = n / i;\n            while j\
    \ % i == 0 {\n                j /= i;\n            }\n            if j == 1 {\n\
    \                result = i;\n            }\n        }\n    }\n    result", " \
    \   let mut primes = vec![2, 3];\n    let mut m = n;\n    let mut p = 0;\n   \
    \ while m != 1 {\n        p = next_prime(&mut primes);\n        while m % p ==\
    \ 0 {\n            m /= p;\n        }\n    }\n    p", "    let mut max = 0;\n\
    \    let mut current = n;\n    while current % 2 == 0 {\n        max = 2;\n  \
    \      current /= 2;\n    }\n    let mut f = 3;\n    while f * f <= current {\n\
    \        if current % f == 0 {\n            max = f;\n            current /= f;\n\
    \        } else {\n            f += 2;\n        }\n    }\n    if current > 2 {\n\
    \        current\n    } else {\n        max\n    }", "    let n = n as usize;\n\
    \    let half = n / 2;\n    let (mut p, mut factor) = (2, n);\n    while p <=\
    \ half {\n        if n % p == 0 {\n            factor = p;\n            while\
    \ n % p == 0 {\n                n /= p;\n            }\n        }\n        p +=\
    \ 1;\n    }\n    factor as isize", "    let mut largest_factor = 1;\n    let mut\
    \ i = 2;\n    while i <= n / i {\n        if n % i == 0 {\n            largest_factor\
    \ = i;\n            n /= i;\n        } else {\n            i += 1;\n        }\n\
    \    }\n    if n > 1 {\n        largest_factor = n;\n    }\n    largest_factor",
  "    let mut res = 1;\n    let mut j = 2;\n    let mut i = n;\n    while i > 1 {\n\
    \        while i % j == 0 {\n            res = j;\n            i /= j;\n     \
    \   }\n        j += 1;\n    }\n    res", "    for i in (2..n / 2).rev() {\n  \
    \      if is_prime(i) && n % i == 0 {\n            return i;\n        }\n    }\n\
    \    0", "    let mut n = n;\n    let mut largest_prime = n;\n    while n % 2\
    \ == 0 {\n        n /= 2;\n    }\n    let mut i = 3;\n    while i <= n {\n   \
    \     if n % i == 0 {\n            n /= i;\n            largest_prime = i;\n \
    \       } else {\n            i += 2;\n        }\n    }\n    largest_prime", " \
    \   let (mut prime, mut last) = (2, 0);\n    while n != 1 {\n        if n % prime\
    \ == 0 {\n            last = prime;\n            n /= prime;\n        } else {\n\
    \            prime += 1;\n        }\n    }\n    last", "    let mut p: isize =\
    \ n;\n    let mut result: isize = 1;\n    let mut factor: isize = 2;\n    while\
    \ p != 1 {\n        if p % factor == 0 {\n            result = factor;\n     \
    \       p /= factor;\n        } else {\n            factor += 1;\n        }\n\
    \    }\n    result", "    for p in (2..n).rev() {\n        if n % p == 0 && is_prime(p)\
    \ {\n            return p;\n        }\n    }\n    unreachable!()", "    let mut\
    \ factors = prime_factors(n);\n    let mut max = 0;\n    while let Some(x) = factors.pop()\
    \ {\n        if x > max {\n            max = x;\n        }\n    }\n    max", " \
    \   let n = n as usize;\n    let limit = n / 2;\n    for i in 2..limit {\n   \
    \     if n % i == 0 {\n            return largest_prime_factor(n / i)\n      \
    \  }\n    }\n    n", "    let mut p = 2;\n    let mut m = n;\n    while m % p\
    \ == 0 {\n        m /= p;\n    }\n    p += 1;\n    while m != 1 {\n        if\
    \ m % p == 0 {\n            m /= p;\n        } else {\n            p += 2;\n \
    \       }\n    }\n    p", "    let mut p = 2;\n    let mut x = n;\n    while x\
    \ % p == 0 {\n        x /= p;\n    }\n    let mut q = p + 1;\n    while q * q\
    \ <= x {\n        if x % q == 0 {\n            p = q;\n            while x % p\
    \ == 0 {\n                x /= p;\n            }\n        }\n        q += 1;\n\
    \    }\n    if x > 1 {\n        p = x;\n    }\n    p", "    let mut n = n;\n \
    \   let mut x = 2;\n    while x * x <= n {\n        if n % x == 0 {\n        \
    \    n /= x;\n        } else {\n            x += 1;\n        }\n    }\n    n",
  "    let mut largest_prime_factor = 2;\n    let mut remaining = n;\n    while remaining\
    \ > largest_prime_factor {\n        if remaining % largest_prime_factor == 0 {\n\
    \            remaining /= largest_prime_factor;\n        } else {\n          \
    \  largest_prime_factor += 1;\n        }\n    }\n    return largest_prime_factor;",
  "    // It is guaranteed that n > 1 and is not a prime.\n    assert!(n > 1);\n \
    \   let mut fact = 1;\n    let mut x = n;\n    // We start from 2 and increment\
    \ the number until we find the largest prime factor.\n    let mut i = 2;\n   \
    \ // The largest factor can't be greater than sqrt(n).\n    while i * i <= x {\n\
    \        // If x is divisible by i, then the loop will continue until x is no\
    \ longer divisible by i.\n        while x % i == 0 {\n            x /= i;\n  \
    \          fact = i;\n        }\n        i += 1;\n    }\n    // If the remainder\
    \ is not 1, then the remainder is a prime number.\n    if x > 1 {\n        fact\
    \ = x;\n    }\n    fact", "    let mut n = n;\n    let mut factor = 2;\n    while\
    \ n % factor != 0 {\n        factor += 1;\n    }\n    n /= factor;\n    if n ==\
    \ 1 {\n        factor\n    } else {\n        largest_prime_factor(n)\n    }",
  "    let mut largest_factor = 0;\n    let mut temp = n;\n    let mut factor = 2;\n\
    \    while temp > 1 {\n        if temp % factor == 0 {\n            largest_factor\
    \ = factor;\n            temp /= factor;\n            while temp % factor == 0\
    \ {\n                temp /= factor;\n            }\n        }\n        factor\
    \ += 1;\n    }\n    largest_factor", "    let mut curr = n;\n    let mut largest\
    \ = 0;\n    while curr % 2 == 0 {\n        largest = 2;\n        curr /= 2;\n\
    \    }\n    let mut i = 3;\n    while i <= (curr as f64).sqrt() as isize {\n \
    \       while curr % i == 0 {\n            largest = i;\n            curr /= i;\n\
    \        }\n        i += 2;\n    }\n    if curr > largest {\n        curr\n  \
    \  } else {\n        largest\n    }", "    // Find smallest factor\n    let mut\
    \ factor = 3;\n    while n % factor != 0 {\n        factor += 2;\n    }\n    //\
    \ Divide out factor as long as it's a factor\n    let mut n = n / factor;\n  \
    \  while n % factor == 0 {\n        n = n / factor;\n    }\n    // There are no\
    \ more factorizations to find, so the largest prime factor of n is either\n  \
    \  // factor or n itself.\n    if n == 1 {\n        factor\n    } else {\n   \
    \     n\n    }", "    for i in (2..n / 2).rev() {\n        if is_prime(i) && n\
    \ % i == 0 {\n            return i;\n        }\n    }\n    0", "    if is_prime(n)\
    \ {\n        return n;\n    }\n\n    let smallest_factor = smallest_factor(n);\n\
    \    largest_prime_factor(n / smallest_factor)", "    let primes = sieve(n);\n\
    \    let mut remaining = n;\n    let mut i = primes.len() - 1;\n    while i >=\
    \ 0 {\n        if remaining % primes[i] == 0 {\n            remaining /= primes[i];\n\
    \        }\n        i -= 1;\n    }\n    n / remaining", "    let mut f = 2;\n\
    \    let mut n = n;\n    while n > 1 {\n        if n % f == 0 {\n            n\
    \ /= f;\n        } else {\n            f += 1;\n        }\n    }\n    f", '    (2..).find(|i|
    n % i == 0 && is_prime(*i)).unwrap()', "    let mut res = 1;\n    let mut i =\
    \ 2;\n    while i <= n {\n        if n % i == 0 {\n            res = i;\n    \
    \        n /= i;\n        } else {\n            i += 1;\n        }\n    }\n  \
    \  res", "    let mut x = 2;\n    let mut max_prime = 0;\n    while x * x <= n\
    \ {\n        if n % x == 0 {\n            max_prime = x;\n            n /= x;\n\
    \        } else {\n            x += 1;\n        }\n    }\n    max_prime", "  \
    \  let mut largest_factor = 2;\n    let mut remaining = n;\n    while remaining\
    \ % largest_factor == 0 {\n        remaining /= largest_factor;\n    }\n    largest_factor\
    \ += 1;\n    while remaining > 1 {\n        while remaining % largest_factor ==\
    \ 0 {\n            remaining /= largest_factor;\n        }\n        largest_factor\
    \ += 2;\n    }\n    largest_factor - 2", "    let mut p = 2;\n    let mut max_p\
    \ = p;\n    while p * p <= n {\n        if n % p == 0 {\n            max_p = p;\n\
    \            n /= p;\n        } else {\n            p += 1;\n        }\n    }\n\
    \    if n > max_p {\n        max_p = n;\n    }\n    max_p", "    let mut n = n;\n\
    \    let mut i = 2;\n    while i * i <= n {\n        while n % i == 0 {\n    \
    \        n /= i;\n        }\n        i += 1;\n    }\n    n", "    let mut p =\
    \ 2;\n    let mut max = p;\n    while p <= n {\n        while n % p == 0 {\n \
    \           max = p;\n            n /= p;\n        }\n        p += 1;\n    }\n\
    \    max", "    let mut n = n;\n    let mut largest_factor = 2;\n    let mut divisor\
    \ = 2;\n    while n > 1 {\n        if n % divisor == 0 {\n            n /= divisor;\n\
    \            largest_factor = divisor;\n        } else {\n            divisor\
    \ += 1;\n        }\n    }\n    largest_factor", "    let mut factors = vec![];\n\
    \    for i in 2..n {\n        if n % i == 0 {\n            factors.push(i);\n\
    \        }\n    }\n    let mut biggest = 0;\n    for i in factors {\n        if\
    \ is_prime(i) {\n            if i > biggest {\n                biggest = i;\n\
    \            }\n        }\n    }\n    return biggest;", "    let mut factor =\
    \ 2;\n    let mut n = n;\n    while n != 1 {\n        if n % factor == 0 {\n \
    \           n /= factor;\n        } else {\n            factor += 1;\n       \
    \ }\n    }\n    factor", "    let mut factors = vec![];\n    let mut num = n;\n\
    \    while num % 2 == 0 {\n        factors.push(2);\n        num /= 2;\n    }\n\
    \    let mut factor = 3;\n    while num > 1 {\n        while num % factor == 0\
    \ {\n            factors.push(factor);\n            num /= factor;\n        }\n\
    \        factor += 2;\n    }\n    *factors.last().unwrap()", "    let mut val\
    \ = n;\n    let mut factor = 2;\n    while val != 1 {\n        if val % factor\
    \ == 0 {\n            val /= factor;\n        } else {\n            factor +=\
    \ 1;\n        }\n    }\n    factor", "    let (p, _) = prime_factorization(n);\n\
    \    p", "    if n % 2 == 0 {\n        return largest_prime_factor(n / 2);\n \
    \   }\n    for i in (3..(n as f64).sqrt() as isize).step_by(2) {\n        if n\
    \ % i == 0 {\n            return largest_prime_factor(n / i);\n        }\n   \
    \ }\n    n", "    let mut i = 2;\n    let mut largest_prime = 1;\n    while i\
    \ <= n {\n        if n % i == 0 {\n            let mut j = 2;\n            let\
    \ mut is_prime = true;\n            while j <= i / 2 {\n                if i %\
    \ j == 0 {\n                    is_prime = false;\n                    break;\n\
    \                }\n                j += 1;\n            }\n            if is_prime\
    \ {\n                largest_prime = i;\n            }\n        }\n        i +=\
    \ 1;\n    }\n    largest_prime", "    let mut factor = n;\n    let mut i = 2;\n\
    \    while i <= (factor as f64).sqrt() as isize {\n        if factor % i == 0\
    \ {\n            factor /= i;\n        } else {\n            i += 1;\n       \
    \ }\n    }\n    factor", "    let mut p = 1;\n    let mut n = n;\n    while n\
    \ > 1 {\n        p += 1;\n        while n % p == 0 {\n            n /= p;\n  \
    \      }\n    }\n    p", "    let mut f = 2;\n    let mut curr = n;\n    let mut\
    \ result = 0;\n    while f <= curr {\n        if curr % f == 0 {\n           \
    \ if is_prime(f) {\n                result = f;\n            }\n            curr\
    \ /= f;\n        } else {\n            f += 1;\n        }\n    }\n    result",
  "    let mut x = n;\n    let mut i = 2;\n    while i <= x {\n        if x % i ==\
    \ 0 {\n            x /= i;\n        } else {\n            i += 1;\n        }\n\
    \    }\n    return i;", "    let mut largest = 0;\n    let mut i = 2;\n    while\
    \ i <= n {\n        if n % i == 0 {\n            largest = i;\n            n /=\
    \ i;\n        } else {\n            i += 1;\n        }\n    }\n    largest", " \
    \   if is_prime(n) {\n        return n;\n    }\n    let mut factor = 2;\n    while\
    \ factor <= n {\n        if n % factor == 0 {\n            return largest_prime_factor(n\
    \ / factor);\n        }\n        factor += 1;\n    }\n    1", "    let mut i =\
    \ 2;\n    let mut largest = 1;\n    let mut cur = n;\n    while i * i <= cur {\n\
    \        if cur % i == 0 {\n            largest = i;\n            cur /= i;\n\
    \        } else {\n            i += 1;\n        }\n    }\n    return std::cmp::max(largest,\
    \ cur);", "    let mut primes = Primes::new();\n    let mut largest_prime = 1;\n\
    \    let mut i = 2;\n    while i <= n {\n        let prime = primes.next().unwrap();\n\
    \        if n % prime == 0 {\n            largest_prime = prime;\n           \
    \ n /= prime;\n        }\n        i += 1;\n    }\n    largest_prime", "    let\
    \ mut primes = vec![2];\n    let mut value = n;\n    let mut factor = 3;\n   \
    \ while value > 1 {\n        while value % factor == 0 {\n            value /=\
    \ factor;\n            primes.push(factor);\n        }\n        factor += 2;\n\
    \    }\n    primes.pop().unwrap()", "    let mut m = n;\n    let mut i = 2;\n\
    \    while i * i <= m {\n        if m % i == 0 {\n            m /= i;\n      \
    \  } else {\n            i += 1;\n        }\n    }\n    m", "    if n <= 1 {\n\
    \        panic!(\"n must be > 1!\");\n    }\n    let mut result = 2;\n    let\
    \ mut num = n;\n    for i in 3..((n as f64).sqrt() as isize) {\n        if is_prime(i)\
    \ && num % i == 0 {\n            result = i;\n            num /= i;\n        }\n\
    \    }\n    result", "    let mut n = n;\n    let mut i = 2;\n    while i <= n\
    \ {\n        if n % i == 0 {\n            n /= i;\n        } else {\n        \
    \    i += 1;\n        }\n    }\n    i", "    let m = n / 2;\n    for i in m..1\
    \ {\n        if n % i == 0 && is_prime(i) {\n            return i;\n        }\n\
    \    }\n    0", "    let mut factor = 2;\n    let mut largest_factor = 0;\n  \
    \  while factor <= n {\n        if n % factor == 0 {\n            largest_factor\
    \ = factor;\n            n /= factor;\n        } else {\n            factor +=\
    \ 1;\n        }\n    }\n    largest_factor", "    let mut f = 2;\n    let mut\
    \ divisor = 2;\n    let mut largest_prime = 1;\n    while divisor <= n {\n   \
    \     if n % divisor == 0 {\n            f = n / divisor;\n            if f %\
    \ divisor == 0 {\n                f = f / divisor;\n            }\n          \
    \  if largest_prime < f {\n                largest_prime = f;\n            }\n\
    \        }\n        divisor += 1;\n    }\n    largest_prime", "    let mut n =\
    \ n;\n    let mut largest_factor = 2;\n    loop {\n        if n == largest_factor\
    \ {\n            return largest_factor;\n        }\n        if n % largest_factor\
    \ == 0 {\n            n /= largest_factor;\n        } else {\n            largest_factor\
    \ += 1;\n        }\n    }", "    let mut p = 2;\n    let mut m = n;\n    while\
    \ m != 1 {\n        while m % p == 0 {\n            m /= p;\n        }\n     \
    \   p += 1;\n    }\n    p - 1", "    if is_prime(n) {\n        return n;\n   \
    \ }\n    // The highest prime factor of n will not be greater than its square\
    \ root\n    for factor in 2..((n as f64).sqrt() as isize + 1) {\n        if n\
    \ % factor == 0 && is_prime(factor) {\n            return factor;\n        }\n\
    \    }\n    return -1;", '    (2..n).rev().find(|i| n % i == 0 && is_prime(*i)).unwrap()',
  "    let mut n = n;\n    let mut i = 2;\n    while i <= n {\n        if n % i ==\
    \ 0 {\n            n /= i;\n        } else {\n            i += 1;\n        }\n\
    \    }\n    return i;", "    let mut f = 2;\n    let mut max_f = 1;\n    while\
    \ f * f <= n {\n        if n % f == 0 {\n            max_f = f;\n            n\
    \ /= f;\n        } else {\n            f += 1;\n        }\n    }\n    if n > 1\
    \ {\n        max_f = n;\n    }\n    max_f", "    let mut n = n;\n    let mut i\
    \ = 2;\n    while i <= (n / i) {\n        while n % i == 0 {\n            n =\
    \ n / i;\n        }\n        i += 1;\n    }\n    n", "    let mut largest = 2;\n\
    \    let mut x = n;\n    while x > largest {\n        if x % largest == 0 {\n\
    \            x /= largest;\n        } else {\n            largest += 1;\n    \
    \    }\n    }\n    largest", "    let mut divisor = 2;\n    let mut largest_factor\
    \ = 1;\n    while n > 1 {\n        while n % divisor == 0 {\n            largest_factor\
    \ = divisor;\n            n /= divisor;\n        }\n        divisor += 1;\n  \
    \  }\n    largest_factor", "    let (mut n, mut factor) = (n, 2);\n    while n\
    \ > 1 {\n        if n % factor == 0 {\n            n /= factor;\n        } else\
    \ {\n            factor += 1;\n        }\n    }\n    factor", "    let (p, r)\
    \ = divide_out_prime_factors(n, 2);\n    if r == 1 {\n        p\n    } else {\n\
    \        largest_prime_factor(r)\n    }", "    let mut n = n;\n    let mut max_prime\
    \ = 2;\n    while n > max_prime {\n        if n % max_prime == 0 {\n         \
    \   n /= max_prime;\n        } else {\n            max_prime += 1;\n        }\n\
    \    }\n    max_prime", "    let mut p: isize = 2;\n    let mut m: isize = n;\n\
    \    while m != 1 {\n        if m % p == 0 {\n            m /= p;\n        } else\
    \ {\n            p += 1;\n        }\n    }\n    p", "    let mut largest_factor\
    \ = 1;\n    let mut f = 2;\n    while f <= n {\n        if n % f == 0 {\n    \
    \        largest_factor = f;\n            n /= f;\n        } else {\n        \
    \    f += 1;\n        }\n    }\n    largest_factor", "    let (mut n, mut f) =\
    \ (n, 2);\n    while n > 1 {\n        while n % f == 0 {\n            n /= f;\n\
    \        }\n        f += 1;\n    }\n    f - 1", "    let mut p = 2;\n    let mut\
    \ q = n;\n    while q > p {\n        if q % p == 0 {\n            q /= p;\n  \
    \      } else {\n            p += 1;\n        }\n    }\n    q", "    let mut n\
    \ = n;\n    let mut p = 2;\n    while n % p == 0 {\n        n /= p;\n    }\n \
    \   p += 1;\n    while n > 1 {\n        while n % p == 0 {\n            n /= p;\n\
    \        }\n        p += 2;\n    }\n    p -= 2", "    let mut largest_prime_factor\
    \ = 0;\n    let mut tmp = n;\n    // The factor is less than sqrt(n)\n    let\
    \ sqrt = (n as f64).sqrt() as isize;\n    for i in 2..sqrt {\n        if tmp %\
    \ i == 0 {\n            largest_prime_factor = i;\n            tmp /= i;\n   \
    \     }\n    }\n    // n is a prime or there is only one prime factor greater\
    \ than sqrt(n)\n    largest_prime_factor = max(largest_prime_factor, tmp);\n \
    \   largest_prime_factor", "    let mut n = n;\n    let mut i = 2;\n    let mut\
    \ ans = 0;\n    while i * i <= n {\n        if n % i == 0 {\n            ans =\
    \ i;\n            while n % i == 0 {\n                n /= i;\n            }\n\
    \        }\n        i += 1;\n    }\n    if n > 1 {\n        ans = n;\n    }\n\
    \    ans", "    let mut max_prime = 2;\n    let mut target = n;\n    while target\
    \ > max_prime {\n        if target % max_prime == 0 {\n            target /= max_prime;\n\
    \        } else {\n            max_prime += 1;\n        }\n    }\n    max_prime",
  "    let mut factor = 2;\n    let mut last_factor = 1;\n    let mut largest_factor\
    \ = 1;\n    while n > 1 {\n        while n % factor == 0 {\n            largest_factor\
    \ = factor;\n            n /= factor;\n        }\n        last_factor = factor;\n\
    \        factor += 1;\n        if factor * factor > n {\n            if n > 1\
    \ {\n                largest_factor = n;\n            }\n            break;\n\
    \        }\n    }\n    largest_factor", "    // TODO\n    n", "    let mut result\
    \ = 1;\n    let mut d = 2;\n    while d * d <= n {\n        if n % d == 0 {\n\
    \            result = d;\n            while n % d == 0 {\n                n /=\
    \ d;\n            }\n        }\n        d += 1;\n    }\n    if n > 1 {\n     \
    \   result = n;\n    }\n    result", "    let mut new_n = n;\n    let mut factor\
    \ = 2;\n    while new_n != 1 {\n        while new_n % factor == 0 {\n        \
    \    new_n /= factor;\n        }\n        factor += 1;\n    }\n    factor - 1",
  "    for i in (2..).take_while(|&i| i * i <= n) {\n        if n % i == 0 {\n   \
    \         return largest_prime_factor(n / i);\n        }\n    }\n    n", "   \
    \ let mut largest = 0;\n    let mut r = n;\n    let mut d = 2;\n    while r >\
    \ 1 {\n        if r % d == 0 {\n            largest = d;\n            r /= d;\n\
    \        } else {\n            d += 1;\n        }\n    }\n    largest", "    for\
    \ i in 2..n {\n        if n % i == 0 {\n            return largest_prime_factor(n\
    \ / i);\n        }\n    }\n    n", "    let mut n = n;\n    let mut p = 2;\n \
    \   while n != 1 {\n        while n % p == 0 {\n            n /= p;\n        }\n\
    \        p += 1;\n    }\n    p - 1", "    let mut x = n;\n    let mut factor =\
    \ 2;\n    while x > 1 {\n        if x % factor == 0 {\n            x /= factor;\n\
    \        } else {\n            factor += 1;\n        }\n    }\n    factor", " \
    \   let mut result = 0;\n    for x in 2..n {\n        if n % x == 0 {\n      \
    \      result = largest_prime_factor(n / x);\n            break;\n        }\n\
    \    }\n    if result == 0 {\n        result = n;\n    }\n    result", "    let\
    \ mut factor = 2;\n    let mut n = n;\n    while n > 1 {\n        if n % factor\
    \ == 0 {\n            n /= factor;\n        } else {\n            factor += 1;\n\
    \        }\n    }\n    factor", "    let mut x = n;\n    let mut prime_factors\
    \ = Vec::new();\n    let mut div = 2;\n    while x > 1 {\n        while x % div\
    \ == 0 {\n            prime_factors.push(div);\n            x /= div;\n      \
    \  }\n        div += 1;\n    }\n    *prime_factors.iter().max().unwrap()", " \
    \   2..n\n        .iter()\n        .filter(|x| n % x == 0)\n        .filter(|x|\
    \ is_prime(*x))\n        .max()\n        .unwrap()", "    let mut n = n;\n   \
    \ let mut factors = Vec::new();\n    let mut prime = 3;\n    let mut max_factor\
    \ = 1;\n    while n % 2 == 0 {\n        factors.push(2);\n        n /= 2;\n  \
    \  }\n    while n > 1 {\n        while n % prime == 0 {\n            max_factor\
    \ = prime;\n            factors.push(prime);\n            n /= prime;\n      \
    \  }\n        prime += 2;\n    }\n    return max_factor;", "    // TODO: implement\n\
    \    -1", "    let mut v = vec![];\n    let mut i = 2;\n    while i < n {\n  \
    \      if n % i == 0 {\n            v.push(i);\n            n /= i;\n        }\
    \ else {\n            i += 1;\n        }\n    }\n    v.push(n);\n    v.pop().unwrap()",
  "    let mut max_prime = 2;\n    let mut current = n;\n    while current > 1 {\n\
    \        max_prime = largest_prime_factor_helper(current, max_prime);\n      \
    \  current /= max_prime;\n    }\n    max_prime", "    let mut largest_prime_factor\
    \ = 1;\n    let mut test_factor = 2;\n    let mut remainder = n;\n    while remainder\
    \ > 1 {\n        while remainder % test_factor == 0 {\n            largest_prime_factor\
    \ = test_factor;\n            remainder /= test_factor;\n        }\n        test_factor\
    \ += 1;\n    }\n    largest_prime_factor", "    let mut n = n;\n    let mut factor\
    \ = 2;\n    while n > 1 {\n        if n % factor == 0 {\n            while n %\
    \ factor == 0 {\n                n /= factor;\n            }\n        }\n    \
    \    factor += 1;\n    }\n    factor - 1", "    let mut primes = Primes::default();\n\
    \    let mut factor = 1;\n    let mut remain = n;\n    while remain > 1 {\n  \
    \      let p = primes.next();\n        while remain % p == 0 {\n            factor\
    \ = p;\n            remain /= p;\n        }\n    }\n    factor", "    let mut\
    \ largest_prime = 2;\n    while n % largest_prime == 0 {\n        n /= largest_prime;\n\
    \    }\n    let mut i = 3;\n    while i * i <= n {\n        while n % i == 0 {\n\
    \            n /= i;\n            largest_prime = i;\n        }\n        i +=\
    \ 2;\n    }\n    largest_prime", "    for i in (2..n).rev() {\n        if is_prime(i)\
    \ && n % i == 0 {\n            return i;\n        }\n    }\n    1", "    let mut\
    \ divisor = 2;\n    let mut n = n;\n    let mut largest_prime_factor = 1;\n  \
    \  while n > 1 {\n        while n % divisor == 0 {\n            n /= divisor;\n\
    \            largest_prime_factor = divisor;\n        }\n        divisor += 1;\n\
    \    }\n    largest_prime_factor", "    let mut n = n;\n    let mut i = 2;\n \
    \   let mut last_factor = 1;\n    while i * i <= n {\n        if n % i == 0 {\n\
    \            last_factor = i;\n            n /= i;\n            while n % i ==\
    \ 0 {\n                n /= i;\n            }\n        }\n        i += 1;\n  \
    \  }\n    if n == 1 {\n        last_factor\n    } else {\n        n\n    }", " \
    \   let mut factor = 2;\n    let mut remaining = n;\n    while factor <= remaining\
    \ {\n        if remaining % factor == 0 {\n            remaining /= factor;\n\
    \        } else {\n            factor += 1;\n        }\n    }\n    factor", " \
    \   let mut largest_prime_factor = 1;\n    let max_factor = n;\n    let mut i\
    \ = 2;\n    while i < max_factor {\n        if n % i == 0 {\n            if is_prime(i)\
    \ {\n                largest_prime_factor = i;\n            }\n        }\n   \
    \     i += 1;\n    }\n    largest_prime_factor", "    let mut divisor = 2;\n \
    \   let mut largest_prime_factor = 0;\n    while n > 1 {\n        while n % divisor\
    \ == 0 {\n            largest_prime_factor = divisor;\n            n /= divisor;\n\
    \        }\n        divisor += 1;\n    }\n    largest_prime_factor", "    let\
    \ mut largest_prime = 2;\n    let mut next_prime = 3;\n    let mut limit = n;\n\
    \    while limit != 1 {\n        while limit % next_prime == 0 {\n           \
    \ largest_prime = next_prime;\n            limit /= next_prime;\n        }\n \
    \       next_prime += 2;\n    }\n    largest_prime", "    fn trial_division(n:\
    \ isize) -> Option<isize> {\n        if n % 2 == 0 {\n            return Some(2);\n\
    \        }\n        for i in (3..).step_by(2) {\n            if n % i == 0 {\n\
    \                return Some(i);\n            }\n        }\n        None\n   \
    \ }\n\n    let mut remainder = n;\n    let mut factor = trial_division(remainder);\n\
    \    while let Some(factor) = factor {\n        remainder /= factor;\n       \
    \ factor = trial_division(remainder);\n    }\n    remainder", "    let mut facs\
    \ = vec![];\n    let mut i = 2;\n    let mut n = n;\n    while i * i <= n {\n\
    \        if n % i == 0 {\n            facs.push(i);\n            n /= i;\n   \
    \     } else {\n            i += 1;\n        }\n    }\n    if n > 1 {\n      \
    \  facs.push(n);\n    }\n    *facs.iter().max().unwrap()", "    let mut factor\
    \ = 2;\n    let mut max_factor = 1;\n    while factor * factor <= n {\n      \
    \  if n % factor == 0 {\n            max_factor = factor;\n            n /= factor;\n\
    \        } else {\n            factor += 1;\n        }\n    }\n    if n > 1 {\n\
    \        return n;\n    }\n    return max_factor;", "    let mut factor = 2;\n\
    \    let mut result = n;\n    while result > 1 {\n        if result % factor ==\
    \ 0 {\n            result /= factor;\n        } else {\n            factor +=\
    \ 1;\n        }\n    }\n    factor", "    let mut factor = 2;\n    let mut n =\
    \ n;\n    while n > 1 {\n        if n % factor == 0 {\n            n /= factor;\n\
    \        } else {\n            factor += 1;\n        }\n    }\n    factor", " \
    \   let mut ret = 2;\n    let mut divisor = 3;\n    let mut num = n;\n    while\
    \ divisor * divisor <= num {\n        if num % divisor == 0 {\n            ret\
    \ = divisor;\n            num /= divisor;\n        } else {\n            divisor\
    \ += 2;\n        }\n    }\n    ret", "    let mut quotient = n;\n    let mut largest_prime_factor\
    \ = 0;\n    let mut i = 2;\n    while i * i <= quotient {\n        if quotient\
    \ % i == 0 {\n            quotient /= i;\n            largest_prime_factor = i;\n\
    \        } else {\n            i += 1;\n        }\n    }\n    if quotient > largest_prime_factor\
    \ {\n        largest_prime_factor = quotient;\n    }\n    largest_prime_factor",
  "    let primes = primes_up_to(n as f64).collect::<Vec<_>>();\n    for prime in\
    \ primes.iter().rev() {\n        if n % prime == 0 {\n            return *prime;\n\
    \        }\n    }\n    unreachable!()", "    let mut n = n;\n    let mut factor\
    \ = 2;\n    let mut largest_factor = 1;\n    while n > 1 {\n        if n % factor\
    \ == 0 {\n            largest_factor = factor;\n            n /= factor;\n   \
    \         while n % factor == 0 {\n                n /= factor;\n            }\n\
    \        }\n        factor += 1;\n    }\n    largest_factor", "    let mut factors\
    \ = vec![];\n    let mut i = 2;\n    while i <= n {\n        while n % i == 0\
    \ {\n            factors.push(i);\n            n /= i;\n        }\n        i +=\
    \ 1;\n    }\n    factors.pop().unwrap()", "    let mut i = 2;\n    let mut result\
    \ = 1;\n    while i <= n {\n        if n % i == 0 {\n            result = i;\n\
    \            n /= i;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    result", '    unimplemented!();', "    let mut prime = 2;\n    let mut is_prime\
    \ = |x| {\n        for i in 2..x {\n            if x % i == 0 {\n            \
    \    return false;\n            }\n        }\n        true\n    };\n    while\
    \ prime <= n {\n        while n % prime == 0 {\n            n /= prime;\n    \
    \    }\n        prime += 1;\n        while !is_prime(prime) {\n            prime\
    \ += 1;\n        }\n    }\n    prime", "    let mut prime = 0;\n    let mut sqrt\
    \ = (n as f64).sqrt().ceil() as isize;\n    while sqrt > 0 {\n        if is_prime(sqrt)\
    \ && n % sqrt == 0 {\n            prime = sqrt;\n            break;\n        }\n\
    \        sqrt -= 1;\n    }\n    prime", "    let mut factor = 2;\n    let mut\
    \ largest_factor = 1;\n    let mut tmp = n;\n    while tmp > 1 {\n        if tmp\
    \ % factor == 0 {\n            largest_factor = factor;\n            tmp /= factor;\n\
    \            while tmp % factor == 0 {\n                tmp /= factor;\n     \
    \       }\n        }\n        factor += 1;\n    }\n    largest_factor", "    let\
    \ mut i = 2;\n    let mut j = n;\n    while i * i <= j {\n        if j % i ==\
    \ 0 {\n            j /= i;\n        } else {\n            i += 1;\n        }\n\
    \    }\n    return j;", "    // First, find some smaller prime factor of n.\n\
    \    let mut factor = 2;\n    while n % factor != 0 {\n        factor += 1;\n\
    \    }\n\n    // Then, see if that factor has any prime factors itself.\n    let\
    \ mut other_factor = largest_prime_factor(factor);\n    let mut result = n / factor;\n\
    \    while result % other_factor == 0 {\n        result /= other_factor;\n   \
    \ }\n\n    // If it doesn't, then that factor is the largest prime factor of n.\n\
    \    if result == 1 {\n        factor\n    } else {\n        // Otherwise, the\
    \ largest prime factor of n is whatever's left.\n        largest_prime_factor(result)\n\
    \    }", "    let mut n = n;\n    let mut p = 2;\n    while n > 1 {\n        while\
    \ n % p == 0 {\n            n /= p;\n        }\n        p += 1;\n    }\n    p\
    \ - 1", "    let mut largest = 1;\n    let mut n = n;\n    for i in 2..n {\n \
    \       while n % i == 0 {\n            n /= i;\n            largest = i;\n  \
    \      }\n    }\n    largest", "    let n = n as usize;\n    let mut result =\
    \ 2;\n    let mut i = 2;\n    while i <= n / i {\n        if n % i == 0 {\n  \
    \          result = i;\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    result as isize", "    let mut num = n;\n    let mut\
    \ largest_prime = 1;\n    for p in primes() {\n        if p > num {\n        \
    \    break;\n        }\n\n        if num % p == 0 {\n            num /= p;\n \
    \           largest_prime = p;\n        }\n    }\n    largest_prime", "    if\
    \ n < 2 {\n        panic!(\"Input number {} is less than 2\", n);\n    }\n\n \
    \   let mut largest_prime_factor = 0;\n    let mut remainder = n;\n    let mut\
    \ p = 2;\n\n    while remainder > 1 {\n        if remainder % p == 0 {\n     \
    \       largest_prime_factor = p;\n            remainder /= p;\n        } else\
    \ {\n            p += 1;\n        }\n    }\n\n    largest_prime_factor", "   \
    \ let mut n = n;\n    let mut largest_factor = 1;\n    let mut current_factor\
    \ = 2;\n    while n > 1 {\n        if n % current_factor == 0 {\n            largest_factor\
    \ = current_factor;\n            n /= current_factor;\n            while n % current_factor\
    \ == 0 {\n                n /= current_factor;\n            }\n        }\n   \
    \     current_factor += 1;\n    }\n    largest_factor", "    if n == 2 {\n   \
    \     return 2;\n    }\n\n    let mut n = n;\n    let mut i = 2;\n    let mut\
    \ largest_prime = 0;\n\n    while i <= n {\n        if n % i == 0 {\n        \
    \    n /= i;\n            largest_prime = i;\n        } else {\n            i\
    \ += 1;\n        }\n    }\n\n    largest_prime", "    let factors = find_factors(n);\n\
    \    factors.iter().fold(0, |acc, &x| if is_prime(x) { x } else { acc })", " \
    \   let mut n = n;\n    let mut i = 2;\n    while i < n {\n        if n % i ==\
    \ 0 {\n            n /= i;\n        } else {\n            i += 1;\n        }\n\
    \    }\n    n", "    let mut d = 2;\n    let mut f = n;\n    while d * d <= f\
    \ {\n        if f % d == 0 {\n            f /= d;\n        } else {\n        \
    \    d += 1;\n        }\n    }\n    f", "    let mut i = 2;\n    let mut num =\
    \ n;\n    let mut max_prime = 1;\n    while i * i <= num {\n        if num % i\
    \ == 0 {\n            max_prime = i;\n            num = num / i;\n        } else\
    \ {\n            i += 1;\n        }\n    }\n    if num > 1 {\n        return num;\n\
    \    }\n    return max_prime;", "    let mut p = 2;\n    let mut primes = vec![];\n\
    \    let mut result = n;\n    while p * p <= result {\n        if result % p ==\
    \ 0 {\n            result /= p;\n            primes.push(p);\n        } else {\n\
    \            p += 1;\n        }\n    }\n    primes.push(result);\n    return *primes.last().unwrap();",
  "    let mut f = 2;\n    let mut d = n;\n    while d % f == 0 {\n        d /= f;\n\
    \    }\n    if d == 1 {\n        return f;\n    }\n    f = 3;\n    while d % f\
    \ == 0 {\n        d /= f;\n    }\n    if d == 1 {\n        return f;\n    }\n\
    \    f = 5;\n    while d % f == 0 {\n        d /= f;\n    }\n    if d == 1 {\n\
    \        return f;\n    }\n    while d % 2 == 0 {\n        d /= 2;\n    }\n  \
    \  let mut f = 7;\n    while d > 1 {\n        while d % f == 0 {\n           \
    \ d /= f;\n        }\n        f += 4;\n        while d % f == 0 {\n          \
    \  d /= f;\n        }\n        f += 2;\n        while d % f == 0 {\n         \
    \   d /= f;\n        }\n        f += 4;\n        while d % f == 0 {\n        \
    \    d /= f;\n        }\n        f += 2;\n        while d % f == 0 {\n       \
    \     d /= f;\n        }\n        f += 4;\n        while d % f == 0 {\n      \
    \      d /= f;\n        }\n        f += 6;\n        while d % f == 0 {\n     \
    \       d /= f;\n        }\n        f += 2;\n        while d % f == 0 {\n    \
    \        d /= f;\n        }\n        f += 6;\n    }\n    f - 2", "    let mut\
    \ n = n;\n    let mut i = 2;\n    while i * i <= n {\n        while n % i == 0\
    \ {\n            n /= i;\n        }\n        i += 1;\n    }\n    if n == 1 {\n\
    \        i -= 1;\n    }\n    n", "    let mut prime_factors = Vec::new();\n  \
    \  let mut n = n;\n    for i in 2..n+1 {\n        if n % i == 0 {\n          \
    \  prime_factors.push(i);\n            n /= i;\n        }\n    }\n    *prime_factors.last().unwrap()",
  "    let mut f = 2;\n    let mut pf = 1;\n    while f * f <= n {\n        if n %\
    \ f == 0 {\n            pf = f;\n            while n % f == 0 {\n            \
    \    n /= f;\n            }\n        }\n        f += 1;\n    }\n    if n > 1 {\n\
    \        pf = n;\n    }\n    pf", "    let mut n = n;\n    let mut factor = 2;\n\
    \    let mut largest_factor = 1;\n    while n > 1 {\n        if n % factor ==\
    \ 0 {\n            largest_factor = factor;\n            n /= factor;\n      \
    \      while n % factor == 0 {\n                n /= factor;\n            }\n\
    \        }\n        factor += 1;\n    }\n    largest_factor", "    let mut n =\
    \ n;\n    let mut i = 2;\n    let mut largest = 2;\n    while i <= n {\n     \
    \   if n % i == 0 {\n            n /= i;\n            largest = i;\n        }\
    \ else {\n            i += 1;\n        }\n    }\n    largest", "    let mut f\
    \ = 2;\n    let mut ans = 1;\n    while f <= n {\n        if is_prime(f) && n\
    \ % f == 0 {\n            ans = f;\n        }\n        f += 1;\n    }\n    ans",
  '    largest_prime_factor_iter(n, 2)', "    let mut i = 2;\n    let mut max_prime\
    \ = 1;\n    while i * i <= n {\n        if n % i == 0 {\n            max_prime\
    \ = i;\n            n /= i;\n        } else {\n            i += 1;\n        }\n\
    \    }\n    max_prime", "    let mut factors = vec![];\n    let mut m = n;\n \
    \   let mut i = 2;\n    loop {\n        if m % i == 0 {\n            factors.push(i);\n\
    \            m /= i;\n        } else {\n            i += 1;\n        }\n     \
    \   if m == 1 {\n            break;\n        }\n    }\n    factors.last().unwrap().clone()",
  "    // 1. 2 is the only even prime, so divide out any multiples of 2 first.\n \
    \   // 2. We don't need to check any numbers higher than the square root of n.\n\
    \    // 3. If a number is a factor of n, it is either a prime or a composite,\
    \ so if it\n    //    divides n, we can stop because we have found the largest\
    \ prime factor.\n    let mut n = n;\n    let mut largest_prime_factor = 1;\n \
    \   while n % 2 == 0 {\n        n /= 2;\n        largest_prime_factor = 2;\n \
    \   }\n    let mut factor = 3;\n    while factor <= n.sqrt() {\n        if n %\
    \ factor == 0 {\n            n /= factor;\n            largest_prime_factor =\
    \ factor;\n        } else {\n            factor += 2;\n        }\n    }\n    if\
    \ n > largest_prime_factor {\n        largest_prime_factor = n;\n    }\n    largest_prime_factor",
  "    let mut largest_prime_factor = 1;\n    let mut x = n;\n    for i in 2..n {\n\
    \        if x % i == 0 {\n            largest_prime_factor = i;\n            x\
    \ = x / i;\n        }\n    }\n    return largest_prime_factor;", "    let mut\
    \ i = 2;\n    let mut factor = n;\n    while i * i <= factor {\n        if factor\
    \ % i == 0 {\n            factor /= i;\n        } else {\n            i += 1;\n\
    \        }\n    }\n    factor", "    let limit = (n as f64).sqrt() as isize;\n\
    \    let mut n = n;\n    let mut i = 2;\n    while i <= limit {\n        if n\
    \ % i == 0 {\n            n /= i;\n            limit = (n as f64).sqrt() as isize;\n\
    \        } else {\n            i += 1;\n        }\n    }\n    n", "    let mut\
    \ quotient = n;\n    let mut largest_prime_factor = 0;\n    let mut factor = 2;\n\
    \    while quotient != 1 {\n        if quotient % factor == 0 {\n            largest_prime_factor\
    \ = factor;\n            quotient /= factor;\n        } else {\n            factor\
    \ += 1;\n        }\n    }\n    largest_prime_factor", "    let mut r = n;\n  \
    \  for i in 2..n {\n        if i * i > n {\n            break;\n        }\n  \
    \      while r % i == 0 {\n            r /= i;\n        }\n    }\n    r", "  \
    \  let mut p = 2;\n    let mut num = n;\n    while num > 1 {\n        while num\
    \ % p == 0 {\n            num /= p;\n        }\n        p += 1;\n    }\n    p\
    \ - 1", "    let mut n = n;\n    let mut f = 2;\n    while n > 1 {\n        if\
    \ n % f == 0 {\n            n /= f;\n        } else {\n            f += 1;\n \
    \       }\n    }\n    f", "    if n % 2 == 0 {\n        largest_prime_factor(n\
    \ / 2)\n    } else {\n        for x in (3..n).step_by(2) {\n            if n %\
    \ x == 0 {\n                return largest_prime_factor(n / x);\n            }\n\
    \        }\n        n\n    }", "    assert!(n > 1);\n    let mut p = 1;\n    let\
    \ mut a = n;\n    while a > 1 {\n        // a is not prime, so a has a prime factor\
    \ p\n        p += 1;\n        while a % p == 0 {\n            a /= p;\n      \
    \  }\n    }\n    p", "    assert!(n > 1);\n    let mut factor = 2;\n    let mut\
    \ num = n;\n    while num > 1 {\n        if num % factor == 0 {\n            while\
    \ num % factor == 0 {\n                num /= factor;\n            }\n       \
    \ }\n        factor += 1;\n    }\n    factor - 1", "    // TODO\n    0", "   \
    \ let mut copy_n = n;\n    let mut i = 2;\n    while i <= copy_n {\n        if\
    \ copy_n % i == 0 {\n            copy_n /= i;\n        } else {\n            i\
    \ += 1;\n        }\n    }\n    i", "    // TODO\n    0", "    let mut max_prime\
    \ = 1;\n    let mut num = n;\n    // Try 2 first\n    while num % 2 == 0 {\n \
    \       max_prime = 2;\n        num /= 2;\n    }\n    // Odd numbers\n    let\
    \ mut i = 3;\n    while i <= (num as f64).sqrt() as isize {\n        while num\
    \ % i == 0 {\n            max_prime = i;\n            num /= i;\n        }\n \
    \       i += 2;\n    }\n    if num > 2 {\n        max_prime = num;\n    }\n  \
    \  max_prime", "    if n == 1 {\n        return 1;\n    }\n\n    for i in (2..).take_while(|x|\
    \ x * x <= n) {\n        if n % i == 0 {\n            return largest_prime_factor(n\
    \ / i);\n        }\n    }\n\n    n"]
stop_tokens:
- "\n}"
