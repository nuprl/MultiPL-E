name: HumanEval_87_get_row
language: rust
results:
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, cell) in row.iter().enumerate() {\n            if *cell ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| a.0.cmp(&b.0).then(b.1.cmp(&a.1)));\n\
    \    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in\
    \ lst.iter().enumerate() {\n        let mut tmp: Vec<(isize, isize)> = Vec::new();\n\
    \        for (j, item) in row.iter().enumerate() {\n            if *item == x\
    \ {\n                tmp.push((i as isize, j as isize));\n            }\n    \
    \    }\n        tmp.sort_by(|a, b| {\n            if a.1 > b.1 {\n           \
    \     std::cmp::Ordering::Less\n            } else {\n                std::cmp::Ordering::Greater\n\
    \            }\n        });\n        for t in tmp {\n            result.push(t);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = vec![];\n    for (y, row) in lst.iter().enumerate()\
    \ {\n        for (x, _) in row.iter().enumerate() {\n            result.push((y\
    \ as isize, x as isize));\n        }\n    }\n    result\n}\n\nfn main() {\n  \
    \  let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (1, 0), (1, 1), (1, 2), (1,\
    \ 3), (1, 4), (1, 5), (2, 0), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5)]`,\n right:\
    \ `[(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]`', /tmp/tmpn1xp8his.rs:29:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut ret = vec![];\n    for (i, row) in lst.iter().enumerate() {\n\
    \        for (j, v) in row.iter().enumerate() {\n            if v == &x {\n  \
    \              ret.push((i as isize, j as isize));\n            }\n        }\n\
    \    }\n    ret.sort_by(|a, b| {\n        let (a_row, a_col) = *a;\n        let\
    \ (b_row, b_col) = *b;\n        a_row.cmp(&b_row).then(b_col.cmp(&a_col))\n  \
    \  });\n    ret\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    // fizz_buzz(n: isize) -> Vec<String> {\n    //     vec![\n    //   \
    \      (0..n).map(|x| if x % 15 == 0 { \"FizzBuzz\".to_string() } else if x %\
    \ 3 == 0 { \"Fizz\".to_string() } else if x % 5 == 0 { \"Buzz\".to_string() }\
    \ else { x.to_string() }).collect()\n    //     ]\n    // }\n    // // let mut\
    \ v = Vec::new();\n    // (0..n).map(|x| if x % 15 == 0 { \"FizzBuzz\".to_string()\
    \ } else if x % 3 == 0 { \"Fizz\".to_string() } else if x % 5 == 0 { \"Buzz\"\
    .to_string() } else { x.to_string() }).collect()\n    // (0..n).map(|x| if x %\
    \ 15 == 0 { \"FizzBuzz\".to_string() } else if x % 3 == 0 { \"Fizz\".to_string()\
    \ } else if x % 5 == 0 { \"Buzz\".to_string() } else { x.to_string() }).collect()\n\
    \    // .map(|x| if x % 15 == 0 { \"FizzBuzz\".to_string() } else if x % 3 ==\
    \ 0 { \"Fizz\".to_string() } else if x % 5 == 0 { \"Buzz\".to_string() } else\
    \ { x.to_string() }).collect()\n    // lst.iter().enumerate().map(|(index, x)|\
    \ if x % 15 == 0 { \"FizzBuzz\".to_string() } else if x % 3 == 0 { \"Fizz\".to_string()\
    \ } else if x % 5 == 0 { \"Buzz\".to_string() } else { x.to_string() }).collect()\n\
    \    // let mut v = Vec::new();\n    // for i in 0..n {\n    //     if i % 15\
    \ == 0 {\n    //         v.push(\"FizzBuzz\".to_string());\n    //     } else\
    \ if i % 3 == 0 {\n    //         v.push(\"Fizz\".to_string());\n    //     }\
    \ else if i %\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjt7o4rli.rs:17:47\n   |\n\
    17 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \    -------                                    ^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut lst: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, val) in row.iter().enumerate() {\n            if val == &x\
    \ {\n                lst.push((i as isize, j as isize));\n            }\n    \
    \    }\n    }\n    let mut lst = lst;\n    lst.sort_by(|a, b| {\n        if a.0\
    \ < b.0 {\n            std::cmp::Ordering::Less\n        } else if a.0 > b.0 {\n\
    \            std::cmp::Ordering::Greater\n        } else {\n            b.1.cmp(&a.1)\n\
    \        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for reference `&(isize, isize)`\
    \ in the current scope\n  --> /tmp/tmpoi3r7z_g.rs:20:29\n   |\n20 |         for\
    \ (j, val) in row.iter().enumerate() {\n   |                             ^^^^\
    \ method not found in `&(isize, isize)`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = vec![];\n    for (idx, val) in\
    \ lst.iter().enumerate() {\n        for (idx2, val2) in val.iter().enumerate()\
    \ {\n            if val2 == &x {\n                result.push((idx as isize, idx2\
    \ as isize));\n            }\n        }\n    }\n    result.sort_by(|a, b| {\n\
    \        if a.0 != b.0 {\n            a.0.cmp(&b.0)\n        } else {\n      \
    \      b.1.cmp(&a.1)\n        }\n    });\n    result\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.iter()\n        .enumerate()\n        .map(|(row, vec)| vec.iter().enumerate().filter(|(_,\
    \ v)| **v == x))\n        .flatten()\n        .map(|(col, _)| (row as isize, col\
    \ as isize))\n        .collect()\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `row` in this scope\n  --> /tmp/tmpkrq9a_50.rs:22:26\n\
    \   |\n22 |         .map(|(col, _)| (row as isize, col as isize))\n   |      \
    \                    ^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = Vec::new();\n    for row in 0..lst.len()\
    \ {\n        for column in 0..lst[row].len() {\n            if lst[row][column]\
    \ == x {\n                result.push((row as isize, column as isize));\n    \
    \        }\n        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0\
    \ {\n            a.1.cmp(&b.1)\n        } else {\n            a.0.cmp(&b.0)\n\
    \        }\n    });\n    result.reverse();\n    result\n}\n\nfn main() {\n   \
    \ let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(2, 5), (2, 0), (1, 4), (1, 0), (0, 0)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmpkhbvuuh3.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, val) in row.iter().enumerate() {\n            if *val ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    let mut sorter = |(y1, x1): &(isize, isize), (y2, x2): &(isize,\
    \ isize)| {\n        if y1 == y2 {\n            return x2.cmp(x1);\n        }\n\
    \        y1.cmp(y2)\n    };\n    res.sort_by(sorter);\n    res\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    let mut res = res;\n    res.sort_by(|a, b| {\n        if\
    \ a.0 < b.0 {\n            Ordering::Less\n        } else if a.0 > b.0 {\n   \
    \         Ordering::Greater\n        } else {\n            b.1.cmp(&a.1)\n   \
    \     }\n    });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n  \
    \  assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1,\
    \ 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpmekk7pgu.rs:29:13\n   |\n29 |             Ordering::Less\n   |     \
    \        ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed to\
    \ resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpmekk7pgu.rs:31:13\n\
    \   |\n31 |             Ordering::Greater\n   |             ^^^^^^^^ use of undeclared\
    \ type `Ordering`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut lst: Vec<Vec<isize>> = lst;\n    lst.iter_mut().for_each(|r|\
    \ r.reverse());\n    lst.sort_by(|a, b| b.len().cmp(&a.len()));\n    lst.iter().enumerate().flat_map(|(i,\
    \ r)| {\n        r.iter().enumerate().filter_map(move |(j, &v)| {\n          \
    \  if v == x {\n                Some((i as isize, j as isize))\n            }\
    \ else {\n                None\n            }\n        })\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(0, 5), (1, 1), (1, 5), (2, 0), (2, 5)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmpofz96km9.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = Vec::new();\n    for (y, row) in lst.iter().enumerate()\
    \ {\n        for (x1, el) in row.iter().enumerate() {\n            if el == &x\
    \ {\n                res.push((y as isize, x1 as isize));\n            }\n   \
    \     }\n    }\n    res.sort_by(|(row1, col1), (row2, col2)| {\n        if row1\
    \ != row2 {\n            row1.cmp(row2)\n        } else {\n            col2.cmp(col1)\n\
    \        }\n    });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = Vec::new();\n    for (y, row) in lst.iter().enumerate()\
    \ {\n        for (x, &val) in row.iter().enumerate() {\n            if val ==\
    \ x {\n                res.push((y as isize, x as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        let (a_y, a_x) = a;\n     \
    \   let (b_y, b_x) = b;\n        a_y.cmp(b_y).then(b_x.cmp(a_x))\n    });\n  \
    \  res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9zoktjes.rs:21:23\n   |\n\
    21 |             if val == x {\n   |                       ^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n21 |             if val == x.try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.iter()\n        .enumerate()\n        .flat_map(|(i, row)| {\n  \
    \          row.iter()\n                .enumerate()\n                .filter(|(_,\
    \ &v)| v == x)\n                .map(move |(j, _)| (i as isize, j as isize))\n\
    \        })\n        .sorted_by(|&(r1, c1), &(r2, c2)| {\n            (r1, -c1).cmp(&(r2,\
    \ -c2))\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate =\
    \ get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sorted_by` found for struct `FlatMap` in\
    \ the current scope\n  --> /tmp/tmptzv2fh3q.rs:26:10\n   |\n26 |         .sorted_by(|&(r1,\
    \ c1), &(r2, c2)| {\n   |          ^^^^^^^^^ method not found in `FlatMap<Enumerate<std::slice::Iter<'_,\
    \ Vec<isize>>>, Map<Filter<Enumerate<std::slice::Iter<'_, isize>>, [closure@/tmp/tmptzv2fh3q.rs:23:25:\
    \ 23:41]>, [closure@/tmp/tmptzv2fh3q.rs:24:22: 24:60]>, [closure@/tmp/tmptzv2fh3q.rs:20:19:\
    \ 25:10]>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = Vec::new();\n    for (row, line) in\
    \ lst.iter().enumerate() {\n        for (col, elem) in line.iter().enumerate()\
    \ {\n            if *elem == x {\n                res.push((row as isize, col\
    \ as isize));\n            }\n        }\n    }\n    res.sort_by(|a, b| {\n   \
    \     a.0.cmp(&b.0).then(b.1.cmp(&a.1))\n    });\n    res\n}\n\nfn main() {\n\
    \    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, e) in row.iter().enumerate() {\n            if *e == x {\n\
    \                res.push((i as isize, j as isize));\n            }\n        }\n\
    \    }\n    res.sort_by(|a, b| {\n        let fst = a.0.cmp(&b.0);\n        match\
    \ fst {\n            Ordering::Equal => b.1.cmp(&a.1),\n            Ordering::Less\
    \ => fst,\n            Ordering::Greater => fst,\n        }\n    });\n    res\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpgu0s3fcx.rs:29:13\n   |\n29 |             Ordering::Equal => b.1.cmp(&a.1),\n\
    \   |             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpgu0s3fcx.rs:30:13\n\
    \   |\n30 |             Ordering::Less => fst,\n   |             ^^^^^^^^ use\
    \ of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Ordering`\n  --> /tmp/tmpgu0s3fcx.rs:31:13\n   |\n31 |             Ordering::Greater\
    \ => fst,\n   |             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.iter()\n        .enumerate()\n        .flat_map(|(i, row)| {\n  \
    \          row.iter()\n                .enumerate()\n                .filter(|(_,\
    \ elem)| **elem == x)\n                .map(move |(j, _)| (i as isize, j as isize))\n\
    \        })\n        .collect()\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmpjylh31d5.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut vec: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        let mut y = row.len() as isize;\n        for j in row.iter() {\n\
    \            if *j == x {\n                vec.push((i as isize, y - 1));\n  \
    \          }\n            y -= 1;\n        }\n    }\n    vec.sort_by(|a, b| a.0.cmp(&b.0).then(b.1.cmp(&a.1)));\n\
    \    vec\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(0, 5), (1, 5), (1, 1), (2, 5), (2, 0)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmp19he57__.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.iter()\n        .enumerate()\n        .flat_map(|(row, item)| {\n\
    \            item.iter()\n                .enumerate()\n                .filter(|&(_,\
    \ x_)| x_ == &x)\n                .map(move |(col, _)| (row as isize, col as isize))\n\
    \        })\n        .sorted_by(|a, b| {\n            if a.0 == b.0 {\n      \
    \          a.1.cmp(&b.1).reverse()\n            } else {\n                a.0.cmp(&b.0)\n\
    \            }\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sorted_by` found for struct `FlatMap` in\
    \ the current scope\n  --> /tmp/tmpd08jg0lv.rs:26:10\n   |\n26 |         .sorted_by(|a,\
    \ b| {\n   |          ^^^^^^^^^ method not found in `FlatMap<Enumerate<std::slice::Iter<'_,\
    \ Vec<isize>>>, Map<Filter<Enumerate<std::slice::Iter<'_, isize>>, [closure@/tmp/tmpd08jg0lv.rs:23:25:\
    \ 23:44]>, [closure@/tmp/tmpd08jg0lv.rs:24:22: 24:66]>, [closure@/tmp/tmpd08jg0lv.rs:20:19:\
    \ 25:10]>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = Vec::new();\n    for y in 0..lst.len()\
    \ {\n        let row = &lst[y];\n        for z in 0..row.len() {\n           \
    \ if row[z] == x {\n                res.push((y as isize, z as isize));\n    \
    \        }\n        }\n    }\n    res.sort_by(|a, b| match a.0.cmp(&b.0) {\n \
    \       Ordering::Equal => b.1.cmp(&a.1),\n        Ordering::Less => Ordering::Less,\n\
    \        Ordering::Greater => Ordering::Greater,\n    });\n    res\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmp3t7incdr.rs:28:9\n   |\n28 |         Ordering::Equal => b.1.cmp(&a.1),\n\
    \   |         ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmp3t7incdr.rs:29:9\n\
    \   |\n29 |         Ordering::Less => Ordering::Less,\n   |         ^^^^^^^^ use\
    \ of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Ordering`\n  --> /tmp/tmp3t7incdr.rs:29:27\n   |\n29 |         Ordering::Less\
    \ => Ordering::Less,\n   |                           ^^^^^^^^ use of undeclared\
    \ type `Ordering`\n\nerror[E0433]: failed to resolve: use of undeclared type `Ordering`\n\
    \  --> /tmp/tmp3t7incdr.rs:30:9\n   |\n30 |         Ordering::Greater => Ordering::Greater,\n\
    \   |         ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmp3t7incdr.rs:30:30\n\
    \   |\n30 |         Ordering::Greater => Ordering::Greater,\n   |            \
    \                  ^^^^^^^^ use of undeclared type `Ordering`\n\nerror: aborting\
    \ due to 5 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.iter()\n        .enumerate()\n        .flat_map(|(i, row)| {\n  \
    \          row.iter()\n                .enumerate()\n                .filter(|(_,\
    \ &v)| v == x)\n                .map(move |(j, _)| (i as isize, j as isize))\n\
    \        })\n        .sorted_by(|&(r1, c1), &(r2, c2)| (r1, -c1).cmp(&(r2, -c2)))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sorted_by` found for struct `FlatMap` in\
    \ the current scope\n  --> /tmp/tmpq9f4ax3i.rs:26:10\n   |\n26 |         .sorted_by(|&(r1,\
    \ c1), &(r2, c2)| (r1, -c1).cmp(&(r2, -c2)))\n   |          ^^^^^^^^^ method not\
    \ found in `FlatMap<Enumerate<std::slice::Iter<'_, Vec<isize>>>, Map<Filter<Enumerate<std::slice::Iter<'_,\
    \ isize>>, [closure@/tmp/tmpq9f4ax3i.rs:23:25: 23:41]>, [closure@/tmp/tmpq9f4ax3i.rs:24:22:\
    \ 24:60]>, [closure@/tmp/tmpq9f4ax3i.rs:20:19: 25:10]>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.is_empty() {\n        return vec![];\n    }\n    let mut res:\
    \ Vec<(isize, isize)> = vec![];\n    for (i, y) in lst.iter().enumerate() {\n\
    \        for (j, z) in y.iter().enumerate() {\n            if *z == x {\n    \
    \            res.push((i as isize, j as isize));\n            }\n        }\n \
    \   }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n            return b.1.cmp(&a.1);\n\
    \        }\n        a.0.cmp(&b.0)\n    });\n    res\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut coordinates: Vec<(isize, isize)> = vec![];\n    for (y, row)\
    \ in lst.iter().enumerate() {\n        for (x, &value) in row.iter().enumerate()\
    \ {\n            if value == x {\n                coordinates.push((y as isize,\
    \ x as isize));\n            }\n        }\n    }\n    coordinates.sort_by(|a,\
    \ b| {\n        if a.0 == b.0 {\n            b.1.cmp(&a.1)\n        } else {\n\
    \            a.0.cmp(&b.0)\n        }\n    });\n    coordinates\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp73gj6ypn.rs:21:25\n   |\n\
    21 |             if value == x {\n   |                         ^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n21 |             if value == x.try_into().unwrap()\
    \ {\n   |                          ++++++++++++++++++++\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = Vec::new();\n    let mut i = 0;\n\
    \    for row in lst {\n        let mut j = 0;\n        for col in row {\n    \
    \        if col == x {\n                res.push((i, j));\n            }\n   \
    \         j += 1;\n        }\n        i += 1;\n    }\n    res.sort_by(|a, b| {\n\
    \        if a.0 == b.0 {\n            a.1.cmp(&b.1)\n        } else {\n      \
    \      a.0.cmp(&b.0)\n        }\n    });\n    res.reverse();\n    res\n}\n\nfn\
    \ main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(2, 5), (2, 0), (1, 4), (1, 0), (0, 0)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmpn9cx3b67.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = Vec::new();\n    for i in 0..lst.len()\
    \ {\n        let row = &lst[i];\n        for j in 0..row.len() {\n           \
    \ if row[j] == x {\n                result.push((i as isize, j as isize));\n \
    \           }\n        }\n    }\n    result.sort_by(|(r1, c1), (r2, c2)| r1.cmp(r2).then(c2.cmp(c1)));\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.iter()\n        .enumerate()\n        .flat_map(|(y, row)| {\n  \
    \          row.iter()\n                .enumerate()\n                .filter(|(_,\
    \ &element)| element == x)\n                .map(move |(x, _)| (y as isize, x\
    \ as isize))\n        })\n        .sorted_by(|(row1, col1), (row2, col2)| {\n\
    \            row1.cmp(row2).then_with(|| col2.cmp(col1))\n        })\n       \
    \ .collect()\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sorted_by` found for struct `FlatMap` in\
    \ the current scope\n  --> /tmp/tmph8ge4nzw.rs:26:10\n   |\n26 |         .sorted_by(|(row1,\
    \ col1), (row2, col2)| {\n   |          ^^^^^^^^^ method not found in `FlatMap<Enumerate<std::slice::Iter<'_,\
    \ Vec<isize>>>, Map<Filter<Enumerate<std::slice::Iter<'_, isize>>, [closure@/tmp/tmph8ge4nzw.rs:23:25:\
    \ 23:53]>, [closure@/tmp/tmph8ge4nzw.rs:24:22: 24:60]>, [closure@/tmp/tmph8ge4nzw.rs:20:19:\
    \ 25:10]>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    // get row and column numbers of the x\n    let mut indices = Vec::new();\n\
    \    for (i, row) in lst.iter().enumerate() {\n        for (j, &v) in row.iter().enumerate()\
    \ {\n            if v == x {\n                indices.push((i as isize, j as isize));\n\
    \            }\n        }\n    }\n    // sort by rows\n    indices.sort_by(|a,\
    \ b| a.0.cmp(&b.0));\n    // sort by columns\n    indices.sort_by(|a, b| a.1.cmp(&b.1).reverse());\n\
    \    indices\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmppfgzvexl.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut xs: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        let mut j = row.len() as isize;\n        while let Some(e) = row.get(j\
    \ as usize) {\n            if e == &x {\n                xs.push((i as isize,\
    \ j));\n            }\n            j -= 1;\n        }\n    }\n    xs.sort_by(|(x1,\
    \ y1), (x2, y2)| x1.cmp(x2).then(y2.cmp(y1)));\n    xs\n}\n\nfn main() {\n   \
    \ let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]`', /tmp/tmpync0xhtq.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = Vec::new();\n    let mut rows =\
    \ 0;\n    for row in lst {\n        let mut cols = 0;\n        for col in row\
    \ {\n            if col == x {\n                result.push((rows, cols));\n \
    \           }\n            cols += 1;\n        }\n        rows += 1;\n    }\n\
    \    result.sort_by(|a, b| {\n        (a.0, -a.1).cmp(&(b.0, -b.1))\n    });\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.iter()\n        .enumerate()\n        .flat_map(|(i, row)| {\n  \
    \          row.iter()\n                .enumerate()\n                .filter(|(_,\
    \ &y)| y == x)\n                .map(move |(j, _)| (i as isize, j as isize))\n\
    \        })\n        .sorted_by(|&(i, j), &(i2, j2)| {\n            if i == i2\
    \ {\n                Ord::cmp(&j2, &j)\n            } else {\n               \
    \ Ord::cmp(&i, &i2)\n            }\n        })\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sorted_by` found for struct `FlatMap` in\
    \ the current scope\n  --> /tmp/tmpkbgiwcaw.rs:26:10\n   |\n26 |         .sorted_by(|&(i,\
    \ j), &(i2, j2)| {\n   |          ^^^^^^^^^ method not found in `FlatMap<Enumerate<std::slice::Iter<'_,\
    \ Vec<isize>>>, Map<Filter<Enumerate<std::slice::Iter<'_, isize>>, [closure@/tmp/tmpkbgiwcaw.rs:23:25:\
    \ 23:41]>, [closure@/tmp/tmpkbgiwcaw.rs:24:22: 24:60]>, [closure@/tmp/tmpkbgiwcaw.rs:20:19:\
    \ 25:10]>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.iter()\n        .enumerate()\n        .flat_map(|(row, v)| {\n  \
    \          v.iter()\n                .enumerate()\n                .filter(|(_,\
    \ elem)| **elem == x)\n                .map(move |(col, _)| (row as isize, col\
    \ as isize))\n        })\n        .sorted_by(|a, b| a.0.cmp(&b.0).then(b.1.cmp(&a.1)))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sorted_by` found for struct `FlatMap` in\
    \ the current scope\n  --> /tmp/tmpm5vaeslw.rs:26:10\n   |\n26 |         .sorted_by(|a,\
    \ b| a.0.cmp(&b.0).then(b.1.cmp(&a.1)))\n   |          ^^^^^^^^^ method not found\
    \ in `FlatMap<Enumerate<std::slice::Iter<'_, Vec<isize>>>, Map<Filter<Enumerate<std::slice::Iter<'_,\
    \ isize>>, [closure@/tmp/tmpm5vaeslw.rs:23:25: 23:48]>, [closure@/tmp/tmpm5vaeslw.rs:24:22:\
    \ 24:66]>, [closure@/tmp/tmpm5vaeslw.rs:20:19: 25:10]>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.iter()\n        .enumerate()\n        .map(|(row, v)| {\n       \
    \     v.iter()\n                .enumerate()\n                .filter(|(_, y)|\
    \ **y == x)\n                .map(|(col, _)| (row as isize, col as isize))\n \
    \               .collect::<Vec<(isize, isize)>>()\n        })\n        .flatten()\n\
    \        .collect::<Vec<(isize, isize)>>()\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmpwzhhaag5.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut results = Vec::new();\n    for i in 0..lst.len() {\n        for\
    \ j in 0..lst[i].len() {\n            if lst[i][j] == x {\n                results.push((i\
    \ as isize, j as isize));\n            }\n        }\n    }\n    results.sort_by(|a,\
    \ b| {\n        if a.0 == b.0 {\n            a.1.cmp(&b.1)\n        } else {\n\
    \            a.0.cmp(&b.0)\n        }\n    });\n    results\n}\n\nfn main() {\n\
    \    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmpycqj1w9g.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut out = vec![];\n    for (y, xs) in lst.iter().enumerate() {\n\
    \        for (x_i, x_) in xs.iter().enumerate() {\n            if *x_ == x {\n\
    \                out.push((y as isize, x_i as isize));\n            }\n      \
    \  }\n    }\n    out.sort_by(|a, b| a.0.cmp(&b.0).then(b.1.cmp(&a.1)));\n    out\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let (mut x_pos, mut y_pos) = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, cell) in row.iter().enumerate() {\n            if cell ==\
    \ &x {\n                x_pos.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    x_pos.sort_by(|a, b| {\n        if a.0 == b.0 {\n     \
    \       a.1.cmp(&b.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    for i in 0..x_pos.len() {\n        if x_pos[i].0 == x_pos[i - 1].0\
    \ {\n            x_pos.swap(i, i - 1);\n        }\n    }\n    for i in 0..x_pos.len()\
    \ {\n        if x_pos[i].0 == x_pos[i - 1].0 {\n            x_pos.swap(i, i -\
    \ 1);\n        }\n    }\n    for i in 0..x_pos.len() {\n        if x_pos[i].0\
    \ == x_pos[i - 1].0 {\n            x_pos.swap(i, i - 1);\n        }\n    }\n \
    \   x_pos\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp144i9mrc.rs:18:9\n   |\n\
    18 |     let (mut x_pos, mut y_pos) = Vec::new();\n   |         ^^^^^^^^^^^^^^^^^^^^^^\
    \   ---------- this expression has type `Vec<_>`\n   |         |\n   |       \
    \  expected struct `Vec`, found tuple\n   |\n   = note: expected struct `Vec<_>`\n\
    \               found tuple `(_, _)`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = vec![];\n    if lst.len() == 0 {\n\
    \        return res;\n    }\n    for (i, row) in lst.iter().enumerate() {\n  \
    \      for (j, el) in row.iter().enumerate() {\n            if *el == x {\n  \
    \              res.push((i as isize, j as isize));\n            }\n        }\n\
    \    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n            b.1.cmp(&a.1)\n\
    \        } else {\n            a.0.cmp(&b.0)\n        }\n    });\n    res\n}\n\
    \nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut locations: Vec<(isize, isize)> = Vec::new();\n    for (i, row)\
    \ in lst.iter().enumerate() {\n        for (j, &val) in row.iter().enumerate()\
    \ {\n            if val == x {\n                locations.push((i as isize, j\
    \ as isize));\n            }\n        }\n    }\n    locations.sort_by(|a, b| a.0.cmp(&b.0).then(b.1.cmp(&a.1)));\n\
    \    locations\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row_vec: Vec<(isize, isize)> = Vec::new();\n    if lst.len()\
    \ == 0 {\n        return row_vec;\n    }\n    for (row_index, row) in lst.iter().enumerate()\
    \ {\n        if row.len() == 0 {\n            continue;\n        }\n        for\
    \ (col_index, col) in row.iter().enumerate() {\n            if *col == x {\n \
    \               row_vec.push((row_index as isize, col_index as isize));\n    \
    \        }\n        }\n    }\n    // sort by row in ascending order\n    row_vec.sort_by(|a,\
    \ b| a.0.cmp(&b.0));\n    // sort by column in descending order\n    row_vec.sort_by(|a,\
    \ b| b.1.cmp(&a.1));\n    row_vec\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmprzbqgx_q.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = Vec::new();\n    for i in 0..lst.len()\
    \ {\n        for j in 0..lst[i].len() {\n            if lst[i][j] == x {\n   \
    \             res.push((i as isize, j as isize));\n            }\n        }\n\
    \    }\n    res.sort_by(|a, b| {\n        if a.0 != b.0 {\n            a.0.cmp(&b.0)\n\
    \        } else {\n            b.1.cmp(&a.1)\n        }\n    });\n    res\n}\n\
    \nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = vec![];\n    for (idx, row) in\
    \ lst.iter().enumerate() {\n        for (i, v) in row.iter().enumerate() {\n \
    \           if v == &x {\n                result.push((idx as isize, i as isize));\n\
    \            }\n        }\n    }\n    result.sort_by(|a, b| {\n        if a.0\
    \ == b.0 {\n            b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n\
    \        }\n    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = Vec::new();\n    let mut i = 0;\n\
    \    for r in lst {\n        let mut j = r.len() as isize - 1;\n        for c\
    \ in r {\n            if c == x {\n                res.push((i, j));\n       \
    \     }\n            j -= 1;\n        }\n        i += 1;\n    }\n    res.sort_by(|a,\
    \ b| (a.0, b.1).cmp(&(b.0, a.1)));\n    res\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(0, 5), (1, 5), (1, 1), (2, 5), (2, 0)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmp0zv21sk6.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut coords: Vec<(isize, isize)> = Vec::new();\n    let mut rows =\
    \ 0;\n    for row in lst {\n        let mut cols = 0;\n        for col in row\
    \ {\n            if x == col {\n                coords.push((rows, cols));\n \
    \           }\n            cols += 1;\n        }\n        rows += 1;\n    }\n\
    \    coords.sort_by(|a, b| {\n        if a.0 == b.0 {\n            b.1.cmp(&a.1)\n\
    \        } else {\n            a.0.cmp(&b.0)\n        }\n    });\n    coords\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = vec![];\n    for (y, sub_lst) in\
    \ lst.iter().enumerate() {\n        for (x1, &x2) in sub_lst.iter().enumerate()\
    \ {\n            if x2 == x {\n                result.push((y as isize, x1 as\
    \ isize));\n            }\n        }\n    }\n    result.sort_by(|a, b| {\n   \
    \     if a.0 == b.0 {\n            b.1.cmp(&a.1)\n        } else {\n         \
    \   a.0.cmp(&b.0)\n        }\n    });\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut ret: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                ret.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    ret.sort_by(|&(i, _), &(j, _)| i.cmp(&j));\n    ret.sort_by(|&(_,\
    \ i), &(_, j)| j.cmp(&i));\n    ret\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmpb5_bhwo5.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, elem) in row.iter().enumerate() {\n            if *elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| a.1.cmp(&b.1));\n    res.sort_by(|a, b|\
    \ a.0.cmp(&b.0));\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n \
    \   assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmpqkn9b_y6.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = vec![];\n    let mut i = 0;\n    for\
    \ row in lst {\n        let mut j = 0;\n        for elem in row {\n          \
    \  if elem == x {\n                res.push((i, j));\n            }\n        \
    \    j += 1;\n        }\n        i += 1;\n    }\n    res.sort_by(|a, b| {\n  \
    \      if a.0 == b.0 {\n            b.1.cmp(&a.1)\n        } else {\n        \
    \    a.0.cmp(&b.0)\n        }\n    });\n    res\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut r: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                r.push((i as isize, j as isize));\n            }\n    \
    \    }\n    }\n    r.sort_by(|a, b| {\n        if a.0 == b.0 {\n            a.1.cmp(&b.1)\n\
    \        } else {\n            a.0.cmp(&b.0)\n        }\n    });\n    r\n}\n\n\
    fn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmprxmwmwyp.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = vec![];\n    for i in 0..lst.len()\
    \ {\n        for j in 0..lst[i].len() {\n            if lst[i][j] == x {\n   \
    \             res.push((i as isize, j as isize));\n            }\n        }\n\
    \    }\n    res.sort_by(|a, b| {\n        if a.0 != b.0 {\n            return\
    \ a.0.cmp(&b.0);\n        }\n        b.1.cmp(&a.1)\n    });\n    res\n}\n\nfn\
    \ main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = vec![];\n    let rows = lst.len();\n\
    \    let cols = lst[0].len();\n    for i in 0..rows {\n        for j in 0..cols\
    \ {\n            if lst[i][j] == x {\n                res.push((i as isize, j\
    \ as isize));\n            }\n        }\n    }\n    res.sort_by(|a, b| a.0.cmp(&b.0));\n\
    \    for i in 0..res.len() {\n        res[i].0 = i as isize;\n    }\n    res.sort_by(|a,\
    \ b| b.1.cmp(&a.1));\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(4, 5), (2, 4), (0, 0), (1, 0), (3, 0)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmprsqs_udz.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = Vec::new();\n    for i in 0..lst.len()\
    \ {\n        for j in 0..lst[i].len() {\n            if lst[i][j] == x {\n   \
    \             result.push((i as isize, j as isize));\n            }\n        }\n\
    \    }\n    result.sort_by(|a, b| {\n        a.0.cmp(&b.0).then(b.1.cmp(&a.1))\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut lst: Vec<(isize, isize)> = Vec::new();\n    let mut i = 0;\n\
    \    for r in lst {\n        let mut j = 0;\n        for c in r {\n          \
    \  if c == x {\n                lst.push((i, j));\n            }\n           \
    \ j += 1;\n        }\n        i += 1;\n    }\n    lst.sort_by(|&(y1, x1), &(y2,\
    \ x2)| {\n        match y1.cmp(&y2) {\n            Ordering::Equal => {\n    \
    \            match x2.cmp(&x1) {\n                    Ordering::Equal => Ordering::Equal,\n\
    \                    Ordering::Greater => Ordering::Greater,\n               \
    \     Ordering::Less => Ordering::Less,\n                }\n            }\n  \
    \          Ordering::Greater => Ordering::Greater,\n            Ordering::Less\
    \ => Ordering::Less,\n        }\n    });\n    lst\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmp5gyuuxgl.rs:32:13\n   |\n32 |             Ordering::Equal => {\n   |\
    \             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmp5gyuuxgl.rs:34:21\n\
    \   |\n34 |                     Ordering::Equal => Ordering::Equal,\n   |    \
    \                 ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmp5gyuuxgl.rs:34:40\n\
    \   |\n34 |                     Ordering::Equal => Ordering::Equal,\n   |    \
    \                                    ^^^^^^^^ use of undeclared type `Ordering`\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmp5gyuuxgl.rs:35:21\n\
    \   |\n35 |                     Ordering::Greater => Ordering::Greater,\n   |\
    \                     ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmp5gyuuxgl.rs:35:42\n\
    \   |\n35 |                     Ordering::Greater => Ordering::Greater,\n   |\
    \                                          ^^^^^^^^ use of undeclared type `Ordering`\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmp5gyuuxgl.rs:36:21\n\
    \   |\n36 |                     Ordering::Less => Ordering::Less,\n   |      \
    \               ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmp5gyuuxgl.rs:36:39\n\
    \   |\n36 |                     Ordering::Less => Ordering::Less,\n   |      \
    \                                 ^^^^^^^^ use of undeclared type `Ordering`\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmp5gyuuxgl.rs:39:13\n\
    \   |\n39 |             Ordering::Greater => Ordering::Greater,\n   |        \
    \     ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `Ordering`\n  --> /tmp/tmp5gyuuxgl.rs:39:34\n   |\n39\
    \ |             Ordering::Greater => Ordering::Great"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut lst2: Vec<(isize, isize)> = Vec::new();\n    let mut count =\
    \ 0;\n    for item in lst {\n        let mut count2 = 0;\n        for item2 in\
    \ item {\n            if item2 == x {\n                lst2.push((count, count2));\n\
    \            }\n            count2 += 1;\n        }\n        count += 1;\n   \
    \ }\n    lst2.sort_by(|a, b| {\n        a.0.cmp(&b.0).then(b.1.cmp(&a.1))\n  \
    \  });\n    lst2\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut coordinates: Vec<(isize, isize)> = Vec::new();\n    if lst.len()\
    \ == 0 {\n        return coordinates;\n    }\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    while i < lst.len() {\n        while j < lst[i].len() {\n      \
    \      if lst[i][j] == x {\n                coordinates.push((i as isize, j as\
    \ isize));\n            }\n            j += 1;\n        }\n        j = 0;\n  \
    \      i += 1;\n    }\n    coordinates.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    coordinates\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmpbdnqx09x.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    // TODO\n    let mut lst = lst;\n    lst.iter_mut().enumerate().for_each(|(idx,\
    \ v)| {\n        let vec = v.iter()\n        .enumerate()\n        .filter(|&(_,\
    \ x1)| x1 == &x)\n        .map(|(idx1, _)| (idx as isize, idx1 as isize))\n  \
    \      .collect::<Vec<(isize, isize)>>();\n        *v = vec;\n    });\n    lst.sort_by(|a,\
    \ b| a[0].1.cmp(&b[0].1));\n    lst.into_iter().flat_map(|v| v).collect()\n}\n\
    \nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpokosev5w.rs:26:14\n   |\n\
    26 |         *v = vec;\n   |         --   ^^^ expected `isize`, found tuple\n\
    \   |         |\n   |         expected due to the type of this binding\n   |\n\
    \   = note: expected struct `Vec<isize>`\n              found struct `Vec<(isize,\
    \ isize)>`\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't\
    \ have fields\n  --> /tmp/tmpokosev5w.rs:28:29\n   |\n28 |     lst.sort_by(|a,\
    \ b| a[0].1.cmp(&b[0].1));\n   |                             ^\n\nerror[E0610]:\
    \ `isize` is a primitive type and therefore doesn't have fields\n  --> /tmp/tmpokosev5w.rs:28:41\n\
    \   |\n28 |     lst.sort_by(|a, b| a[0].1.cmp(&b[0].1));\n   |               \
    \                          ^\n\nerror[E0277]: a value of type `Vec<(isize, isize)>`\
    \ cannot be built from an iterator over elements of type `isize`\n    --> /tmp/tmpokosev5w.rs:29:37\n\
    \     |\n29   |     lst.into_iter().flat_map(|v| v).collect()\n     |        \
    \                             ^^^^^^^ value of type `Vec<(isize, isize)>` cannot\
    \ be built from `std::iter::Iterator<Item=isize>`\n     |\n     = help: the trait\
    \ `FromIterator<isize>` is not implemented for `Vec<(isize, isize)>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0610.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        let mut row_i = i as isize;\n        let mut column_i = 0;\n    \
    \    for (j, _) in row.iter().enumerate() {\n            if row[j] == x {\n  \
    \              res.push((row_i, j as isize - column_i));\n                column_i\
    \ += 1;\n            }\n        }\n    }\n    res.sort_by(|a, b| {\n        if\
    \ a.0 < b.0 {\n            Ordering::Less\n        } else if a.0 > b.0 {\n   \
    \         Ordering::Greater\n        } else {\n            if a.1 > b.1 {\n  \
    \              Ordering::Less\n            } else if a.1 < b.1 {\n           \
    \     Ordering::Greater\n            } else {\n                Ordering::Equal\n\
    \            }\n        }\n    });\n    res\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpvjbvemsq.rs:31:13\n   |\n31 |             Ordering::Less\n   |     \
    \        ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed to\
    \ resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpvjbvemsq.rs:33:13\n\
    \   |\n33 |             Ordering::Greater\n   |             ^^^^^^^^ use of undeclared\
    \ type `Ordering`\n\nerror[E0433]: failed to resolve: use of undeclared type `Ordering`\n\
    \  --> /tmp/tmpvjbvemsq.rs:36:17\n   |\n36 |                 Ordering::Less\n\
    \   |                 ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpvjbvemsq.rs:38:17\n\
    \   |\n38 |                 Ordering::Greater\n   |                 ^^^^^^^^ use\
    \ of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Ordering`\n  --> /tmp/tmpvjbvemsq.rs:40:17\n   |\n40 |               \
    \  Ordering::Equal\n   |                 ^^^^^^^^ use of undeclared type `Ordering`\n\
    \nerror: aborting due to 5 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.is_empty() {\n        return vec![];\n    }\n    let mut x_positions:\
    \ Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                x_positions.push((i as isize, j as isize));\n         \
    \   }\n        }\n    }\n    x_positions.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    let mut x_positions_sorted: Vec<(isize, isize)> = Vec::new();\n    let mut\
    \ last_row: Option<isize> = None;\n    for (i, j) in x_positions {\n        if\
    \ last_row.is_none() || i > last_row.unwrap() {\n            x_positions_sorted.extend(x_positions_sorted.drain(..).rev());\n\
    \            last_row = Some(i);\n        }\n        x_positions_sorted.push((i,\
    \ j));\n    }\n    x_positions_sorted.extend(x_positions_sorted.drain(..).rev());\n\
    \    x_positions_sorted\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0499]: cannot borrow `x_positions_sorted` as mutable more than once\
    \ at a time\n  --> /tmp/tmp9bin4u2t.rs:34:39\n   |\n34 |             x_positions_sorted.extend(x_positions_sorted.drain(..).rev());\n\
    \   |             --------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^-------\n\
    \   |             |                  |      |\n   |             |            \
    \      |      second mutable borrow occurs here\n   |             |          \
    \        first borrow later used by call\n   |             first mutable borrow\
    \ occurs here\n   |\nhelp: try adding a local storing this argument...\n  -->\
    \ /tmp/tmp9bin4u2t.rs:34:39\n   |\n34 |             x_positions_sorted.extend(x_positions_sorted.drain(..).rev());\n\
    \   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp:\
    \ ...and then using that local as the argument to this call\n  --> /tmp/tmp9bin4u2t.rs:34:13\n\
    \   |\n34 |             x_positions_sorted.extend(x_positions_sorted.drain(..).rev());\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0499]: cannot borrow `x_positions_sorted` as mutable more than once at\
    \ a time\n  --> /tmp/tmp9bin4u2t.rs:39:31\n   |\n39 |     x_positions_sorted.extend(x_positions_sorted.drain(..).rev());\n\
    \   |     --------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^-------\n   |\
    \     |                  |      |\n   |     |                  |      second mutable\
    \ borrow occurs here\n   |     |                  first borrow later used by call\n\
    \   |     first mutable borrow occurs here\n   |\nhelp: try adding a local storing\
    \ this argument...\n  --> /tmp/tmp9bin4u2t.rs:39:31\n   |\n39 |     x_positions_sorted.extend(x_positions_sorted.drain(..).rev());\n\
    \   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: ...and\
    \ then using that local as the argument to this call\n  --> /tmp/tmp9bin4u2t.rs:39:5\n\
    \   |\n39 |     x_positions_sorted.extend(x_positions_sorted.drain(..).rev());\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this err"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.iter()\n        .enumerate()\n        .filter_map(|(row, l)| {\n\
    \            l.iter()\n                .enumerate()\n                .filter_map(|(col,\
    \ &el)| if el == x { Some((row as isize, col as isize)) } else { None })\n   \
    \     })\n        .collect::<Vec<(isize, isize)>>()\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk9x8ubna.rs:21:13\n   |\n\
    21 | /             l.iter()\n22 | |                 .enumerate()\n23 | |     \
    \            .filter_map(|(col, &el)| if el == x { Some((row as isize, col as\
    \ isize)) } else { None })\n   | |_________________________________________________________________________________________________________^\
    \ expected enum `Option`, found struct `FilterMap`\n   |\n   = note: expected\
    \ enum `Option<_>`\n            found struct `FilterMap<Enumerate<std::slice::Iter<'_,\
    \ isize>>, [closure@/tmp/tmpk9x8ubna.rs:23:29: 23:105]>`\nhelp: try wrapping the\
    \ expression in `Some`\n   |\n21 ~             Some(l.iter()\n22 |           \
    \      .enumerate()\n23 ~                 .filter_map(|(col, &el)| if el == x\
    \ { Some((row as isize, col as isize)) } else { None }))\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut out = vec![];\n    for (i, row) in lst.iter().enumerate() {\n\
    \        for (j, &x1) in row.iter().enumerate() {\n            if x1 == x {\n\
    \                out.push((i as isize, j as isize));\n            }\n        }\n\
    \    }\n    out.sort_by(|a, b| a.1.cmp(&b.1).reverse().then(a.0.cmp(&b.0)));\n\
    \    out\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmpw1fkwlqp.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = vec![];\n    let mut counter: isize\
    \ = 0;\n    for i in lst {\n        let mut col_counter: isize = 0;\n        for\
    \ j in i {\n            if j == x {\n                result.push((counter, col_counter));\n\
    \            }\n            col_counter += 1;\n        }\n        counter += 1;\n\
    \    }\n    result.sort_by(|a, b| {\n        let (ref y1, ref x1) = *a;\n    \
    \    let (ref y2, ref x2) = *b;\n        y1.cmp(y2).then(x2.cmp(x1))\n    });\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = vec![];\n    for (i, item) in lst.iter().enumerate()\
    \ {\n        for (j, elem) in item.iter().enumerate() {\n            if *elem\
    \ == x {\n                result.push((i as isize, j as isize));\n           \
    \ }\n        }\n    }\n    result.sort_by(|a, b| (a.0, -a.1).cmp(&(b.0, -b.1)));\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = Vec::new();\n    for (index, row)\
    \ in lst.iter().enumerate() {\n        for (item_index, item) in row.iter().enumerate()\
    \ {\n            if *item == x {\n                result.push((index as isize,\
    \ item_index as isize));\n            }\n        }\n    }\n    result.sort_by(|a,\
    \ b| {\n        if a.0 == b.0 {\n            b.1.cmp(&a.1)\n        } else {\n\
    \            a.0.cmp(&b.0)\n        }\n    });\n    result\n}\n\nfn main() {\n\
    \    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut coords: Vec<(isize, isize)> = vec![];\n    let mut r = 0;\n \
    \   for row in lst {\n        let mut c = 0;\n        for elem in row {\n    \
    \        if elem == x {\n                coords.push((r, c));\n            }\n\
    \            c += 1;\n        }\n        r += 1;\n    }\n    // sort the coordinates\n\
    \    coords.sort_by(|a, b| a.0.cmp(&b.0).then(b.1.cmp(&a.1)));\n    coords\n}\n\
    \nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| (a.0, b.1).cmp(&(b.0, a.1)));\n    res\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in\
    \ lst.iter().enumerate() {\n        for (j, item) in row.iter().enumerate() {\n\
    \            if item == &x {\n                result.push((i as isize, j as isize));\n\
    \            }\n        }\n    }\n    result.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmptl3zl8vf.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.iter()\n        .enumerate()\n        .flat_map(|(y, row)| {\n  \
    \          row.iter()\n                .enumerate()\n                .filter(|(_,\
    \ &num)| num == x)\n                .map(move |(x, _)| (y as isize, x as isize))\n\
    \        })\n        .sorted_by(|a, b| {\n            let y = a.0.cmp(&b.0);\n\
    \            if y == std::cmp::Ordering::Equal {\n                b.1.cmp(&a.1)\n\
    \            } else {\n                y\n            }\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sorted_by` found for struct `FlatMap` in\
    \ the current scope\n  --> /tmp/tmpn6kg0eqp.rs:26:10\n   |\n26 |         .sorted_by(|a,\
    \ b| {\n   |          ^^^^^^^^^ method not found in `FlatMap<Enumerate<std::slice::Iter<'_,\
    \ Vec<isize>>>, Map<Filter<Enumerate<std::slice::Iter<'_, isize>>, [closure@/tmp/tmpn6kg0eqp.rs:23:25:\
    \ 23:45]>, [closure@/tmp/tmpn6kg0eqp.rs:24:22: 24:60]>, [closure@/tmp/tmpn6kg0eqp.rs:20:19:\
    \ 25:10]>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, elem) in row.iter().enumerate() {\n            if *elem ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        match a.0.cmp(&b.0) {\n\
    \            Ordering::Equal => b.1.cmp(&a.1),\n            Ordering::Less =>\
    \ Ordering::Less,\n            Ordering::Greater => Ordering::Greater,\n     \
    \   }\n    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n \
    \   assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmprsrk0rp3.rs:28:13\n   |\n28 |             Ordering::Equal => b.1.cmp(&a.1),\n\
    \   |             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmprsrk0rp3.rs:29:13\n\
    \   |\n29 |             Ordering::Less => Ordering::Less,\n   |             ^^^^^^^^\
    \ use of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `Ordering`\n  --> /tmp/tmprsrk0rp3.rs:29:31\n   |\n29 |    \
    \         Ordering::Less => Ordering::Less,\n   |                            \
    \   ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `Ordering`\n  --> /tmp/tmprsrk0rp3.rs:30:13\n   |\n30\
    \ |             Ordering::Greater => Ordering::Greater,\n   |             ^^^^^^^^\
    \ use of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `Ordering`\n  --> /tmp/tmprsrk0rp3.rs:30:34\n   |\n30 |    \
    \         Ordering::Greater => Ordering::Greater,\n   |                      \
    \            ^^^^^^^^ use of undeclared type `Ordering`\n\nerror: aborting due\
    \ to 5 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = Vec::new();\n    for (row, a_row)\
    \ in lst.iter().enumerate() {\n        for (col, a_col) in a_row.iter().enumerate()\
    \ {\n            if x == *a_col {\n                result.push((row as isize,\
    \ col as isize));\n            }\n        }\n    }\n    result.sort_by(|a, b|\
    \ (a.0, -a.1).cmp(&(b.0, -b.1)));\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.iter()\n        .enumerate()\n        .flat_map(|(i, r)| {\n    \
    \        r.iter()\n                .enumerate()\n                .filter(|&(_,\
    \ &e)| e == x)\n                .map(|(j, _)| (i as isize, j as isize))\n    \
    \    })\n        .collect()\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0373]: closure may outlive the current function, but it borrows\
    \ `i`, which is owned by the current function\n  --> /tmp/tmp3n5tu5ui.rs:24:22\n\
    \   |\n24 |                 .map(|(j, _)| (i as isize, j as isize))\n   |    \
    \                  ^^^^^^^^  - `i` is borrowed here\n   |                    \
    \  |\n   |                      may outlive borrowed value `i`\n   |\nnote: closure\
    \ is returned here\n  --> /tmp/tmp3n5tu5ui.rs:21:13\n   |\n21 | /            \
    \ r.iter()\n22 | |                 .enumerate()\n23 | |                 .filter(|&(_,\
    \ &e)| e == x)\n24 | |                 .map(|(j, _)| (i as isize, j as isize))\n\
    \   | |_______________________________________________________^\nhelp: to force\
    \ the closure to take ownership of `i` (and any other referenced variables), use\
    \ the `move` keyword\n   |\n24 |                 .map(move |(j, _)| (i as isize,\
    \ j as isize))\n   |                      ++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0373`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut coords: Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                coords.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    coords.sort_by(|a, b| {\n        if a.0 != b.0 {\n    \
    \        return a.0.cmp(&b.0);\n        }\n        b.1.cmp(&a.1)\n    });\n  \
    \  coords\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut s: Vec<(isize, isize)> = Vec::new();\n    for i in 0..lst.len()\
    \ {\n        for j in 0..lst[i].len() {\n            if lst[i][j] == x {\n   \
    \             s.push((i as isize, j as isize));\n            }\n        }\n  \
    \  }\n    s.sort_by(|&(_, a), &(_, b)| b.cmp(&a));\n    s.sort_by(|&(a, _), &(b,\
    \ _)| a.cmp(&b));\n    s\n}\n\nfn main() {\n    let candidate = get_row;\n   \
    \ assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1,\
    \ 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = vec![];\n    let mut i = 0;\n    for\
    \ row in lst {\n        let mut j = 0;\n        for col in row {\n           \
    \ if col == x {\n                res.push((i, j));\n            }\n          \
    \  j += 1;\n        }\n        i += 1;\n    }\n    let mut cmp = |a: &(isize,\
    \ isize), b: &(isize, isize)| -> std::cmp::Ordering {\n        if a.0 == b.0 {\n\
    \            b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n    \
    \    }\n    };\n    res.sort_by(cmp);\n    res\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = vec![];\n    let mut y = 0;\n    for\
    \ row in lst {\n        let mut x = 0;\n        for num in row {\n           \
    \ if num == x {\n                res.push((y, x));\n            }\n          \
    \  x += 1;\n        }\n        y += 1;\n    }\n    res.sort_by(|a, b| (a.0, -a.1).cmp(&(b.0,\
    \ -b.1)));\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]`', /tmp/tmpxdatwnhj.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = vec![];\n    let mut row = 0;\n\
    \    for i in lst {\n        let mut col = 0;\n        for j in i {\n        \
    \    if j == x {\n                result.push((row, col));\n            }\n  \
    \          col += 1;\n        }\n        row += 1;\n    }\n    result.sort_by(|a,\
    \ b| {\n        if a.0 == b.0 {\n            a.1.cmp(&b.1)\n        } else {\n\
    \            a.0.cmp(&b.0)\n        }\n    });\n    result.reverse();\n    result\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(2, 5), (2, 0), (1, 4), (1, 0), (0, 0)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmpgxq8jz_j.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, elem) in row.iter().enumerate() {\n            if *elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        if a.0 == b.0 {\n         \
    \   b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n  \
    \  });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, el) in row.iter().enumerate() {\n            if *el == x\
    \ {\n                res.push((i as isize, j as isize));\n            }\n    \
    \    }\n    }\n    res.sort_by(|a, b| match (a.0, b.0) {\n        (x, y) if x\
    \ == y => b.1.cmp(&a.1),\n        (x, y) => x.cmp(&y),\n    });\n    res\n}\n\n\
    fn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    // sort by row and column\n    let mut res: Vec<(isize, isize)> = Vec::new();\n\
    \    for (row, sub_list) in lst.iter().enumerate() {\n        for (col, num) in\
    \ sub_list.iter().enumerate() {\n            if *num == x {\n                res.push((row\
    \ as isize, col as isize));\n            }\n        }\n    }\n    res.sort_by(|a,\
    \ b| {\n        if a.0 == b.0 {\n            b.1.cmp(&a.1)\n        } else {\n\
    \            a.0.cmp(&b.0)\n        }\n    });\n    res\n}\n\nfn main() {\n  \
    \  let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.iter()\n        .enumerate()\n        .flat_map(|(y, v)| {\n    \
    \        v.iter()\n                .enumerate()\n                .filter(|&(_,\
    \ &i)| i == x)\n                .map(move |(x, _)| (y as isize, x as isize))\n\
    \        })\n        .sorted_by(|&(y, x), &(y1, x1)| {\n            let ycmp =\
    \ y.cmp(&y1);\n            if ycmp == Ordering::Equal {\n                return\
    \ x1.cmp(&x);\n            }\n            ycmp\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmp3pb7dkp8.rs:28:24\n   |\n28 |             if ycmp == Ordering::Equal\
    \ {\n   |                        ^^^^^^^^ use of undeclared type `Ordering`\n\n\
    error[E0599]: no method named `sorted_by` found for struct `FlatMap` in the current\
    \ scope\n  --> /tmp/tmp3pb7dkp8.rs:26:10\n   |\n26 |         .sorted_by(|&(y,\
    \ x), &(y1, x1)| {\n   |          ^^^^^^^^^ method not found in `FlatMap<Enumerate<std::slice::Iter<'_,\
    \ Vec<isize>>>, Map<Filter<Enumerate<std::slice::Iter<'_, isize>>, [closure@/tmp/tmp3pb7dkp8.rs:23:25:\
    \ 23:42]>, [closure@/tmp/tmp3pb7dkp8.rs:24:22: 24:60]>, [closure@/tmp/tmp3pb7dkp8.rs:20:19:\
    \ 25:10]>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0433, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.iter()\n        .enumerate()\n        .map(|(i, arr)| arr.iter().enumerate().filter(|&(_,\
    \ &v)| v == x))\n        .flat_map(|v| v)\n        .map(|(j, _)| (i as isize,\
    \ j as isize))\n        .collect()\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpbdvt3w_x.rs:22:24\n\
    \   |\n22 |         .map(|(j, _)| (i as isize, j as isize))\n   |            \
    \            ^ help: a local variable with a similar name exists: `j`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = Vec::new();\n    let mut row_index\
    \ = 0;\n    for row in lst {\n        let mut col_index = 0;\n        for col\
    \ in row {\n            if col == x {\n                result.push((row_index,\
    \ col_index));\n            }\n            col_index += 1;\n        }\n      \
    \  row_index += 1;\n    }\n    result.sort_by(|&a, &b| {\n        let &(row_a,\
    \ col_a) = a;\n        let &(row_b, col_b) = b;\n        if row_a == row_b {\n\
    \            col_b.cmp(&col_a)\n        } else {\n            row_a.cmp(&row_b)\n\
    \        }\n    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_pe8trzt.rs:31:13\n   |\n\
    31 |         let &(row_a, col_a) = a;\n   |             ^^^^^^^^^^^^^^^   - this\
    \ expression has type `(isize, isize)`\n   |             |\n   |             expected\
    \ tuple, found reference\n   |\n   = note:  expected tuple `(isize, isize)`\n\
    \           found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_pe8trzt.rs:32:13\n\
    \   |\n32 |         let &(row_b, col_b) = b;\n   |             ^^^^^^^^^^^^^^^\
    \   - this expression has type `(isize, isize)`\n   |             |\n   |    \
    \         expected tuple, found reference\n   |\n   = note:  expected tuple `(isize,\
    \ isize)`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, v) in row.iter().enumerate() {\n            if v == &x {\n\
    \                result.push((i as isize, j as isize));\n            }\n     \
    \   }\n    }\n    result.sort_by(|a, b| if a.0 == b.0 { b.1.cmp(&a.1) } else {\
    \ a.0.cmp(&b.0) });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row_indices = lst\n        .iter()\n        .enumerate()\n  \
    \      .map(|(i, row)| {\n            row.iter()\n                .enumerate()\n\
    \                .filter(|(_, &value)| value == x)\n                .map(|(j,\
    \ _)| (i as isize, j as isize))\n                .collect::<Vec<(isize, isize)>>()\n\
    \        })\n        .collect::<Vec<Vec<(isize, isize)>>>();\n    row_indices.retain(|v|\
    \ !v.is_empty());\n    row_indices.sort_by(|x, y| {\n        if x[0].0 < y[0].0\
    \ {\n            Ordering::Less\n        } else if x[0].0 > y[0].0 {\n       \
    \     Ordering::Greater\n        } else {\n            if x[0].1 > y[0].1 {\n\
    \                Ordering::Less\n            } else if x[0].1 < y[0].1 {\n   \
    \             Ordering::Greater\n            } else {\n                Ordering::Equal\n\
    \            }\n        }\n    });\n    row_indices.iter().flat_map(|v| v.iter()).cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpwl267eyz.rs:32:13\n   |\n32 |             Ordering::Less\n   |     \
    \        ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed to\
    \ resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpwl267eyz.rs:34:13\n\
    \   |\n34 |             Ordering::Greater\n   |             ^^^^^^^^ use of undeclared\
    \ type `Ordering`\n\nerror[E0433]: failed to resolve: use of undeclared type `Ordering`\n\
    \  --> /tmp/tmpwl267eyz.rs:37:17\n   |\n37 |                 Ordering::Less\n\
    \   |                 ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpwl267eyz.rs:39:17\n\
    \   |\n39 |                 Ordering::Greater\n   |                 ^^^^^^^^ use\
    \ of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Ordering`\n  --> /tmp/tmpwl267eyz.rs:41:17\n   |\n41 |               \
    \  Ordering::Equal\n   |                 ^^^^^^^^ use of undeclared type `Ordering`\n\
    \nerror: aborting due to 5 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    // TODO\n    let mut ret = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &el) in row.iter().enumerate() {\n            if el == x\
    \ {\n                ret.push((i as isize, j as isize));\n            }\n    \
    \    }\n    }\n    ret.sort_by(|a, b| {\n        let (row1, col1) = *a;\n    \
    \    let (row2, col2) = *b;\n        if row1 == row2 {\n            col2.cmp(&col1)\n\
    \        } else {\n            row1.cmp(&row2)\n        }\n    });\n    ret\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = Vec::new();\n    for i in 0..lst.len()\
    \ {\n        for j in 0..lst[i].len() {\n            if lst[i][j] == x {\n   \
    \             result.push((i as isize, j as isize));\n            }\n        }\n\
    \    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n            b.1.cmp(&a.1)\n\
    \        } else {\n            a.0.cmp(&b.0)\n        }\n    });\n    result\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = vec![];\n    if lst.len() == 0 {\n\
    \        return res;\n    }\n    let mut row = 0;\n    for i in lst {\n      \
    \  let mut col = 0;\n        for j in i {\n            if j == x {\n         \
    \       res.push((row, col));\n            }\n            col += 1;\n        }\n\
    \        row += 1;\n    }\n    return res;\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmp7d9zo5g1.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut ret = vec![];\n    for (ri, row) in lst.iter().enumerate() {\n\
    \        for (ci, &item) in row.iter().enumerate() {\n            if item == x\
    \ {\n                ret.push((ri as isize, ci as isize));\n            }\n  \
    \      }\n    }\n    ret.sort_by(|&(_, a), &(_, b)| b.cmp(&a));\n    ret.sort_by(|&(a,\
    \ _), &(b, _)| a.cmp(&b));\n    ret\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rtn: Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, num) in row.iter().enumerate() {\n            if *num ==\
    \ x {\n                rtn.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    // sort by column\n    rtn.sort_by(|a, b| (a.1).cmp(&b.1));\n\
    \    // sort by row\n    rtn.sort_by(|a, b| (a.0).cmp(&b.0));\n    rtn\n}\n\n\
    fn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmp3t4n_a36.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    //let mut res: Vec<(isize, isize)> = vec![];\n    let res: Vec<(isize,\
    \ isize)> = lst.iter()\n        .enumerate()\n        .map(|(i, v)| {\n      \
    \      v.iter()\n                .enumerate()\n                .filter(|&(_, n)|\
    \ n == &x)\n                .map(|(j, _)| (i as isize, j as isize))\n        \
    \        .collect::<Vec<(isize, isize)>>()\n        })\n        .flat_map(|x|\
    \ x)\n        .collect();\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmpl967e8t0.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.is_empty() {\n        return vec![];\n    }\n    lst.iter()\n\
    \        .enumerate()\n        .flat_map(|(i, row)| {\n            row.iter()\n\
    \                .enumerate()\n                .filter(|(_, &y)| y == x)\n   \
    \             .map(move |(j, _)| (i as isize, j as isize))\n        })\n     \
    \   .collect()\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmpj7stppc8.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = Vec::new();\n    for (i, v) in lst.iter().enumerate()\
    \ {\n        for (j, e) in v.iter().enumerate() {\n            if *e == x {\n\
    \                res.push((i as isize, j as isize));\n            }\n        }\n\
    \    }\n    res.sort_by(|a, b| {\n        match (a.0).cmp(&b.0) {\n          \
    \  Ordering::Equal => {\n                match (b.1).cmp(&a.1) {\n           \
    \         Ordering::Equal => Ordering::Equal,\n                    Ordering::Greater\
    \ => Ordering::Greater,\n                    Ordering::Less => Ordering::Less,\n\
    \                }\n            }\n            Ordering::Greater => Ordering::Greater,\n\
    \            Ordering::Less => Ordering::Less,\n        }\n    });\n    res\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmph_yqg6y8.rs:28:13\n   |\n28 |             Ordering::Equal => {\n   |\
    \             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmph_yqg6y8.rs:30:21\n\
    \   |\n30 |                     Ordering::Equal => Ordering::Equal,\n   |    \
    \                 ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmph_yqg6y8.rs:30:40\n\
    \   |\n30 |                     Ordering::Equal => Ordering::Equal,\n   |    \
    \                                    ^^^^^^^^ use of undeclared type `Ordering`\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmph_yqg6y8.rs:31:21\n\
    \   |\n31 |                     Ordering::Greater => Ordering::Greater,\n   |\
    \                     ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmph_yqg6y8.rs:31:42\n\
    \   |\n31 |                     Ordering::Greater => Ordering::Greater,\n   |\
    \                                          ^^^^^^^^ use of undeclared type `Ordering`\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmph_yqg6y8.rs:32:21\n\
    \   |\n32 |                     Ordering::Less => Ordering::Less,\n   |      \
    \               ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmph_yqg6y8.rs:32:39\n\
    \   |\n32 |                     Ordering::Less => Ordering::Less,\n   |      \
    \                                 ^^^^^^^^ use of undeclared type `Ordering`\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmph_yqg6y8.rs:35:13\n\
    \   |\n35 |             Ordering::Greater => Ordering::Greater,\n   |        \
    \     ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `Ordering`\n  --> /tmp/tmph_yqg6y8.rs:35:34\n   |\n35\
    \ |             Ordering::Greater => Ordering::Great"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = Vec::new();\n    for (index, arr)\
    \ in lst.iter().enumerate() {\n        let mut rev = arr.clone();\n        rev.reverse();\n\
    \        for (index2, i) in rev.iter().enumerate() {\n            if *i == x {\n\
    \                res.push((index as isize, arr.len() as isize - index2 as isize\
    \ - 1))\n            }\n        }\n    }\n    res.sort_by(|a, b| a.0.cmp(&b.0).then(b.1.cmp(&a.1)));\n\
    \    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.iter()\n        .enumerate()\n        .map(|(i, r)| r.iter().enumerate().filter(|(_,\
    \ a)| **a == x))\n        .flat_map(|e| e)\n        .map(|(i, _)| (i as isize,\
    \ i as isize))\n        .collect()\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(0, 0), (0, 0), (4, 4), (0, 0), (5, 5)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmp9bt4vvi7.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, elem) in row.iter().enumerate() {\n            if *elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        let row_a = a.0;\n        let\
    \ row_b = b.0;\n        let col_a = a.1;\n        let col_b = b.1;\n        match\
    \ row_a.cmp(&row_b) {\n            Ordering::Less => Ordering::Less,\n       \
    \     Ordering::Greater => Ordering::Greater,\n            Ordering::Equal =>\
    \ col_b.cmp(&col_a),\n        }\n    });\n    res\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpxo4t65yj.rs:32:13\n   |\n32 |             Ordering::Less => Ordering::Less,\n\
    \   |             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpxo4t65yj.rs:32:31\n\
    \   |\n32 |             Ordering::Less => Ordering::Less,\n   |              \
    \                 ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpxo4t65yj.rs:33:13\n\
    \   |\n33 |             Ordering::Greater => Ordering::Greater,\n   |        \
    \     ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `Ordering`\n  --> /tmp/tmpxo4t65yj.rs:33:34\n   |\n33\
    \ |             Ordering::Greater => Ordering::Greater,\n   |                \
    \                  ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpxo4t65yj.rs:34:13\n\
    \   |\n34 |             Ordering::Equal => col_b.cmp(&col_a),\n   |          \
    \   ^^^^^^^^ use of undeclared type `Ordering`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 < b.0 {\n     \
    \       std::cmp::Ordering::Less\n        } else if a.0 > b.0 {\n            std::cmp::Ordering::Greater\n\
    \        } else {\n            a.1.cmp(&b.1).reverse()\n        }\n    });\n \
    \   result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.iter()\n        .enumerate()\n        .flat_map(|(i, row)| {\n  \
    \          row.iter()\n                .enumerate()\n                .filter(|(_,\
    \ &n)| n == x)\n                .map(move |(j, _)| (i as isize, j as isize))\n\
    \        })\n        .sorted_by(|(i1, j1), (i2, j2)| match i1.cmp(i2) {\n    \
    \        Ordering::Equal => j2.cmp(j1),\n            other => other,\n       \
    \ })\n        .collect()\n}\n\nfn main() {\n    let candidate = get_row;\n   \
    \ assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1,\
    \ 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpkladqpxh.rs:27:13\n   |\n27 |             Ordering::Equal => j2.cmp(j1),\n\
    \   |             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0599]:\
    \ no method named `sorted_by` found for struct `FlatMap` in the current scope\n\
    \  --> /tmp/tmpkladqpxh.rs:26:10\n   |\n26 |         .sorted_by(|(i1, j1), (i2,\
    \ j2)| match i1.cmp(i2) {\n   |          ^^^^^^^^^ method not found in `FlatMap<Enumerate<std::slice::Iter<'_,\
    \ Vec<isize>>>, Map<Filter<Enumerate<std::slice::Iter<'_, isize>>, [closure@/tmp/tmpkladqpxh.rs:23:25:\
    \ 23:41]>, [closure@/tmp/tmpkladqpxh.rs:24:22: 24:60]>, [closure@/tmp/tmpkladqpxh.rs:20:19:\
    \ 25:10]>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0433, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut vec: Vec<(isize, isize)> = Vec::new();\n    let mut y = 0;\n\
    \    for row in lst {\n        let mut ind = 0;\n        for item in row {\n \
    \           if item == x {\n                vec.push((y, ind));\n            }\n\
    \            ind += 1;\n        }\n        y += 1;\n    }\n    vec.sort_by(|&a,\
    \ &b| (a.0, -a.1).cmp(&(b.0, -b.1)));\n    vec\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = Vec::new();\n    let mut iter = 0;\n\
    \    for x in lst {\n        let mut iter2 = 0;\n        for x2 in x {\n     \
    \       if x2 == x {\n                res.push((iter, iter2));\n            }\n\
    \            iter2 += 1;\n        }\n        iter += 1;\n    }\n    res.sort_by(|a,\
    \ b| a.1.cmp(&b.1));\n    res.sort_by(|a, b| a.0.cmp(&b.0));\n    res\n}\n\nfn\
    \ main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp69qszv15.rs:23:22\n   |\n\
    23 |             if x2 == x {\n   |                      ^ expected `isize`, found\
    \ struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct\
    \ `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = Vec::new();\n    for (i, v) in\
    \ lst.iter().enumerate() {\n        for (j, vv) in v.iter().enumerate() {\n  \
    \          if *vv == x {\n                result.push((i as isize, j as isize));\n\
    \            }\n        }\n    }\n    result.sort_by(|a, b| match a.0.cmp(&b.0)\
    \ {\n        Ordering::Equal => b.1.cmp(&a.1),\n        r => r,\n    });\n   \
    \ result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpirwosqmr.rs:27:9\n   |\n27 |         Ordering::Equal => b.1.cmp(&a.1),\n\
    \   |         ^^^^^^^^ use of undeclared type `Ordering`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.iter()\n        .enumerate()\n        .map(|(y, row)| row.iter().enumerate().filter(|(_,\
    \ z)| **z == x))\n        .flatten()\n        .map(|(z, _)| (y as isize, z as\
    \ isize))\n        .collect()\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `y` in this scope\n  --> /tmp/tmpc8x5kcdw.rs:22:24\n\
    \   |\n22 |         .map(|(z, _)| (y as isize, z as isize))\n   |            \
    \            ^ help: a local variable with a similar name exists: `x`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.iter()\n        .enumerate()\n        .filter_map(|(i, r)| {\n  \
    \          let j = r.iter().position(|&c| c == x);\n            j.map(|j| (i as\
    \ isize, j as isize))\n        })\n        .sorted_by(|&(i1, j1), &(i2, j2)| {\n\
    \            if i1 < i2 {\n                Ordering::Less\n            } else\
    \ if i1 > i2 {\n                Ordering::Greater\n            } else {\n    \
    \            j2.cmp(&j1)\n            }\n        })\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmp7w_78y2_.rs:26:17\n   |\n26 |                 Ordering::Less\n   | \
    \                ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmp7w_78y2_.rs:28:17\n\
    \   |\n28 |                 Ordering::Greater\n   |                 ^^^^^^^^ use\
    \ of undeclared type `Ordering`\n\nerror[E0599]: no method named `sorted_by` found\
    \ for struct `FilterMap` in the current scope\n  --> /tmp/tmp7w_78y2_.rs:24:10\n\
    \   |\n24 |         .sorted_by(|&(i1, j1), &(i2, j2)| {\n   |          ^^^^^^^^^\
    \ method not found in `FilterMap<Enumerate<std::slice::Iter<'_, Vec<isize>>>,\
    \ [closure@/tmp/tmp7w_78y2_.rs:20:21: 23:10]>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    // Your code goes here\n    lst.iter()\n        .enumerate()\n      \
    \  .map(|(i, v)| {\n            v.iter()\n                .enumerate()\n     \
    \           .filter(|(_, &y)| y == x)\n                .map(|(j, _)| (i as isize,\
    \ j as isize))\n                .collect::<Vec<(isize, isize)>>()\n        })\n\
    \        .flatten()\n        .collect::<Vec<(isize, isize)>>()\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmp09vtj972.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.iter()\n        .enumerate()\n        .map(|(i, line)| {\n      \
    \      line.iter()\n                .rev()\n                .enumerate()\n   \
    \             .filter(|(_, &n)| n == x)\n                .map(|(j, _)| (i as isize,\
    \ j as isize))\n                .collect::<Vec<(isize, isize)>>()\n        })\n\
    \        .flatten()\n        .collect()\n}\n\nfn main() {\n    let candidate =\
    \ get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(0, 5), (1, 1), (1, 5), (2, 0), (2, 5)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmphq3ir7ag.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if item ==\
    \ &x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in\
    \ lst.iter().enumerate() {\n        for (j, e) in row.iter().enumerate() {\n \
    \           if *e == x {\n                result.push((i as isize, j as isize));\n\
    \            }\n        }\n    }\n    result.sort_by(|a, b| {\n        let (x1,\
    \ y1) = *a;\n        let (x2, y2) = *b;\n        (x1, -y1).cmp(&(x2, -y2))\n \
    \   });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    // implement the function here\n    let mut result: Vec<(isize, isize)>\
    \ = Vec::new();\n    let mut row_count = 0;\n    for row in lst {\n        let\
    \ mut col_count = 0;\n        for col in row {\n            if col == x {\n  \
    \              result.push((row_count, col_count));\n            }\n         \
    \   col_count += 1;\n        }\n        row_count += 1;\n    }\n    result.sort_by(|x,\
    \ y| {\n        x.0.cmp(&y.0).then(y.1.cmp(&x.1))\n    });\n    result\n}\n\n\
    fn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut lst: Vec<(isize, isize)> = Vec::new();\n    for (i, j) in lst.iter().enumerate()\
    \ {\n        for (k, l) in j.iter().enumerate() {\n            if *l == x {\n\
    \                lst.push((i as isize, k as isize));\n            }\n        }\n\
    \    }\n    lst.sort_by(|&(i, j), &(k, l)| {\n        if i == k {\n          \
    \  Ord::cmp(&l, &j)\n        } else {\n            Ord::cmp(&i, &k)\n        }\n\
    \    });\n    lst\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for reference `&(isize, isize)`\
    \ in the current scope\n  --> /tmp/tmpa7l4gfc7.rs:20:25\n   |\n20 |         for\
    \ (k, l) in j.iter().enumerate() {\n   |                         ^^^^ method not\
    \ found in `&(isize, isize)`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in\
    \ lst.iter().enumerate() {\n        for (j, num) in row.iter().enumerate() {\n\
    \            if *num == x {\n                result.push((i as isize, j as isize));\n\
    \            }\n        }\n    }\n    result.sort_by(|a, b| {\n        if a.0\
    \ == b.0 {\n            b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n\
    \        }\n    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.is_empty() {\n        return vec![];\n    }\n    let mut counter\
    \ = 0;\n    let mut result = vec![];\n    let mut row_counter = 0;\n    for row\
    \ in lst {\n        let mut col_counter = 0;\n        for col in row {\n     \
    \       if col == x {\n                result.push((row_counter, col_counter));\n\
    \            }\n            col_counter += 1;\n        }\n        row_counter\
    \ += 1;\n    }\n    result.sort_by(|a, b| {\n        if a.0 < b.0 {\n        \
    \    return std::cmp::Ordering::Less;\n        } else if a.0 > b.0 {\n       \
    \     return std::cmp::Ordering::Greater;\n        } else {\n            if a.1\
    \ < b.1 {\n                return std::cmp::Ordering::Greater;\n            }\
    \ else if a.1 > b.1 {\n                return std::cmp::Ordering::Less;\n    \
    \        } else {\n                return std::cmp::Ordering::Equal;\n       \
    \     }\n        }\n    });\n    result\n}\n\nfn main() {\n    let candidate =\
    \ get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = vec![];\n    for (i, v) in lst.iter().enumerate()\
    \ {\n        for (j, val) in v.iter().enumerate() {\n            if *val == x\
    \ {\n                res.push((i as isize, j as isize));\n            }\n    \
    \    }\n    }\n    res.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    res\n}\n\
    \nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmputztnos8.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = Vec::new();\n    for (idx, item) in\
    \ lst.iter().enumerate() {\n        for (idx2, item2) in item.iter().enumerate()\
    \ {\n            if item2 == &x {\n                res.push((idx as isize, idx2\
    \ as isize));\n            }\n        }\n    }\n    res.sort_by(|a, b| (a.0, b.1).cmp(&(b.0,\
    \ a.1)));\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    // your code\n    let mut result: Vec<(isize, isize)> = Vec::new();\n\
    \    for (y, row) in lst.iter().enumerate() {\n        for (x, _) in row.iter().enumerate()\
    \ {\n            if row[x] == x as isize {\n                result.push((y as\
    \ isize, x as isize));\n            }\n        }\n    }\n    result.sort_by(|a,\
    \ b| a.0.cmp(&b.0).then(b.1.cmp(&a.1)));\n    result\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]`', /tmp/tmp8t6z3tek.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut ans: Vec<(isize, isize)> = vec![];\n    for (i, j) in lst.iter().enumerate()\
    \ {\n        for (u, v) in j.iter().enumerate() {\n            if *v == x {\n\
    \                ans.push((i as isize, u as isize));\n            }\n        }\n\
    \    }\n    let mut ans1 = ans.clone();\n    ans1.sort_by(|&a, &b| {\n       \
    \ if a.0 == b.0 {\n            b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n\
    \        }\n    });\n    ans1\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &y) in row.iter().enumerate() {\n            if y == x {\n\
    \                res.push((i as isize, j as isize));\n            }\n        }\n\
    \    }\n    res.sort_by(|a, b| {\n        if a.0 < b.0 {\n            std::cmp::Ordering::Less\n\
    \        } else if a.0 > b.0 {\n            std::cmp::Ordering::Greater\n    \
    \    } else {\n            b.1.cmp(&a.1)\n        }\n    });\n    res\n}\n\nfn\
    \ main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = Vec::new();\n    for (i, j) in\
    \ lst.iter().enumerate() {\n        for (k, l) in j.iter().enumerate() {\n   \
    \         if *l == x {\n                result.push((i as isize, k as isize));\n\
    \            }\n        }\n    }\n    result.sort_by(|a, b| {\n        if a.0\
    \ < b.0 {\n            std::cmp::Ordering::Less\n        } else if a.0 > b.0 {\n\
    \            std::cmp::Ordering::Greater\n        } else {\n            b.1.cmp(&a.1)\n\
    \        }\n    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut ans: Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &k) in row.iter().enumerate() {\n            if k == x {\n\
    \                ans.push((i as isize, j as isize));\n            }\n        }\n\
    \    }\n    ans.sort_by(|a, b| {\n        if a.0 == b.0 {\n            b.1.cmp(&a.1)\n\
    \        } else {\n            a.0.cmp(&b.0)\n        }\n    });\n    ans\n}\n\
    \nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    // your code here\n    let mut coordinates: Vec<(isize, isize)> = Vec::new();\n\
    \    if lst.len() == 0 {\n        return coordinates;\n    }\n    for (i, row)\
    \ in lst.iter().enumerate() {\n        for (j, elem) in row.iter().enumerate()\
    \ {\n            if *elem == x {\n                coordinates.push((i as isize,\
    \ j as isize));\n            }\n        }\n    }\n    coordinates.sort_by(|a,\
    \ b| {\n        if a.0 < b.0 {\n            std::cmp::Ordering::Less\n       \
    \ } else if a.0 > b.0 {\n            std::cmp::Ordering::Greater\n        } else\
    \ {\n            if a.1 > b.1 {\n                std::cmp::Ordering::Less\n  \
    \          } else if a.1 < b.1 {\n                std::cmp::Ordering::Greater\n\
    \            } else {\n                std::cmp::Ordering::Equal\n           \
    \ }\n        }\n    });\n    coordinates\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut y = 0;\n    let mut result = Vec::new();\n    for row in lst\
    \ {\n        for (i, item) in row.iter().enumerate() {\n            if item ==\
    \ &x {\n                result.push((y, i as isize));\n            }\n       \
    \ }\n        y += 1;\n    }\n    result.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmpil_wed29.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.iter()\n        .enumerate()\n        .flat_map(|(i, v)| {\n    \
    \        v.iter()\n                .enumerate()\n                .filter(|(_,\
    \ &y)| y == x)\n                .map(move |(j, _)| (i as isize, j as isize))\n\
    \        })\n        .sorted_by(|a, b| {\n            a.0\n                .cmp(&b.0)\n\
    \                .then_with(|| b.1.cmp(&a.1))\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sorted_by` found for struct `FlatMap` in\
    \ the current scope\n  --> /tmp/tmpdi89mqi9.rs:26:10\n   |\n26 |         .sorted_by(|a,\
    \ b| {\n   |          ^^^^^^^^^ method not found in `FlatMap<Enumerate<std::slice::Iter<'_,\
    \ Vec<isize>>>, Map<Filter<Enumerate<std::slice::Iter<'_, isize>>, [closure@/tmp/tmpdi89mqi9.rs:23:25:\
    \ 23:41]>, [closure@/tmp/tmpdi89mqi9.rs:24:22: 24:60]>, [closure@/tmp/tmpdi89mqi9.rs:20:19:\
    \ 25:10]>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.iter()\n        .enumerate()\n        .flat_map(|(y, row)| {\n  \
    \          row.iter()\n                .enumerate()\n                .filter(|(_,\
    \ &n)| n == x)\n                .map(move |(x, _)| (y as isize, x as isize))\n\
    \        })\n        .sorted_by(|&(y1, x1), &(y2, x2)| {\n            y1.cmp(&y2).then_with(||\
    \ x2.cmp(&x1))\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sorted_by` found for struct `FlatMap` in\
    \ the current scope\n  --> /tmp/tmp_rzdx0en.rs:26:10\n   |\n26 |         .sorted_by(|&(y1,\
    \ x1), &(y2, x2)| {\n   |          ^^^^^^^^^ method not found in `FlatMap<Enumerate<std::slice::Iter<'_,\
    \ Vec<isize>>>, Map<Filter<Enumerate<std::slice::Iter<'_, isize>>, [closure@/tmp/tmp_rzdx0en.rs:23:25:\
    \ 23:41]>, [closure@/tmp/tmp_rzdx0en.rs:24:22: 24:60]>, [closure@/tmp/tmp_rzdx0en.rs:20:19:\
    \ 25:10]>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| a.0.cmp(&b.0).then(b.1.cmp(&a.1)));\n\
    \    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = vec![];\n    for (index_row, item_row)\
    \ in lst.iter().enumerate() {\n        for (index_col, item_col) in item_row.iter().enumerate()\
    \ {\n            if *item_col == x {\n                result.push((index_row as\
    \ isize, index_col as isize));\n            }\n        }\n    }\n    result.sort_by(|a,\
    \ b| match a.0.cmp(&b.0) {\n        Ordering::Equal => b.1.cmp(&a.1),\n      \
    \  x => x,\n    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmp63ckasle.rs:27:9\n   |\n27 |         Ordering::Equal => b.1.cmp(&a.1),\n\
    \   |         ^^^^^^^^ use of undeclared type `Ordering`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    // TODO\n    vec![]\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]`', /tmp/tmp7e5x4eqv.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, elem) in row.iter().enumerate() {\n            if *elem ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|tup1, tup2| tup1.1.cmp(&tup2.1));\n    res.sort_by(|tup1,\
    \ tup2| tup1.0.cmp(&tup2.0));\n    res\n}\n\nfn main() {\n    let candidate =\
    \ get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmp6krixve0.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = Vec::new();\n    for (i, v) in lst.iter().enumerate()\
    \ {\n        for (j, &v) in v.iter().enumerate() {\n            if v == x {\n\
    \                res.push((i as isize, j as isize));\n            }\n        }\n\
    \    }\n    res.sort_by(|a, b| a.0.cmp(&b.0).then(b.1.cmp(&a.1)));\n    res\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = Vec::new();\n    for i in 0..lst.len()\
    \ {\n        for j in 0..lst[i].len() {\n            if lst[i][j] == x {\n   \
    \             res.push((i as isize, j as isize));\n            }\n        }\n\
    \    }\n    let mut sorted = res.clone();\n    sorted.sort_by(|a, b| a.0.cmp(&b.0));\n\
    \    let mut result: Vec<(isize, isize)> = Vec::new();\n    for i in 0..sorted.len()\
    \ {\n        let mut arr: Vec<(isize, isize)> = Vec::new();\n        for j in\
    \ 0..res.len() {\n            if sorted[i].0 == res[j].0 {\n                arr.push(res[j]);\n\
    \            }\n        }\n        arr.sort_by(|a, b| b.1.cmp(&a.1));\n      \
    \  for i in 0..arr.len() {\n            result.push(arr[i]);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(0, 0), (1, 4), (1, 0), (1, 4), (1, 0), (2, 5), (2, 0), (2, 5), (2, 0)]`,\n\
    \ right: `[(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]`', /tmp/tmp6vs7wh3a.rs:46:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = Vec::new();\n    for (i, line) in\
    \ lst.iter().enumerate() {\n        for (j, &num) in line.iter().enumerate() {\n\
    \            if num == x {\n                res.push((i as isize, j as isize));\n\
    \            }\n        }\n    }\n    res.sort_by(|a, b| if a.0 == b.0 { b.1.cmp(&a.1)\
    \ } else { a.0.cmp(&b.0) });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut ret: Vec<(isize, isize)> = Vec::new();\n    for i in 0..lst.len()\
    \ {\n        for j in 0..lst[i].len() {\n            if lst[i][j] == x {\n   \
    \             ret.push((i as isize, j as isize));\n            }\n        }\n\
    \    }\n    ret.sort_by(|a, b| {\n        if a.0 == b.0 {\n            if a.1\
    \ > b.1 {\n                std::cmp::Ordering::Less\n            } else {\n  \
    \              std::cmp::Ordering::Greater\n            }\n        } else if a.0\
    \ > b.0 {\n            std::cmp::Ordering::Greater\n        } else {\n       \
    \     std::cmp::Ordering::Less\n        }\n    });\n    ret\n}\n\nfn main() {\n\
    \    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.is_empty() {\n        return vec![];\n    }\n    let mut result:\
    \ Vec<(isize, isize)> = Vec::new();\n    for (y, row) in lst.iter().enumerate()\
    \ {\n        for (x, &val) in row.iter().enumerate() {\n            if val ==\
    \ x {\n                result.push((y as isize, x as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|&(a, b), &(x, y)| a.cmp(&x).then(y.cmp(&b)));\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuux4wb7v.rs:24:23\n   |\n\
    24 |             if val == x {\n   |                       ^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n24 |             if val == x.try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.iter()\n        .enumerate()\n        .map(|(i, row)| {\n       \
    \     row.iter()\n                .enumerate()\n                .filter(|(_, v)|\
    \ **v == x)\n                .map(|(j, _)| (i as isize, j as isize))\n       \
    \         .collect::<Vec<(isize, isize)>>()\n        })\n        .flatten()\n\
    \        .collect::<Vec<(isize, isize)>>()\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmpau26xjht.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = Vec::new();\n    for i in 0..lst.len()\
    \ {\n        for j in 0..lst[i].len() {\n            if lst[i][j] == x {\n   \
    \             res.push((i as isize, j as isize));\n            }\n        }\n\
    \    }\n    res.sort_by(|a, b| a.0.cmp(&b.0).then(b.1.cmp(&a.1)));\n    res\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, y) in row.iter().enumerate() {\n            if *y == x {\n\
    \                res.push((i as isize, j as isize));\n            }\n        }\n\
    \    }\n    res.sort_by(|x, y| {\n        let s = x.0.cmp(&y.0);\n        if s\
    \ == Ordering::Equal {\n            y.1.cmp(&x.1)\n        } else {\n        \
    \    s\n        }\n    });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpm9es49q4.rs:28:17\n   |\n28 |         if s == Ordering::Equal {\n  \
    \ |                 ^^^^^^^^ use of undeclared type `Ordering`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut ans: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, num) in row.iter().enumerate() {\n            if *num ==\
    \ x {\n                ans.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    ans.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    ans\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmpk3y2bzgm.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.iter()\n        .enumerate()\n        .flat_map(|(i, v)| {\n    \
    \        v.iter()\n                .enumerate()\n                .filter(|&(_,\
    \ n)| n == &x)\n                .map(|(j, _)| (i as isize, j as isize))\n    \
    \    })\n        .sorted_by(|&(r1, c1), &(r2, c2)| match r1.cmp(&r2) {\n     \
    \       Ordering::Equal => c2.cmp(&c1),\n            other => other,\n       \
    \ })\n        .collect()\n}\n\nfn main() {\n    let candidate = get_row;\n   \
    \ assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1,\
    \ 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmp6ty7xf9a.rs:27:13\n   |\n27 |             Ordering::Equal => c2.cmp(&c1),\n\
    \   |             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0599]:\
    \ no method named `sorted_by` found for struct `FlatMap` in the current scope\n\
    \  --> /tmp/tmp6ty7xf9a.rs:26:10\n   |\n26 |         .sorted_by(|&(r1, c1), &(r2,\
    \ c2)| match r1.cmp(&r2) {\n   |          ^^^^^^^^^ method not found in `FlatMap<Enumerate<std::slice::Iter<'_,\
    \ Vec<isize>>>, Map<Filter<Enumerate<std::slice::Iter<'_, isize>>, [closure@/tmp/tmp6ty7xf9a.rs:23:25:\
    \ 23:42]>, [closure@/tmp/tmp6ty7xf9a.rs:24:22: 24:55]>, [closure@/tmp/tmp6ty7xf9a.rs:20:19:\
    \ 25:10]>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0433, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.is_empty() {\n        return vec![];\n    }\n    let mut ret =\
    \ vec![];\n    for i in 0..lst.len() {\n        for j in 0..lst[i].len() {\n \
    \           if lst[i][j] == x {\n                ret.push((i as isize, j as isize));\n\
    \            }\n        }\n    }\n    ret.sort_by(|a, b| a.0.cmp(&b.0).then(b.1.cmp(&a.1)));\n\
    \    ret\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut lst = lst;\n    lst.iter_mut()\n        .enumerate()\n      \
    \  .map(|(i, row)| {\n            row.iter()\n                .enumerate()\n \
    \               .filter(|&(_, &el)| el == x)\n                .map(|(j, _)| (i\
    \ as isize, j as isize))\n                .collect::<Vec<(isize, isize)>>()\n\
    \        })\n        .flatten()\n        .collect::<Vec<(isize, isize)>>()\n}\n\
    \nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmpznrtr3vs.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.is_empty() {\n        return vec![];\n    }\n    let mut res:\
    \ Vec<(isize, isize)> = vec![];\n    for (y, xs) in lst.iter().enumerate() {\n\
    \        for (x2, v) in xs.iter().enumerate() {\n            if *v == x {\n  \
    \              res.push((y as isize, x2 as isize));\n            }\n        }\n\
    \    }\n    res.sort_by(|a, b| {\n        if a.0 < b.0 {\n            Ordering::Less\n\
    \        } else if a.0 > b.0 {\n            Ordering::Greater\n        } else\
    \ {\n            b.1.cmp(&a.1)\n        }\n    });\n    res\n}\n\nfn main() {\n\
    \    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmp1ilyemvb.rs:31:13\n   |\n31 |             Ordering::Less\n   |     \
    \        ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed to\
    \ resolve: use of undeclared type `Ordering`\n  --> /tmp/tmp1ilyemvb.rs:33:13\n\
    \   |\n33 |             Ordering::Greater\n   |             ^^^^^^^^ use of undeclared\
    \ type `Ordering`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    // Write your code here\n    let mut result: Vec<(isize, isize)> = Vec::new();\n\
    \    let mut count: isize = 0;\n    for i in 0..lst.len() {\n        for j in\
    \ 0..lst[i].len() {\n            if lst[i][j] == x {\n                result.push((i\
    \ as isize, j as isize));\n            }\n        }\n    }\n    result.sort_by(|a,\
    \ b| {\n        let a = (a.0, -a.1);\n        let b = (b.0, -b.1);\n        a.cmp(&b)\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in\
    \ lst.iter().enumerate() {\n        for (j, col) in row.iter().enumerate() {\n\
    \            if *col == x {\n                result.push((i as isize, j as isize));\n\
    \            }\n        }\n    }\n    result.sort_by(|a, b| {\n        let res\
    \ = a.0.cmp(&b.0);\n        if res == std::cmp::Ordering::Equal {\n          \
    \  b.1.cmp(&a.1)\n        } else {\n            res\n        }\n    });\n    result\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.iter()\n        .enumerate()\n        .flat_map(|(r, row)| {\n  \
    \          row.iter()\n                .enumerate()\n                .filter(|&(_,\
    \ c)| c == &x)\n                .map(move |(c, _)| (r as isize, c as isize))\n\
    \        })\n        .collect()\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmpd7zwbojk.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.is_empty() {\n        return vec![];\n    }\n    let mut res:\
    \ Vec<(isize, isize)> = Vec::new();\n    for (y, row) in lst.iter().enumerate()\
    \ {\n        for (x1, col) in row.iter().enumerate() {\n            if *col ==\
    \ x {\n                res.push((y as isize, x1 as isize));\n            }\n \
    \       }\n    }\n    res.sort_by(|a, b| {\n        if a.0 < b.0 {\n         \
    \   return Ordering::Less;\n        }\n        if a.0 > b.0 {\n            return\
    \ Ordering::Greater;\n        }\n        if a.1 > b.1 {\n            return Ordering::Less;\n\
    \        }\n        if a.1 < b.1 {\n            return Ordering::Greater;\n  \
    \      }\n        Ordering::Equal\n    });\n    res\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpjf2yoo4_.rs:31:20\n   |\n31 |             return Ordering::Less;\n \
    \  |                    ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpjf2yoo4_.rs:34:20\n\
    \   |\n34 |             return Ordering::Greater;\n   |                    ^^^^^^^^\
    \ use of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `Ordering`\n  --> /tmp/tmpjf2yoo4_.rs:37:20\n   |\n37 |    \
    \         return Ordering::Less;\n   |                    ^^^^^^^^ use of undeclared\
    \ type `Ordering`\n\nerror[E0433]: failed to resolve: use of undeclared type `Ordering`\n\
    \  --> /tmp/tmpjf2yoo4_.rs:40:20\n   |\n40 |             return Ordering::Greater;\n\
    \   |                    ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpjf2yoo4_.rs:42:9\n\
    \   |\n42 |         Ordering::Equal\n   |         ^^^^^^^^ use of undeclared type\
    \ `Ordering`\n\nerror: aborting due to 5 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                result.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n    \
    \        b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.iter()\n        .enumerate()\n        .filter_map(|(i, xs)| {\n \
    \           let indices = xs.iter().enumerate().filter_map(|(j, &x1)| {\n    \
    \            if x1 == x {\n                    Some((i as isize, j as isize))\n\
    \                } else {\n                    None\n                }\n     \
    \       });\n            indices.collect::<Vec<(isize, isize)>>()\n        })\n\
    \        .flatten()\n        .collect::<Vec<(isize, isize)>>()\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6hujrsde.rs:28:13\n   |\n\
    28 |             indices.collect::<Vec<(isize, isize)>>()\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found struct `Vec`\n   |\n   = note: expected enum `Option<_>`\n\
    \            found struct `Vec<(isize, isize)>`\nhelp: try wrapping the expression\
    \ in `Some`\n   |\n28 |             Some(indices.collect::<Vec<(isize, isize)>>())\n\
    \   |             +++++                                        +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = vec![];\n    for y in 0..lst.len()\
    \ {\n        for z in 0..lst[y].len() {\n            if lst[y][z] == x {\n   \
    \             res.push((y as isize, z as isize));\n            }\n        }\n\
    \    }\n    res.sort_by(|a, b| a.0.cmp(&b.0).then(b.1.cmp(&a.1)));\n    res\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    // your code here\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmptgo3ln00.rs:19:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut x: Vec<(isize, isize)> = lst\n        .iter()\n        .enumerate()\n\
    \        .flat_map(|(y, x)| {\n            x.iter()\n                .enumerate()\n\
    \                .filter(|(_, z)| z == &&x)\n                .map(|(x, _)| (y\
    \ as isize, x as isize))\n        })\n        .collect();\n    x.sort_by(|a, b|\
    \ {\n        if a.0 == b.0 {\n            b.1.cmp(&a.1)\n        } else {\n  \
    \          a.0.cmp(&b.0)\n        }\n    });\n    x\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: can't compare `isize` with `&Vec<isize>`\n  --> /tmp/tmpc4evgvn3.rs:24:36\n\
    \   |\n24 |                 .filter(|(_, z)| z == &&x)\n   |                 \
    \                   ^^ no implementation for `isize == &Vec<isize>`\n   |\n  \
    \ = help: the trait `PartialEq<&Vec<isize>>` is not implemented for `isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n   = note: required because of the requirements on the impl of\
    \ `PartialEq<&&Vec<isize>>` for `&isize`\n   = note: 1 redundant requirement hidden\n\
    \   = note: required because of the requirements on the impl of `PartialEq<&&&Vec<isize>>`\
    \ for `&&isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row_col_pairs: Vec<(isize, isize)> = Vec::new();\n    for (row_idx,\
    \ row) in lst.iter().enumerate() {\n        for (col_idx, col) in row.iter().enumerate()\
    \ {\n            if *col == x {\n                row_col_pairs.push((row_idx as\
    \ isize, col_idx as isize));\n            }\n        }\n    }\n    row_col_pairs.sort_by(|a,\
    \ b| (a.0, -a.1).cmp(&(b.0, -b.1)));\n    row_col_pairs\n}\n\nfn main() {\n  \
    \  let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.is_empty() {\n        return vec![];\n    }\n    let mut coords:\
    \ Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate() {\n\
    \        for (j, &num) in row.iter().enumerate() {\n            if num == x {\n\
    \                coords.push((i as isize, j as isize));\n            }\n     \
    \   }\n    }\n    coords.sort_by(|a, b| a.0.cmp(&b.0).then(b.1.cmp(&a.1)));\n\
    \    coords\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = Vec::new();\n    let mut size =\
    \ lst.len();\n    for i in 0..size {\n        let mut size2 = lst[i].len();\n\
    \        for j in 0..size2 {\n            if lst[i][j] == x {\n              \
    \  result.push((i as isize, j as isize));\n            }\n        }\n    }\n \
    \   result.sort_by(|a, b| b.1.cmp(&a.1));\n    result.sort_by(|a, b| a.0.cmp(&b.0));\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.is_empty() {\n        return vec![];\n    }\n    let mut res:\
    \ Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate() {\n\
    \        for (j, col) in row.iter().enumerate() {\n            if *col == x {\n\
    \                res.push((i as isize, j as isize));\n            }\n        }\n\
    \    }\n    res.sort_by(|a, b| a.0.cmp(&b.0).then(b.1.cmp(&a.1)));\n    res\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = vec![];\n    for (i, line) in lst.iter().enumerate()\
    \ {\n        for (j, y) in line.iter().enumerate() {\n            if x == *y {\n\
    \                result.push((i as isize, j as isize));\n            }\n     \
    \   }\n    }\n    result.sort_by(|a, b| (a.0, -a.1).cmp(&(b.0, -b.1)));\n    result\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = Vec::new();\n    for (row, col)\
    \ in lst.iter().enumerate() {\n        for (j, value) in col.iter().enumerate()\
    \ {\n            if *value == x {\n                result.push((row as isize,\
    \ j as isize));\n            }\n        }\n    }\n    result.sort_by(|a, b| {\n\
    \        if a.0 < b.0 {\n            Ordering::Less\n        } else if a.0 > b.0\
    \ {\n            Ordering::Greater\n        } else {\n            b.1.cmp(&a.1)\n\
    \        }\n    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpbwa6c3mv.rs:28:13\n   |\n28 |             Ordering::Less\n   |     \
    \        ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed to\
    \ resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpbwa6c3mv.rs:30:13\n\
    \   |\n30 |             Ordering::Greater\n   |             ^^^^^^^^ use of undeclared\
    \ type `Ordering`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.iter()\n        .enumerate()\n        .flat_map(|(y, row)| {\n  \
    \          row.iter()\n                .rev()\n                .enumerate()\n\
    \                .filter(|(_, n)| n == &&x)\n                .map(move |(x, _)|\
    \ (y as isize, x as isize))\n        })\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(0, 5), (1, 1), (1, 5), (2, 0), (2, 5)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmpgl8dmz7q.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = vec![];\n    for (row, sub_list)\
    \ in lst.iter().enumerate() {\n        for (column, element) in sub_list.iter().enumerate()\
    \ {\n            if *element == x {\n                result.push((row as isize,\
    \ column as isize));\n            }\n        }\n    }\n    result.sort_by(|a,\
    \ b| a.partial_cmp(b).unwrap());\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmp4vvfb813.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.iter()\n        .enumerate()\n        .filter_map(|(y, r)| {\n  \
    \          r.iter()\n                .enumerate()\n                .filter_map(|(x,\
    \ e)| if *e == x { Some((y as isize, x as isize)) } else { None })\n         \
    \       .collect::<Vec<(isize, isize)>>()\n        })\n        .flatten()\n  \
    \      .collect::<Vec<(isize, isize)>>()\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3xktfn3a.rs:23:47\n   |\n\
    23 |                 .filter_map(|(x, e)| if *e == x { Some((y as isize, x as\
    \ isize)) } else { None })\n   |                                             \
    \  ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to\
    \ an `isize` and panic if the converted value doesn't fit\n   |\n23 |        \
    \         .filter_map(|(x, e)| if *e == x.try_into().unwrap() { Some((y as isize,\
    \ x as isize)) } else { None })\n   |                                        \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3xktfn3a.rs:21:13\n\
    \   |\n21 | /             r.iter()\n22 | |                 .enumerate()\n23 |\
    \ |                 .filter_map(|(x, e)| if *e == x { Some((y as isize, x as isize))\
    \ } else { None })\n24 | |                 .collect::<Vec<(isize, isize)>>()\n\
    \   | |_________________________________________________^ expected enum `Option`,\
    \ found struct `Vec`\n   |\n   = note: expected enum `Option<_>`\n           \
    \ found struct `Vec<(isize, isize)>`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n21 ~             Some(r.iter()\n22 |                 .enumerate()\n23 |\
    \                 .filter_map(|(x, e)| if *e == x { Some((y as isize, x as isize))\
    \ } else { None })\n24 ~                 .collect::<Vec<(isize, isize)>>())\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = Vec::new();\n    for (y, row) in lst.iter().enumerate()\
    \ {\n        for (x1, x2) in row.iter().enumerate() {\n            if *x2 == x\
    \ {\n                res.push((y as isize, x1 as isize));\n            }\n   \
    \     }\n    }\n    res.sort_by(|a, b| a.0.cmp(&b.0).then(b.1.cmp(&a.1)));\n \
    \   res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut coords: Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, elm) in row.iter().enumerate() {\n            if *elm ==\
    \ x {\n                coords.push((i as isize, j as isize));\n            }\n\
    \        }\n    }\n    // Sorting by column, then row\n    coords.sort_by(|a,\
    \ b| a.1.cmp(&b.1).then(a.0.cmp(&b.0)));\n    coords\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(0, 0), (1, 0), (2, 0), (1, 4), (2, 5)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmpnb9uh2k8.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.iter()\n        .enumerate()\n        .flat_map(|(i, row)| {\n  \
    \          row.iter()\n                .enumerate()\n                .filter(|&(_,\
    \ &item)| item == x)\n                .map(move |(j, _)| (i as isize, j as isize))\n\
    \        })\n        .sorted_by(|&(i, j), &(i1, j1)| {\n            match i.cmp(&i1)\
    \ {\n                Ordering::Equal => j1.cmp(&j),\n                Ordering::Less\
    \ => Ordering::Less,\n                Ordering::Greater => Ordering::Greater,\n\
    \            }\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpc2lrudc2.rs:28:17\n   |\n28 |                 Ordering::Equal => j1.cmp(&j),\n\
    \   |                 ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpc2lrudc2.rs:29:17\n\
    \   |\n29 |                 Ordering::Less => Ordering::Less,\n   |          \
    \       ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed to\
    \ resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpc2lrudc2.rs:29:35\n\
    \   |\n29 |                 Ordering::Less => Ordering::Less,\n   |          \
    \                         ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpc2lrudc2.rs:30:17\n\
    \   |\n30 |                 Ordering::Greater => Ordering::Greater,\n   |    \
    \             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpc2lrudc2.rs:30:38\n\
    \   |\n30 |                 Ordering::Greater => Ordering::Greater,\n   |    \
    \                                  ^^^^^^^^ use of undeclared type `Ordering`\n\
    \nerror[E0599]: no method named `sorted_by` found for struct `FlatMap` in the\
    \ current scope\n  --> /tmp/tmpc2lrudc2.rs:26:10\n   |\n26 |         .sorted_by(|&(i,\
    \ j), &(i1, j1)| {\n   |          ^^^^^^^^^ method not found in `FlatMap<Enumerate<std::slice::Iter<'_,\
    \ Vec<isize>>>, Map<Filter<Enumerate<std::slice::Iter<'_, isize>>, [closure@/tmp/tmpc2lrudc2.rs:23:25:\
    \ 23:48]>, [closure@/tmp/tmpc2lrudc2.rs:24:22: 24:60]>, [closure@/tmp/tmpc2lrudc2.rs:20:19:\
    \ 25:10]>`\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed\
    \ explanations: E0433, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut ret = vec![];\n    for (row, v) in lst.iter().enumerate() {\n\
    \        for (col, e) in v.iter().enumerate() {\n            if *e == x {\n  \
    \              ret.push((row as isize, col as isize));\n            }\n      \
    \  }\n    }\n    ret.sort_by(|a, b| {\n        let (x1, y1) = *a;\n        let\
    \ (x2, y2) = *b;\n        if x1 == x2 {\n            return y2.cmp(&y1);\n   \
    \     }\n        x1.cmp(&x2)\n    });\n    ret\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row = Vec::new();\n    let mut col = Vec::new();\n    let mut\
    \ res = Vec::new();\n    for i in 0..lst.len() {\n        for j in 0..lst[i].len()\
    \ {\n            if lst[i][j] == x {\n                row.push(i as isize);\n\
    \                col.push(j as isize);\n            }\n        }\n    }\n    row.sort();\n\
    \    col.sort();\n    col.reverse();\n    let mut i = 0;\n    while i < row.len()\
    \ {\n        res.push((row[i], col[i]));\n        i += 1;\n    }\n    res\n}\n\
    \nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(0, 5), (1, 4), (1, 0), (2, 0), (2, 0)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmpvpvkd6dj.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.iter()\n        .enumerate()\n        .map(|(i, xs)| xs.iter().enumerate().filter(|&(_,\
    \ &a)| a == x))\n        .flat_map(|xs| xs.map(|(j, _)| (i as isize, j as isize)))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpmje1mugb.rs:21:41\n\
    \   |\n21 |         .flat_map(|xs| xs.map(|(j, _)| (i as isize, j as isize)))\n\
    \   |                                         ^ help: a local variable with a\
    \ similar name exists: `j`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.iter()\n        .enumerate()\n        .flat_map(|(i, row)| {\n  \
    \          row.iter()\n                .enumerate()\n                .filter(|&(_,\
    \ &y)| y == x)\n                .map(move |(j, _)| (i as isize, j as isize))\n\
    \        })\n        .collect()\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(0, 0), (1, 0), (1, 4), (2, 0), (2, 5)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmpgiydyd6w.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = Vec::new();\n    let mut i = 0;\n\
    \    for row in lst {\n        let mut j = 0;\n        for num in row {\n    \
    \        if num == x {\n                result.push((i, j));\n            }\n\
    \            j += 1;\n        }\n        i += 1;\n    }\n    result.sort_by(|a,\
    \ b| if a.0 == b.0 { b.1.cmp(&a.1) } else { a.0.cmp(&b.0) });\n    result\n}\n\
    \nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = Vec::new();\n    let mut rows =\
    \ 0;\n    for row in lst {\n        let mut cols = 0;\n        for col in row\
    \ {\n            if col == x {\n                result.push((rows, cols));\n \
    \           }\n            cols += 1;\n        }\n        rows += 1;\n    }\n\
    \    result.sort_by(|a, b| (a.0).cmp(&b.0));\n    result.sort_by(|a, b| (b.1).cmp(&a.1));\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmppek071nc.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = Vec::new();\n    for y in 0..lst.len()\
    \ {\n        for x1 in 0..lst[y].len() {\n            if lst[y][x1] == x {\n \
    \               res.push((y as isize, x1 as isize));\n            }\n        }\n\
    \    }\n    res.sort_by(|a, b| {\n        a.0.cmp(&b.0).then(b.1.cmp(&a.1))\n\
    \    });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut coordinates: Vec<(isize, isize)> = Vec::new();\n    let mut row\
    \ = 0;\n    for vect in lst {\n        let mut column = vect.len() as isize -\
    \ 1;\n        for num in vect {\n            if num == &x {\n                coordinates.push((row,\
    \ column));\n            }\n            column -= 1;\n        }\n        row +=\
    \ 1;\n    }\n    coordinates.sort_by(|a, b| (a.0, b.1).cmp(&(b.0, a.1)));\n  \
    \  coordinates\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_tm8z4h6.rs:23:23\n   |\n\
    23 |             if num == &x {\n   |                       ^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider removing the borrow\n   |\n23 -       \
    \      if num == &x {\n23 +             if num == x {\n   | \n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = vec![];\n    for row in 0..lst.len()\
    \ {\n        for column in 0..lst[row].len() {\n            if lst[row][column]\
    \ == x {\n                result.push((row as isize, column as isize));\n    \
    \        }\n        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0\
    \ {\n            b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n\
    \        }\n    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut vec = vec![];\n    for (i, item) in lst.iter().enumerate() {\n\
    \        for (j, item2) in item.iter().enumerate() {\n            if *item2 ==\
    \ x {\n                vec.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    vec.sort_by(|a, b| {\n        if a.0 != b.0 {\n         \
    \   a.0.cmp(&b.0)\n        } else {\n            b.1.cmp(&a.1)\n        }\n  \
    \  });\n    vec\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut v = Vec::new();\n    for (i, row) in lst.iter().enumerate() {\n\
    \        for (j, &x_) in row.iter().enumerate() {\n            if x_ == x {\n\
    \                v.push((i as isize, j as isize));\n            }\n        }\n\
    \    }\n    v.sort_by(|&a, &b| {\n        if a.0 != b.0 {\n            a.0.cmp(&b.0)\n\
    \        } else {\n            b.1.cmp(&a.1)\n        }\n    });\n    v\n}\n\n\
    fn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.is_empty() {\n        return vec![];\n    }\n    let mut result:\
    \ Vec<(isize, isize)> = Vec::new();\n    let mut row_index = 0;\n    for row in\
    \ lst {\n        let mut col_index = 0;\n        for el in row {\n           \
    \ if el == x {\n                result.push((row_index, col_index));\n       \
    \     }\n            col_index += 1;\n        }\n        row_index += 1;\n   \
    \ }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n            a.1.cmp(&b.1)\n\
    \        } else {\n            a.0.cmp(&b.0)\n        }\n    });\n    result.reverse();\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(2, 5), (2, 0), (1, 4), (1, 0), (0, 0)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmpcucg82g3.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = Vec::new();\n    for (y, row) in\
    \ lst.iter().enumerate() {\n        for (x, value) in row.iter().enumerate() {\n\
    \            if *value == x {\n                result.push((y as isize, x as isize));\n\
    \            }\n        }\n    }\n    result.sort_by(|a, b| {\n        if a.0\
    \ != b.0 {\n            a.0.cmp(&b.0)\n        } else {\n            b.1.cmp(&a.1)\n\
    \        }\n    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy7050_ke.rs:21:26\n   |\n\
    21 |             if *value == x {\n   |                          ^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n21 |             if *value == x.try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = Vec::new();\n    for (i, item)\
    \ in lst.iter().enumerate() {\n        for (j, item2) in item.iter().enumerate()\
    \ {\n            if *item2 == x {\n                result.push((i as isize, j\
    \ as isize));\n            }\n        }\n    }\n    result.sort_by(|a, b| {\n\
    \        let (a0, a1) = *a;\n        let (b0, b1) = *b;\n        match a0.cmp(&b0)\
    \ {\n            Ordering::Equal => b1.cmp(&a1),\n            otherwise => otherwise,\n\
    \        }\n    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpmnhb79jm.rs:30:13\n   |\n30 |             Ordering::Equal => b1.cmp(&a1),\n\
    \   |             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.iter()\n        .enumerate()\n        .flat_map(|(i, arr)| {\n  \
    \          arr.iter()\n                .enumerate()\n                .filter(|(_,\
    \ e)| **e == x)\n                .map(|(j, _)| (i as isize, j as isize))\n   \
    \     })\n        .collect()\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0373]: closure may outlive the current function, but it borrows\
    \ `i`, which is owned by the current function\n  --> /tmp/tmpcmusdwgt.rs:24:22\n\
    \   |\n24 |                 .map(|(j, _)| (i as isize, j as isize))\n   |    \
    \                  ^^^^^^^^  - `i` is borrowed here\n   |                    \
    \  |\n   |                      may outlive borrowed value `i`\n   |\nnote: closure\
    \ is returned here\n  --> /tmp/tmpcmusdwgt.rs:21:13\n   |\n21 | /            \
    \ arr.iter()\n22 | |                 .enumerate()\n23 | |                 .filter(|(_,\
    \ e)| **e == x)\n24 | |                 .map(|(j, _)| (i as isize, j as isize))\n\
    \   | |_______________________________________________________^\nhelp: to force\
    \ the closure to take ownership of `i` (and any other referenced variables), use\
    \ the `move` keyword\n   |\n24 |                 .map(move |(j, _)| (i as isize,\
    \ j as isize))\n   |                      ++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0373`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = Vec::new();\n    for (row, row_vec)\
    \ in lst.iter().enumerate() {\n        for (column, elem) in row_vec.iter().enumerate()\
    \ {\n            if *elem == x {\n                result.push((row as isize, column\
    \ as isize));\n            }\n        }\n    }\n    result.sort_by(|a, b| {\n\
    \        if a.0 == b.0 {\n            b.1.cmp(&a.1)\n        } else {\n      \
    \      a.0.cmp(&b.0)\n        }\n    });\n    result\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in\
    \ lst.iter().enumerate() {\n        for (j, element) in row.iter().enumerate()\
    \ {\n            if element == &x {\n                result.push((i as isize,\
    \ j as isize));\n            }\n        }\n    }\n    result.sort_by(|a, b| {\n\
    \        if a.0 == b.0 {\n            b.1.cmp(&a.1)\n        } else {\n      \
    \      a.0.cmp(&b.0)\n        }\n    });\n    result\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = Vec::new();\n    for i in 0..lst.len()\
    \ {\n        for j in 0..lst[i].len() {\n            if lst[i][j] == x {\n   \
    \             result.push((i as isize, j as isize));\n            }\n        }\n\
    \    }\n    result.sort_by(|a, b| {\n        a.0.cmp(&b.0).then(b.1.cmp(&a.1))\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &val) in row.iter().enumerate() {\n            if val ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| {\n        a.0.cmp(&b.0).then(b.1.cmp(&a.1))\n\
    \    });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = Vec::new();\n    for (y, row) in lst.iter().enumerate()\
    \ {\n        for (x1, item) in row.iter().enumerate() {\n            if *item\
    \ == x {\n                res.push((y as isize, x1 as isize));\n            }\n\
    \        }\n    }\n    res.sort_by(|(y1, x1), (y2, x2)| {\n        match y1.cmp(y2)\
    \ {\n            Ordering::Equal => x2.cmp(x1),\n            x => x,\n       \
    \ }\n    });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpuvbza3tr.rs:28:13\n   |\n28 |             Ordering::Equal => x2.cmp(x1),\n\
    \   |             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut ret = vec![];\n    let mut rows = vec![];\n    for (r, row) in\
    \ lst.iter().enumerate() {\n        rows.push(r);\n        for (c, x2) in row.iter().enumerate()\
    \ {\n            if *x2 == x {\n                ret.push((r as isize, c as isize));\n\
    \            }\n        }\n    }\n    if ret.len() > 0 {\n        ret.sort_by(|a,\
    \ b| {\n            if a.0 == b.0 {\n                b.1.cmp(&a.1)\n         \
    \   } else {\n                a.0.cmp(&b.0)\n            }\n        });\n    }\n\
    \    ret\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx\
    \ = 0;\n    for row in lst {\n        let mut col_idx = 0;\n        for col in\
    \ row {\n            if col == x {\n                result.push((row_idx, col_idx));\n\
    \            }\n            col_idx += 1;\n        }\n        row_idx += 1;\n\
    \    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n            return\
    \ b.1.cmp(&a.1);\n        }\n        a.0.cmp(&b.0)\n    });\n    result\n}\n\n\
    fn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut coordinates: Vec<(isize, isize)> = vec![];\n    for (y, row)\
    \ in lst.iter().enumerate() {\n        for (x1, col) in row.iter().enumerate()\
    \ {\n            if *col == x {\n                coordinates.push((y as isize,\
    \ x1 as isize));\n            }\n        }\n    }\n    coordinates.sort_by(|a,\
    \ b| {\n        if a.0 == b.0 {\n            a.1.cmp(&b.1)\n        } else {\n\
    \            a.0.cmp(&b.0)\n        }\n    });\n    coordinates.reverse();\n \
    \   coordinates\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(2, 5), (2, 0), (1, 4), (1, 0), (0, 0)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmppauv0x1s.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.iter()\n        .enumerate()\n        .filter_map(|(row, list)| {\n\
    \            list.iter()\n                .enumerate()\n                .filter_map(|(col,\
    \ &val)| if val == x { Some((row as isize, col as isize)) } else { None })\n \
    \               .collect::<Vec<(isize, isize)>>()\n        })\n        .flatten()\n\
    \        .collect::<Vec<(isize, isize)>>()\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8nol29zc.rs:21:13\n   |\n\
    21 | /             list.iter()\n22 | |                 .enumerate()\n23 | |  \
    \               .filter_map(|(col, &val)| if val == x { Some((row as isize, col\
    \ as isize)) } else { None })\n24 | |                 .collect::<Vec<(isize, isize)>>()\n\
    \   | |_________________________________________________^ expected enum `Option`,\
    \ found struct `Vec`\n   |\n   = note: expected enum `Option<_>`\n           \
    \ found struct `Vec<(isize, isize)>`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n21 ~             Some(list.iter()\n22 |                 .enumerate()\n\
    23 |                 .filter_map(|(col, &val)| if val == x { Some((row as isize,\
    \ col as isize)) } else { None })\n24 ~                 .collect::<Vec<(isize,\
    \ isize)>>())\n   |\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = vec![];\n    let mut row = 0;\n  \
    \  for v in lst {\n        let mut col = v.len() as isize - 1;\n        for i\
    \ in v {\n            if i == x {\n                res.push((row, col));\n   \
    \         }\n            col -= 1;\n        }\n        row += 1;\n    }\n    res.sort_by(|a,\
    \ b| {\n        if a.0 == b.0 {\n            b.1.cmp(&a.1)\n        } else {\n\
    \            a.0.cmp(&b.0)\n        }\n    });\n    res\n}\n\nfn main() {\n  \
    \  let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(0, 5), (1, 5), (1, 1), (2, 5), (2, 0)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmp459273zp.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, &col) in row.iter().enumerate() {\n            if col ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| (a.0, b.1).cmp(&(b.0, a.1)));\n    res\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    // your code\n    let mut result: Vec<(isize, isize)> = Vec::new();\n\
    \    for (i, row) in lst.iter().enumerate() {\n        for (j, item) in row.iter().enumerate()\
    \ {\n            if item == &x {\n                result.push((i as isize, j as\
    \ isize));\n            }\n        }\n    }\n    result.sort_by(|a, b| {\n   \
    \     if a.0 != b.0 {\n            a.0.cmp(&b.0)\n        } else {\n         \
    \   b.1.cmp(&a.1)\n        }\n    });\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.is_empty() {\n        return vec![];\n    }\n    let mut result:\
    \ Vec<(isize, isize)> = Vec::new();\n    for i in 0..lst.len() {\n        for\
    \ j in 0..lst[i].len() {\n            if lst[i][j] == x {\n                result.push((i\
    \ as isize, j as isize));\n            }\n        }\n    }\n    result.sort_by(|a,\
    \ b| a.0.cmp(&b.0).then(b.1.cmp(&a.1)));\n    result\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.iter()\n        .enumerate()\n        .flat_map(|(i, v)| {\n    \
    \        v.iter()\n                .rev()\n                .enumerate()\n    \
    \            .filter(|&(_, j)| *j == x)\n                .map(|(j, _)| (i as isize,\
    \ j as isize))\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0373]: closure may outlive the current function, but it borrows\
    \ `i`, which is owned by the current function\n  --> /tmp/tmp6j17kmle.rs:25:22\n\
    \   |\n25 |                 .map(|(j, _)| (i as isize, j as isize))\n   |    \
    \                  ^^^^^^^^  - `i` is borrowed here\n   |                    \
    \  |\n   |                      may outlive borrowed value `i`\n   |\nnote: closure\
    \ is returned here\n  --> /tmp/tmp6j17kmle.rs:21:13\n   |\n21 | /            \
    \ v.iter()\n22 | |                 .rev()\n23 | |                 .enumerate()\n\
    24 | |                 .filter(|&(_, j)| *j == x)\n25 | |                 .map(|(j,\
    \ _)| (i as isize, j as isize))\n   | |_______________________________________________________^\n\
    help: to force the closure to take ownership of `i` (and any other referenced\
    \ variables), use the `move` keyword\n   |\n25 |                 .map(move |(j,\
    \ _)| (i as isize, j as isize))\n   |                      ++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0373`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut coordinates: Vec<(isize, isize)> = vec![];\n    for (row, cells)\
    \ in lst.iter().enumerate() {\n        for (column, cell) in cells.iter().enumerate()\
    \ {\n            if *cell == x {\n                coordinates.push((row as isize,\
    \ column as isize));\n            }\n        }\n    }\n    coordinates.sort_by(|(row1,\
    \ column1), (row2, column2)| {\n        row1.cmp(row2).then(column2.cmp(column1))\n\
    \    });\n    coordinates\n}\n\nfn main() {\n    let candidate = get_row;\n  \
    \  assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1,\
    \ 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    // A sequence of one or more items, separated by commas,\n    // and\
    \ ending with an optional trailing comma\n    let mut v: Vec<(isize, isize)> =\
    \ Vec::new();\n    // Check if list is empty\n    if lst.len() == 0 {\n      \
    \  return v;\n    }\n    // Find the indices of `x`\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        let mut new_i = i as isize;\n        for (j, elem) in row.iter().enumerate()\
    \ {\n            if elem == &x {\n                let new_j = j as isize;\n  \
    \              v.push((new_i, new_j));\n            }\n        }\n    }\n    //\
    \ Sort coordinates by rows in ascending order\n    v.sort_by(|a, b| a.0.cmp(&b.0));\n\
    \    // Sort coordinates of the row by columns in descending order\n    v.sort_by(|a,\
    \ b| b.1.cmp(&a.1));\n    v\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(2, 5), (1, 4), (0, 0), (1, 0), (2, 0)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmpqyt6rqb1.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = vec![];\n    for (y, row) in lst.iter().enumerate()\
    \ {\n        for (x1, cell) in row.iter().enumerate() {\n            if *cell\
    \ == x {\n                result.push((y as isize, x1 as isize));\n          \
    \  }\n        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 == b.0 {\n\
    \            a.1.cmp(&b.1)\n        } else {\n            a.0.cmp(&b.0)\n    \
    \    }\n    });\n    result.reverse();\n    result\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(2, 5), (2, 0), (1, 4), (1, 0), (0, 0)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmp5sbnfmkr.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.is_empty() {\n        return vec![];\n    }\n    let mut result:\
    \ Vec<(isize, isize)> = vec![];\n    for (i, row) in lst.iter().enumerate() {\n\
    \        for (j, element) in row.iter().enumerate() {\n            if *element\
    \ == x {\n                result.push((i as isize, j as isize));\n           \
    \ }\n        }\n    }\n    result.sort_by(|a, b| {\n        if a.0 != b.0 {\n\
    \            a.0.cmp(&b.0)\n        } else {\n            b.1.cmp(&a.1)\n    \
    \    }\n    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut list = vec![];\n    for (i, row) in lst.iter().enumerate() {\n\
    \        for (j, item) in row.iter().enumerate() {\n            if *item == x\
    \ {\n                list.push((i as isize, j as isize));\n            }\n   \
    \     }\n    }\n    list.sort_by(|a, b| {\n        if a.0 < b.0 {\n          \
    \  Ordering::Less\n        } else if a.0 > b.0 {\n            Ordering::Greater\n\
    \        } else {\n            if a.1 > b.1 {\n                Ordering::Less\n\
    \            } else if a.1 < b.1 {\n                Ordering::Greater\n      \
    \      } else {\n                Ordering::Equal\n            }\n        }\n \
    \   });\n    list\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpy70ew0l5.rs:28:13\n   |\n28 |             Ordering::Less\n   |     \
    \        ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed to\
    \ resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpy70ew0l5.rs:30:13\n\
    \   |\n30 |             Ordering::Greater\n   |             ^^^^^^^^ use of undeclared\
    \ type `Ordering`\n\nerror[E0433]: failed to resolve: use of undeclared type `Ordering`\n\
    \  --> /tmp/tmpy70ew0l5.rs:33:17\n   |\n33 |                 Ordering::Less\n\
    \   |                 ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpy70ew0l5.rs:35:17\n\
    \   |\n35 |                 Ordering::Greater\n   |                 ^^^^^^^^ use\
    \ of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Ordering`\n  --> /tmp/tmpy70ew0l5.rs:37:17\n   |\n37 |               \
    \  Ordering::Equal\n   |                 ^^^^^^^^ use of undeclared type `Ordering`\n\
    \nerror: aborting due to 5 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = Vec::new();\n    let mut index\
    \ = 0;\n    for list in lst {\n        let mut row_index = 0;\n        for element\
    \ in list {\n            if element == x {\n                result.push((index,\
    \ row_index));\n            }\n            row_index += 1;\n        }\n      \
    \  index += 1;\n    }\n    result.sort_by(|a, b| {\n        let a_row = a.0;\n\
    \        let b_row = b.0;\n        if a_row != b_row {\n            return a_row.cmp(&b_row);\n\
    \        }\n        let a_col = a.1;\n        let b_col = b.1;\n        b_col.cmp(&a_col)\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.iter()\n        .enumerate()\n        .map(|(r, row)| row.iter().position(|&c|\
    \ c == x).map(|c| (r as isize, c as isize)))\n        .flatten()\n        .collect::<Vec<(isize,\
    \ isize)>>()\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(0, 0), (1, 0), (2, 0)]`,\n right: `[(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]`',\
    \ /tmp/tmp_lrqdjdi.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = Vec::new();\n    for (i, row) in lst.iter().enumerate()\
    \ {\n        for (j, item) in row.iter().enumerate() {\n            if *item ==\
    \ x {\n                res.push((i as isize, j as isize));\n            }\n  \
    \      }\n    }\n    res.sort_by(|a, b| a.0.cmp(&b.0).then(b.1.cmp(&a.1)));\n\
    \    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result: Vec<(isize, isize)> = Vec::new();\n    for (y, row) in\
    \ lst.iter().enumerate() {\n        for (x_i, &x_v) in row.iter().enumerate()\
    \ {\n            if x_v == x {\n                result.push((y as isize, x_i as\
    \ isize));\n            }\n        }\n    }\n    result.sort_by(|a, b| {\n   \
    \     if a.0 == b.0 {\n            a.1.cmp(&b.1)\n        } else {\n         \
    \   a.0.cmp(&b.0)\n        }\n    });\n    result.reverse();\n    result\n}\n\n\
    fn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(2, 5), (2, 0), (1, 4), (1, 0), (0, 0)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmpc8vbs_ei.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    lst.iter()\n        .enumerate()\n        .flat_map(|(i, row)| {\n  \
    \          row.iter()\n                .enumerate()\n                .filter(|(_,\
    \ &v)| v == x)\n                .map(move |(j, _)| (i as isize, j as isize))\n\
    \        })\n        .sorted_by(|&(i, j), &(i2, j2)| match i.cmp(&i2) {\n    \
    \        std::cmp::Ordering::Equal => j2.cmp(&j),\n            x => x,\n     \
    \   })\n        .collect()\n}\n\nfn main() {\n    let candidate = get_row;\n \
    \   assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sorted_by` found for struct `FlatMap` in\
    \ the current scope\n  --> /tmp/tmpyilyqm6n.rs:26:10\n   |\n26 |         .sorted_by(|&(i,\
    \ j), &(i2, j2)| match i.cmp(&i2) {\n   |          ^^^^^^^^^ method not found\
    \ in `FlatMap<Enumerate<std::slice::Iter<'_, Vec<isize>>>, Map<Filter<Enumerate<std::slice::Iter<'_,\
    \ isize>>, [closure@/tmp/tmpyilyqm6n.rs:23:25: 23:41]>, [closure@/tmp/tmpyilyqm6n.rs:24:22:\
    \ 24:60]>, [closure@/tmp/tmpyilyqm6n.rs:20:19: 25:10]>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    for row in lst {\n        let mut col_idx = row.len() as isize - 1;\n\
    \        for i in row {\n            if i == x {\n                res.push((row_idx,\
    \ col_idx));\n            }\n            col_idx -= 1;\n        }\n        row_idx\
    \ += 1;\n    }\n    res.sort_by(|a, b| {\n        a.0.cmp(&b.0).then(b.1.cmp(&a.1))\n\
    \    });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[(0, 5), (1, 5), (1, 1), (2, 5), (2, 0)]`,\n right: `[(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)]`', /tmp/tmpo_a4lxeh.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut lst_row: Vec<(isize, isize)> = Vec::new();\n    let mut lst_temp:\
    \ Vec<(isize, isize)> = Vec::new();\n    for (i, v) in lst.iter().enumerate()\
    \ {\n        for (j, v2) in v.iter().enumerate() {\n            if *v2 == x {\n\
    \                lst_temp.push((i as isize, j as isize));\n            }\n   \
    \     }\n    }\n    lst_temp.sort_by(|&a, &b| {\n        if a.0 == b.0 {\n   \
    \         b.1.cmp(&a.1)\n        } else {\n            a.0.cmp(&b.0)\n       \
    \ }\n    });\n    lst_row = lst_temp;\n    lst_row\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut ixs = vec![];\n    for (i, row) in lst.iter().enumerate() {\n\
    \        for (j, elem) in row.iter().enumerate() {\n            if *elem == x\
    \ {\n                ixs.push((i as isize, j as isize));\n            }\n    \
    \    }\n    }\n    ixs.sort_by(|(a, b), (c, d)| {\n        if a == c {\n     \
    \       d.cmp(b)\n        } else {\n            a.cmp(c)\n        }\n    });\n\
    \    ixs\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// get_row([\n/// [1,2,3,4,5,6],\n\
    /// [1,2,3,4,1,6],\n/// [1,2,3,4,5,1]\n/// ], 1) == [(0, 0), (1, 4), (1, 0), (2,\
    \ 5), (2, 0)]\n/// get_row([], 1) == []\n/// get_row([[], [1], [1, 2, 3]], 3)\
    \ == [(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut res: Vec<(isize, isize)> = Vec::new();\n    let mut row = 0;\n\
    \    let mut col = 0;\n    for i in lst {\n        for j in i {\n            if\
    \ j == x {\n                res.push((row, col));\n            }\n           \
    \ col += 1;\n        }\n        row += 1;\n        col = 0;\n    }\n    res.sort_by(|a,\
    \ b| match a.0.cmp(&b.0) {\n        Ordering::Equal => b.1.cmp(&a.1),\n      \
    \  x => x,\n    });\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpl83ejgif.rs:32:9\n   |\n32 |         Ordering::Equal => b.1.cmp(&a.1),\n\
    \   |         ^^^^^^^^ use of undeclared type `Ordering`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
