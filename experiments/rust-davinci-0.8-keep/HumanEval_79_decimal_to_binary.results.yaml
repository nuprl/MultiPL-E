name: HumanEval_79_decimal_to_binary
language: rust
results:
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let base = 2;\n    let bin = convert_base(decimal, base);\n\
    \    format!(\"db{}db\", bin)\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `convert_base` in this scope\n  -->\
    \ /tmp/tmpadw00bot.rs:11:15\n   |\n11 |     let bin = convert_base(decimal, base);\n\
    \   |               ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    decimal_to_binary_rec(decimal, String::new())\n}\n\n\
    fn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `decimal_to_binary_rec` in this scope\n\
    \  --> /tmp/tmpke9uzhg_.rs:10:5\n   |\n10 |     decimal_to_binary_rec(decimal,\
    \ String::new())\n   |     ^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut result = String::from(\"db\");\n    let mut\
    \ value = decimal;\n    while value > 0 {\n        result.push(match value % 2\
    \ {\n            0 => '0',\n            _ => '1',\n        });\n        value\
    \ /= 2;\n    }\n    result.push_str(\"db\");\n    result.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmp7km56mid.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    match decimal {\n        0 => String::from(\"db0db\"\
    ),\n        x if x > 0 => format!(\"db{}db\", x.to_string().chars().map(|c| c.to_digit(10).unwrap()\
    \ as isize).map(|d| decimal_to_binary(d)).collect::<String>()),\n        x if\
    \ x < 0 => format!(\"db-{}db\", x.to_string().chars().map(|c| c.to_digit(10).unwrap()\
    \ as isize).map(|d| decimal_to_binary(d)).collect::<String>()),\n        _ =>\
    \ unreachable!()\n    }\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    if decimal == 0 {\n        return \"db0db\".to_string();\n\
    \    }\n    let mut result = String::new();\n    let mut counter = 0;\n    let\
    \ mut number = decimal;\n    while number > 0 {\n        if number % 2 == 0 {\n\
    \            result.push('0');\n        } else {\n            result.push('1');\n\
    \        }\n        number /= 2;\n        counter += 1;\n    }\n    let mut length\
    \ = counter * 2 + 2;\n    let mut result_str = String::with_capacity(length as\
    \ usize);\n    result_str.push_str(\"db\");\n    while length > 1 {\n        result_str.push(result.pop().unwrap());\n\
    \        length -= 1;\n    }\n    result_str.push_str(\"db\");\n    result_str\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmpo78l868e.rs:29:38\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut result = String::from(\"db\");\n    let mut\
    \ decimal = decimal;\n    let mut digit;\n    while decimal > 0 {\n        digit\
    \ = decimal % 2;\n        result.push_str(&digit.to_string());\n        decimal\
    \ = decimal / 2;\n    }\n    let mut result: String = result.chars().rev().collect();\n\
    \    result.push_str(\"db\");\n    result\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bddb\"`,\n right: `\"db0db\"`', /tmp/tmp8dxo7t0m.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    unimplemented!(\"decimal_to_binary({})\", decimal)\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented: decimal_to_binary(0)', /tmp/tmp1sme5_ew.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpjtxbuux7.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut binary = String::new();\n    binary.push_str(\"\
    db\");\n    for i in 0..8 {\n        if decimal >= 2i32.pow(7 - i) {\n       \
    \     binary.push('1');\n            decimal -= 2i32.pow(7 - i);\n        } else\
    \ {\n            binary.push('0');\n        }\n    }\n    binary.push_str(\"db\"\
    );\n    binary\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n   \
    \ assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl9j4795_.rs:13:23\n   |\n\
    13 |         if decimal >= 2i32.pow(7 - i) {\n   |                       ^^^^^^^^^^^^^^^\
    \ expected `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n13 |         if decimal\
    \ >= 2i32.pow(7 - i).try_into().unwrap() {\n   |                             \
    \         ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl9j4795_.rs:15:24\n\
    \   |\n15 |             decimal -= 2i32.pow(7 - i);\n   |                    \
    \    ^^^^^^^^^^^^^^^ expected `isize`, found `i32`\n\nerror[E0277]: cannot subtract-assign\
    \ `i32` from `isize`\n  --> /tmp/tmpl9j4795_.rs:15:21\n   |\n15 |            \
    \ decimal -= 2i32.pow(7 - i);\n   |                     ^^ no implementation for\
    \ `isize -= i32`\n   |\n   = help: the trait `SubAssign<i32>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `SubAssign<Rhs>`:\n\
    \             <f32 as SubAssign<&f32>>\n             <f32 as SubAssign>\n    \
    \         <f64 as SubAssign<&f64>>\n             <f64 as SubAssign>\n        \
    \     <i128 as SubAssign<&i128>>\n             <i128 as SubAssign>\n         \
    \    <i16 as SubAssign<&i16>>\n             <i16 as SubAssign>\n           and\
    \ 20 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    String::from(format!(\"db{:b}db\", decimal))\n}\n\n\
    fn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut binary = String::from(\"db\");\n    if decimal\
    \ == 0 {\n        binary.push('0');\n    } else {\n        while decimal > 0 {\n\
    \            binary.push_str(&(decimal % 2).to_string());\n            decimal\
    \ /= 2;\n        }\n    }\n    binary.push_str(\"db\");\n    binary.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `decimal`\n  --> /tmp/tmp3ady6nxv.rs:16:13\n\
    \   |\n9  | fn decimal_to_binary(decimal: isize) -> String {\n   |           \
    \           ------- help: consider making this binding mutable: `mut decimal`\n\
    ...\n16 |             decimal /= 2;\n   |             ^^^^^^^^^^^^ cannot assign\
    \ to immutable argument\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    if decimal == 0 {\n        return String::from(\"db0db\"\
    );\n    }\n    let mut result = String::from(\"db\");\n    let mut decimal = decimal;\n\
    \    while decimal > 0 {\n        let rest = decimal % 2;\n        if rest ==\
    \ 0 {\n            result.push('0');\n        } else {\n            result.push('1');\n\
    \        }\n        decimal /= 2;\n    }\n    result.push_str(\"db\");\n    result.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bd100000bd\"`,\n right: `\"db100000db\"`', /tmp/tmpydg07u9y.rs:31:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut binary = String::new();\n    binary.push_str(\"\
    db\");\n    while decimal > 0 {\n        binary.push_str(&format!(\"{}\", decimal\
    \ % 2));\n        decimal /= 2;\n    }\n    binary.push_str(\"db\");\n    binary.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `decimal`\n  --> /tmp/tmpnqrdiuwo.rs:14:9\n\
    \   |\n9  | fn decimal_to_binary(decimal: isize) -> String {\n   |           \
    \           ------- help: consider making this binding mutable: `mut decimal`\n\
    ...\n14 |         decimal /= 2;\n   |         ^^^^^^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let db: String = \"db\".to_string();\n    db + &decimal.to_string(2)\
    \ + &db\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmpsxaq5qll.rs:11:19\n     |\n11   |     db + &decimal.to_string(2)\
    \ + &db\n     |                   ^^^^^^^^^ - supplied 1 argument\n     |    \
    \               |\n     |                   expected 0 arguments\n     |\nnote:\
    \ associated function defined here\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut result = String::new();\n    result.push_str(\"\
    db\");\n    result.push_str(&decimal.to_string());\n    result.push_str(\"db\"\
    );\n    result\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n   \
    \ assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db32db\"`,\n right: `\"db100000db\"`', /tmp/tmprgbnk694.rs:20:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    // your code here\n    String::from(\"db1111db\")\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db1111db\"`,\n right: `\"db0db\"`', /tmp/tmpi9r30jrk.rs:16:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut str = String::new();\n    str.push_str(\"db\"\
    );\n    for _ in 0..7 {\n        str.push(std::char::from_digit((decimal % 2)\
    \ as u32, 2).unwrap());\n        decimal /= 2;\n    }\n    str.push_str(\"db\"\
    );\n    str.chars().rev().collect()\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `decimal`\n  --> /tmp/tmp4rj6kpv3.rs:14:9\n\
    \   |\n9  | fn decimal_to_binary(decimal: isize) -> String {\n   |           \
    \           ------- help: consider making this binding mutable: `mut decimal`\n\
    ...\n14 |         decimal /= 2;\n   |         ^^^^^^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut decimal = decimal;\n    let mut res = String::from(\"\
    db\");\n    loop {\n        res.push(if decimal % 2 == 0 { '0' } else { '1' });\n\
    \        decimal /= 2;\n        if decimal == 0 {\n            break;\n      \
    \  }\n    }\n    res.push_str(\"db\");\n    res\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db000001db\"`,\n right: `\"db100000db\"`', /tmp/tmplebtzppb.rs:26:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut buffer = String::new();\n    let mut sign: String\
    \ = String::new();\n    let mut remainder: isize;\n    let mut quotient: isize;\n\
    \    let mut binary: String = String::new();\n\n    if decimal < 0 {\n       \
    \ quotient = decimal * -1;\n        sign = \"-\".to_string();\n    } else {\n\
    \        quotient = decimal;\n    }\n\n    loop {\n        remainder = quotient\
    \ % 2;\n        quotient = quotient / 2;\n        binary = remainder.to_string()\
    \ + &binary;\n        if quotient == 0 {\n            break;\n        }\n    }\n\
    \n    buffer.push_str(\"db\");\n    buffer.push_str(&sign);\n    buffer.push_str(&binary);\n\
    \    buffer.push_str(\"db\");\n\n    buffer\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut n = format!(\"{:b}\", decimal);\n    n.insert_str(0,\
    \ \"db\");\n    n.push_str(\"db\");\n    n\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut output = \"db\".to_string();\n    let mut acc:\
    \ isize = 1;\n    while acc < decimal {\n        acc *= 2;\n    }\n    while acc\
    \ >= 1 {\n        if acc <= decimal {\n            output.push('1');\n       \
    \     decimal -= acc;\n        } else {\n            output.push('0');\n     \
    \   }\n        acc /= 2;\n    }\n    output.push_str(\"db\");\n    output\n}\n\
    \nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `decimal`\n  --> /tmp/tmpgnzmyq6o.rs:18:13\n\
    \   |\n9  | fn decimal_to_binary(decimal: isize) -> String {\n   |           \
    \           ------- help: consider making this binding mutable: `mut decimal`\n\
    ...\n18 |             decimal -= acc;\n   |             ^^^^^^^^^^^^^^ cannot\
    \ assign to immutable argument\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut binary = String::from(\"db\");\n    let mut\
    \ temp = decimal;\n    while temp > 0 {\n        let remainder = temp % 2;\n \
    \       temp = temp / 2;\n        binary.push_str(&remainder.to_string());\n \
    \   }\n    binary.push_str(\"db\");\n    binary.chars().rev().collect()\n}\n\n\
    fn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmplfwnbj37.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut binary: String = String::from(\"db\");\n   \
    \ let mut decimal = decimal;\n    let mut iter = 0;\n    let mut db = String::from(\"\
    db\");\n    let mut result = String::from(\"\");\n    let mut db_pos = 2;\n  \
    \  while decimal > 0 {\n        binary.push_str(&(decimal % 2).to_string());\n\
    \        decimal /= 2;\n        iter += 1;\n    }\n    for i in (0..binary.len()).rev()\
    \ {\n        result.push(binary.chars().nth(i).unwrap());\n    }\n    result.push_str(&db);\n\
    \    result\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bddb\"`,\n right: `\"db0db\"`', /tmp/tmph64g29pe.rs:30:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut binary = String::new();\n    let mut num = decimal;\n\
    \    while num > 0 {\n        binary.push_str(&(num % 2).to_string());\n     \
    \   num /= 2;\n    }\n    binary = binary.chars().rev().collect();\n    format!(\"\
    db{}db\", binary)\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpi28p2_4e.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut binary = \"db\".to_string();\n    let mut n\
    \ = decimal;\n    while n > 0 {\n        binary.push_str(&(n % 2).to_string());\n\
    \        n /= 2;\n    }\n    binary.push_str(\"db\");\n    binary.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpztv0soi1.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut binary = String::new();\n    binary.push_str(\"\
    db\");\n    let mut number = decimal;\n    while number != 0 {\n        binary.push_str(&(number\
    \ % 2).to_string());\n        number /= 2;\n    }\n    binary.push_str(\"db\"\
    );\n    binary.chars().rev().collect()\n}\n\nfn main() {\n    let candidate =\
    \ decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmphmq18bka.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut binary = String::new();\n    let mut n = decimal;\n\
    \    while n > 0 {\n        binary.push_str(&format!(\"{}\", n % 2));\n      \
    \  n /= 2;\n    }\n    binary.push_str(\"db\");\n    binary.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bd\"`,\n right: `\"db0db\"`', /tmp/tmpx_jcs5ie.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut binary: String = \"db\".to_string();\n    let\
    \ mut remainder = decimal;\n    let mut modulo;\n    while remainder > 0 {\n \
    \       modulo = remainder % 2;\n        remainder = remainder / 2;\n        if\
    \ modulo == 0 {\n            binary.push('0');\n        } else {\n           \
    \ binary.push('1');\n        }\n    }\n    binary.push_str(\"db\");\n    binary.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpoepp_8pc.rs:28:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut decimal\
    \ = decimal;\n    let mut result_vec = Vec::new();\n    let mut temp = decimal;\n\
    \    while temp > 0 {\n        temp /= 2;\n        result_vec.push('0');\n   \
    \ }\n    result_vec.reverse();\n    while decimal > 0 {\n        let remainder\
    \ = decimal % 2;\n        decimal /= 2;\n        result_vec.push(if remainder\
    \ == 1 { '1' } else { '0' });\n    }\n    result.push_str(\"db\");\n    for each\
    \ in result_vec {\n        result.push(each);\n    }\n    result.push_str(\"db\"\
    );\n    result\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n   \
    \ assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmppl6pbmv1.rs:34:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut binary: String = String::from(\"db\");\n   \
    \ let mut dec: isize = decimal;\n    let mut iter: isize = 0;\n    while 2_isize.pow(iter)\
    \ <= dec {\n        iter += 1;\n    }\n    iter -= 1;\n    while iter >= 0 {\n\
    \        if 2_isize.pow(iter) <= dec {\n            binary.push('1');\n      \
    \      dec -= 2_isize.pow(iter);\n        } else {\n            binary.push('0');\n\
    \        }\n        iter -= 1;\n    }\n    binary.push('d');\n    binary.push('b');\n\
    \    binary\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpebz1afj9.rs:13:23\n   |\n\
    13 |     while 2_isize.pow(iter) <= dec {\n   |                       ^^^^ expected\
    \ `u32`, found `isize`\n   |\nhelp: you can convert an `isize` to a `u32` and\
    \ panic if the converted value doesn't fit\n   |\n13 |     while 2_isize.pow(iter.try_into().unwrap())\
    \ <= dec {\n   |                           ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpebz1afj9.rs:18:24\n   |\n18 |         if 2_isize.pow(iter)\
    \ <= dec {\n   |                        ^^^^ expected `u32`, found `isize`\n \
    \  |\nhelp: you can convert an `isize` to a `u32` and panic if the converted value\
    \ doesn't fit\n   |\n18 |         if 2_isize.pow(iter.try_into().unwrap()) <=\
    \ dec {\n   |                            ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpebz1afj9.rs:20:32\n   |\n20 |             dec\
    \ -= 2_isize.pow(iter);\n   |                                ^^^^ expected `u32`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `u32` and panic if\
    \ the converted value doesn't fit\n   |\n20 |             dec -= 2_isize.pow(iter.try_into().unwrap());\n\
    \   |                                    ++++++++++++++++++++\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut binary = String::new();\n    binary.push_str(\"\
    db\");\n    let mut current_decimal = decimal;\n    while current_decimal != 0\
    \ {\n        let remainder = current_decimal % 2;\n        let mut remainder_str\
    \ = String::new();\n        remainder_str.push_str(&remainder.to_string());\n\
    \        binary.push_str(&remainder_str);\n        current_decimal = current_decimal\
    \ / 2;\n    }\n    binary.push_str(\"db\");\n    binary.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmp3i0gvuxf.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut binary: String = \"db\".to_string();\n    let\
    \ mut dec = decimal;\n    while dec != 0 {\n        binary.push_str(if dec % 2\
    \ == 0 { \"0\" } else { \"1\" });\n        dec /= 2;\n    }\n    binary.push_str(\"\
    db\");\n    binary.chars().rev().collect()\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpp380dt81.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    \"db\".to_string() + &decimal.to_string(2) + \"db\"\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmp74k0ytl5.rs:10:33\n     |\n10   |     \"db\".to_string() + &decimal.to_string(2)\
    \ + \"db\"\n     |                                 ^^^^^^^^^ - supplied 1 argument\n\
    \     |                                 |\n     |                            \
    \     expected 0 arguments\n     |\nnote: associated function defined here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let bin = format!(\"{:b}\", decimal);\n    format!(\"\
    db{}db\", bin)\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n   \
    \ assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut bin = String::from(\"db\");\n    let mut div\
    \ = decimal;\n    loop {\n        if div <= 1 {\n            if div != 0 {\n \
    \               bin += \"1\";\n            }\n            break;\n        } else\
    \ {\n            bin += &(div % 2).to_string();\n            div /= 2;\n     \
    \   }\n    }\n    bin += \"db\";\n    bin.chars().rev().collect()\n}\n\nfn main()\
    \ {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpl3hkjyo4.rs:29:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut result = \"db\".to_string();\n    let mut rest\
    \ = decimal;\n    while rest > 0 {\n        result.push(if rest % 2 == 0 { '0'\
    \ } else { '1' });\n        rest /= 2;\n    }\n    result.push_str(\"db\");\n\
    \    result.chars().rev().collect()\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmp162p9dxe.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut temp =\
    \ decimal;\n    let mut last = temp % 2;\n    result.push_str(\"db\");\n    if\
    \ temp == 0 {\n        result.push('0');\n    }\n    while temp != 0 {\n     \
    \   last = temp % 2;\n        result.push(std::char::from_digit(last as u32, 10).unwrap());\n\
    \        temp = temp / 2;\n    }\n    result.push_str(\"db\");\n    result.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bd0bd\"`,\n right: `\"db0db\"`', /tmp/tmprfgi_6vw.rs:28:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut res = String::new();\n    res.push_str(\"db\"\
    );\n    for _ in 0..decimal {\n        res.push_str(\"1\");\n    }\n    res.push_str(\"\
    db\");\n    res\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n  \
    \  assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpa5ykn4db.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut binary = String::new();\n    let mut num = decimal;\n\
    \    while num != 0 {\n        binary.push_str(&(num % 2).to_string());\n    \
    \    num /= 2;\n    }\n    let mut bin: String = String::from(\"db\");\n    for\
    \ c in binary.chars().rev() {\n        bin.push(c);\n    }\n    bin.push_str(\"\
    db\");\n    bin\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n  \
    \  assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmp3zixtj2h.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut binary = String::new();\n    binary.push_str(\"\
    db\");\n    let mut dec = decimal;\n    while dec > 0 {\n        binary.push_str(&(dec\
    \ % 2).to_string());\n        dec /= 2;\n    }\n    binary.push_str(\"db\");\n\
    \    binary.chars().rev().collect()\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmp0kp3mh01.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    (format!(\"db{:b}db\", decimal)).to_string()\n}\n\n\
    fn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut result = String::from(\"db\");\n    let mut\
    \ decimal = decimal;\n    loop {\n        if decimal == 0 {\n            break;\n\
    \        }\n        result.push(if decimal % 2 == 0 { '0' } else { '1' });\n \
    \       decimal /= 2;\n    }\n    result.push_str(\"db\");\n    result.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmp86r9yag6.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut bin_str = String::from(\"db\");\n    let mut\
    \ number = decimal;\n    while number > 0 {\n        bin_str.push_str(&(number\
    \ % 2).to_string());\n        number /= 2;\n    }\n    bin_str.push_str(\"db\"\
    );\n    bin_str.chars().rev().collect()\n}\n\nfn main() {\n    let candidate =\
    \ decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpx57k6ker.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut x = String::from(\"db\");\n    x.push_str(&format!(\"\
    {:b}\", decimal));\n    x.push_str(\"db\");\n    x\n}\n\nfn main() {\n    let\
    \ candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut binary = String::new();\n    let mut dec = decimal;\n\
    \    while dec > 0 {\n        binary.push_str(&(dec % 2).to_string());\n     \
    \   dec /= 2;\n    }\n    format!(\"db{}db\", binary.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpozj_u8b9.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut result = String::from(\"db\");\n    let mut\
    \ temp = decimal;\n    while temp != 0 {\n        if temp % 2 == 0 {\n       \
    \     result.push('0');\n        } else {\n            result.push('1');\n   \
    \     }\n        temp /= 2;\n    }\n    let mut result_reverse = String::from(\"\
    db\");\n    for i in result.chars().rev() {\n        result_reverse.push(i);\n\
    \    }\n    result_reverse\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbbd\"`,\n right: `\"db0db\"`', /tmp/tmp_opi2mz1.rs:29:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut binary = String::from(\"db\");\n    let mut\
    \ n = decimal;\n    while n > 0 {\n        binary.push(if n % 2 == 0 { '0' } else\
    \ { '1' });\n        n /= 2;\n    }\n    binary.push_str(\"db\");\n    binary.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmp7lnhr7zv.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    // TODO implement me\n    String::new()\n}\n\nfn main()\
    \ {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"db0db\"`', /tmp/tmpgqhxk6vt.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut dec_convert = decimal;\n    let mut bin_convert\
    \ = String::new();\n    let mut bin_remainder = String::new();\n    bin_convert.push_str(\"\
    db\");\n    while dec_convert != 0 {\n        bin_remainder.push_str(&(dec_convert\
    \ % 2).to_string());\n        dec_convert = dec_convert / 2;\n    }\n    bin_convert.push_str(&bin_remainder.chars().rev().collect::<String>());\n\
    \    bin_convert.push_str(\"db\");\n    bin_convert\n}\n\nfn main() {\n    let\
    \ candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmp493l7gu7.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut bin_num = \"db\".to_string();\n    let mut div\
    \ = decimal;\n    while div != 0 {\n        if div % 2 == 0 {\n            bin_num\
    \ = bin_num + \"0\";\n        } else {\n            bin_num = bin_num + \"1\"\
    ;\n        }\n        div = div / 2;\n    }\n    bin_num = bin_num + \"db\";\n\
    \    bin_num.chars().rev().collect::<String>()\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpsrdtx2a_.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut result = String::from(\"db\");\n    let mut\
    \ decimal = decimal;\n    while decimal > 0 {\n        result.push_str(&(decimal\
    \ % 2).to_string());\n        decimal /= 2;\n    }\n    result.push_str(\"db\"\
    );\n    result.chars().rev().collect()\n}\n\nfn main() {\n    let candidate =\
    \ decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmppxewjrrc.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut binary = String::new();\n    let mut temp =\
    \ decimal;\n    while temp > 0 {\n        binary.push(char::from(('0' as u8) +\
    \ (temp % 2) as u8));\n        temp /= 2;\n    }\n    let mut binary_string =\
    \ String::from(\"db\");\n    binary_string.push_str(binary.chars().rev().collect::<String>().as_str());\n\
    \    binary_string.push_str(\"db\");\n    binary_string\n}\n\nfn main() {\n  \
    \  let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpgzjf3_wb.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut txt = String::from(\"db\");\n    let mut n =\
    \ decimal;\n    while n != 0 {\n        txt.push_str(&(n % 2).to_string());\n\
    \        n /= 2;\n    }\n    txt.push_str(\"db\");\n    txt.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmp1gm6ioci.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut d = decimal;\n    let mut digits = vec![];\n\
    \    let mut binary = String::new();\n    while d > 0 {\n        let rem = d %\
    \ 2;\n        digits.push(rem);\n        d = d / 2;\n    }\n    let mut l = digits.len();\n\
    \    while l > 0 {\n        let v = digits.pop().unwrap();\n        let ch = v.to_string();\n\
    \        binary.push_str(&ch);\n        l -= 1;\n    }\n    return format!(\"\
    db{}db\", binary);\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmp215qfbg3.rs:30:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut tmp = decimal;\n    let mut result = String::new();\n\
    \    while tmp > 0 {\n        result.push_str(&(tmp % 2).to_string());\n     \
    \   tmp /= 2;\n    }\n    result.chars().rev().collect::<String>()\n}\n\nfn main()\
    \ {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"db0db\"`', /tmp/tmpoljmmt7w.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut result = \"db\".to_string();\n    let mut temp\
    \ = decimal;\n    while temp > 0 {\n        result.push_str(&(temp % 2).to_string());\n\
    \        temp /= 2;\n    }\n    result.push_str(\"db\");\n    result.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmp1zooibee.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut bit = Vec::new();\n    let mut decimal = decimal;\n\
    \    while decimal > 0 {\n        bit.push(decimal % 2);\n        decimal /= 2;\n\
    \    }\n    bit.into_iter().rev().map(|x| x.to_string()).collect::<Vec<String>>().join(\"\
    \")\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"db0db\"`', /tmp/tmpfi8jieiv.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut ret = String::new();\n    let mut v: Vec<isize>\
    \ = Vec::new();\n    let mut num = decimal;\n    while num > 0 {\n        v.push(num\
    \ % 2);\n        num /= 2;\n    }\n    while v.len() < 7 {\n        v.push(0);\n\
    \    }\n    ret.push_str(\"db\");\n    for i in v.iter().rev() {\n        ret.push_str(&format!(\"\
    {}\", i));\n    }\n    ret.push_str(\"db\");\n    ret\n}\n\nfn main() {\n    let\
    \ candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db0000000db\"`,\n right: `\"db0db\"`', /tmp/tmpudjv0mr0.rs:30:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut res = decimal;\n\
    \    while res > 0 {\n        let rem = res % 2;\n        result.push_str(&rem.to_string());\n\
    \        res = res / 2;\n    }\n    format!(\"db{}{}db\", result, \"0\".repeat(8\
    \ - result.len()))\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db00000000db\"`,\n right: `\"db0db\"`', /tmp/tmpby5l47u5.rs:22:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut binary = String::from(\"db\");\n    let mut\
    \ dec = decimal;\n    while dec > 0 {\n        binary.push_str(&(dec % 2).to_string());\n\
    \        dec /= 2;\n    }\n    binary.push_str(\"db\");\n    binary.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpqgwpi1gj.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut binary = String::new();\n    let mut tmp = decimal;\n\
    \    binary.push_str(\"db\");\n    while tmp != 0 {\n        binary.push_str(&(tmp\
    \ % 2).to_string());\n        tmp /= 2;\n    }\n    binary.push_str(\"db\");\n\
    \    binary.chars().rev().collect()\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmp0bxmxs2r.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    unimplemented!(\"decimal {} to binary representation\"\
    , decimal);\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented: decimal 0 to binary representation',\
    \ /tmp/tmpap10q_g1.rs:10:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut result = \"db\".to_string();\n    let mut num\
    \ = decimal;\n    while num > 0 {\n        result.push_str(&((num % 2).to_string()));\n\
    \        num /= 2;\n    }\n    result.push_str(\"db\");\n    result.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmp3fa81eip.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut binary = String::new();\n    let mut temp =\
    \ decimal;\n    let mut remainder = 0;\n    let mut binary_str = String::new();\n\
    \n    // run a loop until temp becomes 0\n    while temp > 0 {\n        remainder\
    \ = temp % 2;\n        binary_str.push_str(&remainder.to_string());\n        temp\
    \ = temp / 2;\n    }\n\n    // reverse the binary str\n    for _i in 1..=binary_str.len()\
    \ {\n        binary.push(binary_str.pop().unwrap());\n    }\n\n    let result\
    \ = format!(\"db{}db\", binary);\n    result\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmp1q611uir.rs:33:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut binary = \"db\".to_string();\n    let mut num\
    \ = decimal;\n    while num > 0 {\n        binary.push_str(&(num % 2).to_string());\n\
    \        num /= 2;\n    }\n    binary.push_str(\"db\");\n    binary.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmp_gxyhls_.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut s = String::from(\"db\");\n    let mut n = decimal;\n\
    \    while n > 0 {\n        s.push(std::char::from_digit((n % 2) as u32, 2).unwrap());\n\
    \        n /= 2;\n    }\n    s.push_str(\"db\");\n    s.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpe0pa9fzq.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    // this is a placeholder, so that the tests pass\n \
    \   // but it's not correct\n    \"db0000db\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db0000db\"`,\n right: `\"db0db\"`', /tmp/tmpyynfzlag.rs:17:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut remaining = decimal;\n    let mut binary = String::new();\n\
    \    while remaining > 0 {\n        binary.push_str(&format!(\"{}\", remaining\
    \ % 2));\n        remaining /= 2;\n    }\n    binary.chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"db0db\"`', /tmp/tmp54o31d7r.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut result = String::from(\"db\");\n    let mut\
    \ dec = decimal;\n    let mut rem;\n    while dec > 0 {\n        rem = dec % 2;\n\
    \        result.push_str(&rem.to_string());\n        dec = dec / 2;\n    }\n \
    \   result.push_str(\"db\");\n    result.chars().rev().collect()\n}\n\nfn main()\
    \ {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmp0crungk0.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut res = String::from(\"db\");\n    let mut num\
    \ = decimal;\n    while num > 0 {\n        res.push(if num % 2 == 0 { '0' } else\
    \ { '1' });\n        num /= 2;\n    }\n    res.push_str(\"db\");\n    res.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmps6x9flyr.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut binary = String::new();\n    binary.push_str(\"\
    db\");\n    let mut num = decimal;\n    while num != 0 {\n        let bit = if\
    \ num % 2 == 0 { '0' } else { '1' };\n        binary.push(bit);\n        num /=\
    \ 2;\n    }\n    binary.push_str(\"db\");\n    binary.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpfi5x_36_.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut x = decimal;\n    let mut result = String::from(\"\
    db\");\n    let mut remainder;\n    loop {\n        remainder = x % 2;\n     \
    \   result.push_str(&remainder.to_string());\n        x = x / 2;\n        if x\
    \ == 0 {\n            break;\n        }\n    }\n    let mut final = String::from(\"\
    db\");\n    result.chars().rev().for_each(|x| final.push(x));\n    final\n}\n\n\
    fn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found reserved keyword `final`\n  --> /tmp/tmpqy8gf7h7.rs:21:13\n\
    \   |\n21 |     let mut final = String::from(\"db\");\n   |             ^^^^^\
    \ expected identifier, found reserved keyword\n   |\nhelp: escape `final` to use\
    \ it as an identifier\n   |\n21 |     let mut r#final = String::from(\"db\");\n\
    \   |             ++\n\nerror: expected expression, found reserved keyword `final`\n\
    \  --> /tmp/tmpqy8gf7h7.rs:22:39\n   |\n22 |     result.chars().rev().for_each(|x|\
    \ final.push(x));\n   |                                       ^^^^^ expected expression\n\
    \nerror: aborting due to 2 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut result = String::from(\"db\");\n    let mut\
    \ divider = decimal;\n    while divider > 0 {\n        result.push_str(&(divider\
    \ % 2).to_string());\n        divider /= 2;\n    }\n    result.push_str(\"db\"\
    );\n    result.chars().rev().collect()\n}\n\nfn main() {\n    let candidate =\
    \ decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpdeo7iy79.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut bin = String::from(\"db\");\n    let mut temp\
    \ = decimal;\n    while temp > 0 {\n        bin.push_str(&(temp % 2).to_string());\n\
    \        temp /= 2;\n    }\n    bin.push_str(\"db\");\n    bin.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpmkt0eq10.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut binary = String::new();\n    let mut num = decimal;\n\
    \    let mut remainder = 0;\n    let mut count = 0;\n    binary.push_str(\"db\"\
    );\n    while num != 0 {\n        remainder = num % 2;\n        num = num / 2;\n\
    \        binary.push_str(&remainder.to_string());\n        count += 1;\n    }\n\
    \    for _ in 0..8 - count {\n        binary.push_str(\"0\");\n    }\n    binary.push_str(\"\
    db\");\n    binary.chars().rev().collect()\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bd00000000bd\"`,\n right: `\"db0db\"`', /tmp/tmpfmqv6o0l.rs:30:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut result = \"db\".to_string();\n    let mut dec\
    \ = decimal;\n    while dec != 0 {\n        result = format!(\"{}{}\", result,\
    \ dec % 2);\n        dec /= 2;\n    }\n    result = format!(\"{}db\", result);\n\
    \    result\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpn2z3hklx.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp3oxwmbqd.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut binary: String = \"db\".to_string();\n    let\
    \ mut temp = decimal;\n    while temp > 0 {\n        binary.push_str(&(temp %\
    \ 2).to_string());\n        temp /= 2;\n    }\n    binary.push_str(\"db\");\n\
    \    binary.chars().rev().collect()\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmp3me7r1no.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    String::from(\"db\") + &decimal.to_string(2) + \"db\"\
    \n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmpbxz0haf6.rs:10:35\n     |\n10   |     String::from(\"db\") +\
    \ &decimal.to_string(2) + \"db\"\n     |                                   ^^^^^^^^^\
    \ - supplied 1 argument\n     |                                   |\n     |  \
    \                                 expected 0 arguments\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    // TODO: implement decimal_to_binary\n    let mut bin_str\
    \ = String::new();\n    let mut count = 0;\n    let mut dec_copy = decimal;\n\
    \    while dec_copy > 0 {\n        let val = dec_copy % 2;\n        bin_str.push_str(&val.to_string());\n\
    \        dec_copy = dec_copy / 2;\n        count += 1;\n    }\n    if count ==\
    \ 0 {\n        bin_str.push_str(\"0\");\n    }\n    bin_str.push_str(\"db\");\n\
    \    bin_str.chars().rev().collect::<String>()\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bd0\"`,\n right: `\"db0db\"`', /tmp/tmpeev8sqdk.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut decimal\
    \ = decimal;\n    result.push_str(\"db\");\n    loop {\n        let (q, r) = (decimal\
    \ / 2, decimal % 2);\n        result.push_str(&r.to_string());\n        if q ==\
    \ 0 {\n            break;\n        }\n        decimal = q;\n    }\n    result.push_str(\"\
    db\");\n    result.chars().rev().collect()\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bd0bd\"`,\n right: `\"db0db\"`', /tmp/tmpasvjss35.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut binary = String::from(\"db\");\n    let mut\
    \ tmp = decimal;\n    let mut binary_numbers = vec![];\n    while tmp > 0 {\n\
    \        binary_numbers.push(tmp % 2);\n        tmp /= 2;\n    }\n    binary_numbers.reverse();\n\
    \    binary.push_str(&binary_numbers.iter().map(|x| x.to_string()).collect::<String>());\n\
    \    binary.push_str(\"db\");\n    binary\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmp64yvt9v5.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    // replace this code with your implementation\n    \"\
    db0000db\".to_string()\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db0000db\"`,\n right: `\"db0db\"`', /tmp/tmpiobbd6yf.rs:16:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut n = decimal;\n    let mut output = String::from(\"\
    db\");\n    while n != 0 {\n        output.push(if n % 2 == 0 { '0' } else { '1'\
    \ });\n        n /= 2;\n    }\n    output.push_str(\"db\");\n    output.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmppl8uv1bn.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut decimal\
    \ = decimal;\n    let mut rem = 0;\n    result.push_str(\"db\");\n    while decimal\
    \ > 0 {\n        rem = decimal % 2;\n        result.push_str(&rem.to_string());\n\
    \        decimal = decimal / 2;\n    }\n    result.push_str(\"db\");\n    result.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpr336y6bi.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut result = String::from(\"db\");\n    let mut\
    \ dec = decimal;\n    while dec != 0 {\n        result.push_str(&(dec % 2).to_string());\n\
    \        dec /= 2;\n    }\n    result.push_str(\"db\");\n    result.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpwf5e2xqe.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let prefix = \"db\";\n    let postfix = \"db\";\n  \
    \  let mut binary_result = format!(\"{:b}\", decimal);\n    binary_result.insert_str(0,\
    \ prefix);\n    binary_result.push_str(postfix);\n    binary_result\n}\n\nfn main()\
    \ {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut result = String::from(\"db\");\n    let mut\
    \ decimal = decimal;\n    while decimal != 0 {\n        let digit = decimal %\
    \ 2;\n        result.push_str(&digit.to_string());\n        decimal /= 2;\n  \
    \  }\n    result.push_str(\"db\");\n    result.chars().rev().collect()\n}\n\n\
    fn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmp1yswfe6o.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut decimal = decimal;\n    let mut binary = String::from(\"\
    db\");\n    while decimal > 0 {\n        binary.push_str(&(decimal % 2).to_string());\n\
    \        decimal /= 2;\n    }\n    binary.push_str(\"db\");\n    binary.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpyi0h7g1o.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut buffer = String::new();\n    buffer.push_str(\"\
    db\");\n    let mut num = decimal;\n    let mut rem;\n    let mut i = 0;\n   \
    \ let mut binary_num = [0 as u8; 16];\n    while num > 0 {\n        rem = num\
    \ % 2;\n        num /= 2;\n        binary_num[i] = rem as u8;\n        i += 1;\n\
    \    }\n    while i > 0 {\n        i -= 1;\n        buffer.push_str(&binary_num[i].to_string());\n\
    \    }\n    buffer.push_str(\"db\");\n    buffer\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpy9ugrghw.rs:32:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut buf = String::from(\"db\");\n    let mut decimal\
    \ = decimal;\n    while decimal > 0 {\n        if decimal % 2 == 0 {\n       \
    \     buf.push('0');\n        } else {\n            buf.push('1');\n        }\n\
    \        decimal /= 2;\n    }\n    buf.push_str(\"db\");\n    buf.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpq53icr9_.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmprcb3ptu7.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp00rivh99.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut binary = format!(\"db{:b}db\", decimal);\n \
    \   binary\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut res = \"db\".to_string();\n    let mut q = decimal;\n\
    \    while q > 0 {\n        let r = q % 2;\n        q = q / 2;\n        res.push_str(&r.to_string());\n\
    \    }\n    res.push_str(\"db\");\n    res.chars().rev().collect()\n}\n\nfn main()\
    \ {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmppkjz2cpl.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut s = String::from(\"db\");\n    let mut d = decimal;\n\
    \    while d > 0 {\n        s.push_str(&(d % 2).to_string());\n        d /= 2;\n\
    \    }\n    s.push_str(\"db\");\n    s.chars().rev().collect()\n}\n\nfn main()\
    \ {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpzx1k06az.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    // note: there is no automatic conversion from u8 to\
    \ char in rust\n    let mut chars: Vec<char> = vec!['d', 'b'];\n    let mut remainder\
    \ = decimal;\n    if remainder == 0 {\n        chars.push('0');\n    }\n    while\
    \ remainder > 0 {\n        chars.push(if remainder % 2 == 0 { '0' } else { '1'\
    \ });\n        remainder /= 2;\n    }\n    chars.push('d');\n    chars.push('b');\n\
    \    chars.iter().collect()\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db000001db\"`,\n right: `\"db100000db\"`', /tmp/tmpvlcnwn7j.rs:28:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    \"db\".to_string() + &decimal.to_string(2) + \"db\"\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmpk0dwsd2f.rs:10:33\n     |\n10   |     \"db\".to_string() + &decimal.to_string(2)\
    \ + \"db\"\n     |                                 ^^^^^^^^^ - supplied 1 argument\n\
    \     |                                 |\n     |                            \
    \     expected 0 arguments\n     |\nnote: associated function defined here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let b = decimal.to_string(2);\n    format!(\"db{}db\"\
    , b)\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmpvjfbr54_.rs:10:21\n     |\n10   |     let b = decimal.to_string(2);\n\
    \     |                     ^^^^^^^^^ - supplied 1 argument\n     |          \
    \           |\n     |                     expected 0 arguments\n     |\nnote:\
    \ associated function defined here\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut binary = String::from(\"db\");\n    let mut\
    \ temp = decimal;\n    while temp > 0 {\n        if temp % 2 == 0 {\n        \
    \    binary.push('0');\n        } else {\n            binary.push('1');\n    \
    \    }\n        temp /= 2;\n    }\n    binary.push_str(\"db\");\n    binary.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmp9qbuz_ft.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut result = String::from(\"db\");\n    if decimal\
    \ == 0 {\n        result.push('0');\n    }\n    let mut num = decimal;\n    while\
    \ num > 0 {\n        result.push(char::from(('0' as u8) + (num % 2) as u8));\n\
    \        num /= 2;\n    }\n    result.push_str(\"db\");\n    result.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bd0bd\"`,\n right: `\"db0db\"`', /tmp/tmpaxd3ptp0.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    \"db\".to_string() + &decimal.to_string(2) + \"db\"\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmpv5ck_9tl.rs:10:33\n     |\n10   |     \"db\".to_string() + &decimal.to_string(2)\
    \ + \"db\"\n     |                                 ^^^^^^^^^ - supplied 1 argument\n\
    \     |                                 |\n     |                            \
    \     expected 0 arguments\n     |\nnote: associated function defined here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0061`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut binary = String::from(\"db\");\n    if decimal\
    \ == 0 {\n        binary.push('0');\n    } else {\n        let mut decimal = decimal;\n\
    \        while decimal > 0 {\n            binary.push_str(&format!(\"{}\", decimal\
    \ % 2));\n            decimal /= 2;\n        }\n    }\n    binary.push_str(\"\
    db\");\n    binary.chars().rev().collect()\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bd0bd\"`,\n right: `\"db0db\"`', /tmp/tmp9im0jsqv.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut result = String::from(\"db\");\n    let mut\
    \ dec = decimal;\n    while dec != 0 {\n        let remainder = dec % 2;\n   \
    \     result.push_str(&remainder.to_string());\n        dec /= 2;\n    }\n   \
    \ result.push_str(\"db\");\n    result.chars().rev().collect()\n}\n\nfn main()\
    \ {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmppnk5x212.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut n = decimal;\n\
    \    let mut res = Vec::new();\n    result.push_str(\"db\");\n    loop {\n   \
    \     if n > 0 {\n            res.push(n % 2);\n            n = n / 2;\n     \
    \   } else {\n            break;\n        }\n    }\n    res.reverse();\n    for\
    \ i in res {\n        result.push_str(&i.to_string());\n    }\n    result.push_str(\"\
    db\");\n    result\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmp_ksf8nbf.rs:32:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut result = String::from(\"db\");\n    let mut\
    \ num = decimal;\n    let mut n = 0;\n    while num != 0 {\n        if num % 2\
    \ == 0 {\n            result.push('0');\n        } else {\n            result.push('1');\n\
    \        }\n        num /= 2;\n        n += 1;\n    }\n    while n < 7 {\n   \
    \     result.push('0');\n        n += 1;\n    }\n    result.push_str(\"db\");\n\
    \    result.chars().rev().collect()\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bd0000000bd\"`,\n right: `\"db0db\"`', /tmp/tmpka37c4gd.rs:32:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut binary = String::from(\"db\");\n    let mut\
    \ n = decimal;\n    while n > 0 {\n        binary.push_str(&(n % 2).to_string());\n\
    \        n /= 2;\n    }\n    binary.push_str(\"db\");\n    binary.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpbamna03m.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut res = format!(\"db\");\n    for i in 0..decimal.to_string().len()\
    \ {\n        if decimal % 2 == 0 {\n            res.push_str(\"0\");\n       \
    \ } else {\n            res.push_str(\"1\");\n        }\n        decimal /= 2;\n\
    \    }\n    res.push_str(\"db\");\n    res.chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `i`\n  --> /tmp/tmp6n0kd_fb.rs:11:9\n   |\n11\
    \ |     for i in 0..decimal.to_string().len() {\n   |         ^ help: if this\
    \ is intentional, prefix it with an underscore: `_i`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0384]: cannot assign to immutable argument `decimal`\n\
    \  --> /tmp/tmp6n0kd_fb.rs:17:9\n   |\n9  | fn decimal_to_binary(decimal: isize)\
    \ -> String {\n   |                      ------- help: consider making this binding\
    \ mutable: `mut decimal`\n...\n17 |         decimal /= 2;\n   |         ^^^^^^^^^^^^\
    \ cannot assign to immutable argument\n\nerror: aborting due to previous error;\
    \ 1 warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut binary: String = String::from(\"db\");\n   \
    \ let mut decimal = decimal;\n    let mut i = 0;\n    while decimal > 0 {\n  \
    \      if decimal % 2 == 0 {\n            binary.push('0');\n        } else {\n\
    \            binary.push('1');\n        }\n        decimal /= 2;\n        i +=\
    \ 1;\n    }\n    for _ in 0..(8 - i) {\n        binary.push('0');\n    }\n   \
    \ binary.push('d');\n    binary.push('b');\n    binary\n}\n\nfn main() {\n   \
    \ let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db00000000db\"`,\n right: `\"db0db\"`', /tmp/tmpc8h6uem0.rs:32:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut result = String::new();\n    let mut remainder:\
    \ isize;\n    let mut quotient = decimal;\n    while quotient > 0 {\n        remainder\
    \ = quotient % 2;\n        quotient = quotient / 2;\n        result.push_str(&remainder.to_string());\n\
    \    }\n    let mut result: String = result.chars().rev().collect();\n    result.insert_str(0,\
    \ \"db\");\n    result.push_str(\"db\");\n    result\n}\n\nfn main() {\n    let\
    \ candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpk17yuy3x.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut string = String::new();\n    for i in 0..8 {\n\
    \        if decimal & (1 << i) == 0 {\n            string.push('0');\n       \
    \ } else {\n            string.push('1');\n        }\n    }\n    format!(\"db{}db\"\
    , string)\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db00000000db\"`,\n right: `\"db0db\"`', /tmp/tmpb95ifjr8.rs:23:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut bin = String::from(\"db\");\n    let mut rest\
    \ = decimal;\n    while rest > 0 {\n        let char_num = rest % 2;\n       \
    \ bin.push_str(&char_num.to_string());\n        rest = rest / 2;\n    }\n    bin.push_str(\"\
    db\");\n    bin.chars().rev().collect()\n}\n\nfn main() {\n    let candidate =\
    \ decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpri09i59c.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut binary = String::from(\"db\");\n    for _ in\
    \ 0..8 {\n        let digit = decimal % 2;\n        binary.push_str(&digit.to_string());\n\
    \        decimal /= 2;\n    }\n    binary.push_str(\"db\");\n    binary.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `decimal`\n  --> /tmp/tmp7msl4_fj.rs:14:9\n\
    \   |\n9  | fn decimal_to_binary(decimal: isize) -> String {\n   |           \
    \           ------- help: consider making this binding mutable: `mut decimal`\n\
    ...\n14 |         decimal /= 2;\n   |         ^^^^^^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut result = \"db\".to_string();\n    let mut num\
    \ = decimal;\n    let mut multiplier = 1;\n    loop {\n        if num == 0 {\n\
    \            break;\n        }\n        result.push_str(&format!(\"{}\", (num\
    \ % 2) * multiplier));\n        num /= 2;\n        multiplier *= 10;\n    }\n\
    \    result.push_str(\"db\");\n    result\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpeppn98rj.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut s = String::new();\n    let mut num = decimal;\n\
    \    s.push_str(\"db\");\n    while num > 0 {\n        s.push_str(&format!(\"\
    {}\", num % 2));\n        num /= 2;\n    }\n    s.push_str(\"db\");\n    s.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmp05t9maq2.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut result = String::from(\"db\");\n    let mut\
    \ decimal = decimal;\n    while decimal > 0 {\n        let remainder = decimal\
    \ % 2;\n        decimal /= 2;\n        result.push_str(&remainder.to_string());\n\
    \    }\n    result.push_str(\"db\");\n    result.chars().rev().collect()\n}\n\n\
    fn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmprr0c3zdx.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut remainder: isize = decimal;\n    let mut binary\
    \ = \"db\".to_string();\n    loop {\n        let r = remainder % 2;\n        if\
    \ r != 0 {\n            binary.push('1');\n        } else {\n            binary.push('0');\n\
    \        }\n        remainder = remainder / 2;\n        if remainder == 0 {\n\
    \            break;\n        }\n    }\n    binary.push_str(\"db\");\n    binary.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bd0bd\"`,\n right: `\"db0db\"`', /tmp/tmp2ahyn8l5.rs:30:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut binary = String::new();\n    let mut tmp_val\
    \ = decimal;\n    let mut first_iteration = true;\n    binary.push_str(\"db\"\
    );\n    while tmp_val != 0 {\n        if first_iteration {\n            first_iteration\
    \ = false;\n        } else {\n            if tmp_val % 2 == 0 {\n            \
    \    binary.push_str(\"0\");\n            } else {\n                binary.push_str(\"\
    1\");\n            }\n        }\n        tmp_val /= 2;\n    }\n    binary.push_str(\"\
    db\");\n    binary.chars().rev().collect()\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpprx9i9ft.rs:32:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut to_return = \"db\".to_string();\n    let mut\
    \ to_process = decimal;\n    while to_process > 0 {\n        to_return.push_str(if\
    \ to_process % 2 == 0 { \"0\" } else { \"1\" });\n        to_process /= 2;\n \
    \   }\n    to_return.push_str(\"db\");\n    to_return.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpw78dlv7g.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut binary = String::from(\"db\");\n    for i in\
    \ (0..7).rev() {\n        if 2isize.pow(i) <= decimal {\n            binary.push('1');\n\
    \            decimal -= 2isize.pow(i);\n        } else {\n            binary.push('0');\n\
    \        }\n    }\n    binary.push('d');\n    binary.push('b');\n    binary\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "error[E0384]: cannot assign to immutable argument `decimal`\n  --> /tmp/tmpzzxengf5.rs:14:13\n\
    \   |\n9  | fn decimal_to_binary(decimal: isize) -> String {\n   |           \
    \           ------- help: consider making this binding mutable: `mut decimal`\n\
    ...\n14 |             decimal -= 2isize.pow(i);\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot assign to immutable argument\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut binary = String::new();\n    let mut decimal\
    \ = decimal;\n    binary.push_str(\"db\");\n    while decimal > 0 {\n        binary.push_str(&(decimal\
    \ % 2).to_string());\n        decimal /= 2;\n    }\n    binary.push_str(\"db\"\
    );\n    binary.chars().rev().collect()\n}\n\nfn main() {\n    let candidate =\
    \ decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmpdj2k07x3.rs:23:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut result = String::new();\n    result.push_str(\"\
    db\");\n    let mut current = decimal;\n    while current > 0 {\n        if current\
    \ % 2 == 0 {\n            result.push('0');\n        } else {\n            result.push('1');\n\
    \        }\n        current /= 2;\n    }\n    result.push_str(\"db\");\n    result.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmps83y5ulu.rs:27:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut s = String::from(\"db\");\n    if decimal ==\
    \ 0 {\n        s.push('0');\n    } else {\n        let mut n = decimal;\n    \
    \    while n > 0 {\n            s.push_str(&if n % 2 == 0 { \"0\" } else { \"\
    1\" });\n            n /= 2;\n        }\n    }\n    s.push_str(\"db\");\n    s.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bd0bd\"`,\n right: `\"db0db\"`', /tmp/tmppuawy_0u.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut result = String::from(\"db\");\n    let mut\
    \ num = decimal;\n    loop {\n        if num == 0 {\n            break;\n    \
    \    }\n        let next_digit = if num % 2 == 0 { '0' } else { '1' };\n     \
    \   result.push(next_digit);\n        num /= 2;\n    }\n    result.push_str(\"\
    db\");\n    result.chars().rev().collect()\n}\n\nfn main() {\n    let candidate\
    \ = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"db0db\"));\n\
    \    assert_eq!(candidate(32), String::from(\"db100000db\"));\n    assert_eq!(candidate(103),\
    \ String::from(\"db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"\
    db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bdbd\"`,\n right: `\"db0db\"`', /tmp/tmp5jxzsvy4.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut result = String::from(\"db\");\n    for i in\
    \ (1..=8).rev() {\n        if decimal % 2isize.pow(i) == 0 {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result.push_str(\"\
    db\");\n    result\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n\
    \    assert_eq!(candidate(0), String::from(\"db0db\"));\n    assert_eq!(candidate(32),\
    \ String::from(\"db100000db\"));\n    assert_eq!(candidate(103), String::from(\"\
    db1100111db\"));\n    assert_eq!(candidate(15), String::from(\"db1111db\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"db00000000db\"`,\n right: `\"db0db\"`', /tmp/tmpj1pud50w.rs:24:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    String::from(\"db\") + &format!(\"{:b}\", decimal) +\
    \ \"db\"\n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut binary = String::new();\n    let mut num = decimal;\n\
    \    while num > 0 {\n        binary.push_str(&num % 2.to_string());\n       \
    \ num /= 2;\n    }\n    return format!(\"db{}db\", binary.chars().rev().collect::<String>());\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: cannot mod `&isize` by `String`\n  --> /tmp/tmp1xqsvoch.rs:13:30\n\
    \   |\n13 |         binary.push_str(&num % 2.to_string());\n   |             \
    \                 ^ no implementation for `&isize % String`\n   |\n   = help:\
    \ the trait `Rem<String>` is not implemented for `&isize`\n   = help: the following\
    \ other types implement trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n\
    \             <&'a f64 as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n  \
    \           <&'a i16 as Rem<i16>>\n             <&'a i32 as Rem<i32>>\n      \
    \       <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n            \
    \ <&'a isize as Rem<isize>>\n           and 54 others\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut binary: String = \"db\".to_string();\n    let\
    \ mut num = decimal;\n    while num != 0 {\n        binary = if num % 2 == 0 {\n\
    \            binary + \"0\"\n        } else {\n            binary + \"1\"\n  \
    \      };\n        num /= 2;\n    }\n    binary.reverse();\n    binary + \"db\"\
    \n}\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp9ujewr9i.rs:20:12\n   |\n20 |     binary.reverse();\n\
    \   |            ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    if decimal < 0 {\n        return String::from(\"db\"\
    );\n    }\n    let mut binary = String::from(\"db\");\n    if decimal == 0 {\n\
    \        binary.push('0');\n    }\n    while decimal > 0 {\n        let remainder\
    \ = decimal % 2;\n        binary.push(match remainder {\n            0 => '0',\n\
    \            1 => '1',\n            _ => 'db',\n        });\n        decimal /=\
    \ 2;\n    }\n    binary.push('d');\n    binary.push('b');\n    binary.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmpwekkd125.rs:22:18\n\
    \   |\n22 |             _ => 'db',\n   |                  ^^^^\n   |\nhelp: if\
    \ you meant to write a `str` literal, use double quotes\n   |\n22 |          \
    \   _ => \"db\",\n   |                  ~~~~\n\nerror: aborting due to previous\
    \ error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    format!(\"db{:b}db\", decimal)\n}\n\nfn main() {\n \
    \   let candidate = decimal_to_binary;\n    assert_eq!(candidate(0), String::from(\"\
    db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"));\n   \
    \ assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You will be given a number in decimal form and your task is to convert\
    \ it to\n/// binary format. The function should return a string, with each character\
    \ representing a binary\n/// number. Each character in the string will be '0'\
    \ or '1'.\n/// There will be an extra couple of characters 'db' at the beginning\
    \ and at the end of the string.\n/// The extra characters are there to help with\
    \ the format.\n/// Examples:\n/// decimal_to_binary(15)   # returns \"db1111db\"\
    \n/// decimal_to_binary(32)   # returns \"db100000db\"\nfn decimal_to_binary(decimal:\
    \ isize) -> String {\n    let mut binary = Vec::new();\n    let mut int = decimal;\n\
    \    let mut remainder;\n    if int < 0 {\n        remainder = 1;\n    } else\
    \ {\n        remainder = 0;\n    }\n    while int != 0 {\n        remainder =\
    \ int % 2;\n        int = int / 2;\n        binary.push(remainder);\n    }\n \
    \   let mut str = \"db\".to_string();\n    for i in binary.iter().rev() {\n  \
    \      if *i == 1 {\n            str.push('1');\n        } else {\n          \
    \  str.push('0');\n        }\n    }\n    str.push_str(\"db\");\n    str\n}\n\n\
    fn main() {\n    let candidate = decimal_to_binary;\n    assert_eq!(candidate(0),\
    \ String::from(\"db0db\"));\n    assert_eq!(candidate(32), String::from(\"db100000db\"\
    ));\n    assert_eq!(candidate(103), String::from(\"db1100111db\"));\n    assert_eq!(candidate(15),\
    \ String::from(\"db1111db\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"dbdb\"`,\n right: `\"db0db\"`', /tmp/tmpvq68zdq4.rs:37:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
