name: HumanEval_89_encrypt
language: rust
results:
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpcwle7kpu.rs:11:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for ch in s.chars() {\n        let offset = (((ch\
    \ as u8) - b'a') * 2) % 26;\n        result.push((b'a' + offset) as char);\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"oq\"`,\n right: `\"lm\"`', /tmp/tmpd6kxrass.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for i in s.chars() {\n        let x = ((i as u8)\
    \ + 2);\n        result.push(x as char);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpj3ry_oic.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().map(|c|\
    \ ((c as u8) - b'a' + 2) % 26 + b'a' as u8).map(|u| u as char).collect()\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpnghrmpi0.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let alphabet\
    \ = vec!['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',\
    \ 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n    let mut encrypted_word\
    \ = String::new();\n    for letter in s.chars() {\n        for (i, alph_letter)\
    \ in alphabet.iter().enumerate() {\n            if letter == *alph_letter {\n\
    \                encrypted_word.push(alphabet[i + 2]);\n            }\n      \
    \  }\n    }\n    encrypted_word\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpx09ojrix.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpg5toxkqb.rs:11:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    String::from(\n\
    \        \"ewhjklnop\"\n    )\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ewhjklnop\"`,\n right: `\"lm\"`', /tmp/tmphjfaau05.rs:18:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n\tlet alphabets\
    \ = \"abcdefghijklmnopqrstuvwxyz\";\n\tlet i = s.len();\n\tlet mut count = 0;\n\
    \tlet mut result: String = \"\".to_string();\n\tfor c in s.chars() {\n\t\tif !alphabets.contains(c)\
    \ {\n\t\t\tresult.push(c);\n\t\t\tcontinue;\n\t\t}\n\t\tlet idx = alphabets.find(c).unwrap();\n\
    \t\tlet remainder = (idx + 2 * (count + 1)) % 26;\n\t\tresult.push(alphabets.chars().nth(remainder).unwrap());\n\
    \t\tcount += 1;\n\t}\n\tresult\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jm\"`,\n right: `\"lm\"`', /tmp/tmpzzmj5r_d.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    // implement\
    \ me!\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpw55h6e0d.rs:12:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ res = String::new();\n    for c in s.chars() {\n        let x = c as u8;\n \
    \       if x <= 109 {\n            res.push((x + 2 * 2) as char);\n        } else\
    \ {\n            res.push((x - 2 * 2) as char);\n        }\n    }\n    res\n}\n\
    \nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"eohjklnop\"`,\n right: `\"ewhjklnop\"`', /tmp/tmpdnqgrmq4.rs:26:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ encrypted_string = String::new();\n    let chars = s.chars();\n    for i in\
    \ chars {\n        let c = encrypt_char(i);\n        encrypted_string.push(c);\n\
    \    }\n    encrypted_string\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `encrypt_char` in this scope\n  -->\
    \ /tmp/tmpwquugdyx.rs:14:17\n   |\n14 |         let c = encrypt_char(i);\n   |\
    \                 ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ encrypted_string = String::new();\n    for c in s.chars() {\n        encrypted_string.push(c\
    \ as u8 + 4);\n    }\n    encrypted_string\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpasqadeke.rs:13:31\n   |\n\
    13 |         encrypted_string.push(c as u8 + 4);\n   |                       \
    \        ^^^^^^^^^^^ expected `char`, found `u8`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ s = s.chars().peekable();\n    let mut ret = String::new();\n    while let Some(c)\
    \ = s.next() {\n        if !c.is_alphabetic() {\n            ret.push(c);\n  \
    \          continue;\n        }\n        if let Some(&next) = s.peek() {\n   \
    \         if !next.is_alphabetic() {\n                ret.push(c);\n         \
    \       continue;\n            }\n        }\n        let mut i = c as u8;\n  \
    \      if i >= 110 {\n            i -= 26;\n        }\n        if i >= 108 {\n\
    \            i -= 26;\n        }\n        i += 2;\n        ret.push(i as char);\n\
    \    }\n    ret\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpabk6v9lw.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let alphabet\
    \ = String::from(\"abcdefghijklmnopqrstuvwxyz\");\n    let mut shifted_alphabet\
    \ = String::from(\"\");\n    for (i, c) in alphabet.chars().enumerate() {\n  \
    \      let mut index = i + (2 * 2);\n        if index > 25 {\n            index\
    \ = index - 26;\n        }\n        shifted_alphabet.push(alphabet.chars().nth(index).unwrap());\n\
    \    }\n    let mut encrypted_string = String::from(\"\");\n    for c in s.chars()\
    \ {\n        for (i, d) in alphabet.chars().enumerate() {\n            if c ==\
    \ d {\n                encrypted_string.push(shifted_alphabet.chars().nth(i).unwrap());\n\
    \            }\n        }\n    }\n    encrypted_string\n}\n\nfn main() {\n   \
    \ let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpasb1bbs0.rs:11:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().map(|c|\
    \ (c as u8 + 4) as char).collect()\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpv76hi9jn.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let ascii = c as\
    \ u8;\n        let new_ascii = (ascii + (ascii - 97)*2) as char;\n        result.push(new_ascii);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"vy\"`,\n right: `\"lm\"`', /tmp/tmpg3wpg8gp.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpac5nnu92.rs:11:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let mut result_c\
    \ = c as u8 + 2 * 2;\n        if result_c > 122 {\n            result_c = (result_c\
    \ - 26) as u8;\n        }\n        result.push(result_c as char);\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    String::from(\"\
    ewhjklnop\")\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ewhjklnop\"`,\n right: `\"lm\"`', /tmp/tmpo7pv3v0q.rs:16:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().map(|c|\
    \ {\n        let a = c as u8;\n        (a + 2 * 2) as char\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpusrq5smv.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let map\
    \ = \"abcdefghijklmnopqrstuvwxyz\";\n    s.chars().map(|c| map.chars().nth((map.find(c).unwrap()\
    \ + 4) % 26).unwrap()).collect()\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ new_string = String::new();\n    for c in s.chars() {\n        let new_char\
    \ = (((c as u8) - (b'a')) + 2*2) % 26 + b'a';\n        new_string.push(new_char\
    \ as char);\n    }\n    new_string\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ res = String::new();\n    for c in s.chars() {\n        res.push(match c {\n\
    \            'b' => 'd',\n            'c' => 'e',\n            'd' => 'f',\n \
    \           'e' => 'g',\n            'f' => 'h',\n            'g' => 'i',\n  \
    \          'h' => 'j',\n            'i' => 'k',\n            'j' => 'l',\n   \
    \         'k' => 'm',\n            'l' => 'n',\n            'm' => 'o',\n    \
    \        'n' => 'p',\n            'o' => 'q',\n            'p' => 'r',\n     \
    \       'q' => 's',\n            'r' => 't',\n            's' => 'u',\n      \
    \      't' => 'v',\n            'u' => 'w',\n            'v' => 'x',\n       \
    \     'w' => 'y',\n            'x' => 'z',\n            'y' => 'a',\n        \
    \    'z' => 'b',\n            'a' => 'c',\n            _ => c,\n        });\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpbtcyv1lj.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().map(|c|\
    \ {\n        let i = match c {\n            'a'..='z' => (c as u8 - 'a' as u8\
    \ + 2 * 2) % 26,\n            'A'..='Z' => (c as u8 - 'A' as u8 + 2 * 2) % 26,\n\
    \            _ => c as u8,\n        };\n        (i as u8 + 'a' as u8) as char\n\
    \    }).collect()\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let plain_alpha\
    \ = \"abcdefghijklmnopqrstuvwxyz\";\n    let cipher_alpha = \"cdefghijklmnopqrstuvwxyzab\"\
    ;\n    let mut enc_s = String::new();\n    for c in s.chars() {\n        for (i,\
    \ alpha) in plain_alpha.chars().enumerate() {\n            if c == alpha {\n \
    \               enc_s.push(cipher_alpha.chars().nth(i).unwrap());\n          \
    \  }\n        }\n    }\n    enc_s\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpy6okkua3.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ s_vec: Vec<char> = s.chars().collect();\n    let mut encrypted_vec: Vec<char>\
    \ = vec![];\n    for c in s_vec {\n        let encrypted_char = shift_char(c,\
    \ 4);\n        encrypted_vec.push(encrypted_char);\n    }\n    let encrypted_string:\
    \ String = encrypted_vec.into_iter().collect();\n    encrypted_string\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `shift_char` in this scope\n  --> /tmp/tmpo9bcg1qz.rs:14:30\n\
    \   |\n14 |         let encrypted_char = shift_char(c, 4);\n   |             \
    \                 ^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpgviqz3w5.rs:11:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut encrypted = String::new();\n\
    \    let length = alphabet.len();\n    for c in s.chars() {\n        if let Some(i)\
    \ = alphabet.find(c) {\n            if i < length - 2 {\n                encrypted.push(alphabet.chars().nth(i\
    \ + 2).unwrap());\n            } else {\n                encrypted.push(alphabet.chars().nth(i\
    \ - (length - 2)).unwrap());\n            }\n        } else {\n            encrypted.push(c);\n\
    \        }\n    }\n    encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpqfkfawcz.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let shift\
    \ = 2 * 2;\n    return encode(s, shift);\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `encode` in this scope\n  --> /tmp/tmptogjbmk8.rs:12:12\n\
    \   |\n12 |     return encode(s, shift);\n   |            ^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let chars\
    \ = s.chars().collect::<Vec<char>>();\n    let mut enc = String::new();\n    for\
    \ c in chars {\n        let n = (c as u8 - 97) * 2;\n        let lower_c = n as\
    \ u8 + 97;\n        enc.push(lower_c as char);\n    }\n    enc\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"oq\"`,\n right: `\"lm\"`', /tmp/tmpw4o1qsrm.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ counter = 0;\n    let mut encrypted_string = String::new();\n    while counter\
    \ < s.len() {\n        let current_char = s.chars().nth(counter).unwrap();\n \
    \       let current_char_int = current_char as u8;\n        let encrypted_char\
    \ = current_char_int + 4;\n        let mut ascii_char = encrypted_char as char;\n\
    \        encrypted_string.push(ascii_char);\n        counter += 1;\n    }\n  \
    \  encrypted_string\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpe10clv6r.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let alphabet:\
    \ Vec<char> = \"abcdefghijklmnopqrstuvwxyz\".chars().collect();\n    let mut result\
    \ = String::new();\n    for c in s.chars() {\n        let index = alphabet.iter().position(|&x|\
    \ x == c).unwrap();\n        result.push(alphabet[(index + 4) % 26]);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut new_alphabet = \"\";\n    for\
    \ ch in alphabet.chars() {\n        if ch == 'z' {\n            new_alphabet.push('b');\n\
    \        } else if ch == 'y' {\n            new_alphabet.push('a');\n        }\
    \ else {\n            new_alphabet.push((ch as u8 + 2) as char);\n        }\n\
    \    }\n    let mut new_string = \"\".to_string();\n    for ch in s.chars() {\n\
    \        new_string.push(new_alphabet.chars().nth(alphabet.find(ch).unwrap()).unwrap());\n\
    \    }\n    new_string\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `push` found for reference `&str` in the\
    \ current scope\n  --> /tmp/tmpcuih67ut.rs:15:26\n   |\n15 |             new_alphabet.push('b');\n\
    \   |                          ^^^^ method not found in `&str`\n\nerror[E0599]:\
    \ no method named `push` found for reference `&str` in the current scope\n  -->\
    \ /tmp/tmpcuih67ut.rs:17:26\n   |\n17 |             new_alphabet.push('a');\n\
    \   |                          ^^^^ method not found in `&str`\n\nerror[E0599]:\
    \ no method named `push` found for reference `&str` in the current scope\n  -->\
    \ /tmp/tmpcuih67ut.rs:19:26\n   |\n19 |             new_alphabet.push((ch as u8\
    \ + 2) as char);\n   |                          ^^^^ method not found in `&str`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpmamdg9hu.rs:11:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ encrypted = String::new();\n    for c in s.chars() {\n        let shifted_char\
    \ = match c {\n            'a'...'y' => (c as u8 + 2) as char,\n            'z'\
    \ => 'b',\n            'A'...'Y' => (c as u8 + 2) as char,\n            'Z' =>\
    \ 'B',\n            _ => c,\n        };\n        encrypted.push(shifted_char);\n\
    \    }\n    encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmphz7bzt6a.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpamg96246.rs:11:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let shift_by:\
    \ i32 = 4;\n\n    let mut new_s = String::new();\n    for c in s.chars() {\n \
    \       let mut shift_c = c as i32;\n        if (shift_c + shift_by) > 122 {\n\
    \            shift_c = 96 + ((shift_c + shift_by) - 122);\n        } else {\n\
    \            shift_c += shift_by;\n        }\n        new_s.push(shift_c as u8\
    \ as char);\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        result.push(match\
    \ c {\n            'a'...'y' => char::from_u32(c as u32 + 2).unwrap(),\n     \
    \       'z' => 'b',\n            'A'...'Y' => char::from_u32(c as u32 + 2).unwrap(),\n\
    \            'Z' => 'B',\n            _ => c,\n        });\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp7brig_zq.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        result.push(c as\
    \ u8 + 4);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn0acnocd.rs:13:21\n   |\n\
    13 |         result.push(c as u8 + 4);\n   |                     ^^^^^^^^^^^ expected\
    \ `char`, found `u8`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ encrypted = String::new();\n    for c in s.chars() {\n        encrypted.push(c.wrapping_add(2));\n\
    \    }\n    encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `wrapping_add` found for type `char` in the\
    \ current scope\n  --> /tmp/tmph46vwdqd.rs:13:26\n   |\n13 |         encrypted.push(c.wrapping_add(2));\n\
    \   |                          ^^^^^^^^^^^^ method not found in `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n  let mut char_vec:\
    \ Vec<char> = s.chars().collect();\n  for i in 0..char_vec.len() {\n    char_vec[i]\
    \ = match char_vec[i] {\n      'a' => 'c',\n      'b' => 'd',\n      'c' => 'e',\n\
    \      'd' => 'f',\n      'e' => 'g',\n      'f' => 'h',\n      'g' => 'i',\n\
    \      'h' => 'j',\n      'i' => 'k',\n      'j' => 'l',\n      'k' => 'm',\n\
    \      'l' => 'n',\n      'm' => 'o',\n      'n' => 'p',\n      'o' => 'q',\n\
    \      'p' => 'r',\n      'q' => 's',\n      'r' => 't',\n      's' => 'u',\n\
    \      't' => 'v',\n      'u' => 'w',\n      'v' => 'x',\n      'w' => 'y',\n\
    \      'x' => 'z',\n      'y' => 'a',\n      'z' => 'b',\n      _ => char_vec[i],\n\
    \    };\n  }\n  char_vec.into_iter().collect()\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpbcx5kmwg.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    /// your\
    \ code here\n    return s;\n}\n\nfn main() {\n    let candidate = encrypt;\n \
    \   assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpce7tj17e.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ chars: Vec<char> = s.chars().collect();\n    for i in 0..chars.len() {\n   \
    \     chars[i] = match chars[i] {\n            'a' => 'c',\n            'b' =>\
    \ 'd',\n            'c' => 'e',\n            'd' => 'f',\n            'e' => 'g',\n\
    \            'f' => 'h',\n            'g' => 'i',\n            'h' => 'j',\n \
    \           'i' => 'k',\n            'j' => 'l',\n            'k' => 'm',\n  \
    \          'l' => 'n',\n            'm' => 'o',\n            'n' => 'p',\n   \
    \         'o' => 'q',\n            'p' => 'r',\n            'q' => 's',\n    \
    \        'r' => 't',\n            's' => 'u',\n            't' => 'v',\n     \
    \       'u' => 'w',\n            'v' => 'x',\n            'w' => 'y',\n      \
    \      'x' => 'z',\n            'y' => 'a',\n            'z' => 'b',\n       \
    \     _ => chars[i],\n        };\n    }\n    chars.into_iter().collect()\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpchst8r3a.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().map(|c|\
    \ {\n        match c {\n            'a'...'z' => ((c as u8 - b'a' + 4) % 26 +\
    \ b'a') as char,\n            'A'...'Z' => ((c as u8 - b'A' + 4) % 26 + b'A')\
    \ as char,\n            _ => c,\n        }\n    }).collect()\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    // let\
    \ mut new_s = String::new();\n    // for c in s.chars() {\n    //     let mut\
    \ i = 0;\n    //     let mut x = c as u8;\n    //     while i < 2 {\n    //  \
    \       if x == 122 {\n    //             x = 96;\n    //         }\n    //  \
    \       x += 1;\n    //         i += 1;\n    //     }\n    //     new_s.push(x\
    \ as char);\n    // }\n    // new_s\n    s.chars().map(|c| match c {\n       \
    \ 'x' => 'a',\n        'y' => 'b',\n        'z' => 'c',\n        _ => {\n    \
    \        let x = c as u8;\n            (x + 2) as char\n        }\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpgfughh_e.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    // TODO:\
    \ Add your code here.\n    return String::from(\"\");\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"lm\"`', /tmp/tmp3z_1pv8n.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().map(|c|\
    \ {\n        ((c as u8) + (b'a' - b'a') + 2 * 2) as char\n    }).collect()\n}\n\
    \nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpyl6i4p4p.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().map(|c|\
    \ ((c as u8) + 2 * 2) as char).collect()\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpirv0hrap.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    let mut shift_number = 2;\n    for character in\
    \ s.chars() {\n        result.push(match character {\n            'a' | 'b' |\
    \ 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o'\
    \ | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' => {\n   \
    \             let mut new_character = character as u8;\n                let mut\
    \ offset = shift_number;\n                while offset > 0 {\n               \
    \     new_character += 1;\n                    if new_character > 'z' as u8 {\n\
    \                        new_character = 'a' as u8;\n                    }\n \
    \                   offset -= 1;\n                }\n                new_character\
    \ as char\n            },\n            _ => character\n        });\n        shift_number\
    \ = shift_number * 2;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jm\"`,\n right: `\"lm\"`', /tmp/tmplkdtt6z9.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for i in s.chars() {\n        let num = (i as u8\
    \ + 2) % 91;\n        let new_char = (num + 6) as char;\n        result.push(new_char);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\u{15}\\u{16}\"`,\n right: `\"lm\"`', /tmp/tmp25ti8yi2.rs:22:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let alphabet\
    \ = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',\
    \ 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n    let mut output\
    \ = String::new();\n    for c in s.chars() {\n        let index = (c as u8 - 'a'\
    \ as u8) as usize;\n        output.push(alphabet[(index + (index * 2)) % alphabet.len()]);\n\
    \    }\n    output\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"vy\"`,\n right: `\"lm\"`', /tmp/tmp9bzr6mjh.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n  unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpwvg3_0fy.rs:11:3\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    // ----\
    \ Start your code here. ----\n    \"\".to_string()\n    // ---- End of your code.\
    \ ----\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"lm\"`', /tmp/tmpiipy01g2.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        result.push(c.wrapping_add(2).wrapping_add(2));\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `wrapping_add` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpkovahf1a.rs:13:23\n   |\n13 |         result.push(c.wrapping_add(2).wrapping_add(2));\n\
    \   |                       ^^^^^^^^^^^^ method not found in `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ v: Vec<char> = s.chars().collect();\n    for (i, c) in v.iter_mut().enumerate()\
    \ {\n        if *c == ' ' {\n            continue;\n        }\n        for _ in\
    \ 0..(i * 2) {\n            *c = shift_char(*c);\n        }\n    }\n    v.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `shift_char` in this scope\n  --> /tmp/tmp72h4t5la.rs:17:18\n\
    \   |\n17 |             *c = shift_char(*c);\n   |                  ^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    // Place\
    \ code here\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpqqs0tqnu.rs:12:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\";\n    let alphabet_vec: Vec<char> = alphabet.chars().collect();\n\
    \    let mut s_vec: Vec<char> = s.chars().collect();\n    let mut result = String::new();\n\
    \    for i in 0..s_vec.len() {\n        let mut found = false;\n        for j\
    \ in 0..alphabet_vec.len() {\n            if s_vec[i] == alphabet_vec[j] {\n \
    \               result.push(alphabet_vec[(j+10)%26]);\n                found =\
    \ true;\n                break;\n            }\n        }\n        if !found {\n\
    \            result.push(s_vec[i]);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"rs\"`,\n right: `\"lm\"`', /tmp/tmprlwzrqfb.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ encrypted = String::new();\n    for c in s.chars() {\n        let rotated =\
    \ char::from_u32(c as u32 + (2 * 2));\n        encrypted.push(rotated.unwrap());\n\
    \    }\n    encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpyiexd823.rs:25:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    // TODO\n\
    \    // *soulution 1*\n    let mut new_string = String::new();\n    for ch in\
    \ s.chars() {\n        new_string.push((ch as u8 - 'a' as u8 + 2 * 2) as char);\n\
    \    }\n    new_string\n    //soulution 2\n    // s.chars().map(|ch| (ch as u8\
    \ - 'a' as u8 + 2 * 2) as char).collect()\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\u{b}\\u{c}\"`,\n right: `\"lm\"`', /tmp/tmptilpav4p.rs:24:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp00t0529a.rs:11:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ cipher = String::new();\n    for c in s.chars() {\n        match c {\n     \
    \       'a' => cipher.push('c'),\n            'b' => cipher.push('d'),\n     \
    \       'c' => cipher.push('e'),\n            'd' => cipher.push('f'),\n     \
    \       'e' => cipher.push('g'),\n            'f' => cipher.push('h'),\n     \
    \       'g' => cipher.push('i'),\n            'h' => cipher.push('j'),\n     \
    \       'i' => cipher.push('k'),\n            'j' => cipher.push('l'),\n     \
    \       'k' => cipher.push('m'),\n            'l' => cipher.push('n'),\n     \
    \       'm' => cipher.push('o'),\n            'n' => cipher.push('p'),\n     \
    \       'o' => cipher.push('q'),\n            'p' => cipher.push('r'),\n     \
    \       'q' => cipher.push('s'),\n            'r' => cipher.push('t'),\n     \
    \       's' => cipher.push('u'),\n            't' => cipher.push('v'),\n     \
    \       'u' => cipher.push('w'),\n            'v' => cipher.push('x'),\n     \
    \       'w' => cipher.push('y'),\n            'x' => cipher.push('z'),\n     \
    \       'y' => cipher.push('a'),\n            'z' => cipher.push('b'),\n     \
    \       _ => cipher.push(c),\n        }\n    }\n    cipher\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpbojk0o8a.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpz8o1cwhy.rs:11:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ output = String::new();\n    for i in s.chars() {\n        let n = (i as u8\
    \ + 2 * 2) as char;\n        output.push(n);\n    }\n    output\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpvnhnwb0m.rs:25:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let index = (c as\
    \ u8 - ('a' as u8) + 2 * 2) % 26;\n        result.push((index + ('a' as u8)) as\
    \ char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ encrypted = String::new();\n    for c in s.chars() {\n        let upper = c.is_uppercase();\n\
    \        let original = c.to_ascii_lowercase();\n        let shifted = ((original\
    \ as u8) - 'a' as u8) * 2 + 'a' as u8;\n        let encrypted_char = char::from(shifted);\n\
    \        if upper {\n            encrypted.push(encrypted_char.to_ascii_uppercase());\n\
    \        } else {\n            encrypted.push(encrypted_char);\n        }\n  \
    \  }\n    encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"oq\"`,\n right: `\"lm\"`', /tmp/tmpx9vpcw0y.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    const ALPHABET:\
    \ &'static [char] = &['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\
    \ 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n   \
    \ s.chars().map(|x| {\n        let index = x as usize - 'a' as usize;\n      \
    \  ALPHABET[(index + 2 * 2) % ALPHABET.len()]\n    }).collect()\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    // TODO\n\
    \    let alphabet = 'a'..'z';\n    let mut encrypted_alphabet = 'a'..'z';\n  \
    \  let mut i = 0;\n    for c in alphabet {\n        encrypted_alphabet.nth(i);\n\
    \        i = (i + 4) % 24;\n    }\n    s.chars().map(|c| encrypted_alphabet.nth(c\
    \ as usize - 97)).collect()\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `String` cannot be built from an iterator\
    \ over elements of type `Option<char>`\n    --> /tmp/tmpbbqvpb2f.rs:19:64\n  \
    \   |\n19   |     s.chars().map(|c| encrypted_alphabet.nth(c as usize - 97)).collect()\n\
    \     |                                                                ^^^^^^^\
    \ value of type `String` cannot be built from `std::iter::Iterator<Item=Option<char>>`\n\
    \     |\n     = help: the trait `FromIterator<Option<char>>` is not implemented\
    \ for `String`\n     = help: the following other types implement trait `FromIterator<A>`:\n\
    \               <String as FromIterator<&'a char>>\n               <String as\
    \ FromIterator<&'a str>>\n               <String as FromIterator<Box<str>>>\n\
    \               <String as FromIterator<Cow<'a, str>>>\n               <String\
    \ as FromIterator<String>>\n               <String as FromIterator<char>>\nnote:\
    \ required by a bound in `collect`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        result.push(get_encrypted_letter(c));\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `get_encrypted_letter` in this scope\n\
    \  --> /tmp/tmp0qd6fztu.rs:13:21\n   |\n13 |         result.push(get_encrypted_letter(c));\n\
    \   |                     ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let shifted\
    \ = s.chars().map(|c| {\n        match c {\n            'a' => 'c',\n        \
    \    'b' => 'd',\n            'c' => 'e',\n            'd' => 'f',\n         \
    \   'e' => 'g',\n            'f' => 'h',\n            'g' => 'i',\n          \
    \  'h' => 'j',\n            'i' => 'k',\n            'j' => 'l',\n           \
    \ 'k' => 'm',\n            'l' => 'n',\n            'm' => 'o',\n            'n'\
    \ => 'p',\n            'o' => 'q',\n            'p' => 'r',\n            'q' =>\
    \ 's',\n            'r' => 't',\n            's' => 'u',\n            't' => 'v',\n\
    \            'u' => 'w',\n            'v' => 'x',\n            'w' => 'y',\n \
    \           'x' => 'z',\n            'y' => 'a',\n            'z' => 'b',\n  \
    \          _ => c,\n        }\n    });\n    shifted.collect()\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp5picijb8.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let s =\
    \ s.to_lowercase();\n    let num = 2;\n    let shift = num * 2;\n    let mut result\
    \ = String::new();\n    for x in s.chars() {\n        let code: u8 = x as u8;\n\
    \        let new_code = code + shift;\n        let new_code = match new_code {\n\
    \            97...122 => new_code,\n            _ => new_code - 26,\n        };\n\
    \        let new_char = new_code as char;\n        result.push(new_char);\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    \"\".to_string()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"lm\"`', /tmp/tmpr7qpewis.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let characters:\
    \ Vec<char> = s.chars().collect();\n    let mut result: Vec<char> = vec![];\n\
    \    for c in characters {\n        if c == ' ' {\n            result.push(c);\n\
    \        } else {\n            let new_c = c as u8 + 2 * 2;\n            let new_c\
    \ = new_c as char;\n            result.push(new_c);\n        }\n    }\n    result.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp5gsxsh84.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let alpha\
    \ = String::from(\"abcdefghijklmnopqrstuvwxyz\");\n    let rot = String::from(\"\
    cdefghijklmnopqrstuvwxyzab\");\n    let mut res = String::new();\n    for c in\
    \ s.chars() {\n        let idx = alpha.find(c).unwrap();\n        res.push(rot.chars().nth(idx).unwrap());\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpwlx88wu4.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    String::from(\"\
    \")\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"lm\"`', /tmp/tmpe5_prpzd.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().map(|c|\
    \ (c as u8 + 10) as char).collect()\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"rs\"`,\n right: `\"lm\"`', /tmp/tmpfdfcvwol.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpxj02wptg.rs:11:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().map(|c|\
    \ {\n        let i = c as i32 - 'a' as i32;\n        (i * 2 + 2 + 'a' as i32)\
    \ as u8 as char\n    }).collect()\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"qs\"`,\n right: `\"lm\"`', /tmp/tmpoohljy0n.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    // TODO:\
    \ implement\n    let mut encrypted_string = String::new();\n    for c in s.chars()\
    \ {\n        encrypted_string.push(rotate_character(c, ROTATE_NUMBER));\n    }\n\
    \    encrypted_string\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate_character` in this scope\n \
    \ --> /tmp/tmp1ik6snqt.rs:14:31\n   |\n14 |         encrypted_string.push(rotate_character(c,\
    \ ROTATE_NUMBER));\n   |                               ^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `ROTATE_NUMBER` in this scope\n\
    \  --> /tmp/tmp1ik6snqt.rs:14:51\n   |\n14 |         encrypted_string.push(rotate_character(c,\
    \ ROTATE_NUMBER));\n   |                                                   ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ cipher_string = String::new();\n    for c in s.chars() {\n        let mut x\
    \ = c as u8;\n        x = x + 2 * 2;\n        cipher_string.push(x as char);\n\
    \    }\n    cipher_string\n}\n\nfn main() {\n    let candidate = encrypt;\n  \
    \  assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpur6zocp8.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let alphabet\
    \ = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',\
    \ 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n    let mut index =\
    \ 0;\n    let mut word = s.to_lowercase();\n    let mut new_word = \"\".to_string();\n\
    \    for x in word.chars() {\n        for y in alphabet.iter() {\n           \
    \ if x == *y {\n                index = alphabet.iter().position(|&z| z == *y).unwrap();\n\
    \                if index >= 22 {\n                    new_word.push_str(&*alphabet[index\
    \ - 22].to_string());\n                } else {\n                    new_word.push_str(&*alphabet[index\
    \ + 4].to_string());\n                }\n            }\n        }\n    }\n   \
    \ new_word\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let chars:\
    \ Vec<char> = s.chars().collect();\n    let mut encrypted_chars: Vec<char> = Vec::new();\n\
    \    for c in chars {\n        let encrypted_char = match c {\n            'a'\
    \ => 'c',\n            'b' => 'd',\n            'c' => 'e',\n            'd' =>\
    \ 'f',\n            'e' => 'g',\n            'f' => 'h',\n            'g' => 'i',\n\
    \            'h' => 'j',\n            'i' => 'k',\n            'j' => 'l',\n \
    \           'k' => 'm',\n            'l' => 'n',\n            'm' => 'o',\n  \
    \          'n' => 'p',\n            'o' => 'q',\n            'p' => 'r',\n   \
    \         'q' => 's',\n            'r' => 't',\n            's' => 'u',\n    \
    \        't' => 'v',\n            'u' => 'w',\n            'v' => 'x',\n     \
    \       'w' => 'y',\n            'x' => 'z',\n            'y' => 'a',\n      \
    \      'z' => 'b',\n            _ => c,\n        };\n        encrypted_chars.push(encrypted_char);\n\
    \    }\n    let encrypted_string: String = encrypted_chars.into_iter().collect();\n\
    \    encrypted_string\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmptrjs2z1j.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    // TODO\n\
    \    \"\".to_string()\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"lm\"`', /tmp/tmp3sahhw0h.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let x = c as u8;\n\
    \        if x >= 97 && x <= 122 {\n            result.push(((x-97)*2+2) as char);\n\
    \        } else if x >= 65 && x <= 90 {\n            result.push(((x-65)*2+2)\
    \ as char);\n        } else {\n            result.push(c);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\u{10}\\u{12}\"`,\n right: `\"lm\"`', /tmp/tmpsf90fpbn.rs:27:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    if s.len()\
    \ > 0 {\n        let s_u8 = s.into_bytes();\n        for i in 0..s_u8.len() {\n\
    \            s_u8[i] += 2 * 2;\n        }\n        String::from_utf8(s_u8).unwrap()\n\
    \    } else {\n        String::from(\"\")\n    }\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `s_u8` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpustl95qi.rs:14:13\n   |\n12 |         let s_u8 = s.into_bytes();\n\
    \   |             ---- help: consider changing this to be mutable: `mut s_u8`\n\
    13 |         for i in 0..s_u8.len() {\n14 |             s_u8[i] += 2 * 2;\n  \
    \ |             ^^^^ cannot borrow as mutable\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let alph\
    \ = String::from(\"abcdefghijklmnopqrstuvwxyz\");\n    let mut out_string = String::new();\n\
    \    for i in s.to_lowercase().chars() {\n        if i.is_alphabetic() {\n   \
    \         out_string.push(alph.chars().nth(((i as usize) - 97 + 2*2) % 26).unwrap());\n\
    \        } else {\n            out_string.push(i);\n        }\n    }\n    out_string\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().map(|c|\
    \ char_shift(c,2,2)).collect()\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `char_shift` in this scope\n  --> /tmp/tmpp76xfxui.rs:11:23\n\
    \   |\n11 |     s.chars().map(|c| char_shift(c,2,2)).collect()\n   |         \
    \              ^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ v: Vec<String> = Vec::new();\n    let mut x: Vec<usize> = Vec::new();\n    let\
    \ mut j: usize = 0;\n    let alphabet = vec![\"a\", \"b\", \"c\", \"d\", \"e\"\
    , \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\"\
    , \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n   \
    \ for i in s.chars() {\n        v.push(i.to_string());\n    }\n    for i in v.iter()\
    \ {\n        j = 0;\n        for j in alphabet.iter() {\n            if i == j\
    \ {\n                x.push(j);\n            }\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl45n8u86.rs:22:24\n   |\n\
    22 |                 x.push(j);\n   |                        ^ expected `usize`,\
    \ found `&&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl45n8u86.rs:18:5\n\
    \   |\n10 |   fn encrypt(s: String) -> String {\n   |                        \
    \    ------ expected `String` because of return type\n...\n18 | /     for i in\
    \ v.iter() {\n19 | |         j = 0;\n20 | |         for j in alphabet.iter() {\n\
    21 | |             if i == j {\n...  |\n24 | |         }\n25 | |     }\n   | |_____^\
    \ expected struct `String`, found `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let c =\
    \ match s.get(0..1) {\n        Some(c) => c,\n        None => \"\",\n    };\n\
    \    let encrypt_str = c.chars().map(|c| {\n        if c == 'h' { 'l' }\n    \
    \    else if c == 'i' { 'm' }\n        else if c == 'j' { 'n' }\n        else\
    \ if c == 'k' { 'o' }\n        else if c == 'l' { 'p' }\n        else if c ==\
    \ 'm' { 'q' }\n        else if c == 'n' { 'r' }\n        else if c == 'o' { 's'\
    \ }\n        else if c == 'p' { 't' }\n        else if c == 'q' { 'u' }\n    \
    \    else if c == 'r' { 'v' }\n        else if c == 's' { 'w' }\n        else\
    \ if c == 't' { 'x' }\n        else if c == 'u' { 'y' }\n        else if c ==\
    \ 'v' { 'z' }\n        else if c == 'w' { 'a' }\n        else if c == 'x' { 'b'\
    \ }\n        else if c == 'y' { 'c' }\n        else if c == 'z' { 'd' }\n    \
    \    else if c == 'a' { 'e' }\n        else if c == 'b' { 'f' }\n        else\
    \ if c == 'c' { 'g' }\n        else if c == 'd' { 'h' }\n        else if c ==\
    \ 'e' { 'i' }\n        else if c == 'f' { 'j' }\n        else if c == 'g' { 'k'\
    \ }\n        else { c }\n    }).collect::<String>();\n    encrypt_str\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"l\"`,\n right: `\"lm\"`', /tmp/tmpee1z2oo4.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ v: Vec<char> = s.chars().collect();\n    for (i, c) in v.iter_mut().enumerate()\
    \ {\n        if *c == 'h' {\n            *c = 'l';\n        } else if *c == 'i'\
    \ {\n            *c = 'm';\n        } else if *c == 'j' {\n            *c = 'n';\n\
    \        } else if *c == 'k' {\n            *c = 'o';\n        } else if *c ==\
    \ 'l' {\n            *c = 'p';\n        } else if *c == 'm' {\n            *c\
    \ = 'q';\n        } else if *c == 'n' {\n            *c = 'r';\n        } else\
    \ if *c == 'o' {\n            *c = 's';\n        } else if *c == 'p' {\n     \
    \       *c = 't';\n        } else if *c == 'q' {\n            *c = 'u';\n    \
    \    } else if *c == 'r' {\n            *c = 'v';\n        } else if *c == 's'\
    \ {\n            *c = 'w';\n        } else if *c == 't' {\n            *c = 'x';\n\
    \        } else if *c == 'u' {\n            *c = 'y';\n        } else if *c ==\
    \ 'v' {\n            *c = 'z';\n        } else if *c == 'w' {\n            *c\
    \ = 'a';\n        } else if *c == 'x' {\n            *c = 'b';\n        } else\
    \ if *c == 'y' {\n            *c = 'c';\n        } else if *c == 'z' {\n     \
    \       *c = 'd';\n        } else if *c == 'a' {\n            *c = 'e';\n    \
    \    } else if *c == 'b' {\n            *c = 'f';\n        } else if *c == 'c'\
    \ {\n            *c = 'g';\n        } else if *c == 'd' {\n            *c = 'h';\n\
    \        } else if *c == 'e' {\n            *c\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpr5gvpn48.rs:73:3\n\
    \   |\n10 | fn encrypt(s: String) -> String {\n   |                          \
    \       - unclosed delimiter\n11 |     let mut v: Vec<char> = s.chars().collect();\n\
    12 |     for (i, c) in v.iter_mut().enumerate() {\n   |                      \
    \                      - unclosed delimiter\n...\n59 |         } else if *c ==\
    \ 'e' {\n   |                             - this delimiter might not be properly\
    \ closed...\n60 |             *c\n61 | }\n   | - ...as it matches this but it\
    \ has different indentation\n...\n73 | }\n   |   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpr5gvpn48.rs:60:13\n   |\n59 |           } else if *c ==\
    \ 'e' {\n   |  ________________-\n60 | |             *c\n   | |             ^^\
    \ expected `()`, found `char`\n61 | | }\n   | |_- expected this to be `()`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpr5gvpn48.rs:12:5\n   |\n10 |   fn\
    \ encrypt(s: String) -> String {\n   |                            ------ expected\
    \ `String` because of return type\n11 |       let mut v: Vec<char> = s.chars().collect();\n\
    12 | /     for (i, c) in v.iter_mut().enumerate() {\n13 | |         if *c == 'h'\
    \ {\n14 | |             *c = 'l';\n15 | |         } else if *c == 'i' {\n... \
    \ |\n72 | |     assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"\
    ));\n73 | | }\n   | |__^ expected struct `String`, found `()`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ new = String::new();\n    for c in s.chars() {\n        let c1 = c as u8;\n\
    \        let new_c = match c1 {\n            97..=101 => c1 + 4,\n           \
    \ 102..=109 => c1 - 2,\n            110..=115 => c1 + 2,\n            116..=120\
    \ => c1 - 4,\n            121..=122 => c1 + 4,\n            _ => 0,\n        };\n\
    \        new.push(new_c as char);\n    }\n    new\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"fg\"`,\n right: `\"lm\"`', /tmp/tmpuadwk416.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpv5c0_1y1.rs:11:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n  //make a\
    \ vec of chars from the string\n  let mut vec = s.chars().collect::<Vec<char>>();\n\
    \  //println!(\"{:?}\", vec);\n  //iterate through the vector of chars\n  for\
    \ i in 0..vec.len() {\n    //println!(\"{}\", vec[i]);\n    //if we are at the\
    \ end of the alphabet and the char is not a space\n    if vec[i] == 'z' && vec[i]\
    \ != ' '{\n      //shift it to the beginning\n      vec[i] = 'a';\n    }\n   \
    \ //else if we are at the end of the alphabet and the char is not a space\n  \
    \  else if vec[i] == 'y' && vec[i] != ' '{\n      //shift it to the beginning\n\
    \      vec[i] = 'a';\n    }\n    //else if the char is a space\n    else if vec[i]\
    \ == ' '{\n      //add the offset of the space char\n      vec[i] = ' ';\n   \
    \ }\n    //else we are somewhere in the middle of the alphabet and we add the\
    \ offset\n    else {\n      vec[i] = (vec[i] as u8 + 2 * 2) as char;\n    }\n\
    \  }\n  //print out the vec of encrypted chars\n  println!(\"{:?}\", vec);\n \
    \ //return the vec of encrypted chars as a string\n  return vec.into_iter().collect::<String>();\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: "['l', 'm']\n['e', 'w', 'h', 'j', 'k', 'l', 'n', 'o', 'p']\n['k', 'j']\n\
    ['i', 'x']\n['j', 'e', 'i', '{', 'j', 'e', '{', 'i', 'j', 'e', 'i', '{', 'k']\n"
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp_smgg0uf.rs:49:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmplkdcku0o.rs:11:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().map(|c|\
    \ {\n        let n = c as u8;\n        if n >= 97 && n <= 122 {\n            (((n\
    \ - 97) + (2 * 2)) % 26 + 97) as char\n        } else {\n            c\n     \
    \   }\n    }).collect()\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let a:\
    \ Vec<char> = vec!['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\
    \ 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n   \
    \ let mut o: Vec<char> = Vec::new();\n    for c in s.chars() {\n        o.push(a[(a.iter().position(|&d|\
    \ d == c).unwrap()+2*2)%a.len()]);\n    }\n    o.iter().cloned().collect()\n}\n\
    \nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    //TODO\
    \ 2:\n    //Implement the encrypt function.\n    //Hint: alphabetical chars can\
    \ be represented by their unicode values\n    let alphabet: Vec<char> = \"abcdefghijklmnopqrstuvwxyz\"\
    .chars().collect();\n    let mut encrypted = String::new();\n    for (index, c)\
    \ in s.chars().enumerate() {\n        let pos: usize = match alphabet.iter().position(|&x|\
    \ x == c) {\n            Some(p) => p,\n            None => continue,\n      \
    \  };\n        let idx = match pos + 2*index {\n            p if p < alphabet.len()\
    \ => p,\n            p => p - alphabet.len(),\n        };\n        encrypted.push(alphabet[idx]);\n\
    \    }\n    encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hk\"`,\n right: `\"lm\"`', /tmp/tmpz4l9j5uf.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for ch in s.chars() {\n        let mut index =\
    \ (ch as i32 - 'a' as i32) as i32;\n        index = index*2;\n        index =\
    \ index % 26;\n        let ch = ('a' as i32 + index) as u8 as char;\n        result.push(ch);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"oq\"`,\n right: `\"lm\"`', /tmp/tmphipalpw9.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let letters\
    \ = s.chars().map(|c| {\n        match c {\n            'a' => 'c',\n        \
    \    'b' => 'd',\n            'c' => 'e',\n            'd' => 'f',\n         \
    \   'e' => 'g',\n            'f' => 'h',\n            'g' => 'i',\n          \
    \  'h' => 'j',\n            'i' => 'k',\n            'j' => 'l',\n           \
    \ 'k' => 'm',\n            'l' => 'n',\n            'm' => 'o',\n            'n'\
    \ => 'p',\n            'o' => 'q',\n            'p' => 'r',\n            'q' =>\
    \ 's',\n            'r' => 't',\n            's' => 'u',\n            't' => 'v',\n\
    \            'u' => 'w',\n            'v' => 'x',\n            'w' => 'y',\n \
    \           'x' => 'z',\n            'y' => 'a',\n            'z' => 'b',\n  \
    \          _ => c,\n        }\n    });\n    letters.collect()\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpur3_op5z.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n  let alph\
    \ = \"abcdefghijklmnopqrstuvwxyz\";\n  let mut res: String = \"\".to_string();\n\
    \  for c in s.chars() {\n    let pos = alph.find(c).unwrap();\n    let pos_new\
    \ = (pos + 4) % 26;\n    res.push(alph.chars().nth(pos_new).unwrap());\n  }\n\
    \  res\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ encrypted_str = String::new();\n    for c in s.chars() {\n        let val =\
    \ ((c as u8) - 'a' as u8) as i32;\n        let encrypted_c = ((val + 2) * 2 +\
    \ 'a' as i32) as u8;\n        encrypted_str.push(encrypted_c as char);\n    }\n\
    \    encrypted_str\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"su\"`,\n right: `\"lm\"`', /tmp/tmp8_4armgt.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    return\
    \ \"wow\".to_string();\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"wow\"`,\n right: `\"lm\"`', /tmp/tmpjnz5kgce.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    // TODO\n\
    \    return s;\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpcp7w05nn.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().map(|c|\
    \ (((c as u8) - 97 + 4) % 26 + 97) as char).collect()\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ new_s = String::new();\n    for c in s.chars() {\n        new_s.push(rotate(c,\
    \ 2 * 2));\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate` in this scope\n  --> /tmp/tmp_0k2ynal.rs:13:20\n\
    \   |\n13 |         new_s.push(rotate(c, 2 * 2));\n   |                    ^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ encrypted = String::new();\n    let s = s.to_lowercase();\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            let index = (c as u8 - 'a' as\
    \ u8) as u8;\n            let index = (index + 2 * 2) % 26;\n            let c\
    \ = (index + 'a' as u8) as char;\n            encrypted.push(c);\n        } else\
    \ {\n            encrypted.push(c);\n        }\n    }\n    encrypted\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpa2vrtqu2.rs:11:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    String::from(s)\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpoldvvgog.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ a = s.chars().map(|c| {\n        if c.is_uppercase() {\n            let i =\
    \ (c as u8 - 'A' as u8) as u8;\n            let i = (i + 4) % 26;\n          \
    \  (i + 'A' as u8) as char\n        } else {\n            let i = (c as u8 - 'a'\
    \ as u8) as u8;\n            let i = (i + 4) % 26;\n            (i + 'a' as u8)\
    \ as char\n        }\n    });\n    let s: String = a.collect();\n    s\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().map(|c|\
    \ {\n        (((c as u8) - ('a' as u8) + 4) % 26 + ('a' as u8)) as char\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for ch in s.chars() {\n        result.push(rotate_char(ch,\
    \ 2));\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n  \
    \  assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate_char` in this scope\n  --> /tmp/tmpbpazk4k7.rs:13:21\n\
    \   |\n13 |         result.push(rotate_char(ch, 2));\n   |                   \
    \  ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    let len = s.len();\n    let mut i = 0;\n    while\
    \ i < len {\n        let c = s.chars().nth(i).unwrap();\n        let n = c as\
    \ u8;\n        if n >= 97 && n <= 122 {\n            result.push(((n - 97 + 2)\
    \ % 26 + 97) as char);\n        } else if n >= 65 && n <= 90 {\n            result.push(((n\
    \ - 65 + 2) % 26 + 65) as char);\n        } else {\n            result.push(c);\n\
    \        }\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp1_1zbds0.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().map(|c|\
    \ (((c as u8 - b'a') + 2) % 26 + b'a') as char).collect()\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmprcxtlwj9.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpgxgdjm19.rs:11:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().map(|c|\
    \ ((c as u8) + 2 * 2) as char).collect()\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpwxwbie5z.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    // Implement\
    \ encrypt here\n    String::new()\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"lm\"`', /tmp/tmpfni6f4yj.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpsf1ewq_n.rs:11:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    String::from(\"\
    s\")\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"s\"`,\n right: `\"lm\"`', /tmp/tmpwfwem_yf.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let a =\
    \ 'a' as u8;\n    let mut res = String::new();\n    for i in s.into_bytes() {\n\
    \        let n = i - a;\n        let v = (n + 4) % 26;\n        res.push((v +\
    \ a) as char);\n    }\n    res\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    // TODO:\
    \ Implement function\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpi0akwqyi.rs:12:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().map(|c|\
    \ {\n        let result = c as u8 + 2 * 2;\n        result as char\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp5k36fxk3.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.into_bytes().iter().map(|x|\
    \ *x + 4).map(|x| x as char).collect()\n}\n\nfn main() {\n    let candidate =\
    \ encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"\
    ));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"ewhjklnop\"\
    ));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"kj\"));\n\
    \    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"\
    faewfawefaewg\")), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpfkbk09tf.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let v =\
    \ s.chars().map(|c| {\n        let n: u8 = c as u8;\n        if n >= (b'a' + 2)\
    \ { n - 2 } else { n + 24 } as char\n    }).collect::<Vec<char>>();\n    v.iter().collect()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error: expected expression, found `as`\n  --> /tmp/tmp9mi2_vfq.rs:13:54\n\
    \   |\n13 |         if n >= (b'a' + 2) { n - 2 } else { n + 24 } as char\n   |\
    \                                                      ^^ expected expression\n\
    \   |\nhelp: parentheses are required to parse this as an expression\n   |\n13\
    \ |         (if n >= (b'a' + 2) { n - 2 } else { n + 24 }) as char\n   |     \
    \    +                                            +\n\nerror: aborting due to\
    \ previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let lowercase\
    \ = \"abcdefghijklmnopqrstuvwxyz\";\n    let alphabet: HashMap<char, char> = lowercase.chars().zip(lowercase.chars().cycle().skip(2\
    \ * 2)).collect();\n    s.chars().map(|c| {\n        match alphabet.get(&c) {\n\
    \            Some(x) => *x,\n            None => c\n        }\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmpmmceuzkx.rs:12:19\n\
    \   |\n12 |     let alphabet: HashMap<char, char> = lowercase.chars().zip(lowercase.chars().cycle().skip(2\
    \ * 2)).collect();\n   |                   ^^^^^^^ not found in this scope\n \
    \  |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let chars:\
    \ Vec<char> = s.chars().collect();\n    let length = chars.len();\n    let mut\
    \ result = String::new();\n    for i in 0..length {\n        let mut c = (chars[i]\
    \ as u8 + 2) as char;\n        if c > 'z' {\n            c = (c as u8 - 26) as\
    \ char;\n        }\n        result.push(c);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpmnh77bcs.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let offset = match\
    \ c {\n            'a'...'y' => 2,\n            'z' => 0,\n            _ => 2,\n\
    \        };\n        result.push((c as u8 + offset) as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmppyiwrqk9.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    // unimplemented!()\n\
    \    let mut v = Vec::new();\n    for b in s.into_bytes() {\n        v.push(b\
    \ + 2*2);\n    }\n    return String::from_utf8(v).unwrap();\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpw0ugamva.rs:25:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let v:\
    \ Vec<char> = s.chars().collect();\n    let mut n: Vec<char> = Vec::new();\n \
    \   for c in v {\n        if let Some(idx) = ALPHABET.chars().position(|x| x ==\
    \ c) {\n            let new_idx = (idx + 4) % 26;\n            n.push(ALPHABET.chars().nth(new_idx).unwrap());\n\
    \        }\n    }\n    n.into_iter().collect()\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `ALPHABET` in this scope\n  --> /tmp/tmpd1r6fe_x.rs:14:28\n\
    \   |\n14 |         if let Some(idx) = ALPHABET.chars().position(|x| x == c) {\n\
    \   |                            ^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `ALPHABET` in this scope\n  --> /tmp/tmpd1r6fe_x.rs:16:20\n\
    \   |\n16 |             n.push(ALPHABET.chars().nth(new_idx).unwrap());\n   |\
    \                    ^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result: Vec<char> = Vec::new();\n    let chars = s.chars();\n    for c in chars\
    \ {\n        result.push(rot_char(c));\n    }\n    return result.into_iter().collect();\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rot_char` in this scope\n  --> /tmp/tmp7xa8rci1.rs:14:21\n\
    \   |\n14 |         result.push(rot_char(c));\n   |                     ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ encryptString = String::new();\n    let mut i = 0;\n    while i < s.len() {\n\
    \        let c = s.chars().nth(i).unwrap();\n        let mut number = c as u8\
    \ - 97;\n        number = number * 2;\n        number = number % 26;\n       \
    \ number = number + 97;\n        let char = number as char;\n        encryptString.push(char);\n\
    \        i = i + 1;\n    }\n    encryptString\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"oq\"`,\n right: `\"lm\"`', /tmp/tmp67xgcgl1.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for character in s.chars() {\n        let new_character\
    \ = match character {\n            'a' => 'c',\n            'b' => 'd',\n    \
    \        'c' => 'e',\n            'd' => 'f',\n            'e' => 'g',\n     \
    \       'f' => 'h',\n            'g' => 'i',\n            'h' => 'j',\n      \
    \      'i' => 'k',\n            'j' => 'l',\n            'k' => 'm',\n       \
    \     'l' => 'n',\n            'm' => 'o',\n            'n' => 'p',\n        \
    \    'o' => 'q',\n            'p' => 'r',\n            'q' => 's',\n         \
    \   'r' => 't',\n            's' => 'u',\n            't' => 'v',\n          \
    \  'u' => 'w',\n            'v' => 'x',\n            'w' => 'y',\n           \
    \ 'x' => 'z',\n            'y' => 'a',\n            'z' => 'b',\n            _\
    \ => panic!(\"Invalid character.\")\n        };\n        result.push(new_character);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp69iynh7o.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ new_string = String::new();\n    for c in s.chars() {\n        new_string.push((c\
    \ as u8 + 2 * 2) as char);\n    }\n    new_string\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpo2on17pd.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut encrypted_alphabet = String::new();\n\
    \    encrypted_alphabet.push_str(alphabet);\n    encrypted_alphabet.push_str(alphabet);\n\
    \    let mut new_string = String::new();\n    for l in s.chars() {\n        if\
    \ l == ' ' {\n            new_string.push(l);\n        } else {\n            let\
    \ index = encrypted_alphabet.find(l).unwrap();\n            new_string.push(encrypted_alphabet.chars().nth(index\
    \ + 2).unwrap());\n        }\n    }\n    new_string\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpdrkeuiot.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let x:\
    \ Vec<char> = s.chars().collect();\n    let mut y: Vec<char> = Vec::new();\n \
    \   for c in x {\n        let mut t = c as u8 + 2;\n        if t > 122 {\n   \
    \         t = (t-122) + 96;\n        }\n        y.push(t as char);\n    }\n  \
    \  y.iter().collect()\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmps1y84wf0.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().map(|c|\
    \ match c {\n        'a' => 'c',\n        'b' => 'd',\n        'c' => 'e',\n \
    \       'd' => 'f',\n        'e' => 'g',\n        'f' => 'h',\n        'g' =>\
    \ 'i',\n        'h' => 'j',\n        'i' => 'k',\n        'j' => 'l',\n      \
    \  'k' => 'm',\n        'l' => 'n',\n        'm' => 'o',\n        'n' => 'p',\n\
    \        'o' => 'q',\n        'p' => 'r',\n        'q' => 's',\n        'r' =>\
    \ 't',\n        's' => 'u',\n        't' => 'v',\n        'u' => 'w',\n      \
    \  'v' => 'x',\n        'w' => 'y',\n        'x' => 'z',\n        'y' => 'a',\n\
    \        'z' => 'b',\n        _ => c,\n    }).collect()\n}\n\nfn main() {\n  \
    \  let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpmnki_crh.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let chars:\
    \ Vec<char> = s.chars().collect();\n    let mut encrypted_chars: Vec<char> = Vec::new();\n\
    \    for c in chars {\n        encrypted_chars.push(rotate_char(c, 2*2));\n  \
    \  }\n    let encrypted_chars_str = encrypted_chars.iter().collect::<String>();\n\
    \    encrypted_chars_str\n}\n\nfn main() {\n    let candidate = encrypt;\n   \
    \ assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate_char` in this scope\n  --> /tmp/tmpclt8svkg.rs:14:30\n\
    \   |\n14 |         encrypted_chars.push(rotate_char(c, 2*2));\n   |         \
    \                     ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ x: String = String::new();\n    for i in s.chars() {\n        let c = i as u8;\n\
    \        let new_c = (c + 2*2) as char;\n        x.push(new_c);\n    }\n    x\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp2bx4ttgj.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    // s.into_bytes().iter().map(|c|\
    \ (c + 2 * 2) as char).collect()\n    String::from_utf8(s.into_bytes().iter().map(|c|\
    \ (c + 2 * 2) as u8).collect()).unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp5bf2r1n6.rs:21:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let alphabet\
    \ = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',\
    \ 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];\n    let s: Vec<char>\
    \ = s.chars().collect();\n    let mut r: Vec<char> = Vec::new();\n    for c in\
    \ s {\n        for (i, &a) in alphabet.iter().enumerate() {\n            if c\
    \ == a {\n                r.push(alphabet[(i+4)%26]);\n            }\n       \
    \ }\n    }\n    r.into_iter().collect()\n}\n\nfn main() {\n    let candidate =\
    \ encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"\
    ));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"ewhjklnop\"\
    ));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"kj\"));\n\
    \    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"\
    faewfawefaewg\")), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().map(\
    \ |c| ((c as u8 + 2) * 2) as char).collect()\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\xD4\xD6\"`,\n right: `\"lm\"`', /tmp/tmphriojanl.rs:16:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n\tlet mut x\
    \ = 2;\n\tlet mut n = s.chars().map(|c| {\n\t\tif x == 2 {\n\t\t\tx = 1;\n\t\t\
    \tlet c = c as u8;\n\t\t\tlet c = c + 2;\n\t\t\tlet c = c as char;\n\t\t\tc\n\t\
    \t} else {\n\t\t\tx = 2;\n\t\t\tlet c = c as u8;\n\t\t\tlet c = c + 1;\n\t\t\t\
    let c = c as char;\n\t\t\tc\n\t\t}\n\t});\n\tlet n: String = n.collect();\n\t\
    return n;\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jj\"`,\n right: `\"lm\"`', /tmp/tmp8_ao8sgi.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpv5dl_2k7.rs:11:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let s =\
    \ s.into_bytes();\n    let mut encrypted = String::new();\n    for c in s {\n\
    \        if c >= 97 && c <= 122 {\n            let new = c + (2 * 2);\n      \
    \      if new > 122 {\n                encrypted.push(new - 26);\n           \
    \ } else {\n                encrypted.push(new);\n            }\n        } else\
    \ {\n            encrypted.push(c);\n        }\n    }\n    encrypted\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1aoi9zsy.rs:17:32\n   |\n\
    17 |                 encrypted.push(new - 26);\n   |                         \
    \       ^^^^^^^^ expected `char`, found `u8`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1aoi9zsy.rs:19:32\n   |\n19 |                 encrypted.push(new);\n\
    \   |                                ^^^ expected `char`, found `u8`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1aoi9zsy.rs:22:28\n   |\n22 |             encrypted.push(c);\n\
    \   |                            ^ expected `char`, found `u8`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpz9ccck4y.rs:11:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().map(|c|\
    \ if c == 'z' { 'a' } else if c == 'y' { 'z' } else { ((c as u8) + 2) as char\
    \ }).collect()\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmplhusdmzd.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    //If we\
    \ need to shift down multiple times, use a loop\n    let mut new_s = String::new();\n\
    \    for c in s.chars() {\n        //If we need to shift down a single time, do\
    \ so\n        if (c as u8) > 109 {\n            new_s.push(((c as u8) - 26 + 2)\
    \ as char);\n        } else {\n            new_s.push(((c as u8) + 2) as char);\n\
    \        }\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpeh3njq6t.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().map(|c|\
    \ (((c as u8) - 97 + 2) % 26 + 97) as char).collect()\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpely2g_3_.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    // unimplemented!()\n\
    \    let mut word = s.chars().collect::<Vec<char>>();\n    let mut result = String::new();\n\
    \    for i in word {\n        match i {\n            'a' => result.push('c'),\n\
    \            'b' => result.push('d'),\n            'c' => result.push('e'),\n\
    \            'd' => result.push('f'),\n            'e' => result.push('g'),\n\
    \            'f' => result.push('h'),\n            'g' => result.push('i'),\n\
    \            'h' => result.push('j'),\n            'i' => result.push('k'),\n\
    \            'j' => result.push('l'),\n            'k' => result.push('m'),\n\
    \            'l' => result.push('n'),\n            'm' => result.push('o'),\n\
    \            'n' => result.push('p'),\n            'o' => result.push('q'),\n\
    \            'p' => result.push('r'),\n            'q' => result.push('s'),\n\
    \            'r' => result.push('t'),\n            's' => result.push('u'),\n\
    \            't' => result.push('v'),\n            'u' => result.push('w'),\n\
    \            'v' => result.push('x'),\n            'w' => result.push('y'),\n\
    \            'x' => result.push('z'),\n            'y' => result.push('a'),\n\
    \            'z' => result.push('b'),\n            _ => result.push(i),\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n  \
    \  assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp9sux8wt9.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    // TODO:\
    \ implement function\n    // Return value should be the encrypted string\n   \
    \ unimplemented!();\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpqcquxxq0.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    // TODO:\
    \ Implement\n    \"\".to_string()\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"lm\"`', /tmp/tmpyrcgl9ej.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ res = String::new();\n    for ch in s.chars() {\n        res.push(rotate(ch,\
    \ 2 * 2));\n    }\n    res\n}\n\nfn main() {\n    let candidate = encrypt;\n \
    \   assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate` in this scope\n  --> /tmp/tmpxvc68a8v.rs:13:18\n\
    \   |\n13 |         res.push(rotate(ch, 2 * 2));\n   |                  ^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ encrypted = String::new();\n    for c in s.chars() {\n        let new_c = match\
    \ c {\n            'a' => 'c',\n            'b' => 'd',\n            'c' => 'e',\n\
    \            'd' => 'f',\n            'e' => 'g',\n            'f' => 'h',\n \
    \           'g' => 'i',\n            'h' => 'j',\n            'i' => 'k',\n  \
    \          'j' => 'l',\n            'k' => 'm',\n            'l' => 'n',\n   \
    \         'm' => 'o',\n            'n' => 'p',\n            'o' => 'q',\n    \
    \        'p' => 'r',\n            'q' => 's',\n            'r' => 't',\n     \
    \       's' => 'u',\n            't' => 'v',\n            'u' => 'w',\n      \
    \      'v' => 'x',\n            'w' => 'y',\n            'x' => 'z',\n       \
    \     'y' => 'a',\n            'z' => 'b',\n            _ => c,\n        };\n\
    \        encrypted.push(new_c);\n    }\n    encrypted\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpnocg5y34.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpri8f4xmg.rs:11:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ res: Vec<u8> = Vec::new();\n    let mut s = s.into_bytes();\n    for i in 0..s.len()\
    \ {\n        let shifted = (s[i] as u8) + 2 * 2;\n        res.push(shifted);\n\
    \    }\n    String::from_utf8(res).unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpok8ckhzn.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    String::from(\"\
    \")\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"lm\"`', /tmp/tmp8o75q7yw.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().map(|x|\
    \ (((x as u8 + 2) - 97) % 26 + 97) as char).collect()\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp9sxq9cwj.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let rot_by\
    \ = 2*2;\n    let mut s_vec: Vec<char> = s.chars().collect();\n    for i in 0..s_vec.len()\
    \ {\n        match s_vec[i] {\n            'a'..='z' => {\n                let\
    \ x = s_vec[i] as u8;\n                s_vec[i] = ((x - 97 + rot_by) % 26 + 97)\
    \ as char;\n            },\n            'A'..='Z' => {\n                let x\
    \ = s_vec[i] as u8;\n                s_vec[i] = ((x - 65 + rot_by) % 26 + 65)\
    \ as char;\n            },\n            _ => {}\n        }\n    }\n    let mut\
    \ encrypted_str = String::new();\n    for i in 0..s_vec.len() {\n        encrypted_str.push(s_vec[i]);\n\
    \    }\n    encrypted_str\n}\n\nfn main() {\n    let candidate = encrypt;\n  \
    \  assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp15kv9db5.rs:11:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    // TODO\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp293fg4hh.rs:12:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    // let\
    \ alph = \"abcdefghijklmnopqrstuvwxyz\";\n    // let mut v_rotated = Vec::new();\n\
    \    // for c in s.chars() {\n    //     let index = alph.find(c).unwrap();\n\
    \    //     let index_plus_two = (index + 2) % 26;\n    //     v_rotated.push(alph.chars().nth(index_plus_two).unwrap());\n\
    \    // }\n    // v_rotated.into_iter().collect()\n\n    s.chars().map(|c| {\n\
    \        let alph = \"abcdefghijklmnopqrstuvwxyz\";\n        let index = alph.find(c).unwrap();\n\
    \        let index_plus_two = (index + 2) % 26;\n        alph.chars().nth(index_plus_two).unwrap()\n\
    \    }).collect()\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpfrwlsaho.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    String::from(s)\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpwj_dpst1.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    String::from(\"\
    \")\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"lm\"`', /tmp/tmpbaq20bak.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    // use\
    \ your cipher function here\n    // I suggest using it more than once.\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpdaktr237.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    // TODO\n\
    \    \"\".to_string()\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"lm\"`', /tmp/tmpttxqr8j0.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let s_vec:\
    \ Vec<char> = s.chars().collect();\n    let mut encrypted_string = String::new();\n\
    \    for i in 0..s_vec.len() {\n        let encrypted_letter = encrypt_char(s_vec[i]);\n\
    \        encrypted_string.push(encrypted_letter);\n    }\n    encrypted_string\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `encrypt_char` in this scope\n  -->\
    \ /tmp/tmpyhg8ev77.rs:14:32\n   |\n14 |         let encrypted_letter = encrypt_char(s_vec[i]);\n\
    \   |                                ^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ encrypted = String::new();\n    for c in s.chars() {\n        encrypted.push(rotate_char(c,\
    \ 2));\n    }\n    encrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate_char` in this scope\n  --> /tmp/tmpwcxddohn.rs:13:24\n\
    \   |\n13 |         encrypted.push(rotate_char(c, 2));\n   |                 \
    \       ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().map(|c|\
    \ {\n        c.to_ascii_lowercase().wrapping_add(2).wrapping_mul(2) as char\n\
    \    }).collect()\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `wrapping_add` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpx76ygybl.rs:12:32\n   |\n12 |         c.to_ascii_lowercase().wrapping_add(2).wrapping_mul(2)\
    \ as char\n   |                                ^^^^^^^^^^^^ method not found in\
    \ `char`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut result = String::new();\n   \
    \ for c in s.chars() {\n        let index = alphabet.find(c).unwrap();\n     \
    \   let shifted_index = (index + 2 * 2) % alphabet.len();\n        result.push(alphabet.chars().nth(shifted_index).unwrap());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for x in s.chars() {\n        result.push(char_shift(x));\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `char_shift` in this scope\n  --> /tmp/tmpfnovdi27.rs:13:21\n\
    \   |\n13 |         result.push(char_shift(x));\n   |                     ^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n\tlet mut ret\
    \ = \"\".to_string();\n\tfor c in s.chars() {\n\t\tlet idx = match c {\n\t\t\t\
    'a' => 2,\n\t\t\t'b' => 3,\n\t\t\t'c' => 4,\n\t\t\t'd' => 5,\n\t\t\t'e' => 6,\n\
    \t\t\t'f' => 7,\n\t\t\t'g' => 8,\n\t\t\t'h' => 9,\n\t\t\t'i' => 10,\n\t\t\t'j'\
    \ => 11,\n\t\t\t'k' => 12,\n\t\t\t'l' => 13,\n\t\t\t'm' => 14,\n\t\t\t'n' => 15,\n\
    \t\t\t'o' => 16,\n\t\t\t'p' => 17,\n\t\t\t'q' => 18,\n\t\t\t'r' => 19,\n\t\t\t\
    's' => 20,\n\t\t\t't' => 21,\n\t\t\t'u' => 22,\n\t\t\t'v' => 23,\n\t\t\t'w' =>\
    \ 24,\n\t\t\t'x' => 25,\n\t\t\t'y' => 26,\n\t\t\t'z' => 27,\n\t\t\t_ => 0,\n\t\
    \t};\n\t\tret.push(idx as u8 as char);\n\t}\n\tret\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\t\\n\"`,\n right: `\"lm\"`', /tmp/tmpf6kdit0k.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    encrypt_mod(s,\
    \ 2)\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `encrypt_mod` in this scope\n  --> /tmp/tmpsrszv7i0.rs:11:5\n\
    \   |\n11 |     encrypt_mod(s, 2)\n   |     ^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpszn9dqfg.rs:11:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result: Vec<u8> = vec![];\n    let chars = s.as_bytes();\n    for c in chars\
    \ {\n        let char = (*c as i32) + 2;\n        let char = (char + 2) % 26;\n\
    \        result.push(char as u8);\n    }\n    String::from_utf8(result).unwrap()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\u{4}\\u{5}\"`,\n right: `\"lm\"`', /tmp/tmp4xah0hzp.rs:23:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut new_string = String::new();\n\
    \    for i in s.chars() {\n        let a = &alphabet[(i as usize - 97 + 4) % 26];\n\
    \        new_string.push_str(a);\n    }\n    new_string\n}\n\nfn main() {\n  \
    \  let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `str` cannot be indexed by `usize`\n  --> /tmp/tmpd4plftpr.rs:14:18\n\
    \   |\n14 |         let a = &alphabet[(i as usize - 97 + 4) % 26];\n   |     \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ string indices are ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented for\
    \ `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<usize>`\
    \ for `str`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    return\
    \ s.chars().map(|c| {\n        (c as u8 + 2*2) as char\n    }).collect();\n}\n\
    \nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmpkya_j2z4.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ z = String::new();\n    for c in s.chars() {\n        z.push((c as u8 - 'a'\
    \ as u8 + 1) as char);\n    }\n    z\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\u{8}\\t\"`,\n right: `\"lm\"`', /tmp/tmpwkzj6afi.rs:20:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    // TODO:\
    \ Implement\n    let mut new_string = String::new();\n    for c in s.chars() {\n\
    \        new_string.push(rotate_char(c, 2 * 2))\n    }\n    new_string\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rotate_char` in this scope\n  --> /tmp/tmpv87pqekg.rs:14:25\n\
    \   |\n14 |         new_string.push(rotate_char(c, 2 * 2))\n   |             \
    \            ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        result.push(match\
    \ c {\n            'a' | 'b' => 'c',\n            'c' | 'd' => 'e',\n        \
    \    'e' | 'f' => 'g',\n            'g' | 'h' => 'i',\n            'i' | 'j' =>\
    \ 'k',\n            'k' | 'l' => 'm',\n            'm' | 'n' => 'o',\n       \
    \     'o' | 'p' => 'q',\n            'q' | 'r' => 's',\n            's' | 't'\
    \ => 'u',\n            'u' | 'v' => 'w',\n            'w' | 'x' => 'y',\n    \
    \        'y' | 'z' => 'a',\n            _ => c,\n        });\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ik\"`,\n right: `\"lm\"`', /tmp/tmph_omh1rm.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    let chars: Vec<char> = s.chars().collect();\n \
    \   for c in chars {\n        let code = c as u8;\n        result.push(if code\
    \ >= 97 && code <= 122 {\n            ((code + 4) as char)\n        } else {\n\
    \            c\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmps32ljwgv.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        if c.is_alphabetic()\
    \ {\n            result.push(match c {\n                'c' ... 'z' => {\n   \
    \                 let c_num = c as u8;\n                    let num = (c_num -\
    \ 'a' as u8 + 2) % 26;\n                    num as char\n                },\n\
    \                'a' ... 'b' => {\n                    let c_num = c as u8;\n\
    \                    let num = (c_num - 'a' as u8 + 2) % 26;\n               \
    \     num as char\n                },\n                _ => c\n            });\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\t\\n\"`,\n right: `\"lm\"`', /tmp/tmp8tzkvhpq.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    return\
    \ s;\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpnfk5qrr9.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ enc = String::new();\n    for (i, c) in s.chars().enumerate() {\n        enc.push(letter_after(c,\
    \ i * 2));\n    }\n    enc\n}\n\nfn main() {\n    let candidate = encrypt;\n \
    \   assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `letter_after` in this scope\n  -->\
    \ /tmp/tmp1ouo6dcc.rs:13:18\n   |\n13 |         enc.push(letter_after(c, i * 2));\n\
    \   |                  ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp0r7zetd1.rs:11:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    s.chars().map(|c|\
    \ {\n        if c == 'z' {\n            return 'b';\n        } else if c == 'y'\
    \ {\n            return 'a';\n        } else {\n            return ((c as u8)\
    \ + 2) as char;\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmp2p79kgiq.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = \"\".to_string();\n    for c in s.chars() {\n        let n = ((c as\
    \ u8) - 97);\n        let m = ((n + 2) * 2) % 26;\n        result.push((m + 97)\
    \ as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"su\"`,\n right: `\"lm\"`', /tmp/tmpavqiuz3d.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    let char_vector: Vec<char> = s.chars().collect();\n\
    \    for c in char_vector {\n        let ascii = c as u8;\n        let new_ascii\
    \ = ascii + 4;\n        result.push(new_ascii as char);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jei{je{ijei{k\"`,\n right: `\"jeiajeaijeiak\"`', /tmp/tmp0a57as_7.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    String::from(\"\
    hi\")\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmp3n9v9yry.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    // TODO:\
    \ complete this function\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpe_lv96_o.rs:12:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\";\n    s.chars().map(|c| {\n        let index\
    \ = alphabet.find(c).unwrap() as i32;\n        let index = (index + 2) % 26;\n\
    \        alphabet.chars().nth(index as usize).unwrap()\n    }).collect()\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpw1zod2sz.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp00wa69ue.rs:11:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ output: Vec<char> = Vec::new();\n    for c in s.chars() {\n        output.push(shift_down(c,\
    \ 4));\n    }\n    output.into_iter().collect()\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `shift_down` in this scope\n  --> /tmp/tmpobxc3vzk.rs:13:21\n\
    \   |\n13 |         output.push(shift_down(c, 4));\n   |                     ^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let alphabet:\
    \ Vec<char> = \"abcdefghijklmnopqrstuvwxyz\".chars().collect();\n    s.chars().map(|c|\
    \ {\n        let index = alphabet.iter().position(|&x| x == c).unwrap();\n   \
    \     alphabet[(index + 4) % alphabet.len()]\n    }).collect()\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    return\
    \ s.chars().map(|c| match c {\n        'a' => 'c',\n        'b' => 'd',\n    \
    \    'c' => 'e',\n        'd' => 'f',\n        'e' => 'g',\n        'f' => 'h',\n\
    \        'g' => 'i',\n        'h' => 'j',\n        'i' => 'k',\n        'j' =>\
    \ 'l',\n        'k' => 'm',\n        'l' => 'n',\n        'm' => 'o',\n      \
    \  'n' => 'p',\n        'o' => 'q',\n        'p' => 'r',\n        'q' => 's',\n\
    \        'r' => 't',\n        's' => 'u',\n        't' => 'v',\n        'u' =>\
    \ 'w',\n        'v' => 'x',\n        'w' => 'y',\n        'x' => 'z',\n      \
    \  'y' => 'a',\n        'z' => 'b',\n        _ => ' '\n    }).collect();\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"jk\"`,\n right: `\"lm\"`', /tmp/tmpajwtx16d.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ result = String::new();\n    for c in s.chars() {\n        let pos = (((c as\
    \ u8) - 97) * 2) % 26;\n        result.push((pos + 97) as char);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"oq\"`,\n right: `\"lm\"`', /tmp/tmph2jqhw83.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ key: Vec<char> = Vec::new();\n    for c in s.chars() {\n        if c.is_alphabetic()\
    \ {\n            key.push(c);\n        }\n    }\n    let mut i = 0;\n    let result:\
    \ String = s.chars().map(|c| {\n        if c.is_alphabetic() {\n            let\
    \ encrypted = match c {\n                'a' => key[i] = 'c',\n              \
    \  'b' => key[i] = 'd',\n                'c' => key[i] = 'e',\n              \
    \  'd' => key[i] = 'f',\n                'e' => key[i] = 'g',\n              \
    \  'f' => key[i] = 'h',\n                'g' => key[i] = 'i',\n              \
    \  'h' => key[i] = 'j',\n                'i' => key[i] = 'k',\n              \
    \  'j' => key[i] = 'l',\n                'k' => key[i] = 'm',\n              \
    \  'l' => key[i] = 'n',\n                'm' => key[i] = 'o',\n              \
    \  'n' => key[i] = 'p',\n                'o' => key[i] = 'q',\n              \
    \  'p' => key[i] = 'r',\n                'q' => key[i] = 's',\n              \
    \  'r' => key[i] = 't',\n                's' => key[i] = 'u',\n              \
    \  't' => key[i] = 'v',\n                'u' => key[i] = 'w',\n              \
    \  'v' => key[i] = 'x',\n                'w' => key[i] = 'y',\n              \
    \  'x' => key[i] = 'z',\n                'y' => key[i] = 'a',\n              \
    \  'z' => key[i] = 'b',\n                _ => unreachable!(),\n            };\n\
    \            i += 1;\n            encrypted\n        } else {\n            c\n\
    \        }\n    }).collect();\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: `if` and `else` have incompatible types\n  --> /tmp/tmpux6ixb9w.rs:52:13\n\
    \   |\n19 | /         if c.is_alphabetic() {\n20 | |             let encrypted\
    \ = match c {\n21 | |                 'a' => key[i] = 'c',\n22 | |           \
    \      'b' => key[i] = 'd',\n...  |\n50 | |             encrypted\n   | |    \
    \         --------- expected because of this\n51 | |         } else {\n52 | |\
    \             c\n   | |             ^ expected `()`, found `char`\n53 | |    \
    \     }\n   | |_________- `if` and `else` have incompatible types\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let a =\
    \ ('a' as u8, 'z' as u8);\n    let b = ('A' as u8, 'Z' as u8);\n    let mut r:\
    \ Vec<u8> = Vec::new();\n    for c in s.bytes() {\n        if c >= a.0 && c <=\
    \ a.1 {\n            r.push((c - a.0 + 2 * 2) % 26 + a.0);\n        } else if\
    \ c >= b.0 && c <= b.1 {\n            r.push((c - b.0 + 2 * 2) % 26 + b.0);\n\
    \        } else {\n            r.push(c);\n        }\n    }\n    String::from_utf8(r).unwrap()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let rotation_factor\
    \ = 4;\n    // First we construct a new alphabet by taking a standard alphabet\
    \ and then appending \n    // the rotated letters to the end.\n    let mut new_alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\".to_string();\n    new_alphabet.push_str(&\"\
    cdefghijklmnopqrstuvwxyzab\".to_string());\n    // Then we split the new alphabet\
    \ and convert it to a vector.\n    let new_alphabet_vec: Vec<char> = new_alphabet.split(\"\
    \").filter(|s| s != &\"\").collect();\n    // And finally we iterate over each\
    \ character in the string to encrypt and use the position\n    // of that character\
    \ in the standard alphabet to find it's position in the new alphabet.\n    //\
    \ We use that position to get the correct character from the new alphabet and\
    \ append that\n    // character to a new string to be returned.\n    let mut new_string\
    \ = String::new();\n    for ch in s.chars() {\n        let position = \"abcdefghijklmnopqrstuvwxyz\"\
    .chars().position(|x| x == ch).unwrap();\n        new_string.push(new_alphabet_vec[position\
    \ + rotation_factor]);\n    }\n    new_string\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<char>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmp730vc6xy.rs:17:83\n     |\n17\
    \   |     let new_alphabet_vec: Vec<char> = new_alphabet.split(\"\").filter(|s|\
    \ s != &\"\").collect();\n     |                                             \
    \                                      ^^^^^^^ value of type `Vec<char>` cannot\
    \ be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait\
    \ `FromIterator<&str>` is not implemented for `Vec<char>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n\tlet ascii_offset\
    \ = 97;\n\tlet alphabet_count = 26;\n\tlet shift_amount = 2 * 2;\n\n\tlet encrypted\
    \ = s.chars().map(|c| {\n\t\tlet mut offset = (c as u8 - ascii_offset) as i32;\n\
    \t\toffset = offset + shift_amount;\n\t\tif offset >= alphabet_count {\n\t\t\t\
    offset = offset - alphabet_count;\n\t\t}\n\t\tif offset < 0 {\n\t\t\toffset =\
    \ offset + alphabet_count;\n\t\t}\n\t\t(offset + ascii_offset) as u8 as char\n\
    \t}).collect();\n\n\tencrypted\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx5wyobp8.rs:24:13\n   |\n\
    24 |         (offset + ascii_offset) as u8 as char\n   |                   ^^^^^^^^^^^^\
    \ expected `i32`, found `u8`\n\nerror[E0277]: cannot add `u8` to `i32`\n  -->\
    \ /tmp/tmpx5wyobp8.rs:24:11\n   |\n24 |         (offset + ascii_offset) as u8\
    \ as char\n   |                 ^ no implementation for `i32 + u8`\n   |\n   =\
    \ help: the trait `Add<u8>` is not implemented for `i32`\n   = help: the following\
    \ other types implement trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n\
    \             <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n  \
    \           <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n      \
    \       <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n            \
    \ <&'a isize as Add<isize>>\n           and 48 others\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n\tlet mut result:\
    \ String = \"\".to_string();\n\tlet chars: Vec<char> = s.chars().collect();\n\t\
    for c in chars {\n\t\tif c as u8 >= 97 && c as u8 <= 122 {\n\t\t\tlet new_ascii\
    \ = c as u8 + 4;\n\t\t\tif new_ascii > 122 {\n\t\t\t\tlet new_num = new_ascii\
    \ - 122 + 96;\n\t\t\t\tresult.push(new_num as char);\n\t\t\t} else {\n\t\t\t\t\
    result.push(new_ascii as char);\n\t\t\t}\n\t\t} else {\n\t\t\tresult.push(c);\n\
    \t\t}\n\t}\n\tresult\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// encrypt('hi') returns 'lm'\n\
    /// encrypt('asdfghjkl') returns 'ewhjklnop'\n/// encrypt('gf') returns 'kj'\n\
    /// encrypt('et') returns 'ix'\nfn encrypt(s: String) -> String {\n    let mut\
    \ v: Vec<char> = Vec::new();\n    for c in s.chars() {\n        let n = ((c as\
    \ u8 - 96) * 2 + 2) % 26;\n        v.push((n as u8 + 96) as char);\n    }\n  \
    \  v.into_iter().collect()\n}\n\nfn main() {\n    let candidate = encrypt;\n \
    \   assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"rt\"`,\n right: `\"lm\"`', /tmp/tmpn3qyz6lq.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
