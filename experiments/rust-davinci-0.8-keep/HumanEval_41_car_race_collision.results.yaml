name: HumanEval_41_car_race_collision
language: rust
results:
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut nl = n;\n    let\
    \ mut nr = n;\n    let mut i = 0;\n    let mut j = 0;\n    let mut il = -1;\n\
    \    let mut ir = -1;\n    let mut jl = -1;\n    let mut jr = -1;\n    let mut\
    \ x: isize;\n    let mut y: isize;\n    let mut temp: isize;\n    let mut zero:\
    \ isize = 0;\n    loop {\n        if nl == zero {\n            break;\n      \
    \  }\n        temp = il;\n        il = i;\n        i = temp;\n        temp = jl;\n\
    \        jl = j;\n        j = temp;\n        j = j + 1;\n        y = i - j;\n\
    \        x = j - il;\n        if x > y {\n            collisions = collisions\
    \ + 1;\n        }\n        nl = nl - 1;\n    }\n    loop {\n        if nr == zero\
    \ {\n            break;\n        }\n        temp = ir;\n        ir = i;\n    \
    \    i = temp;\n        temp = jr;\n        jr = j;\n        j = temp;\n     \
    \   j = j + 1;\n        y = i - j;\n        x = j - ir;\n        if x > y {\n\
    \            collisions = collisions + 1;\n        }\n        nr = nr - 1;\n \
    \   }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `9`', /tmp/tmpw7jc9her.rs:65:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n    let mut total\
    \ = 0;\n    for car_index in 0..n {\n        // how many cars does this car collide\
    \ with\n        let cars_collided = n - car_index - 1;\n        total += cars_collided;\n\
    \    }\n    total\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpbhywjadb.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut i = 0;\n    let mut j = n - 1;\n    let mut result\
    \ = 0;\n    while i < j {\n        if i < j {\n            i += 1;\n         \
    \   result += 1;\n        }\n        if i < j {\n            j -= 1;\n       \
    \     result += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpy2dzhqlt.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (1..n).fold(0, |sum, i| sum + i * (n - i))\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpitvsjxxf.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut x = n - 1;\n    for i in 0..n {\n        x +=\
    \ i;\n    }\n    x\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmph6ef0b43.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // TODO\n    let mut i = 0;\n    let mut j = 0;\n   \
    \ let mut count = 0;\n    while i < n {\n        let mut k = 0;\n        while\
    \ k < n {\n            if k == j {\n                j = j + 1;\n             \
    \   count = count + 1;\n            }\n            k = k + 1;\n        }\n   \
    \     i = i + 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpwq00wl2t.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut num_collisions = 0;\n    let mut left_to_right\
    \ = Vec::with_capacity(n as usize);\n    let mut right_to_left = Vec::with_capacity(n\
    \ as usize);\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    while !left_to_right.is_empty() && !right_to_left.is_empty()\
    \ {\n        if left_to_right[0] < right_to_left[0] {\n            left_to_right.remove(0);\n\
    \            num_collisions += 1;\n        } else {\n            right_to_left.remove(0);\n\
    \        }\n    }\n    num_collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpqzw1rlr8.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp8vm2mug7.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    0\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp3b31k874.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n < 1 {\n        return 0;\n    }\n    car_race_collision(n\
    \ - 1) + n - 1\n}\n\nfn main() {\n    let candidate = car_race_collision;\n  \
    \  assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpk6qsqwzc.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    n * (n - 1) / 2\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpmwlwiuht.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut a = vec![0; n as usize];\n    let mut b = vec![0;\
    \ n as usize];\n    let mut count = 0;\n    for i in 0..n {\n        a[i as usize]\
    \ = 2 * i;\n        b[i as usize] = 2 * i - 1;\n    }\n    for &i in a.iter()\
    \ {\n        for &j in b.iter() {\n            if i == j {\n                count\
    \ += 1;\n            }\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpcf4dq09m.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // TODO: implement this function\n    let mut out = 0;\n\
    \    for i in 0..n {\n        for j in 0..n {\n            if i > j {\n      \
    \          out += 1;\n            }\n        }\n    }\n    out\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp32e9wn7d.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count = 0;\n    for i in 1..n {\n        for\
    \ j in 1..n {\n            if (i * j) % n == 0 {\n                count += 1;\n\
    \            }\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpo39qgqzw.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpcxl3oxmu.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut ans = 0;\n    let mut cars = vec![0; 2 * n as\
    \ usize];\n    for i in 0..n {\n        cars[i as usize] = i;\n    }\n    for\
    \ i in n..2 * n {\n        cars[i as usize] = 2 * n - i - 1;\n    }\n    cars.sort();\n\
    \    for i in 0..2 * n {\n        if cars[i as usize] == i {\n            ans\
    \ += 1;\n        }\n    }\n    ans\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmprzfh20yk.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    car_race_collision_helper(n, n)\n}\n\nfn main() {\n \
    \   let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n  \
    \  assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `car_race_collision_helper` in this\
    \ scope\n  --> /tmp/tmp_6nvxtuo.rs:10:5\n   |\n10 |     car_race_collision_helper(n,\
    \ n)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    println!(\"n={}\", n);\n    if n <= 0 {\n        return\
    \ 0;\n    }\n\n    let mut ans = 0;\n    for i in 1..n {\n        let l: isize\
    \ = (i - 1) * (n - i);\n        if l < 0 {\n            panic!(\"l < 0\");\n \
    \       }\n        ans += l;\n    }\n    ans * 2\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: "n=2\n"
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp9v14l0n9.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count = 0;\n    let mut left_to_right = vec![false;\
    \ n as usize];\n    let mut right_to_left = vec![false; n as usize];\n    // generate\
    \ the left to right array\n    for i in 0..n {\n        left_to_right[i as usize]\
    \ = true;\n        count += rtl_collision(&left_to_right, &right_to_left);\n \
    \   }\n    // generate the right to left array\n    for i in 0..n {\n        right_to_left[i\
    \ as usize] = true;\n        count += ltr_collision(&left_to_right, &right_to_left);\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `rtl_collision` in this scope\n  -->\
    \ /tmp/tmprxptq0wy.rs:16:18\n   |\n16 |         count += rtl_collision(&left_to_right,\
    \ &right_to_left);\n   |                  ^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `ltr_collision` in this scope\n  --> /tmp/tmprxptq0wy.rs:21:18\n\
    \   |\n21 |         count += ltr_collision(&left_to_right, &right_to_left);\n\
    \   |                  ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // 1. car_race_collision(n) = car_race_collision(n-1)\
    \ + n - 1\n    // 2. car_race_collision(1) = 0\n    if n == 1 {\n        return\
    \ 0;\n    }\n    car_race_collision(n - 1) + n - 1\n}\n\nfn main() {\n    let\
    \ candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp0bm1omga.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    car_race_collision_helper(n, 0)\n}\n\nfn main() {\n \
    \   let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n  \
    \  assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `car_race_collision_helper` in this\
    \ scope\n  --> /tmp/tmpx3pxqs8o.rs:10:5\n   |\n10 |     car_race_collision_helper(n,\
    \ 0)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars = vec![0; 2 * n as usize];\n    let mut\
    \ cars2 = vec![0; 2 * n as usize];\n    for i in 0..n {\n        cars[i as usize]\
    \ = i;\n        cars2[i as usize] = -i;\n    }\n    mergesort_cars(&mut cars2,\
    \ &mut cars);\n    return car_race_collision_helper(&mut cars, &mut cars2, 0,\
    \ n) as isize;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n  \
    \  assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `mergesort_cars` in this scope\n  -->\
    \ /tmp/tmp0kutsfq4.rs:16:5\n   |\n16 |     mergesort_cars(&mut cars2, &mut cars);\n\
    \   |     ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `car_race_collision_helper` in this scope\n  --> /tmp/tmp0kutsfq4.rs:17:12\n\
    \   |\n17 |     return car_race_collision_helper(&mut cars, &mut cars2, 0, n)\
    \ as isize;\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    0\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpyzvbi0w8.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut car_right_to_left = Vec::with_capacity(n as usize);\n\
    \    let mut car_left_to_right = Vec::with_capacity(n as usize);\n    for _ in\
    \ 0..n {\n        car_right_to_left.push(Position::new(5, -100));\n        car_left_to_right.push(Position::new(5,\
    \ 100));\n    }\n    for t in 0..100 {\n        let mut i = 0;\n        for car\
    \ in car_right_to_left.iter_mut() {\n            car.x += 1;\n            car.y\
    \ += 1;\n            let j = i;\n            let other_car = &mut car_left_to_right[j];\n\
    \            if car.y == other_car.y {\n                car.y += 1;\n        \
    \        other_car.y -= 1;\n            }\n            i += 1;\n        }\n  \
    \      let mut i = 0;\n        for car in car_left_to_right.iter_mut() {\n   \
    \         car.x += 1;\n            car.y -= 1;\n            let j = i;\n     \
    \       let other_car = &mut car_right_to_left[j];\n            if car.y == other_car.y\
    \ {\n                car.y -= 1;\n                other_car.y += 1;\n        \
    \    }\n            i += 1;\n        }\n    }\n    let mut collisions = 0;\n \
    \   for (car1, car2) in car_right_to_left.iter().zip(car_left_to_right.iter())\
    \ {\n        if car1.y == car2.y {\n            collisions += 1;\n        }\n\
    \    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Position`\n  -->\
    \ /tmp/tmpba_zq71y.rs:13:32\n   |\n13 |         car_right_to_left.push(Position::new(5,\
    \ -100));\n   |                                ^^^^^^^^ use of undeclared type\
    \ `Position`\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n\
    \  --> /tmp/tmpba_zq71y.rs:14:32\n   |\n14 |         car_left_to_right.push(Position::new(5,\
    \ 100));\n   |                                ^^^^^^^^ use of undeclared type\
    \ `Position`\n\nerror[E0609]: no field `x` on type `&mut _`\n  --> /tmp/tmpba_zq71y.rs:19:17\n\
    \   |\n19 |             car.x += 1;\n   |                 ^\n\nerror[E0609]: no\
    \ field `y` on type `&mut _`\n  --> /tmp/tmpba_zq71y.rs:23:35\n   |\n23 |    \
    \         if car.y == other_car.y {\n   |                                   ^\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0433, E0609.\nFor more information about an error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // TODO\n    0\n}\n\nfn main() {\n    let candidate =\
    \ car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpmjbwe74n.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // We can model a car's position as an integer that moves\
    \ left or right at unit\n    // speed.  A car driving from left to right has a\
    \ positive position, and a car\n    // driving from right to left has a negative\
    \ position.\n    // Thus, a car from left to right has position x, and a car from\
    \ right to left\n    // has position -x.\n    // A collision happens when two\
    \ cars have the same position.\n    // Since the two sets of cars start out being\
    \ very far from each other,\n    // every collision occurs when a car from left\
    \ to right drives across\n    // a car from right to left.\n    // The question\
    \ of counting the number of collisions is equivalent to\n    // the question of\
    \ counting the number of negative integers.\n    // Thus, there are n collisions.\n\
    \    n\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp_1eza_k2.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    n * (n - 1) / 2\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpb6sfs0z6.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // No collision is possible when there is only 1 car\
    \ in each direction\n    if n <= 1 {\n        return 0;\n    }\n\n    // Think\
    \ of each of these cars as being a '1' in a binary number.\n    // So for example,\
    \ the first car in the left direction is a '1',\n    // the second car is a '10',\
    \ the third car is a '100', etc.\n    // Then sum up all these binary numbers\
    \ together.  The lowest bit\n    // will be the number of collisions involving\
    \ the first car in the\n    // left direction and the first car in the right direction.\n\
    \    // The second lowest bit will be the number of collisions involving\n   \
    \ // the first car in the left direction and the second car in the\n    // right\
    \ direction.  And so on.\n    // Specifically, return the lowest log2(n) bits\
    \ of sum, where\n    // n is the total number of cars.\n    let mut sum = 0;\n\
    \    for i in 0..n {\n        sum += 1 << i;\n    }\n    sum & ((1 << (n as usize))\
    \ - 1)\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpcaz5_eu_.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count: isize = 0;\n    let mut i: isize = 1;\n\
    \    while i <= n {\n        count += i;\n        i += 1;\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmp0trh6g81.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // Write your code here\n    0\n}\n\nfn main() {\n  \
    \  let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n   \
    \ assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp7qaayp3b.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n < 2 {\n        return 0;\n    }\n    let mut sum\
    \ = 1;\n    let mut k = 1;\n    while k < n - 1 {\n        sum += k;\n       \
    \ k += 1;\n    }\n    return sum;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpag7ps2m1.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        0\n    } else {\n        let mut\
    \ i = 1;\n        let mut prev = 0;\n        let mut curr = 1;\n        while\
    \ i < n {\n            let temp = curr;\n            curr = prev + curr;\n   \
    \         prev = temp;\n            i += 1;\n        }\n        n * (n - 1) /\
    \ 2 - curr\n    }\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpv7hi7mdf.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_car_positions = HashSet::new();\n    let\
    \ mut right_car_positions = HashSet::new();\n    for i in 0..n {\n        let\
    \ pos = i * 2;\n        left_car_positions.insert(pos);\n        right_car_positions.insert(-pos);\n\
    \    }\n    let mut current_positions = HashSet::new();\n    let mut collisions\
    \ = 0;\n    for car_pos in left_car_positions.iter() {\n        current_positions.insert(*car_pos);\n\
    \        if current_positions.contains(&(*car_pos + 1)) {\n            collisions\
    \ += 1;\n        }\n    }\n    for car_pos in right_car_positions.iter() {\n \
    \       current_positions.insert(*car_pos);\n        if current_positions.contains(&(*car_pos\
    \ - 1)) {\n            collisions += 1;\n        }\n    }\n    collisions\n}\n\
    \nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmprpwyav1h.rs:10:34\n   |\n10 |     let mut left_car_positions = HashSet::new();\n\
    \   |                                  ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmprpwyav1h.rs:11:35\n   |\n11 |     let mut right_car_positions =\
    \ HashSet::new();\n   |                                   ^^^^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmprpwyav1h.rs:17:33\n   |\n17 |     let mut current_positions = HashSet::new();\n\
    \   |                                 ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n < 1 {\n        return 0;\n    }\n    // cars n -\
    \ 1 ... 0 are moving left to right.\n    // cars n - 1 ... 0 are moving right\
    \ to left.\n    // a car n - 1 is at position n - 1.\n    // a car n - 2 is at\
    \ position 2 * n - 2.\n    // a car n - 3 is at position 3 * n - 3.\n    // ...\n\
    \    // car 0 is at position n * n - n.\n    let mut cur = n;\n    let mut res\
    \ = 0;\n    for i in (0..n).rev() {\n        if cur > i {\n            res +=\
    \ cur - i;\n        }\n        cur += i;\n    }\n    res\n}\n\nfn main() {\n \
    \   let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n  \
    \  assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `11`,\n right: `9`', /tmp/tmpxjmtdxy4.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count: isize = 0;\n    let mut right_to_left:\
    \ Vec<bool> = vec![false; n as usize];\n    let mut left_to_right: Vec<bool> =\
    \ vec![false; n as usize];\n    for i in 0..n {\n        for j in 0..n {\n   \
    \         if !left_to_right[i as usize] && !right_to_left[j as usize] {\n    \
    \            count += 1;\n                left_to_right[i as usize] = true;\n\
    \                right_to_left[j as usize] = true;\n            }\n        }\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpw8mzssr5.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    use std::cmp::{min, max};\n    if n <= 1 {\n        return\
    \ 0;\n    }\n    // Let's say we have n cars driving right to left, with velocity\n\
    \    // vec![v_0, v_1, ..., v_n-1].\n    // We want to count the number of collisions\
    \ with the cars that are\n    // driving left to right (which are of the form\
    \ [1, 2, ..., n]).\n    // Since these cars can only move in the positive direction,\
    \ if two cars\n    // collide, we must have (for some i and j) that v_i >= j and\
    \ v_j >= i.\n    // We can visualize this as a bunch of cells.\n    // We'll have\
    \ n rows and n columns, of form\n    // [ v_0  v_1  v_2  ...  v_n-1 ]\n    //\
    \ [ 1    2    3    ...  n     ]\n    // [ 2    3    4    ...  n+1   ]\n    //\
    \ [ ...                 ...   ]\n    // [ n    n+1  n+2  ...  2n-1  ]\n    //\
    \ We'll be interested in the number of cells with v_i >= j, so we want to know\n\
    \    // how many cells are above the lower-right to upper-left diagonal.\n   \
    \ // We can count this by doing the following.  For each row, we'll keep track\
    \ of\n    // how many elements are on or above the lower-right to upper-left diagonal,\
    \ and\n    // how many are below the diagonal.  Then, the number of elements above\
    \ the diagonal\n    // in each row is (n - num_below_diagonal).  So we can sum\
    \ up those numbers and multiply\n    // by 2 (since we want to count each collision\
    \ twice) to get the total number of collisions.\n    let mut num_above_diagonal\
    \ = 0;\n    let mut num_below_diagonal = 0;\n    for i in 0..n {\n        let\
    \ v_i = n - i;\n        for j in 0..n {\n            let v_j = n - j;\n      \
    \      if v_i >= v_j {\n                num_above_diagonal += 1;\n           \
    \ } else {\n\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpjuovyylb.rs:53:3\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - unclosed delimiter\n...\n36 |     for i in 0..n {\n\
    \   |                   - unclosed delimiter\n37 |         let v_i = n - i;\n\
    38 |         for j in 0..n {\n   |                       - unclosed delimiter\n\
    ...\n42 |             } else {\n   |                    - this delimiter might\
    \ not be properly closed...\n43 | \n44 | }\n   | - ...as it matches this but it\
    \ has different indentation\n...\n53 | }\n   |   ^\n\nwarning: unused imports:\
    \ `max`, `min`\n  --> /tmp/tmpjuovyylb.rs:10:20\n   |\n10 |     use std::cmp::{min,\
    \ max};\n   |                    ^^^  ^^^\n   |\n   = note: `#[warn(unused_imports)]`\
    \ on by default\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjuovyylb.rs:36:5\n\
    \   |\n9  |   fn car_race_collision(n: isize) -> isize {\n   |               \
    \                       ----- expected `isize` because of return type\n...\n36\
    \ | /     for i in 0..n {\n37 | |         let v_i = n - i;\n38 | |         for\
    \ j in 0..n {\n39 | |             let v_j = n - j;\n...  |\n52 | |     assert_eq!(candidate(10),\
    \ 100);\n53 | | }\n   | |__^ expected `isize`, found `()`\n\nerror: aborting due\
    \ to 2 previous errors; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // TODO: actually implement this function.\n    0\n}\n\
    \nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpztjlluoe.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    car_race_collision_recursive(n, 0)\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `car_race_collision_recursive` in this\
    \ scope\n  --> /tmp/tmp9k9rm8y2.rs:10:5\n   |\n10 |     car_race_collision_recursive(n,\
    \ 0)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (1..n).map(|i| i * (n - i)).sum()\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp9bkud9wu.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // TODO implement this function\n\n    n - n + 1\n}\n\
    \nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp_hlemdi7.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // As the cars move, this represents the segment of the\
    \ road that\n    // has no cars in it.  The cars are represented by this line\
    \ segment\n    // shrinking to zero size.  As the line segment shrinks to zero,\
    \ it is\n    // essentially representing the collision of two cars.\n    let mut\
    \ no_car_segment = n;\n\n    // This function essentially represents the left\
    \ side of the road that\n    // consists of moving cars.  It essentially represents\
    \ the left side of\n    // the line segment representing no cars in the road.\n\
    \    // It essentially represents the shrinking of the line segment representing\n\
    \    // no cars in the road.\n    fn helper(no_car_segment: isize) -> isize {\n\
    \        if no_car_segment == 0 {\n            return 0;\n        }\n\n      \
    \  // In this case, the line segment is too big to shrink.  So we\n        //\
    \ have to partition it into two smaller line segments and pass them\n        //\
    \ to two recursive calls.\n        if no_car_segment >= 2 {\n            let left_no_car_segment\
    \ = no_car_segment / 2;\n            let right_no_car_segment = no_car_segment\
    \ - left_no_car_segment;\n            return helper(left_no_car_segment) + helper(right_no_car_segment);\n\
    \        }\n\n        // In this case, the line segment cannot be partitioned\
    \ into two smaller\n        // line segments; so we must have a collision in the\
    \ road.\n        // The cars are infinitely strong and sturdy, so they do not\
    \ stop.\n        // They just continue going; so we have to account for the collision.\n\
    \        1\n    }\n\n    // Kick off the recursion.\n    helper(no_car_segment)\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpq35ew69j.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut position_right_to_left = HashSet::new();\n  \
    \  let mut position_left_to_right = HashSet::new();\n    let mut collides = 0;\n\
    \    for i in 0..n {\n        position_right_to_left.insert(i as isize);\n   \
    \     position_left_to_right.insert(n - i - 1);\n    }\n    let mut index_right_to_left\
    \ = 0;\n    let mut index_left_to_right = 0;\n    let mut direction_right_to_left\
    \ = 1;\n    let mut direction_left_to_right = -1;\n    loop {\n        // Cars\
    \ moving right to left\n        if position_right_to_left.contains(&index_right_to_left)\
    \ {\n            // In case the car is moving right to left\n            if position_left_to_right.contains(&index_right_to_left)\
    \ {\n                collides += 1;\n            }\n            index_right_to_left\
    \ += direction_right_to_left;\n            if index_right_to_left >= n {\n   \
    \             direction_right_to_left = -1;\n                index_right_to_left\
    \ = n - 1;\n            } else if index_right_to_left < 0 {\n                direction_right_to_left\
    \ = 1;\n                index_right_to_left = 0;\n            }\n        } else\
    \ {\n            index_right_to_left += direction_right_to_left;\n           \
    \ if index_right_to_left >= n {\n                direction_right_to_left = -1;\n\
    \                index_right_to_left = n - 1;\n            } else if index_right_to_left\
    \ < 0 {\n                direction_right_to_left = 1;\n                index_right_to_left\
    \ = 0;\n            }\n        }\n        // Cars moving left to right\n     \
    \   if position_left_to_right.contains(&index_left_to_right) {\n            //\
    \ In case the car is moving left to right\n            if position_right_to_left.contains(&index_left_to_right)\
    \ {\n                collides += 1;\n            }\n\n}\n\nfn main() {\n    let\
    \ candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpajxv1uzi.rs:62:3\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - unclosed delimiter\n...\n21 |     loop {\n   |   \
    \       - unclosed delimiter\n...\n47 |         if position_left_to_right.contains(&index_left_to_right)\
    \ {\n   |                                                                  - this\
    \ delimiter might not be properly closed...\n...\n53 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n62 | }\n   |   ^\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpajxv1uzi.rs:10:38\n\
    \   |\n10 |     let mut position_right_to_left = HashSet::new();\n   |       \
    \                               ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpajxv1uzi.rs:11:38\n\
    \   |\n11 |     let mut position_left_to_right = HashSet::new();\n   |       \
    \                               ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    //\n    // Note that the number of collisions is equal\
    \ to the number of pairs\n    // in which the first car comes before the second\
    \ car, considering the order in which\n    // the cars start the race.\n    //\n\
    \    // So, the number of such collisions is equal to:\n    //\n    // n*(n-1)/2,\n\
    \    //\n    // but you can't compute it by multiplying, because then you overflow.\n\
    \    //\n    // Instead, you can compute it by adding:\n    //\n    // 0 + 1 +\
    \ 2 + 3 + ... + (n-1)\n    //\n    // Using the following trick.\n    //\n   \
    \ // In fact,\n    //\n    // 0 + 1 + 2 + 3 + ... + (n-1) =\n    // (n-1) + (n-2)\
    \ + (n-3) + ... + 0\n    //\n    // (in other words, the sum of the numbers from\
    \ 0 to n-1 is equal to the\n    // sum of the numbers from n-1 to 0)\n    //\n\
    \    // This is because the sum from 0 to n-1 adds up everything\n    // and then\
    \ adds n-1 to the result; the sum from n-1 to 0 adds up everything\n    // and\
    \ then adds 0 to the result.\n    //\n    // So, you can use this fact to implement\
    \ the function without overflowing.\n    //\n    // The first and last numbers\
    \ are the same.  The second and second to last\n    // numbers are the same. \
    \ The third and third to last numbers are the same.\n    // The fourth and fourth\
    \ to last numbers are the same.\n    //\n    // The next number after the last\
    \ number is the one right before the first number.\n    //\n    // In other words,\n\
    \    //\n    //     1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n    // 1 + 2 + 3 + 4 + 5 +\
    \ 6 + 7 + 8 + 9 + 10\n    //     10 + 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1\n    //\
    \ -----------------------------------------\n    //     2 + 2 + 2 + 2 + 2 + 2\
    \ + 2 + 2 + 2 + 2\n    //     11 + 11 + 11\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpl06fzhlb.rs:9:36\n  |\n9 |\
    \ fn car_race_collision(n: isize) -> isize {\n  |    ------------------      \
    \        ^^^^^ expected `isize`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (1..n+1).map(|x| (n-x+1)*x).sum()\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `10`,\n right: `9`', /tmp/tmp__qn265u.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left: Vec<isize> = Vec::new();\n    let mut right:\
    \ Vec<isize> = Vec::new();\n    for i in 0..n {\n        left.push(i);\n     \
    \   right.push(n - i - 1);\n    }\n    left.sort();\n    right.sort();\n    merge_sort_collision(&mut\
    \ left, &mut right)\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `merge_sort_collision` in this scope\n\
    \  --> /tmp/tmp4cqxevgo.rs:18:5\n   |\n18 |     merge_sort_collision(&mut left,\
    \ &mut right)\n   |     ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left = HashSet::new();\n    let mut right = HashSet::new();\n\
    \    for i in 0..n {\n        left.insert(i);\n        right.insert(n + i);\n\
    \    }\n    let mut collisions = 0;\n    while left.len() > 0 && right.len() >\
    \ 0 {\n        let mut s: HashSet<isize> = HashSet::new();\n        for i in &left\
    \ {\n            if right.contains(i) {\n                collisions += 1;\n  \
    \          } else {\n                s.insert(*i);\n            }\n        }\n\
    \        left = s;\n        let mut s: HashSet<isize> = HashSet::new();\n    \
    \    for i in &right {\n            if left.contains(i) {\n                collisions\
    \ += 1;\n            } else {\n                s.insert(*i);\n            }\n\
    \        }\n        right = s;\n    }\n    collisions\n}\n\nfn main() {\n    let\
    \ candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp_xw4ftjs.rs:10:20\n   |\n10 |     let mut left = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp_xw4ftjs.rs:11:21\n\
    \   |\n11 |     let mut right = HashSet::new();\n   |                     ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0412]: cannot find type `HashSet`\
    \ in this scope\n  --> /tmp/tmp_xw4ftjs.rs:18:20\n   |\n18 |         let mut s:\
    \ HashSet<isize> = HashSet::new();\n   |                    ^^^^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmp_xw4ftjs.rs:18:37\n   |\n18 |         let mut s: HashSet<isize>\
    \ = HashSet::new();\n   |                                     ^^^^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp_xw4ftjs.rs:27:20\n\
    \   |\n27 |         let mut s: HashSet<isize> = HashSet::new();\n   |        \
    \            ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp_xw4ftjs.rs:27:37\n\
    \   |\n27 |         let mut s: HashSet<isize> = HashSet::new();\n   |        \
    \                             ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut answer = 0;\n    let mut right_to_left_cars =\
    \ vec![];\n    for i in 0..n {\n        let mut collisions = 0;\n        // if\
    \ there's a collision, then there cannot be a collision with a car\n        //\
    \ that hasn't arrived yet.  We do not consider such cars; they will be\n     \
    \   // handled by the next iteration.\n        while let Some(index) = right_to_left_cars.pop()\
    \ {\n            if index > i {\n                right_to_left_cars.push(index);\n\
    \                break;\n            }\n            collisions += 1;\n       \
    \ }\n        answer += collisions;\n        right_to_left_cars.push(n - i - 1);\n\
    \    }\n    answer\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpkkvbzjrm.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // We can do better than O(n^2), because the cars never\
    \ change their speed.\n    // As a result, the left to right car that enters from\
    \ the left meets the\n    // right to left car that enters from the right at a\
    \ specific moment in time.\n    // This means that we don't need to track the\
    \ cars' positions at every moment\n    // in time.  We only need to track the\
    \ number of cars that entered at each point in time.\n    // The cars never change\
    \ their speed, so the number of cars that entered at each moment in time\n   \
    \ // stays constant.\n    // We will track the number of cars that enter at each\
    \ moment in time as a hash table.\n    // The key is the time a car enters, and\
    \ the value is the number of cars that entered at that time.\n    // Initially,\
    \ the hash table will be empty.\n    let mut cars_entering_at_time = HashMap::new();\n\
    \    // Let's first initialize the map for the cars entering from the left.\n\
    \    for x in 0..n {\n        // Cars entering from the left will enter at time\
    \ x, since it takes x time for a car that\n        // started from the left to\
    \ reach the intersection.\n        let number_of_cars_entering_at_time = cars_entering_at_time.entry(x).or_insert(0);\n\
    \        *number_of_cars_entering_at_time += 1;\n    }\n    // Now we'll initialize\
    \ the map for the cars entering from the right.\n    for x in 0..n {\n       \
    \ // Cars entering from the right will enter at time -x, since it takes x time\
    \ for a car that\n        // started from the right to reach the intersection.\n\
    \        let number_of_cars_entering_at_time = cars_entering_at_time.entry(-x).or_insert(0);\n\
    \        *number_of_cars_entering_at_time += 1;\n    }\n    // So now we have\
    \ a hash table that maps each time a car enters to the number of cars that enter\n\
    \    // at that time.  Now we'll iterate over the hash table, and for each time,\
    \ we'll compute the\n    // number of cars that enter from the opposite direction\
    \ at that time, and\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpe98lp36e.rs:20:37\n   |\n20 |     let mut cars_entering_at_time = HashMap::new();\n\
    \   |                                     ^^^^^^^ not found in this scope\n  \
    \ |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe98lp36e.rs:29:5\n   |\n\
    9  |   fn car_race_collision(n: isize) -> isize {\n   |                      \
    \                ----- expected `isize` because of return type\n...\n29 | /  \
    \   for x in 0..n {\n30 | |         // Cars entering from the right will enter\
    \ at time -x, since it takes x time for a car that\n31 | |         // started\
    \ from the right to reach the intersection.\n32 | |         let number_of_cars_entering_at_time\
    \ = cars_entering_at_time.entry(-x).or_insert(0);\n33 | |         *number_of_cars_entering_at_time\
    \ += 1;\n34 | |     }\n   | |_____^ expected `isize`, found `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left = vec![0; n as usize];\n    let mut right\
    \ = vec![0; n as usize];\n    for i in 0..n {\n        left[i as usize] = 2 *\
    \ i;\n        right[i as usize] = 2 * i + 1;\n    }\n    let mut res = 0;\n  \
    \  for pos in left {\n        for pos2 in right.iter() {\n            if pos2\
    \ <= &pos {\n                res += 1;\n            }\n        }\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp9tzohd4n.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // No cars on the road so no collisions\n    if n ==\
    \ 0 {\n        return 0;\n    }\n\n    // There is one car on the road.  It must\
    \ collide with itself.\n    if n == 1 {\n        return 1;\n    }\n\n    // There\
    \ are two cars on the road.  One is moving left, the other right.\n    // They\
    \ each start out 10 miles away from each other and move at 40 miles\n    // per\
    \ hour.  Do they collide?\n    //\n    // We can find out how much time has elapsed\
    \ since the cars started moving\n    // by using the formula:\n    //\n    //\
    \      distance = speed * time\n    //\n    // Solving for time, we get\n    //\n\
    \    //      time = distance / speed\n    //\n    // In this case, we want to\
    \ know how much time elapses when two cars that\n    // start out 10 miles apart\
    \ from each other and move at 40 miles per hour\n    // travel in opposite directions.\
    \  It takes 0.25 hours, or 15 minutes.\n    //\n    // It helps to look at this\
    \ problem in terms of a graph of the cars'\n    // movements.  Imagine a graph\
    \ where the x-axis represents miles and the\n    // y-axis represents time.  The\
    \ cars start out at (10, 0) and (0, 0).\n    // They travel in opposite directions\
    \ at the same speed, so we can plot\n    // the location of the cars every 15\
    \ minutes.\n    //\n    //      After 15 minutes  (0, 15)     (10, 15)\n    //\
    \      After 30 minutes  (-10, 30)   (20, 30)\n    //      After 45 minutes  (-20,\
    \ 45)   (30, 45)\n    //      After 60 minutes  (-30, 60)   (40, 60)\n    //\n\
    \    // We see that the cars collide at the point (0, 30).  Since the x-axis\n\
    \    // represents miles, the cars collide at mile 0.\n    //\n    // Let's try\
    \ with three cars.  One car starts out at 10 miles, goes left,\n    // and travels\
    \ at 40 miles per hour.  The other two cars start out at 0 miles\n    // and travel\
    \ at 30 miles per hour.  Do they collide?\n   \n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0317]: `if` may be missing an `else` clause\n  --> /tmp/tmpueh__q2q.rs:16:5\n\
    \   |\n9  |   fn car_race_collision(n: isize) -> isize {\n   |               \
    \                       ----- expected `isize` because of this return type\n...\n\
    16 | /     if n == 1 {\n17 | |         return 1;\n18 | |     }\n   | |_____^ expected\
    \ `isize`, found `()`\n   |\n   = note: `if` expressions without `else` evaluate\
    \ to `()`\n   = help: consider adding an `else` block that evaluates to the expected\
    \ type\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0317`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (1..n + 1).sum()\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpd32t0xwu.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // While the list of moving left to right cars and the\
    \ list of moving right to left cars\n    // are both non-empty, this program compares\
    \ the leftmost moving left to right car and\n    // the rightmost moving right\
    \ to left car.  If their positions intersect, we get a\n    // collision.\n  \
    \  let mut left_to_right_cars = Vec::new();\n    for i in 0..n {\n        left_to_right_cars.push(i);\n\
    \    }\n    let mut right_to_left_cars = Vec::new();\n    for i in 0..n {\n  \
    \      right_to_left_cars.push(i);\n    }\n    let mut collisions = 0;\n    while\
    \ !left_to_right_cars.is_empty() && !right_to_left_cars.is_empty() {\n       \
    \ if left_to_right_cars[0] == right_to_left_cars[right_to_left_cars.len() - 1]\
    \ {\n            collisions += 1;\n        }\n        right_to_left_cars.pop();\n\
    \        left_to_right_cars.remove(0);\n    }\n    collisions\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpz_jvdtov.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // The maximal number of cars that can\n    // potentially\
    \ collide is the first n cars on the\n    // left plus the first n cars on the\
    \ right.\n    // There's no potential collision between cars that\n    // are\
    \ further than that, since they would be too far away.\n    (1..=n).sum::<isize>()\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpmi3uy_4h.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = (0..n).collect();\n\
    \    let mut right_to_left: Vec<isize> = (0..n).rev().collect();\n    let mut\
    \ collisions = 0;\n    while !left_to_right.is_empty() && !right_to_left.is_empty()\
    \ {\n        if left_to_right[0] > right_to_left[0] {\n            collisions\
    \ += 1;\n            left_to_right.remove(0);\n            right_to_left.remove(0);\n\
    \        } else {\n            left_to_right.remove(0);\n        }\n    }\n  \
    \  collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n   \
    \ assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp3m6b4j5o.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut res = 0;\n    for i in 1..n + 1 {\n        for\
    \ j in 1..n + 1 {\n            if i < j {\n                res += 1;\n       \
    \     }\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmphcx6nnty.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 0 {\n        return 0;\n    }\n    // Arrange\
    \ the cars on a number line.\n    // Imagine two integers on the number line,\
    \ and imagine another line\n    // that is shifted one unit to the right of the\
    \ first line, and the integers\n    // on the second line are shifted by one unit\
    \ to the right of the first line.\n    // Start with the cars on the right line.\
    \  For the next n iterations,\n    // move the integers on the right line to the\
    \ left line and vise versa.\n    // I'm using a single vector and will use modular\
    \ arithmetic.\n    let mut v = Vec::with_capacity(n as usize);\n    for i in 0..n\
    \ {\n        v.push(i);\n    }\n    // We will flip the cars at position i to\
    \ position i+1.\n    let mut is_right_line = true;\n    let mut num_collisions\
    \ = 0;\n    for i in 0..n {\n        if is_right_line {\n            if v[i as\
    \ usize] == i + 1 {\n                num_collisions += 1;\n            }\n   \
    \         v[i as usize] = i + 1;\n        } else {\n            if v[i as usize]\
    \ == i {\n                num_collisions += 1;\n            }\n            v[i\
    \ as usize] = i;\n        }\n        is_right_line = !is_right_line;\n    }\n\
    \    num_collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpvexcdqgi.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // Note that all cars move in the same speed.\n    //\
    \ For example, let's consider the following case:\n    //\n    //         Left-to-right\
    \ cars:   [4, 7, 9, 11, 20]\n    //         Right-to-left cars:   [6, 8, 15, 24,\
    \ 25]\n    //\n    // Notice that we can immediately conclude that:\n    //  \
    \  - Any left-to-right car behind 20 will never collide.\n    //    - Any right-to-left\
    \ car behind 25 will never collide.\n    //    - Any left-to-right car before\
    \ 4 will never collide.\n    //    - Any right-to-left car before 6 will never\
    \ collide.\n    //\n    // Given this observation, we can design the following\
    \ algorithm:\n    //      - Let's say we have two pointers, one for left-to-right\
    \ cars,\n    //        and one for right-to-left cars.\n    //      - We can move\
    \ the left-to-right car pointer from left to right, and\n    //        similarly\
    \ move the right-to-left car pointer from right to left.\n    //      - As soon\
    \ as we found a pair of cars whose positions are within each other's\n    // \
    \       starting position, we know that they will collide.\n    //\n    // For\
    \ example, in the above case, we would first check 4 and 25,\n    // and then\
    \ 7 and 24, and so on.\n    //\n    // Therefore, the overall algorithmic complexity\
    \ is O(n).\n    // Note that this is a fairly simple problem, but it's a good\
    \ opportunity to introduce\n    // a few important concepts:\n    //\n    // \
    \     - Merge-sort-like algorithms.\n    //      - Finding \"largest-n\" and \"\
    smallest-n\" in a given array.\n    //      - Checking for collisions.\n    //\n\
    \    //     This problem also provides the following important lessons:\n    //\n\
    \    //      - In the above solution, the algorithm can be broken down into a\
    \ series of\n    //        smaller sub-problems.\n    //      - We can use a pair\
    \ of pointers to solve these sub-problems.\n    //      - The above solution can\
    \ be generalized to solve much more complex problems.\n    //\n    // If\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmph3ozybbj.rs:9:36\n  |\n9 |\
    \ fn car_race_collision(n: isize) -> isize {\n  |    ------------------      \
    \        ^^^^^ expected `isize`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // let mut left_cars = Vec::with_capacity(n as usize);\n\
    \    // let mut right_cars = Vec::with_capacity(n as usize);\n    // for _ in\
    \ 0..n {\n    //     left_cars.push(0);\n    //     right_cars.push(0);\n    //\
    \ }\n    // for i in 0..n {\n    //     left_cars[i as usize] = i;\n    //   \
    \  right_cars[i as usize] = n - i - 1;\n    // }\n    let mut cars: Vec<isize>\
    \ = Vec::with_capacity(n as usize);\n    for i in 0..n {\n        cars.push(i);\n\
    \    }\n    let mut left_cars = cars.clone();\n    let mut right_cars = cars.clone();\n\
    \    left_cars.sort();\n    right_cars.sort();\n    let mut collisions = 0;\n\
    \    let mut left_index = 0;\n    let mut right_index = n - 1;\n    while left_index\
    \ < n && right_index >= 0 {\n        if left_cars[left_index as usize] < right_cars[right_index\
    \ as usize] {\n            left_index += 1;\n        } else if left_cars[left_index\
    \ as usize] > right_cars[right_index as usize] {\n            right_index -= 1;\n\
    \        } else {\n            collisions += 1;\n            left_index += 1;\n\
    \            right_index -= 1;\n        }\n    }\n    collisions\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp0r4rvtbw.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    //\n    // The first car from the left will collide with\
    \ the nth car from the right.\n    // The second car from the left will collide\
    \ with the (n-1)th car from the right.\n    // And so on.\n    //\n    (n*(n-1))/2\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmptsn7fjc5.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // Each car (moving left to right) enters the scene at\
    \ a different time t.\n    // The cars (moving right to left) all enter at the\
    \ same time t=0.\n    // We are asked to count the number of collisions.\n   \
    \ // Since collisions happen one at a time, we can find the time of the\n    //\
    \ first collision (i.e. the smallest t), then compute the number of\n    // collisions\
    \ by counting the number of cars that have not yet entered\n    // the scene.\n\
    \n    // Find the time of the first collision.\n    let mut first_collision_time\
    \ = isize::max_value();\n    for i in 0..n {\n        let t = 2 * i + 2;\n   \
    \     first_collision_time = first_collision_time.min(t);\n    }\n\n    // Count\
    \ the number of cars that have not yet entered the scene\n    // at the time of\
    \ the first collision.\n    n - first_collision_time / 2\n}\n\nfn main() {\n \
    \   let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n  \
    \  assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp732ucu8_.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count = 0;\n    let mut cars = vec![0; n as usize];\n\
    \    let mut cars_rev = vec![0; n as usize];\n    for i in 0..n {\n        cars[i\
    \ as usize] = i + 1;\n        cars_rev[i as usize] = n - i;\n    }\n    let mut\
    \ index = 0;\n    while index < n {\n        let car = cars[index as usize];\n\
    \        let car_rev = cars_rev[index as usize];\n        if car_rev > car {\n\
    \            count += car_rev - car;\n        }\n        index += 1;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp1zobjjxd.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut res = 0;\n    if n > 1 {\n        res = n * (n\
    \ - 1) / 2;\n    }\n    res\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpukkno5x4.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 1 {\n        return 0;\n    }\n\n    let mut\
    \ left_to_right: Vec<bool> = Vec::new();\n    for _ in 0..n {\n        left_to_right.push(true);\n\
    \    }\n\n    let mut right_to_left: Vec<bool> = Vec::new();\n    for _ in 0..n\
    \ {\n        right_to_left.push(false);\n    }\n\n    let mut sum: isize = 0;\n\
    \    while left_to_right.len() > 0 && right_to_left.len() > 0 {\n        let front_left_to_right:\
    \ usize = left_to_right.remove(0);\n        let front_right_to_left: usize = right_to_left.remove(0);\n\
    \n        if front_left_to_right == front_right_to_left {\n            sum +=\
    \ 1;\n        }\n    }\n\n    sum\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpofwj9iif.rs:26:42\n   |\n\
    26 |         let front_left_to_right: usize = left_to_right.remove(0);\n   | \
    \                                 -----   ^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`,\
    \ found `bool`\n   |                                  |\n   |                \
    \                  expected due to this\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpofwj9iif.rs:27:42\n   |\n27 |         let front_right_to_left: usize\
    \ = right_to_left.remove(0);\n   |                                  -----   ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `bool`\n   |                                  |\n  \
    \ |                                  expected due to this\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut total = 0;\n    for i in 1..n + 1 {\n       \
    \ total += i;\n    }\n    total\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmph5vz97_1.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count = 0;\n    let n = n as usize;\n    for\
    \ i in 0..n {\n        for j in 0..n {\n            if i != j {\n            \
    \    if (i < j && j - i < n) || (i > j && i - j >= n) {\n                    count\
    \ += 1;\n                }\n            }\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpqggb4gnm.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut num_collisions = 0;\n    for car_1 in 0..n {\n\
    \        for car_2 in 0..n {\n            if car_1 > car_2 {\n               \
    \ num_collisions += 1;\n            }\n        }\n    }\n    num_collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpsxi81o61.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n < 2 {\n        return 0;\n    }\n    let (mut left_to_right,\
    \ mut right_to_left) = (vec![true; n as usize], vec![false; n as usize]);\n  \
    \  let mut time = 0;\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ || !right_to_left.is_empty() {\n        let mut pos_to_car_idx: HashMap<isize,\
    \ usize> = HashMap::new();\n        let mut new_left_to_right = vec![];\n    \
    \    let mut new_right_to_left = vec![];\n        for (idx, &direction) in left_to_right.iter().enumerate()\
    \ {\n            let pos = (time - idx as isize) * 2;\n            if let Some(&other_idx)\
    \ = pos_to_car_idx.get(&pos) {\n                collisions += 1;\n           \
    \     if pos_to_car_idx.get(&(pos + 1)).is_none() {\n                    new_left_to_right.push(direction);\n\
    \                }\n                if pos_to_car_idx.get(&(pos - 1)).is_none()\
    \ {\n                    new_right_to_left.push(!direction);\n               \
    \ }\n            } else {\n                pos_to_car_idx.insert(pos, idx);\n\
    \                new_left_to_right.push(direction);\n            }\n        }\n\
    \        left_to_right = new_left_to_right;\n        for (idx, &direction) in\
    \ right_to_left.iter().enumerate() {\n            let pos = (time - idx as isize)\
    \ * 2;\n            if let Some(&other_idx) = pos_to_car_idx.get(&pos) {\n   \
    \             collisions += 1;\n                if pos_to_car_idx.get(&(pos +\
    \ 1)).is_none() {\n                    new_left_to_right.push(direction);\n  \
    \              }\n                if pos_to_car_idx.get(&(pos - 1)).is_none()\
    \ {\n\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp5gehxl87.rs:54:3\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - unclosed delimiter\n...\n16 |     while !left_to_right.is_empty()\
    \ || !right_to_left.is_empty() {\n   |                                       \
    \                           - unclosed delimiter\n...\n36 |         for (idx,\
    \ &direction) in right_to_left.iter().enumerate() {\n   |                    \
    \                                               - unclosed delimiter\n37 |   \
    \          let pos = (time - idx as isize) * 2;\n38 |             if let Some(&other_idx)\
    \ = pos_to_car_idx.get(&pos) {\n   |                                         \
    \                       - unclosed delimiter\n...\n43 |                 if pos_to_car_idx.get(&(pos\
    \ - 1)).is_none() {\n   |                                                    \
    \         - this delimiter might not be properly closed...\n44 | \n45 | }\n  \
    \ | - ...as it matches this but it has different indentation\n...\n54 | }\n  \
    \ |   ^\n\nerror[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmp5gehxl87.rs:17:33\n\
    \   |\n17 |         let mut pos_to_car_idx: HashMap<isize, usize> = HashMap::new();\n\
    \   |                                 ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmp5gehxl87.rs:17:57\n   |\n17 |         let mut pos_to_car_idx: HashMap<isize,\
    \ usize> = HashMap::new();\n   |                                             \
    \            ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5gehxl87.rs:16:5\n   |\n9  |   fn car_race_collision(n:\
    \ isize) -> isize {\n   |                                      ----- expected\
    \ `isize` because of return type\n...\n16 | /     while !left_to_right.is_empty()\
    \ || !right_to_left.is_empty() {\n17 | |         let mut pos_to_car_idx: HashMap<"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        0\n    } else {\n        n - 1 +\
    \ car_race_collision(n - 1)\n    }\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmph2tiopa4.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut result = 0;\n    for i in 1..n {\n        for\
    \ j in i + 1..n + 1 {\n            result += i * j;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpz7rp_rcm.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // You can use this function to find the square root\
    \ of a number.\n    (1..n).fold(0, |acc, i| acc + (i * (n - i)))\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpunld6e7v.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // TODO: Write your code here.\n    isize::min(n, 0)\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpu335b_4n.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut c = n;\n    let mut cnt = 0;\n    while c !=\
    \ 0 {\n        c -= 1;\n        let mut z = n;\n        while z != 0 {\n     \
    \       z -= 1;\n            cnt += 1;\n        }\n    }\n    cnt\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut c = 0;\n    for i in 0..n {\n        for j in\
    \ 0..n {\n            if i < j {\n                c += 1;\n            }\n   \
    \     }\n    }\n    c\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpi624k2j5.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    n * (n - 1) / 2\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp790teqq0.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    ///  A simulation of a car race on an infinite road.\
    \  All cars move at the same speed.\n    ///  Both left and right cars are spawned\
    \ immediately at the start.\n    struct CarRace {\n        left_cars: Vec<isize>,\n\
    \        right_cars: Vec<isize>,\n    }\n\n    impl CarRace {\n        fn new(n:\
    \ isize) -> CarRace {\n            let mut left_cars = Vec::new();\n         \
    \   let mut right_cars = Vec::new();\n            for i in 0..n {\n          \
    \      left_cars.push(i);\n                right_cars.push(i);\n            }\n\
    \            CarRace {\n                left_cars,\n                right_cars,\n\
    \            }\n        }\n\n        /// Simulate one time step of the race.\n\
    \        /// Assume that a car can never leave the road.\n        /// We return\
    \ the number of cars that collided at this time step.\n        fn step(&mut self)\
    \ -> isize {\n            let mut nb_collisions = 0;\n            // The cars\
    \ whose position already has been checked; we have already\n            // detected\
    \ that they did not collide with any other car.\n            let mut checked_left_cars\
    \ = BTreeSet::new();\n            let mut checked_right_cars = BTreeSet::new();\n\
    \            for i in 0..self.left_cars.len() {\n                if !checked_left_cars.contains(&i)\
    \ {\n                    for j in 0..self.right_cars.len() {\n               \
    \         if !checked_right_cars.contains(&j) {\n                            if\
    \ self.left_cars[i] == self.right_cars[j] {\n                                nb_collisions\
    \ += 1;\n                                checked_left_cars.insert(i);\n      \
    \                          checked_right_cars.insert(j);\n                   \
    \         }\n                        }\n                    }\n              \
    \  }\n            }\n            // Advance the cars.\n            for i in 0..self.left_cars.len()\
    \ {\n                self.left_cars[i] += 1;\n            }\n            for i\
    \ in 0..self.right_cars.len() {\n                self.right_cars[i] -= 1;\n  \
    \          }\n            nb_\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpvacifgvl.rs:70:3\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - unclosed delimiter\n...\n17 |     impl CarRace {\n\
    \   |                  - unclosed delimiter\n...\n34 |         fn step(&mut self)\
    \ -> isize {\n   |                                     - this delimiter might\
    \ not be properly closed...\n...\n61 | }\n   | - ...as it matches this but it\
    \ has different indentation\n...\n70 | }\n   |   ^\n\nerror[E0433]: failed to\
    \ resolve: use of undeclared type `BTreeSet`\n  --> /tmp/tmpvacifgvl.rs:38:41\n\
    \   |\n38 |             let mut checked_left_cars = BTreeSet::new();\n   |   \
    \                                      ^^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::BTreeSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `BTreeSet`\n\
    \  --> /tmp/tmpvacifgvl.rs:39:42\n   |\n39 |             let mut checked_right_cars\
    \ = BTreeSet::new();\n   |                                          ^^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::BTreeSet;\n   |\n\nerror[E0425]: cannot find value `nb_`\
    \ in this scope\n  --> /tmp/tmpvacifgvl.rs:60:13\n   |\n60 |             nb_\n\
    \   |             ^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpvacifgvl.rs:9:36\n  |\n9 | fn car_race_collision(n: isize) -> isize\
    \ {\n  |    ------------------              ^^^^^ expected `isize`, found `()`\n\
    \  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425, E0433.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut counter = 0;\n    for i in 0..n {\n        for\
    \ j in (i + 1)..n {\n            counter += 1;\n        }\n    }\n    counter\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpbnr5wlvc.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    n - n / 2\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpwkzj1xs1.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars = vec![0; n as usize];\n    let mut cars2\
    \ = vec![0; n as usize];\n    let mut pos = 0;\n    let mut pos2 = n - 1;\n  \
    \  let mut collisions = 0;\n    while pos < n {\n        cars[pos as usize] =\
    \ 1;\n        cars2[pos2 as usize] = 1;\n        if cars[pos as usize] == 1 &&\
    \ cars2[pos as usize] == 1 {\n            collisions += 1;\n        }\n      \
    \  pos += 1;\n        pos2 -= 1;\n    }\n    collisions\n}\n\nfn main() {\n  \
    \  let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n   \
    \ assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp_02bidgf.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut array_left: Vec<bool> = vec![false; n as usize];\n\
    \    let mut array_right: Vec<bool> = vec![false; n as usize];\n    let mut collisions\
    \ = 0;\n    for i in 0..n {\n        if array_left[i as usize] {\n           \
    \ collisions += 1;\n        }\n        array_left[i as usize] = true;\n      \
    \  if array_right[(n - i - 1) as usize] {\n            collisions += 1;\n    \
    \    }\n        array_right[(n - i - 1) as usize] = true;\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpv8z4d2ig.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n < 1 {\n        return 0;\n    }\n    n * (n - 1)\
    \ / 2\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpajtjetrx.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // TODO:  Complete the function\n    // Suggestion: \
    \ Use a priority queue to solve this in O(n lg n) time\n    // Your code must\
    \ pass compile!  Running it is optional\n    0\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpa263jt4f.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars: Vec<(isize, isize)> = Vec::new();\n   \
    \ for k in 0..n {\n        cars.push((-k, -k));\n        cars.push((k, k));\n\
    \    }\n    let mut collide = 0;\n    for i in 0..2 * n {\n        for j in i\
    \ + 1..2 * n {\n            if (cars[i].0 > cars[j].0 && cars[i].1 < cars[j].1)\
    \ ||\n               (cars[i].0 < cars[j].0 && cars[i].1 > cars[j].1) {\n    \
    \            collide += 1;\n            }\n        }\n    }\n    collide\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[(isize, isize)]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpksq57g4x.rs:18:17\n   |\n18 |             if (cars[i].0 > cars[j].0\
    \ && cars[i].1 < cars[j].1) ||\n   |                 ^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[(isize,\
    \ isize)]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<isize>` for `Vec<(isize, isize)>`\n\nerror[E0277]: the\
    \ type `[(isize, isize)]` cannot be indexed by `isize`\n  --> /tmp/tmpksq57g4x.rs:18:29\n\
    \   |\n18 |             if (cars[i].0 > cars[j].0 && cars[i].1 < cars[j].1) ||\n\
    \   |                             ^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[(isize, isize)]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<(isize, isize)>`\n\nerror[E0277]: the type `[(isize,\
    \ isize)]` cannot be indexed by `isize`\n  --> /tmp/tmpksq57g4x.rs:18:42\n   |\n\
    18 |             if (cars[i].0 > cars[j].0 && cars[i].1 < cars[j].1) ||\n   |\
    \                                          ^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[(isize, isize)]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<(isize, isize)>`\n\nerror[E0277]: the type `[(isize,\
    \ isize)]` cannot be indexed by `isize`\n  --> /tmp/tmpksq57g4x.rs:18:54\n   |\n\
    18 |             if (cars[i].0 > cars[j].0 && cars[i].1 < cars[j].1) ||\n   |\
    \                                                      ^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[(isize,\
    \ isize)]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    n * (n - 1) / 2\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpyzd7_b2t.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let (mut right_to_left, mut left_to_right) = (0, 0);\n\
    \    for i in 0..n {\n        if i % 2 == 0 {\n            left_to_right += 1;\n\
    \        } else {\n            right_to_left += 1;\n        }\n    }\n    if left_to_right\
    \ > right_to_left {\n        left_to_right - right_to_left\n    } else {\n   \
    \     right_to_left - left_to_right\n    }\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpiptu033v.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // Yikes, this is not the best use case of isize\n  \
    \  if n < 0 { return 0 }\n    // This should have been an enum\n    let mut colliding\
    \ = (1..n + 1).fold(0, |acc, x| acc + 2 * x - 1);\n    let mut pair = 2;\n   \
    \ while pair < n {\n        let max_1 = pair * (pair + 1) / 2;\n        let max_2\
    \ = pair * (pair - 1) / 2;\n        if colliding >= max_1 {\n            colliding\
    \ -= max_1\n        } else if colliding >= max_2 {\n            colliding -= max_2\n\
    \        } else {\n            colliding = 0\n        }\n        pair += 1;\n\
    \    }\n    colliding\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `9`', /tmp/tmpy3d_2kji.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpse77mtt_.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    car_race_collision_helper(n, n, 0)\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `car_race_collision_helper` in this\
    \ scope\n  --> /tmp/tmpa_lswd1f.rs:10:5\n   |\n10 |     car_race_collision_helper(n,\
    \ n, 0)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut fname = \"foo\".to_string();\n    let mut writer\
    \ = BufWriter::new(File::create(&fname).unwrap());\n    let mut cars_left: HashMap<u64,\
    \ u64> = HashMap::new();\n    let mut cars_right: HashMap<u64, u64> = HashMap::new();\n\
    \    let mut races: u64 = 0;\n    let mut total_cars = n as u64;\n    while n\
    \ > 0 {\n        let l: u64 = (total_cars as f64 * rand::random::<f64>()) as u64;\n\
    \        let r: u64 = (total_cars as f64 * rand::random::<f64>()) as u64;\n  \
    \      if l == r {\n            continue;\n        }\n        if cars_left.contains_key(&l)\
    \ || cars_right.contains_key(&r) {\n            continue;\n        }\n       \
    \ cars_left.insert(l, r);\n        cars_right.insert(r, l);\n        races +=\
    \ 1;\n        n -= 1;\n    }\n    for (left, right) in cars_left {\n        writeln!(writer,\
    \ \"{} {}\", left, right).unwrap();\n    }\n    fname = \"bar\".to_string();\n\
    \    let mut writer = BufWriter::new(File::create(&fname).unwrap());\n    for\
    \ (right, left) in cars_right {\n        writeln!(writer, \"{} {}\", right, left).unwrap();\n\
    \    }\n    let mut collisions = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    for (_, right) in cars_left {\n        let mut a = cars_right.clone();\n\
    \        let mut j = 0;\n        let mut b = a.values().enumerate().skip(i + 1);\n\
    \        for (_, left) in b {\n            if left == &right {\n             \
    \   collisions += 1;\n            }\n            j += 1;\n        }\n        i\
    \ += 1;\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `rand`\n\
    \  --> /tmp/tmpnnghyc_o.rs:17:43\n   |\n17 |         let l: u64 = (total_cars\
    \ as f64 * rand::random::<f64>()) as u64;\n   |                              \
    \             ^^^^ use of undeclared crate or module `rand`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared crate or module `rand`\n  --> /tmp/tmpnnghyc_o.rs:18:43\n\
    \   |\n18 |         let r: u64 = (total_cars as f64 * rand::random::<f64>()) as\
    \ u64;\n   |                                           ^^^^ use of undeclared\
    \ crate or module `rand`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `BufWriter`\n  --> /tmp/tmpnnghyc_o.rs:11:22\n   |\n11 |     let mut writer\
    \ = BufWriter::new(File::create(&fname).unwrap());\n   |                     \
    \ ^^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::io::BufWriter;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `File`\n  --> /tmp/tmpnnghyc_o.rs:11:37\n   |\n11 | \
    \    let mut writer = BufWriter::new(File::create(&fname).unwrap());\n   |   \
    \                                  ^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::fs::File;\n   |\n\nerror[E0412]:\
    \ cannot find type `HashMap` in this scope\n  --> /tmp/tmpnnghyc_o.rs:12:24\n\
    \   |\n12 |     let mut cars_left: HashMap<u64, u64> = HashMap::new();\n   | \
    \                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpnnghyc_o.rs:12:44\n\
    \   |\n12 |     let mut cars_left: HashMap<u64, u64> = HashMap::new();\n   | \
    \                                           ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmpnnghyc_o.rs:13:25\n\
    \   |\n13 |     let mut cars_right: HashMap<u64, u64> = HashMap::new();\n   |\
    \                         ^^^^^^^ not fou"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // Given an array of cars\n    // Initialize an empty\
    \ array of collisions\n    // For each car in the cars array\n    //   For each\
    \ car in the collisions array\n    //     If their velocities are opposite\n \
    \   //       Add the cars to the collisions array\n    // Return the collisions\
    \ array\n    let mut cars = vec![vec![0; 2]; n as usize];\n    for i in 0..n {\n\
    \        cars[i as usize][0] = i;\n        cars[i as usize][1] = 1;\n    }\n \
    \   for i in 0..n {\n        cars[i as usize][0] = -i;\n        cars[i as usize][1]\
    \ = -1;\n    }\n    let mut collisions = vec![vec![0; 2]; n as usize];\n    for\
    \ i in 0..n {\n        for j in 0..n {\n            if cars[i as usize][1] * cars[j\
    \ as usize][1] == -1 {\n                collisions[i as usize][0] = i;\n     \
    \           collisions[i as usize][1] = j;\n            }\n        }\n    }\n\
    \    collisions.len() as isize\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpa_2f_c0k.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut right_to_left = vec![0; n as usize];\n    let\
    \ mut left_to_right = vec![0; n as usize];\n    for i in 0..n {\n        right_to_left[i\
    \ as usize] = n + i;\n        left_to_right[i as usize] = i - n;\n    }\n    car_race_collision_internal(n,\
    \ &mut right_to_left, &mut left_to_right)\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `car_race_collision_internal` in this\
    \ scope\n  --> /tmp/tmpor855ft3.rs:16:5\n   |\n16 |     car_race_collision_internal(n,\
    \ &mut right_to_left, &mut left_to_right)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    0\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpajq9puji.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count = 0;\n    for i in 1..n + 1 {\n       \
    \ count += n - i + 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate =\
    \ car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpm6ah232d.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut num_collisions = 0;\n    let mut left: Vec<isize>\
    \ = (0..n).map(|i| i).collect();\n    let mut right: Vec<isize> = (0..n).map(|i|\
    \ -i).collect();\n    let mut both = left.clone();\n    both.append(&mut right);\n\
    \    both.sort();\n    for i in 0..n {\n        let mut l = 0;\n        let mut\
    \ r = 0;\n        for j in i..2 * n {\n            if both[j] < 0 {\n        \
    \        r += 1;\n            } else {\n                l += 1;\n            }\n\
    \            if l == r {\n                num_collisions += 1;\n            }\n\
    \        }\n    }\n    num_collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpmup878qk.rs:20:16\n\
    \   |\n20 |             if both[j] < 0 {\n   |                ^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // car_race_collision(1000) == 499500\n    // car_race_collision(10000)\
    \ == 4999_9500\n    // car_race_collision(1_000_000) == 499_995_000\n    // car_race_collision(10_000_000)\
    \ == 4999_995_000\n    let mut count = 0;\n    for i in 0..n {\n        for j\
    \ in 0..n {\n            if i < j {\n                count += 1;\n           \
    \ }\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmprekq2uhz.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_cars: Vec<isize> = (0..n).collect();\n \
    \   let mut right_cars: Vec<isize> = (0..n).collect();\n    left_cars.sort();\n\
    \    right_cars.sort();\n    let mut i = 0;\n    let mut j = 0;\n    let mut num_collisions\
    \ = 0;\n    while i < n && j < n {\n        if left_cars[i] <= right_cars[j] {\n\
    \            num_collisions += j;\n            i += 1;\n        } else {\n   \
    \         j += 1;\n        }\n    }\n    num_collisions += j * (n - i);\n    num_collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpif4bd0gy.rs:18:12\n\
    \   |\n18 |         if left_cars[i] <= right_cars[j] {\n   |            ^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpif4bd0gy.rs:18:28\n\
    \   |\n18 |         if left_cars[i] <= right_cars[j] {\n   |                 \
    \           ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    0\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpdsey0d6y.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n < 1 {\n        return 0;\n    }\n    n - 1\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpy1055mzn.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        0\n    } else {\n        car_race_collision(n\
    \ - 1) + n - 1\n    }\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpsje5ibjy.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // e.g.  5  2\n    if n == 0 {\n        return 0;\n \
    \   }\n    if n == 1 {\n        return 1;\n    }\n    let mut ret = 0;\n    for\
    \ i in 1..=n {\n        // 1\n        let left_to_right_cars = n - i;\n      \
    \  // (6 - 1) / 2\n        let right_to_left_cars = n - left_to_right_cars;\n\
    \        // (5 - 1) / 2\n        let right_to_left_passed_cars = i - 1;\n    \
    \    // (5 + 2 - 1) / 2\n        ret += left_to_right_cars * right_to_left_cars\
    \ - right_to_left_passed_cars;\n    }\n    ret\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpufh11eu5.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut car_left_to_right: Vec<isize> = Vec::new();\n\
    \    let mut car_right_to_left: Vec<isize> = Vec::new();\n    for i in 0..n {\n\
    \        car_left_to_right.push(i);\n        car_right_to_left.push(n-i-1);\n\
    \    }\n    println!(\"{:?}\", car_left_to_right);\n    println!(\"{:?}\", car_right_to_left);\n\
    \    let mut collision = 0;\n    while car_left_to_right.len() > 0 && car_right_to_left.len()\
    \ > 0 {\n        if car_left_to_right[0] > car_right_to_left[0] {\n          \
    \  car_right_to_left.remove(0);\n            collision += 1;\n        } else {\n\
    \            car_left_to_right.remove(0);\n        }\n    }\n    collision\n}\n\
    \nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: "[0, 1]\n[1, 0]\n"
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmppw6ep34o.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    assert!(n >= 0);\n    let mut result = 0;\n    for i\
    \ in 0..n {\n        for j in 0..n {\n            result += (i - j).abs();\n \
    \       }\n    }\n    result\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp6774pdnk.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_right_to_left = vec![0; n as usize];\n \
    \   let mut cars_left_to_right = vec![0; n as usize];\n    let mut count: isize\
    \ = 0;\n    for i in 0..n {\n        cars_right_to_left[i as usize] = n - i;\n\
    \        cars_left_to_right[i as usize] = n - i;\n    }\n    let mut index_right_to_left\
    \ = 0;\n    let mut index_left_to_right = 0;\n    while index_right_to_left <\
    \ n && index_left_to_right < n {\n        if cars_right_to_left[index_right_to_left\
    \ as usize] == cars_left_to_right[index_left_to_right as usize] {\n          \
    \  count += 1;\n            index_right_to_left += 1;\n            index_left_to_right\
    \ += 1;\n        } else if cars_right_to_left[index_right_to_left as usize] <\
    \ cars_left_to_right[index_left_to_right as usize] {\n            index_right_to_left\
    \ += 1;\n        } else {\n            index_left_to_right += 1;\n        }\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpo_rkvpzs.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // Ok, so I'm not sure what I'm supposed to do here.\
    \  Is this asking me to simulate each car\n    // moving left to right and right\
    \ to left, and see how long each car takes to reach the\n    // other end?  In\
    \ that case I can do it but it seems a bit convoluted and not a particularly\n\
    \    // good use of time.  Are there better algorithms for this?\n    // This\
    \ one is a bit clearer: https://stackoverflow.com/questions/31106936/interview-question-scheduling-of-cars\n\
    \    let mut n_collisions = 0;\n    for c1 in 0..n {\n        for c2 in (c1 +\
    \ 1)..n {\n            if c1 < n - c2 {\n                n_collisions += 1;\n\
    \            }\n        }\n    }\n    n_collisions\n}\n\nfn main() {\n    let\
    \ candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpuoxee6n4.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut pairs: Vec<(isize, isize)> = vec![];\n    for\
    \ i in 0..n {\n        pairs.push((i, i));\n    }\n    pairs.iter().fold(0, |acc,\
    \ pair| acc + car_pair_collision(pair.0, pair.1))\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `car_pair_collision` in this scope\n\
    \  --> /tmp/tmpxtpas3i3.rs:14:44\n   |\n14 |     pairs.iter().fold(0, |acc, pair|\
    \ acc + car_pair_collision(pair.0, pair.1))\n   |                            \
    \                ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // using an algorithm that does not require sorting the\n\
    \    // array of starting positions.\n    let mut cars_l_to_r: Vec<isize> = (0..n).collect();\n\
    \    let mut cars_r_to_l: Vec<isize> = (0..n).rev().collect();\n    let mut x_count:\
    \ isize = 0;\n    let mut i: usize = 0;\n    let mut j: usize = 0;\n    while\
    \ i < n as usize && j < n as usize {\n        if cars_l_to_r[i] < cars_r_to_l[j]\
    \ {\n            x_count += j as isize;\n            i += 1;\n        } else {\n\
    \            j += 1;\n        }\n    }\n    x_count += j as isize * (n - i as\
    \ isize);\n    x_count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpob_ift__.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut i = 0;\n    let mut j = n - 1;\n    let mut collision\
    \ = 0;\n    while i < n && j >= 0 {\n        if i == j {\n            collision\
    \ += 1;\n        } else {\n            collision += 2;\n        }\n        i +=\
    \ 1;\n        j -= 1;\n    }\n    collision\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `9`', /tmp/tmplvrta26_.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_cars = (0..n).collect::<Vec<isize>>();\n\
    \    let mut right_cars = (0..n).rev().collect::<Vec<isize>>();\n    let mut count\
    \ = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while i < n && j < n {\n \
    \       if left_cars[i] > right_cars[j] {\n            count += n - i - 1;\n \
    \           j += 1;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp7ggl87a4.rs:16:12\n\
    \   |\n16 |         if left_cars[i] > right_cars[j] {\n   |            ^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp7ggl87a4.rs:16:27\n\
    \   |\n16 |         if left_cars[i] > right_cars[j] {\n   |                  \
    \         ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = (0..n).collect();\n\
    \    let mut right_to_left: Vec<isize> = (0..n).collect();\n    left_to_right.sort();\n\
    \    right_to_left.sort();\n    right_to_left.reverse();\n    let mut i = 0;\n\
    \    let mut j = 0;\n    let mut total_collisions = 0;\n    while i < n && j <\
    \ n {\n        if left_to_right[i] == right_to_left[j] {\n            total_collisions\
    \ += 1;\n            i += 1;\n            j += 1;\n        } else if left_to_right[i]\
    \ < right_to_left[j] {\n            i += 1;\n        } else {\n            j +=\
    \ 1;\n        }\n    }\n    total_collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpxynzw7bn.rs:19:12\n\
    \   |\n19 |         if left_to_right[i] == right_to_left[j] {\n   |          \
    \  ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n \
    \  |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpxynzw7bn.rs:19:32\n\
    \   |\n19 |         if left_to_right[i] == right_to_left[j] {\n   |          \
    \                      ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpxynzw7bn.rs:23:19\n   |\n23 |         } else if left_to_right[i]\
    \ < right_to_left[j] {\n   |                   ^^^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpxynzw7bn.rs:23:38\n   |\n23 |         } else\
    \ if left_to_right[i] < right_to_left[j] {\n   |                             \
    \         ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more "
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let left_moving_cars = (0..n).map(|x| x as f64 + 0.5).collect::<Vec<f64>>();\n\
    \    let right_moving_cars = (0..n).map(|x| -x as f64 - 0.5).collect::<Vec<f64>>();\n\
    \    let mut initial_state = HashMap::new();\n    for car in left_moving_cars\
    \ {\n        initial_state.insert(car, 1.0);\n    }\n    for car in right_moving_cars\
    \ {\n        initial_state.insert(car, -1.0);\n    }\n    let collisions = simulate_traffic(0.1,\
    \ &initial_state);\n    collisions.len() as isize\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpvmx1dbw_.rs:12:29\n   |\n12 |     let mut initial_state = HashMap::new();\n\
    \   |                             ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0425]: cannot find function `simulate_traffic` in this scope\n\
    \  --> /tmp/tmpvmx1dbw_.rs:19:22\n   |\n19 |     let collisions = simulate_traffic(0.1,\
    \ &initial_state);\n   |                      ^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0425, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n < 2 {\n        0\n    } else {\n        // The intersection\
    \ point between (i, 0) and (0, j) is ((j+i)/(i+j), (j+i)/(i+j))\n        let mut\
    \ count = 0;\n        for i in 1..n {\n            for j in 1..n {\n         \
    \       if j + i > 0 && (j + i) % (i + j) == 0 {\n                    count +=\
    \ 1;\n                }\n            }\n        }\n        count\n    }\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpdwno0epu.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left = 0;\n    let mut right = 0;\n    let mut\
    \ num_collisions = 0;\n    while left < n && right < n {\n        if left == right\
    \ {\n            num_collisions += 1;\n        }\n        left += 1;\n       \
    \ right += 1;\n    }\n    num_collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpkbz8zgfq.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut r = 0;\n    for i in 1..n + 1 {\n        r +=\
    \ i * (n - i);\n    }\n    r\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpv_mputrl.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    // TODO\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpg37dak5l.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut pos = [0; 2 * MAX_N as usize];\n    let mut car\
    \ = [0; 2 * MAX_N as usize];\n    let mut sorted_pos = [0; 2 * MAX_N as usize];\n\
    \    let mut dp = [false; MAX_N as usize];\n    let mut dq = [false; MAX_N as\
    \ usize];\n    for i in 0..n {\n        let (mut p, mut d) = (0, 0);\n       \
    \ read_two::<isize>(&mut p, &mut d);\n        if d == 1 {\n            pos[i as\
    \ usize] = p;\n            car[i as usize] = true;\n        } else {\n       \
    \     pos[i as usize] = -p;\n            car[i as usize] = false;\n        }\n\
    \        sorted_pos[i as usize] = pos[i as usize];\n    }\n    sorted_pos[n as\
    \ usize..].clone_from_slice(&pos[0..n as usize]);\n    sorted_pos.sort();\n  \
    \  let mut ans = 0;\n    for i in 0..n {\n        if car[i as usize] {\n     \
    \       let p = pos[i as usize];\n            dp[i as usize] = true;\n       \
    \     let mut l = 0;\n            let mut r = n;\n            while r - l > 1\
    \ {\n                let med = (l + r) / 2;\n                if sorted_pos[med\
    \ as usize] >= p {\n                    r = med;\n                } else {\n \
    \                   l = med;\n                }\n            }\n            ans\
    \ += n - r;\n        } else {\n            let p = pos[i as usize];\n        \
    \    dq[i as usize] = true;\n            let mut l = 0;\n            let mut r\
    \ = n;\n            while r - l > 1 {\n                let med = (l + r) / 2;\n\
    \                if sorted_pos[med as usize] > p {\n                    r = med;\n\
    \                } else {\n                    l = med;\n                }\n \
    \           }\n            ans += n - r;\n        }\n    }\n\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `MAX_N` in this scope\n  --> /tmp/tmpiaut5swj.rs:10:27\n\
    \   |\n10 |     let mut pos = [0; 2 * MAX_N as usize];\n   |                 \
    \          ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `MAX_N`\
    \ in this scope\n  --> /tmp/tmpiaut5swj.rs:11:27\n   |\n11 |     let mut car =\
    \ [0; 2 * MAX_N as usize];\n   |                           ^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find value `MAX_N` in this scope\n  --> /tmp/tmpiaut5swj.rs:12:34\n\
    \   |\n12 |     let mut sorted_pos = [0; 2 * MAX_N as usize];\n   |          \
    \                        ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `MAX_N` in this scope\n  --> /tmp/tmpiaut5swj.rs:13:26\n   |\n13\
    \ |     let mut dp = [false; MAX_N as usize];\n   |                          ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_N` in this scope\n\
    \  --> /tmp/tmpiaut5swj.rs:14:26\n   |\n14 |     let mut dq = [false; MAX_N as\
    \ usize];\n   |                          ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `read_two` in this scope\n  --> /tmp/tmpiaut5swj.rs:17:9\n\
    \   |\n17 |         read_two::<isize>(&mut p, &mut d);\n   |         ^^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiaut5swj.rs:30:5\n\
    \   |\n9  |   fn car_race_collision(n: isize) -> isize {\n   |               \
    \                       ----- expected `isize` because of return type\n...\n30\
    \ | /     for i in 0..n {\n31 | |         if car[i as usize] {\n32 | |       \
    \      let p = pos[i as usize];\n33 | |             dp[i as usize] = true;\n...\
    \  |\n59 | |         }\n60 | |     }\n   | |_____^ expected `isize`, found `()`\n\
    \nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    0\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpvl8myzm_.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_left = n.to_string();\n    let mut cars_right\
    \ = n.to_string();\n    let mut collision = 0;\n    while cars_left.len() > 0\
    \ && cars_right.len() > 0 {\n        let left_pos = cars_left.pop().unwrap().to_digit(10).unwrap()\
    \ as isize;\n        let right_pos = cars_right.pop().unwrap().to_digit(10).unwrap()\
    \ as isize;\n        if left_pos == right_pos {\n            collision += 1;\n\
    \        }\n    }\n    collision\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp_5i8nirr.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut num = 0;\n    for i in 0..n {\n        for j\
    \ in 0..n {\n            num += 1;\n        }\n    }\n    num\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n < 2 {\n        return 0;\n    }\n    return car_race_collision(n\
    \ - 1) + n - 1;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n \
    \   assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpra72o9yg.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n    let mut left_to_right:\
    \ Vec<_> = (0..n).map(|i| (i, false)).collect();\n    let mut right_to_left: Vec<_>\
    \ = (0..n).map(|i| (i, false)).collect();\n    let mut collisions = 0;\n    for\
    \ i in (0..n).rev() {\n        let l = left_to_right[i].0;\n        if !left_to_right[i].1\
    \ {\n            let r = right_to_left[l].0;\n            if !right_to_left[l].1\
    \ {\n                collisions += 1;\n                left_to_right[i].1 = true;\n\
    \                right_to_left[l].1 = true;\n                left_to_right[r].1\
    \ = true;\n                right_to_left[i].1 = true;\n            }\n       \
    \ }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[(isize, bool)]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmpxj617pa4.rs:17:17\n   |\n17 |         let l = left_to_right[i].0;\n\
    \   |                 ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[(isize, bool)]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<(isize, bool)>`\n\nerror[E0277]: the type `[(isize,\
    \ bool)]` cannot be indexed by `isize`\n  --> /tmp/tmpxj617pa4.rs:18:13\n   |\n\
    18 |         if !left_to_right[i].1 {\n   |             ^^^^^^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[(isize, bool)]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<(isize, bool)>`\n\
    \nerror[E0277]: the type `[(isize, bool)]` cannot be indexed by `isize`\n  -->\
    \ /tmp/tmpxj617pa4.rs:22:17\n   |\n22 |                 left_to_right[i].1 = true;\n\
    \   |                 ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[(isize, bool)]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<(isize, bool)>`\n\nerror[E0277]: the type `[(isize,\
    \ bool)]` cannot be indexed by `isize`\n  --> /tmp/tmpxj617pa4.rs:25:17\n   |\n\
    25 |                 right_to_left[i].1 = true;\n   |                 ^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[(isize, bool)]>` is not implemented for `isize`\n   = help:\
    \ the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<(isize, bool)>`\n\
    \nerror: aborting due to 4 previous errors\n\nFor mor"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // This solution is inspired by the answer from the book.\n\
    \    // The book's solution is O(n) time complexity.\n    // This solution has\
    \ O(1) time complexity.\n\n    // Let n be the number of cars driving from left\
    \ to right.\n    // There are 2n cars in total.\n    // Assume the left cars are\
    \ labeled from 0 to n-1.\n    // Assume the right cars are labeled from n to 2n-1.\n\
    \    // The car labeled x is moving left to right if x < n.\n    // The car labeled\
    \ x is moving right to left if x >= n.\n    // Because the cars are infinitely\
    \ strong, they continue moving in their\n    // trajectory as if they did not\
    \ collide.  As a result, no collision occurs.\n    // \n    // Consider the following\
    \ setup with n = 4.\n    // \n    //                       +----+\n    //    \
    \                   |    |\n    //                       |    |\n    //      \
    \                 |    |\n    //                       |    |\n    //        \
    \               |    |\n    //                       |    |\n    //          \
    \             |    |\n    //                       |    |\n    //            \
    \           |    |\n    //                       |    |\n    //              \
    \         |    |\n    //                       |    |\n    //                \
    \       |    |\n    // +----+  +----+  +----+ |    |  +----+  +----+  +----+\n\
    \    // |    |  |    |  |    | |    |  |    |  |    |  |    |\n    // | 3  | \
    \ | 2  |  | 1  | | 0  |  | 7  |  | 6  |  | 5  |\n    // | <--|--| <--|--| <--|-|\
    \ -->|--| <--|--| <--|--| <--|\n    // +----+  +----+  +----+ |    |  +----+ \
    \ +----+  +----+\n    //                       |    |\n    //                \
    \       |    |\n    //                       |    |\n    //                  \
    \     |    |\n    //                       |    |\n    //                    \
    \   |    |\n    //                       |    |\n    //                      \
    \ |    |\n    //                       |    |\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpr9_4i68t.rs:9:36\n  |\n9 |\
    \ fn car_race_collision(n: isize) -> isize {\n  |    ------------------      \
    \        ^^^^^ expected `isize`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n\n    let mut\
    \ s = 0;\n    let mut l = 0;\n    for i in 1..n + 1 {\n        s += i;\n     \
    \   l += n - i + 1;\n    }\n\n    s - l\n}\n\nfn main() {\n    let candidate =\
    \ car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpjwc_ng69.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count: isize = 0;\n    let mut r = (1..=n)\n\
    \        .rev()\n        .zip(0..n)\n        .map(|(i, j)| {\n            if i\
    \ <= j {\n                count += 1;\n            }\n            count\n    \
    \    })\n        .collect::<Vec<isize>>();\n    println!(\"{:?}\", r);\n    count\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: "[0, 1]\n"
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp09_jm7d0.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n < 1 {\n        return 0;\n    }\n    // TODO - you\
    \ fill in here.\n    0\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpusrb0uzn.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut cars_left_to_right\
    \ = Vec::with_capacity(n as usize);\n    let mut cars_right_to_left = Vec::with_capacity(n\
    \ as usize);\n    for i in 0..n {\n        cars_left_to_right.push(Car { x: i,\
    \ y: n - i });\n        cars_right_to_left.push(Car { x: n - i, y: i });\n   \
    \ }\n    for i in 0..n {\n        for j in 0..n {\n            if cars_left_to_right[i\
    \ as usize].y <= cars_right_to_left[j as usize].y {\n                collisions\
    \ += 1;\n            }\n        }\n    }\n    collisions\n}\n\nfn main() {\n \
    \   let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n  \
    \  assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0422]: cannot find struct, variant or union type `Car` in this scope\n\
    \  --> /tmp/tmpbpwovkiv.rs:14:33\n   |\n14 |         cars_left_to_right.push(Car\
    \ { x: i, y: n - i });\n   |                                 ^^^ not found in\
    \ this scope\n\nerror[E0422]: cannot find struct, variant or union type `Car`\
    \ in this scope\n  --> /tmp/tmpbpwovkiv.rs:15:33\n   |\n15 |         cars_right_to_left.push(Car\
    \ { x: n - i, y: i });\n   |                                 ^^^ not found in\
    \ this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0422`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut ctr: isize = 0;\n    if n > 0 {\n        // the\
    \ \"cars\" are the numbers between 1 and n inclusive\n        let left_cars: Vec<isize>\
    \ = (1..=n).collect();\n        let right_cars: Vec<isize> = (1..=n).rev().collect();\n\
    \        // so we need a variable to store the \"position\" of each car as it\
    \ moves\n        let mut pos: Vec<isize> = Vec::new();\n        for car in left_cars\
    \ {\n            // each car starts at 1 mile\n            pos.push(1);\n    \
    \    }\n        for _ in 1..20 {\n            for (i, car) in left_cars.iter().enumerate()\
    \ {\n                // if car is at the middle of the road and is moving to the\
    \ right,\n                // it may collide with a car moving to the left\n  \
    \              if pos[i] == 0 && right_cars.contains(car) {\n                \
    \    ctr += 1;\n                }\n                // the car advances one mile\n\
    \                pos[i] += 1;\n            }\n            for (i, car) in right_cars.iter().enumerate()\
    \ {\n                // if car is at the middle of the road and is moving to the\
    \ left,\n                // it may collide with a car moving to the right\n  \
    \              if pos[i] == 0 && left_cars.contains(car) {\n                 \
    \   ctr += 1;\n                }\n                // the car advances one mile\n\
    \                pos[i] -= 1;\n            }\n        }\n    }\n    ctr\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "warning: unused variable: `car`\n  --> /tmp/tmpbhhah9w3.rs:17:13\n   |\n\
    17 |         for car in left_cars {\n   |             ^^^ help: if this is intentional,\
    \ prefix it with an underscore: `_car`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `left_cars`\n   --> /tmp/tmpbhhah9w3.rs:22:29\n\
    \    |\n13  |         let left_cars: Vec<isize> = (1..=n).collect();\n    |  \
    \           --------- move occurs because `left_cars` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n...\n17  |         for car in left_cars\
    \ {\n    |                    --------- `left_cars` moved due to this implicit\
    \ call to `.into_iter()`\n...\n22  |             for (i, car) in left_cars.iter().enumerate()\
    \ {\n    |                             ^^^^^^^^^^^^^^^^ value borrowed here after\
    \ move\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `left_cars`\n    = note: borrow occurs due to deref coercion to `[isize]`\n\
    help: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n17  |         for car in &left_cars {\n    |   \
    \                 +\n\nerror: aborting due to previous error; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    car_race_collision_recursive(n, 0)\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `car_race_collision_recursive` in this\
    \ scope\n  --> /tmp/tmp4hvbqf4h.rs:10:5\n   |\n10 |     car_race_collision_recursive(n,\
    \ 0)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // We sort both groups of cars based on their starting\
    \ location, and then we iterate\n    // over both groups.  For every car that\
    \ we meet coming from the left, we add a number\n    // to our total based on\
    \ how many cars we've met coming from the right that are to the\n    // left of\
    \ it.\n    //\n    // For the first case, the right group of cars are sorted so\
    \ that the closest car\n    // is at the end of the array.  We loop through the\
    \ left group and always add zero\n    // since there's no cars we've seen coming\
    \ from the right.\n    //\n    // For the second case, the right group of cars\
    \ are sorted in the same way as the\n    // left group.  However, since every\
    \ car is to the left of the current car, we add\n    // n - i (the number of cars\
    \ we've seen to the left).\n    //\n    // To deal with negative numbers, we can\
    \ just take their absolute value and\n    // add that to the total.\n    //\n\
    \    // T(n) = O(n log n)\n    let mut left_cars: Vec<isize> = vec![0; n as usize];\n\
    \    let mut right_cars: Vec<isize> = vec![0; n as usize];\n    for i in 0..n\
    \ {\n        left_cars[i as usize] = i;\n        right_cars[(n - i - 1) as usize]\
    \ = -i;\n    }\n    left_cars.sort();\n    right_cars.sort();\n    let mut collisions\
    \ = 0;\n    for i in 0..n {\n        let mut j = 0;\n        while right_cars[j\
    \ as usize] < left_cars[i as usize] {\n            j += 1;\n        }\n      \
    \  collisions += n - i - j;\n    }\n    collisions\n}\n\nfn main() {\n    let\
    \ candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 2 but the index\
    \ is 2', /tmp/tmp9x8e8b6b.rs:38:15\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpi03c9nfw.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n    let mut moving_right\
    \ = (0..n).collect::<Vec<isize>>();\n    let mut moving_left = (0..n).rev().collect::<Vec<isize>>();\n\
    \    let mut collision_count = 0;\n    for _ in 0..n {\n        for x in &mut\
    \ moving_right {\n            *x += 1;\n        }\n        for x in &mut moving_left\
    \ {\n            *x -= 1;\n        }\n        collision_count += moving_right.iter().filter(|&x|\
    \ moving_left.contains(x)).count() as isize;\n    }\n    collision_count\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmps3jdp8tq.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count = 0;\n    let mut left_car = 1;\n    let\
    \ mut right_car = n;\n    while left_car <= n {\n        if left_car == right_car\
    \ {\n            count += 1;\n        }\n        left_car += 1;\n        right_car\
    \ -= 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpbtxbwjda.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut left = 0;\n    let\
    \ mut right = n - 1;\n    while left < right {\n        collisions += left * (n\
    \ - right);\n        left += 1;\n        right -= 1;\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpgk0p7cs_.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    n * (n - 1) / 2\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpreccf83n.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        0\n    } else {\n        car_race_collision(n\
    \ - 1) + n - 1\n    }\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpctiywxtb.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut coll = 0;\n    let mut k = 0;\n    while k <\
    \ n {\n        k += 1;\n        coll += n - k;\n    }\n    coll\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpz28raf7v.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 0 {\n        return 0;\n    }\n    n * (n - 1)\
    \ / 2\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpur2x9g32.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_l2r = Vec::new();\n    let mut cars_r2l\
    \ = Vec::new();\n    let mut col_count = 0;\n    for _ in 0..n {\n        cars_l2r.push(rand::random::<isize>());\n\
    \        cars_r2l.push(rand::random::<isize>());\n    }\n    cars_l2r.sort();\n\
    \    cars_r2l.sort();\n    let mut car_r2l_idx = n - 1;\n    for i in 0..n {\n\
    \        while car_r2l_idx >= 0 && cars_l2r[i as usize] >= cars_r2l[car_r2l_idx\
    \ as usize] {\n            car_r2l_idx -= 1;\n        }\n        col_count +=\
    \ n - car_r2l_idx - 1;\n    }\n    col_count\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `rand`\n\
    \  --> /tmp/tmp5f3oz7yv.rs:14:23\n   |\n14 |         cars_l2r.push(rand::random::<isize>());\n\
    \   |                       ^^^^ use of undeclared crate or module `rand`\n\n\
    error[E0433]: failed to resolve: use of undeclared crate or module `rand`\n  -->\
    \ /tmp/tmp5f3oz7yv.rs:15:23\n   |\n15 |         cars_r2l.push(rand::random::<isize>());\n\
    \   |                       ^^^^ use of undeclared crate or module `rand`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n    let m = (n\
    \ as f64).log2() as isize;\n    let mut s = 0;\n    for i in 0..m + 1 {\n    \
    \    let p = (1 << i) - 1;\n        s += (n / (1 << (i + 1))) * p;\n        s\
    \ += max(0, n % (1 << (i + 1)) - (1 << i));\n    }\n    s\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp9iesum0i.rs:18:14\n\
    \   |\n18 |         s += max(0, n % (1 << (i + 1)) - (1 << i));\n   |        \
    \      ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars: HashMap<f64, Vec<bool>> = HashMap::new();\n\
    \n    let mut curr_position = -100000.0;\n    while curr_position < 100000.0 {\n\
    \        let left_to_right_cars = cars.entry(curr_position).or_insert(vec![]);\n\
    \        left_to_right_cars.push(true);\n        curr_position += 10.0;\n    }\n\
    \n    let mut curr_position = 100000.0;\n    while curr_position > -100000.0 {\n\
    \        let right_to_left_cars = cars.entry(curr_position).or_insert(vec![]);\n\
    \        right_to_left_cars.push(false);\n        curr_position -= 10.0;\n   \
    \ }\n\n    let mut curr_position = -100000.0;\n    let mut num_collisions = 0;\n\
    \    while curr_position < 100000.0 {\n        let car_set = cars.get(&curr_position).unwrap();\n\
    \        for car in car_set {\n            if !car {\n                num_collisions\
    \ += 1;\n            }\n        }\n        curr_position += 10.0;\n    }\n\n \
    \   num_collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmp8pach8oe.rs:10:19\n\
    \   |\n10 |     let mut cars: HashMap<f64, Vec<bool>> = HashMap::new();\n   |\
    \                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp8pach8oe.rs:10:45\n\
    \   |\n10 |     let mut cars: HashMap<f64, Vec<bool>> = HashMap::new();\n   |\
    \                                             ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0412, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    n.pow(2)\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_from_left = Vec::with_capacity(n as usize);\n\
    \    let mut cars_from_right = Vec::with_capacity(n as usize);\n    for i in 0..n\
    \ {\n        cars_from_left.push(i);\n        cars_from_right.push(n - i - 1);\n\
    \    }\n    let mut collision_count = 0;\n    let mut i = 0;\n    let mut j =\
    \ 0;\n    while i < n && j < n {\n        if cars_from_left[i as usize] < cars_from_right[j\
    \ as usize] {\n            collision_count += j;\n            i += 1;\n      \
    \  } else {\n            j += 1;\n        }\n    }\n    collision_count\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp6ehdc_59.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 0 {\n        return 0;\n    }\n    let mut first_to_last:\
    \ Vec<isize> = Vec::new();\n    let mut last_to_first: Vec<isize> = Vec::new();\n\
    \    for i in 0..n {\n        first_to_last.push(i);\n        last_to_first.push(n\
    \ - i - 1);\n    }\n    car_race_collision_help(n, first_to_last, last_to_first)\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `car_race_collision_help` in this scope\n\
    \  --> /tmp/tmpmy1fd_ov.rs:19:5\n   |\n19 |     car_race_collision_help(n, first_to_last,\
    \ last_to_first)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    ((n as f64).log2() as isize) + 1\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpxm0uuns4.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n    let car_race_collision_n\
    \ = |n: isize| -> isize {\n        // 2*i is a car moving left to right\n    \
    \    // 2*i + 1 is a car moving right to left\n        (0..n)\n            .map(|i|\
    \ 2 * i)\n            .flat_map(|i| {\n                (0..n)\n              \
    \      .map(|j| 2 * j + 1)\n                    .map(move |j| (i, j))\n      \
    \              .filter(move |&(i, j)| j > i)\n            })\n            .count()\
    \ as isize\n    };\n    let car_race_collision_n_plus_1 = |n: isize| -> isize\
    \ {\n        // 2*i is a car moving left to right\n        // 2*i + 1 is a car\
    \ moving right to left\n        (0..n + 1)\n            .map(|i| 2 * i)\n    \
    \        .flat_map(|i| {\n                (0..n + 1)\n                    .map(|j|\
    \ 2 * j + 1)\n                    .map(move |j| (i, j))\n                    .filter(move\
    \ |&(i, j)| j > i)\n            })\n            .count() as isize\n    };\n  \
    \  let a = car_race_collision_n(n);\n    let b = car_race_collision_n_plus_1(n);\n\
    \    let c = car_race_collision_n_plus_1(n - 1);\n    // The last car added will\
    \ have n-1 collisions so we add that to the number of collisions\n    // of the\
    \ n-1 car case.\n    b - c + n - 1\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `9`', /tmp/tmpj3lleo7t.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n    let mut count\
    \ = n;\n    let mut cars_left = n;\n    let mut cars_right = n;\n    while cars_left\
    \ > 0 && cars_right > 0 {\n        let mut left = (1..cars_left + 1).rev();\n\
    \        let mut right = 1..cars_right + 1;\n        while let (Some(x), Some(y))\
    \ = (left.next(), right.next()) {\n            if x == y {\n                count\
    \ -= 1;\n            }\n        }\n        cars_left -= 1;\n        cars_right\
    \ -= 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpu8np5836.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 1 {\n        return 0;\n    }\n\n    // Recurrence\
    \ relation is:\n    //\n    //                /      0 if n = 1\n    //      \
    \          |\n    // car_race(n) = <       n(n-1)/2 if n = 2\n    //         \
    \       |\n    //                \\      car_race(n-1) + (n-1) if n > 2\n    //\n\
    \    // Proof:\n    //\n    // - For n = 1, there are no collisions.\n    // -\
    \ For n = 2, there are n(n-1)/2 = 1 collision.\n    //\n    // Suppose the program\
    \ is true for n-1.  Then the cars that move left to right\n    // are numbered\
    \ 1, 2, ..., n-1.  Car n-1 is the rightmost car that moves left to right.\n  \
    \  // It will collide with every car that moves right to left (whose numbers are\
    \ n, n+1, ..., 2n-1).\n    // Therefore, the total number of collisions is car_race(n-1)\
    \ + (n-1).\n\n    let mut sum = 0;\n    for i in 1..n {\n        sum += i;\n \
    \   }\n    sum\n}\n\nfn main() {\n    let candidate = car_race_collision;\n  \
    \  assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpw5wffut4.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut i = 0;\n    let\
    \ mut current_car = 0;\n    let mut arr = vec![0; n as usize];\n    for car in\
    \ 1..n {\n        current_car = car;\n        i = 0;\n        while i < n - car\
    \ {\n            if arr[i as usize] == 1 {\n                collisions += 1;\n\
    \            }\n            arr[i as usize] = current_car;\n            i += 1;\n\
    \        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp8dna0hsl.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let n = n as usize;\n    // Length of the road\n    let\
    \ l = n * n;\n    // Simultaneously give all n cars on the left a number from\
    \ 0 to n - 1.\n    // Simultaneously give all n cars on the right a number from\
    \ n to 2 * n - 1.\n    // The cars start out in their respective halves of the\
    \ road; the car on the left\n    // with the lowest number will start out at the\
    \ leftmost position; the car on the\n    // right with the highest number will\
    \ start out at the rightmost position.\n    // Now we can tell how many collisions\
    \ there will be.\n    // How far out does car k on the left start out?  That's\
    \ 2 * k.\n    // How far out does car k on the right start out?  That's l - 2\
    \ * k - 1.\n    // The two cars collide if these distances are equal.\n    //\
    \ The kth car on the left will collide with the l - k - 1 th car on the right.\n\
    \    // Therefore, there are n / 2 collisions.\n    n / 2\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpan0j94pi.rs:24:5\n   |\n\
    9  | fn car_race_collision(n: isize) -> isize {\n   |                        \
    \            ----- expected `isize` because of return type\n...\n24 |     n /\
    \ 2\n   |     ^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    24 |     (n / 2).try_into().unwrap()\n   |     +     +++++++++++++++++++++\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count = 0;\n    let mut left = 0;\n    let mut\
    \ right = n - 1;\n    while left < right {\n        let mut left_moved = false;\n\
    \        let mut right_moved = false;\n        if left_moved && right_moved {\n\
    \            count += 1;\n        }\n        if !left_moved {\n            left\
    \ += 1;\n        }\n        if !right_moved {\n            right -= 1;\n     \
    \   }\n    }\n    count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpa2v0lf_z.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_left = std::iter::repeat(1).take(n as usize).collect::<Vec<_>>();\n\
    \    let mut cars_right = std::iter::repeat(1).take(n as usize).collect::<Vec<_>>();\n\
    \    let mut pos = vec![0; n as usize];\n    for i in 0..n {\n        pos[i as\
    \ usize] = i;\n    }\n    let mut collisions = 0;\n    let mut last_idx = (n -\
    \ 1) as usize;\n    while cars_left.len() > 0 {\n        if pos[0] >= 0 {\n  \
    \          collisions += cars_right.len();\n            let idx = pos[0] as usize;\n\
    \            cars_left.remove(idx);\n            pos.remove(idx);\n          \
    \  for i in idx..pos.len() {\n                pos[i] -= 1;\n            }\n  \
    \      } else {\n            let idx = (-pos[0] - 1) as usize;\n            cars_right.remove(idx);\n\
    \            pos.remove(0);\n            for i in 0..pos.len() {\n           \
    \     pos[i] += 1;\n            }\n        }\n    }\n    collisions\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdkej08b3.rs:36:5\n   |\n\
    9  | fn car_race_collision(n: isize) -> isize {\n   |                        \
    \            ----- expected `isize` because of return type\n...\n36 |     collisions\n\
    \   |     ^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    36 |     collisions.try_into().unwrap()\n   |               ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpome21ntj.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<i32> = Vec::new();\n    let\
    \ mut right_to_left: Vec<i32> = Vec::new();\n    for x in 0..n {\n        left_to_right.push(x\
    \ as i32);\n        right_to_left.push(n - x - 1);\n    }\n    // Now merge the\
    \ two arrays and count the number of inversions.\n    let mut collisions = 0;\n\
    \    for i in 0..left_to_right.len() {\n        for j in i..right_to_left.len()\
    \ {\n            if left_to_right[i] > right_to_left[j] {\n                collisions\
    \ += 1;\n            }\n        }\n    }\n    collisions\n}\n\nfn main() {\n \
    \   let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n  \
    \  assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7oa8eqfj.rs:14:28\n   |\n\
    14 |         right_to_left.push(n - x - 1);\n   |                            ^^^^^^^^^\
    \ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n14 |         right_to_left.push((n\
    \ - x - 1).try_into().unwrap());\n   |                            +         +++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left: Vec<bool> = vec![false; n as usize];\n\
    \    let mut right: Vec<bool> = vec![false; n as usize];\n    for i in 0..n {\n\
    \        if i % 2 == 0 {\n            left[i as usize] = true;\n        } else\
    \ {\n            right[i as usize] = true;\n        }\n    }\n    let mut result\
    \ = 0;\n    while !left.is_empty() {\n        if right.is_empty() {\n        \
    \    break;\n        }\n        let mut left_pos = 0;\n        let mut right_pos\
    \ = 0;\n        for i in 0..n {\n            if left[i as usize] {\n         \
    \       left_pos = i;\n                break;\n            }\n        }\n    \
    \    for i in 0..n {\n            if right[i as usize] {\n                right_pos\
    \ = i;\n                break;\n            }\n        }\n        left_pos +=\
    \ 1;\n        right_pos += 1;\n        if left_pos > right_pos {\n           \
    \ result += 1;\n        }\n        left[left_pos as usize] = true;\n        right[right_pos\
    \ as usize] = true;\n        left[(left_pos - 1) as usize] = false;\n        right[(right_pos\
    \ - 1) as usize] = false;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 2 but the index\
    \ is 2', /tmp/tmp7veykjws.rs:44:9\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut number_of_collisions = 0;\n    // You'll want\
    \ to keep track of each car as it moves left or right.\n    // You'll want to\
    \ increment number_of_collisions each time a collision occurs.\n    // We'll leave\
    \ the actual logic up to you.\n    unimplemented!();\n    number_of_collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmph4_8g47l.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_left = n;\n    let mut cars_right = n;\n\
    \    let mut collisions = 0;\n    while cars_left > 0 || cars_right > 0 {\n  \
    \      collisions += cars_left * cars_right;\n        cars_left -= 1;\n      \
    \  cars_right -= 1;\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `4`', /tmp/tmpzl4_1zj0.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    assert!(n >= 0);\n    if n <= 1 {\n        return 0;\n\
    \    }\n    n * (n - 1) / 2\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpcf8fw_n1.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars = (1..=n).map(|x| (x, true)).collect::<Vec<(isize,\
    \ bool)>>();\n    let mut collisions = 0;\n    while cars.len() > 1 {\n      \
    \  cars.sort_by(|x, y| {\n            if x.0 == y.0 {\n                if x.1\
    \ && !y.1 {\n                    Ordering::Less\n                } else if !x.1\
    \ && y.1 {\n                    Ordering::Greater\n                } else {\n\
    \                    Ordering::Equal\n                }\n            } else {\n\
    \                if x.1 {\n                    x.0.cmp(&y.0)\n               \
    \ } else {\n                    y.0.cmp(&x.0)\n                }\n           \
    \ }\n        });\n        let mut i = 0;\n        while i < cars.len() - 1 {\n\
    \            if cars[i].1 == cars[i + 1].1 {\n                cars.remove(i);\n\
    \                collisions += 1;\n            } else {\n                i +=\
    \ 1;\n            }\n        }\n        cars.iter_mut().for_each(|x| x.0 += 1);\n\
    \    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpybopkgtk.rs:16:21\n   |\n16 |                     Ordering::Less\n \
    \  |                     ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpybopkgtk.rs:18:21\n\
    \   |\n18 |                     Ordering::Greater\n   |                     ^^^^^^^^\
    \ use of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `Ordering`\n  --> /tmp/tmpybopkgtk.rs:20:21\n   |\n20 |    \
    \                 Ordering::Equal\n   |                     ^^^^^^^^ use of undeclared\
    \ type `Ordering`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut left_to_right_cars\
    \ = 0;\n    let mut right_to_left_cars = 0;\n    for i in 0..n {\n        if i\
    \ % 2 == 0 {\n            left_to_right_cars += 1;\n        } else {\n       \
    \     right_to_left_cars += 1;\n        }\n        if left_to_right_cars != 0\
    \ && right_to_left_cars != 0 {\n            collisions += left_to_right_cars *\
    \ right_to_left_cars;\n        }\n    }\n    collisions\n}\n\nfn main() {\n  \
    \  let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n   \
    \ assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmptou5ecq5.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    for i in 0..n {\n      \
    \  for j in 0..n {\n            if i + j == n {\n                collisions +=\
    \ 1;\n            }\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let\
    \ candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpoxv7nf1f.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut result = 0;\n    for i in 1..n {\n        result\
    \ += (n - i) * i;\n    }\n    result * 2\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpds6lqz56.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    car_race_collision_using_hashset(n)\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `car_race_collision_using_hashset` in\
    \ this scope\n  --> /tmp/tmp98uam17w.rs:10:5\n   |\n10 |     car_race_collision_using_hashset(n)\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // TODO: Fill me in\n    return 0;\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmps8eb2vcs.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n < 2 {\n        return 0;\n    }\n    let left_t_start\
    \ = vec![0.0; n as usize];\n    let left_t_end = vec![(n - 1) as f64; n as usize];\n\
    \    let right_t_start = vec![(n - 1) as f64; n as usize];\n    let right_t_end\
    \ = vec![0.0; n as usize];\n    time_interval_collision(left_t_start, left_t_end,\
    \ right_t_start, right_t_end)\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `time_interval_collision` in this scope\n\
    \  --> /tmp/tmpc3vtvw6p.rs:17:5\n   |\n17 |     time_interval_collision(left_t_start,\
    \ left_t_end, right_t_start, right_t_end)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n < 1 {\n        panic!(\"n < 1\");\n    }\n\n   \
    \ // The number of collisions between i'th car from the left and\n    // j'th\
    \ car from the right is min(i, j).  For example, if n = 4,\n    // the collision\
    \ counts are (in descending order):\n    // 1 1 1 1\n    // 0 2 2 2\n    // 0\
    \ 0 3 3\n    // 0 0 0 4\n    //\n    // The total number of collisions is then\
    \ equal to the sum of diagonal\n    // elements in the above matrix.\n    // In\
    \ addition, sum of first n numbers is n * (n + 1) / 2.\n    // So in our example,\
    \ the collision count is 4 * (4 + 1) / 2 = 10.\n    (n * (n + 1)) / 2\n}\n\nfn\
    \ main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpyc3omtad.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_right_cars: Vec<isize> = (0..n).collect();\n\
    \    let mut right_left_cars: Vec<isize> = (0..n).collect();\n    let mut num_collisions\
    \ = 0;\n    while !left_right_cars.is_empty() && !right_left_cars.is_empty() {\n\
    \        if left_right_cars[0] == right_left_cars[0] {\n            left_right_cars.remove(0);\n\
    \            right_left_cars.remove(0);\n            num_collisions += 1;\n  \
    \      } else if left_right_cars[0] < right_left_cars[0] {\n            left_right_cars.remove(0);\n\
    \        } else {\n            right_left_cars.remove(0);\n        }\n    }\n\
    \    num_collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmplse7gr3j.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_left = Vec::new();\n    let mut cars_right\
    \ = Vec::new();\n    for i in 0..n {\n        cars_left.push(i);\n        cars_right.push(n\
    \ - i - 1);\n    }\n    for i in 0..n {\n        for j in 0..n {\n           \
    \ if cars_left[i] == cars_right[j] {\n                return i as isize + j as\
    \ isize;\n            }\n        }\n    }\n    unreachable!()\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpxwednn4p.rs:18:16\n\
    \   |\n18 |             if cars_left[i] == cars_right[j] {\n   |             \
    \   ^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n \
    \  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpxwednn4p.rs:18:32\n\
    \   |\n18 |             if cars_left[i] == cars_right[j] {\n   |             \
    \                   ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut l_to_r = vec![0; n as usize];\n    let mut r_to_l\
    \ = vec![0; n as usize];\n    let left_to_right = l_to_r.iter_mut();\n    let\
    \ right_to_left = r_to_l.iter_mut();\n    let l_cars = left_to_right.enumerate().filter(|&(idx,\
    \ car)| {\n        let idx = idx as isize;\n        car.is_none() && idx % 2 ==\
    \ 0\n    });\n    let r_cars = right_to_left.enumerate().filter(|&(idx, car)|\
    \ {\n        let idx = idx as isize;\n        car.is_none() && idx % 2 == 1\n\
    \    });\n    for (&mut (_, car), (_, car2)) in l_cars.zip(r_cars) {\n       \
    \ *car = Some(car2);\n        *car2 = Some(car);\n    }\n    let mut cnt = 0;\n\
    \    let mut l_car_idx = 0;\n    let mut r_car_idx = n - 1;\n    while l_car_idx\
    \ < n && r_car_idx >= 0 {\n        if l_to_r[l_car_idx as usize].is_some() {\n\
    \            // There is a car in front of us.  To avoid collision, we must\n\
    \            // move to the next position.\n            l_car_idx += 1;\n    \
    \    } else if r_to_l[r_car_idx as usize].is_some() {\n            // There is\
    \ a car in front of us.  To avoid collision, we must\n            // move to the\
    \ next position.\n            r_car_idx -= 1;\n        } else {\n            //\
    \ We're safe for now, we can move to the next position.\n            l_car_idx\
    \ += 1;\n            r_car_idx -= 1;\n        }\n        if l_car_idx >= n ||\
    \ r_car_idx < 0 {\n            break;\n        }\n        if l_to_r\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpi293apcz.rs:56:3\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \                         - unclosed delimiter\n...\n29 |     while l_car_idx\
    \ < n && r_car_idx >= 0 {\n   |                                           - this\
    \ delimiter might not be properly closed...\n...\n47 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n56 | }\n   |   ^\n\nerror: expected\
    \ `{`, found `}`\n  --> /tmp/tmpi293apcz.rs:47:1\n   |\n46 |         if l_to_r\n\
    \   |         -- this `if` expression has a condition, but no block\n47 | }\n\
    \   | ^ expected `{`\n\nerror[E0599]: no method named `is_none` found for mutable\
    \ reference `&mut {integer}` in the current scope\n  --> /tmp/tmpi293apcz.rs:16:13\n\
    \   |\n16 |         car.is_none() && idx % 2 == 0\n   |             ^^^^^^^ method\
    \ not found in `&mut {integer}`\n\nerror[E0599]: no method named `is_none` found\
    \ for mutable reference `&mut {integer}` in the current scope\n  --> /tmp/tmpi293apcz.rs:20:13\n\
    \   |\n20 |         car.is_none() && idx % 2 == 1\n   |             ^^^^^^^ method\
    \ not found in `&mut {integer}`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi293apcz.rs:22:10\n\
    \   |\n22 |     for (&mut (_, car), (_, car2)) in l_cars.zip(r_cars) {\n   | \
    \         ^^^^^^^^^^^^^                ------------------ this expression has\
    \ type `Option<((usize, &mut {integer}), (usize, &mut {integer}))>`\n   |    \
    \      |\n   |          expected tuple, found `&mut _`\n   |\n   = note:     \
    \     expected tuple `(usize, &mut {integer})`\n           found mutable reference\
    \ `&mut _`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi293apcz.rs:24:17\n\
    \   |\n24 |         *car2 = Some(car);\n   |         -----   ^^^^^^^^^ expected\
    \ integer, found enum `Option`\n   |         |\n   |         expected due to the\
    \ type of this binding\n   |\n   = note: expected type `{integer}`\n         \
    \     found enum `Option<_>`\n\nerror[E0599]: no method named `is_some` found\
    \ for type `{integer}` in the current scope\n  --> /tmp/tmpi293apcz.rs:30:39\n\
    \   |\n30 |         if l_to_r[l_car"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp5_fcrfvc.rs:10:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 0 {\n        return 0;\n    }\n    car_race_collision(n\
    \ - 1) + n - 1\n}\n\nfn main() {\n    let candidate = car_race_collision;\n  \
    \  assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpfkeuwzdb.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut car_positions = vec![0; n as usize];\n    let\
    \ mut car_directions = vec![1; n as usize];\n    let mut collisions = 0;\n   \
    \ for i in 0..n {\n        car_positions[i as usize] = i;\n    }\n    for car_idx\
    \ in 0..n {\n        let car_position = car_positions[car_idx as usize];\n   \
    \     for other_car_idx in (car_idx + 1)..n {\n            let other_car_position\
    \ = car_positions[other_car_idx as usize];\n            if car_directions[car_idx\
    \ as usize] != car_directions[other_car_idx as usize]\n                && car_position\
    \ == other_car_position\n            {\n                collisions += 1;\n   \
    \         }\n        }\n        car_positions[car_idx as usize] += car_directions[car_idx\
    \ as usize];\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpwnua165u.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // Base cases:\n    // n = 0, collision = 0\n    // n\
    \ = 1, collision = 0\n    // n = 2, collision = 1\n    // We now show that the\
    \ number of collisions for n = 3 is the same as\n    // 3 times the number of\
    \ collisions for n = 1.\n    // This can be done by counting how many times the\
    \ middle car collides\n    // with the other cars.\n    // The middle car will\
    \ collide with the car to its left and the car to its right.\n    // In total,\
    \ this is 3 collisions.\n    // Now assume the theorem holds for some n > 2.\n\
    \    // We then prove that the theorem holds for n + 1.\n    // The first n cars\
    \ will have n collisions.\n    // Furthermore, the n+1 car will collide with the\
    \ n car.\n    // This is an additional collision.\n    // The total number of\
    \ collisions is then n + 1.\n    // By induction, the number of collisions is\
    \ n.\n    n\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp_packq7f.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count = 0;\n    for i in 1..=n {\n        count\
    \ += i;\n    }\n    count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmppljptzxd.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // TODO: Place the code that solves the problem here.\n\
    \    0\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpqk4xvvpu.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    n*(n-1)/2\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpfb8octq2.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // TODO: write your solution to the problem here\n  \
    \  panic!(\"To be implemented!\");\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'To be implemented!', /tmp/tmpfqgo2vsy.rs:11:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut l_to_r = Vec::new();\n    let mut r_to_l = Vec::new();\n\
    \    for i in 0..n {\n        let x = n - i - 1;\n        l_to_r.push(x);\n  \
    \      r_to_l.push(x);\n    }\n    let mut collisions = 0;\n    while let Some(left_most)\
    \ = l_to_r.pop() {\n        let right_most = r_to_l.pop().unwrap();\n        if\
    \ left_most > right_most {\n            collisions += 1;\n        }\n    }\n \
    \   collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n  \
    \  assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpacyotzde.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // number of cars moving left to right\n    // mutable\
    \ because we decrement this\n    let mut n_left = n;\n    // number of cars moving\
    \ right to left\n    let mut n_right = n;\n    // number of collisions\n    let\
    \ mut collisions = 0;\n    // modify n_left, n_right, and collisions in the loop\n\
    \    while n_left > 0 && n_right > 0 {\n        // the left car drives one minute\n\
    \        n_left -= 1;\n        // the right car drives one minute\n        n_right\
    \ -= 1;\n        // if the left car reached the right car, then there's a collision\n\
    \        if n_left == n_right {\n            collisions += 1;\n        }\n   \
    \ }\n    // return the number of collisions\n    collisions\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpp3ty64vr.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 0 {\n        return 0;\n    }\n    let mut left_cars:\
    \ Vec<isize> = Vec::new();\n    for i in 1..=n {\n        left_cars.push(i);\n\
    \    }\n    let mut right_cars: Vec<isize> = Vec::new();\n    for i in 1..=n {\n\
    \        right_cars.push(i);\n    }\n    return _car_race_collision(0, n, &mut\
    \ left_cars, &mut right_cars);\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `_car_race_collision` in this scope\n\
    \  --> /tmp/tmpcbyqgttz.rs:21:12\n   |\n21 |     return _car_race_collision(0,\
    \ n, &mut left_cars, &mut right_cars);\n   |            ^^^^^^^^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut direction = 1;\n    let mut head = n;\n    let\
    \ mut tail = n;\n    let mut count = 0;\n    while head != 0 || tail != 0 {\n\
    \        if direction == 1 {\n            head -= 1;\n            count += tail;\n\
    \        } else {\n            tail -= 1;\n            count += head;\n      \
    \  }\n        direction *= -1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    n\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmptc6qrt_y.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    for i in 1..=n {\n     \
    \   for j in 1..=n {\n            if (i - j).abs() == 1 {\n                collisions\
    \ += 1;\n            }\n        }\n    }\n    collisions\n}\n\nfn main() {\n \
    \   let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n  \
    \  assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmplae29vq8.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = (0..n).collect();\n\
    \    let mut right_to_left: Vec<isize> = (0..n).rev().collect();\n    let mut\
    \ collisions = 0;\n    while left_to_right.len() > 0 {\n        let first_ltor\
    \ = left_to_right[0];\n        let first_rtol = right_to_left[0];\n        let\
    \ mut i = 0;\n        while i < left_to_right.len() {\n            if left_to_right[i]\
    \ <= first_rtol {\n                left_to_right.remove(i);\n                i\
    \ -= 1;\n            }\n            i += 1;\n        }\n        i = 0;\n     \
    \   while i < right_to_left.len() {\n            if right_to_left[i] >= first_ltor\
    \ {\n                right_to_left.remove(i);\n                i -= 1;\n     \
    \       }\n            i += 1;\n        }\n        collisions += 1;\n    }\n \
    \   collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n  \
    \  assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp5hngeqcb.rs:20:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut counter = 0;\n    let mut left_to_right = 0;\n\
    \    let mut right_to_left = n - 1;\n    while left_to_right < right_to_left {\n\
    \        if left_to_right == right_to_left {\n            counter += 1;\n    \
    \    } else {\n            counter += 2;\n        }\n        left_to_right +=\
    \ 1;\n        right_to_left -= 1;\n    }\n    counter\n}\n\nfn main() {\n    let\
    \ candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpl_saearv.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    (1..n + 1).map(|x| (x - 1) * x).sum()\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp4re17c7e.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n    return n +\
    \ car_race_collision(n - 1);\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpcxh36mcj.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut l = 0;\n    let mut r = 0;\n    while l < n {\n\
    \        l += 1;\n        r += 1;\n    }\n    l + r\n}\n\nfn main() {\n    let\
    \ candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `9`', /tmp/tmpwhvmn88k.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<(isize, isize)> = vec![];\n\
    \    let mut right_to_left: Vec<(isize, isize)> = vec![];\n    for i in 0..n {\n\
    \        left_to_right.push((i, i + 1));\n        right_to_left.push((-i, -i -\
    \ 1));\n    }\n    let mut total = 0;\n    let mut done = false;\n    while !done\
    \ {\n        done = true;\n        for (i, r) in right_to_left.iter_mut().enumerate()\
    \ {\n            if r.1 > r.0 {\n                done = false;\n             \
    \   r.0 += 1;\n                r.1 += 1;\n                let (x1, x2) = r;\n\
    \                for j in i + 1..right_to_left.len() {\n                    let\
    \ (x3, x4) = right_to_left[j];\n                    if x1 < x3 && x2 > x4 {\n\
    \                        total += 1;\n                    }\n                }\n\
    \                for (x3, x4) in left_to_right.iter() {\n                    if\
    \ x1 < x3 && x2 > x4 {\n                        total += 1;\n                \
    \    }\n                }\n            }\n        }\n        for (i, l) in left_to_right.iter_mut().enumerate()\
    \ {\n            if l.1 > l.0 {\n                done = false;\n             \
    \   l.0 += 1;\n                l.1 += 1;\n                let (x1, x2) = l;\n\
    \                for j in i + 1..left_to_right.len() {\n                    let\
    \ (x3, x4) = left_to_right[j];\n                    if x1 < x3 && x2 > x4 {\n\
    \                        total += 1;\n                    }\n                }\n\
    \                for (x3, x4) in right_to_left.iter() {\n                    if\
    \ x1 < x3 && x2 > x4 {\n                        total += 1;\n                \
    \    }\n                }\n            }\n        }\n    }\n    total\n}\n\nfn\
    \ main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_vz4slrx.rs:28:29\n   |\n\
    28 |                     if x1 < x3 && x2 > x4 {\n   |                       \
    \      ^^\n   |                             |\n   |                          \
    \   expected `&mut isize`, found `isize`\n   |                             help:\
    \ consider mutably borrowing here: `&mut x3`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_vz4slrx.rs:28:40\n   |\n28 |                     if x1 < x3 &&\
    \ x2 > x4 {\n   |                                        ^^\n   |            \
    \                            |\n   |                                        expected\
    \ `&mut isize`, found `isize`\n   |                                        help:\
    \ consider mutably borrowing here: `&mut x4`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_vz4slrx.rs:33:29\n   |\n33 |                     if x1 < x3 &&\
    \ x2 > x4 {\n   |                             ^^ types differ in mutability\n\
    \   |\n   = note: expected mutable reference `&mut isize`\n                  \
    \    found reference `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_vz4slrx.rs:33:40\n\
    \   |\n33 |                     if x1 < x3 && x2 > x4 {\n   |                \
    \                        ^^ types differ in mutability\n   |\n   = note: expected\
    \ mutable reference `&mut isize`\n                      found reference `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_vz4slrx.rs:47:29\n   |\n47 |\
    \                     if x1 < x3 && x2 > x4 {\n   |                          \
    \   ^^\n   |                             |\n   |                             expected\
    \ `&mut isize`, found `isize`\n   |                             help: consider\
    \ mutably borrowing here: `&mut x3`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_vz4slrx.rs:47:40\n\
    \   |\n47 |                     if x1 < x3 && x2 > x4 {\n   |                \
    \                        ^^\n   |                                        |\n \
    \  |                                        expected `&mut isize`, found `isize`\n\
    \   |                                        help: consider mutably borrowing\
    \ here: `&mut x4`\n\nerror[E0308]: mis"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // let mut right_moving = (0..n).collect::<Vec<isize>>();\n\
    \    // let mut left_moving = (0..n).rev().collect::<Vec<isize>>();\n    // let\
    \ mut collisions = 0;\n    //\n    // while right_moving.len() > 0 && left_moving.len()\
    \ > 0 {\n    //     let right_moved = right_moving.pop().unwrap();\n    //   \
    \  let left_moved = left_moving.pop().unwrap();\n    //     collisions += n -\
    \ std::cmp::max(right_moved, left_moved);\n    // }\n    // collisions\n    n\
    \ * (n - 1) / 2\n}\n\nfn main() {\n    let candidate = car_race_collision;\n \
    \   assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmprrh_5mng.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut cars = vec![0; n\
    \ as usize];\n    for i in 0..n {\n        cars[i as usize] = i;\n    }\n    for\
    \ i in 0..n {\n        for j in 0..n {\n            if cars[i as usize] > cars[j\
    \ as usize] {\n                collisions += 1;\n            }\n        }\n  \
    \  }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp2mi4ilc0.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        0\n    } else {\n        car_race_collision(n\
    \ - 1) + n - 1\n    }\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpfj6mwo9f.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut coll = 0;\n    let mut dir: Vec<isize> = Vec::new();\n\
    \    for i in 0..n {\n        dir.push(1);\n    }\n    for i in n..(2 * n) {\n\
    \        dir.push(-1);\n    }\n    for i in 0..(2 * n) {\n        for j in (i\
    \ + 1)..(2 * n) {\n            if dir[i as usize] > 0 && dir[j as usize] < 0 {\n\
    \                coll += 1;\n            }\n        }\n    }\n    coll\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut i = 1;\n    let mut collisons = 0;\n    while\
    \ i <= n {\n        collisons += n - i;\n        i += 1;\n    }\n    collisons\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp2dgjh9r3.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars: Vec<Car> = Vec::new();\n    for i in 0..n\
    \ {\n        cars.push(Car { dir: Dir::LeftToRight, pos: i as isize });\n    \
    \    cars.push(Car { dir: Dir::RightToLeft, pos: n - i as isize });\n    }\n \
    \   cars.sort_by(|a, b| a.cmp(b));\n    let mut collisions = 0;\n    for i in\
    \ 0..cars.len() - 1 {\n        if cars[i].dir == cars[i + 1].dir {\n         \
    \   collisions += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n   \
    \ let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Dir`\n  --> /tmp/tmpxs88a1ra.rs:12:30\n\
    \   |\n12 |         cars.push(Car { dir: Dir::LeftToRight, pos: i as isize });\n\
    \   |                              ^^^ use of undeclared type `Dir`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Dir`\n  --> /tmp/tmpxs88a1ra.rs:13:30\n\
    \   |\n13 |         cars.push(Car { dir: Dir::RightToLeft, pos: n - i as isize\
    \ });\n   |                              ^^^ use of undeclared type `Dir`\n\n\
    error[E0412]: cannot find type `Car` in this scope\n  --> /tmp/tmpxs88a1ra.rs:10:23\n\
    \   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                 \
    \     - help: you might be missing a type parameter: `<Car>`\n10 |     let mut\
    \ cars: Vec<Car> = Vec::new();\n   |                       ^^^ not found in this\
    \ scope\n\nerror[E0422]: cannot find struct, variant or union type `Car` in this\
    \ scope\n  --> /tmp/tmpxs88a1ra.rs:12:19\n   |\n12 |         cars.push(Car { dir:\
    \ Dir::LeftToRight, pos: i as isize });\n   |                   ^^^ not found\
    \ in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Car`\
    \ in this scope\n  --> /tmp/tmpxs88a1ra.rs:13:19\n   |\n13 |         cars.push(Car\
    \ { dir: Dir::RightToLeft, pos: n - i as isize });\n   |                   ^^^\
    \ not found in this scope\n\nerror: aborting due to 5 previous errors\n\nSome\
    \ errors have detailed explanations: E0412, E0422, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    return 0;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmphsv9o03y.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n < 1 {\n        return 0;\n    }\n    // There are\
    \ 2^(n-1) cars.\n    // For every car A, there are 2^(n-1) - A cars faster than\
    \ A.\n    // All of these cars have the same speed as A.\n    // So for every\
    \ car A, A will collide with 2^(n-1) - A cars.\n    // For every pair of cars\
    \ A and B, if A is faster than B, A will collide with B.\n    // If B is faster\
    \ than A, B will collide with A.\n    // So for every pair of cars A and B, there\
    \ will be 1 collision.\n    // The result is the sum of (2^(n-1) - A) for all\
    \ A, which is\n    // 2^(n-1) * 2^(n-1) - (1 + 2 + ... + 2^(n-1))\n    // = 2^(n-1)\
    \ * 2^(n-1) - (2^n - 1)\n    // = 2^(n-1) * 2^(n-1) - 2^n + 1\n    // = (2^(n-1)\
    \ - 1) * (2^(n-1) + 1)\n    // = (2^(n-1) - 1) * (2^(n-1) - 1 + 2)\n    // = (2^(n-1)\
    \ - 1) * (2^(n-1) + 1)\n    // = (2^(n-1) - 1) * 2^(n-1) + (2^(n-1) - 1)\n   \
    \ // = 2^(2n-2) - 2^(n-1) + 2^(n-1) - 1\n    // = 2^(2n-2) - 1\n    (1 << (2 *\
    \ n - 2)) - 1\n}\n\nfn main() {\n    let candidate = car_race_collision;\n   \
    \ assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmp5bcmapnu.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut result = 0;\n    let mut left_to_right = vec![(0,\
    \ false); n as usize];\n    let mut right_to_left = vec![(0, false); n as usize];\n\
    \    for i in 0..n {\n        left_to_right[i as usize] = (i * 2, false);\n  \
    \      right_to_left[i as usize] = (i * 2 + 1, false);\n    }\n    for i in 0..n\
    \ {\n        left_to_right[i as usize].1 = false;\n        for j in 0..n {\n \
    \           if right_to_left[j as usize].1 {\n                continue;\n    \
    \        }\n            if left_to_right[i as usize].0 > right_to_left[j as usize].0\
    \ {\n                result += 1;\n                right_to_left[j as usize].1\
    \ = true;\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmponin7zv8.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // This is a demo algorithm; it is not meant to be useful.\n\
    \    // In fact, it is a terrible algorithm.  The point of this demo\n    // is\
    \ to illustrate how to test code.\n    //\n    // (The point of this demo algorithm\
    \ is to be terrible.\n    // There are better algorithms that we didn't use.)\n\
    \    if n <= 0 {\n        return 0;\n    }\n\n    let mut out = 0;\n    for i\
    \ in 0..n {\n        out += i;\n    }\n    return out;\n}\n\nfn main() {\n   \
    \ let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp_omz5lyg.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let (p, c) = (1, 1);\n    let mut res = 1;\n    for _\
    \ in 1..n + 1 {\n        res = ncr(p + c, c);\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `ncr` in this scope\n  --> /tmp/tmpa28yeqx4.rs:13:15\n\
    \   |\n13 |         res = ncr(p + c, c);\n   |               ^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count: isize = 0;\n    let mut i: isize = 0;\n\
    \    while i < n {\n        let mut j: isize = 0;\n        while j < n {\n   \
    \         if i > j {\n                count += 1;\n            }\n           \
    \ j += 1;\n        }\n        i += 1;\n    }\n    count\n}\n\nfn main() {\n  \
    \  let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n   \
    \ assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp4cowmrwr.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // We are given n cars moving left to right, and n cars\
    \ moving right to left,\n    // starting at the same time, and from opposite ends\
    \ of a straight infinitely long road.\n    // We have an algorithm to identify\
    \ whether a car will collide with any other car.\n    // Suppose we put the cars\
    \ in a queue, left to right, and then we pop cars from the\n    // right end of\
    \ the queue, and we add new cars to the left end of the queue.\n    // The cars\
    \ can be compared to each other.  If a car is popped from the queue,\n    // then\
    \ we check whether it collides with any other car that's still in the queue.\n\
    \    // If it collides with one or more cars, then we increment our collision\
    \ count by one.\n    // If we implement the queue using a linked list, then popping\
    \ the right-most car\n    // and adding a new car to the left side of the queue\
    \ takes constant time.\n    // The algorithm to determine whether a car collides\
    \ with any other car is O(n),\n    // so the total run time is n * O(n) = O(n^2).\n\
    \    // Since this is a coding interview, we could have been asked to do better.\n\
    \    // However, we do not want to spend too much time on this problem.\n    //\
    \ We don't need to spend any time at all.  We can just observe that the collision\n\
    \    // count is equal to the sum of the first n integers.  2 + 3 + 4 + ... +\
    \ n = n(n+1)/2.\n    n * (n + 1) / 2\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpkf4er4y6.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 0 {\n        return 0;\n    }\n    let mut lr_ranges\
    \ = HashMap::new();\n    let mut rl_ranges = HashMap::new();\n    // car #0 starts\
    \ at position -1 and moves towards +1\n    lr_ranges.insert(0, Range { start:\
    \ -1, end: 1 });\n    // car #1 starts at position 1 and moves towards -1\n  \
    \  rl_ranges.insert(1, Range { start: 1, end: -1 });\n    // Assume that there\
    \ are at least two cars.\n    assert!(n >= 2);\n    for i in 2..n {\n        //\
    \ car #i starts at position -i and moves towards +i\n        lr_ranges.insert(i,\
    \ Range { start: -i, end: i });\n        // car #i starts at position i and moves\
    \ towards -i\n        rl_ranges.insert(i, Range { start: i, end: -i });\n    }\n\
    \    let mut coll_count = 0;\n    let mut coll_set = HashSet::new();\n    // Go\
    \ through the range of left to right cars\n    for (x, r) in lr_ranges.iter()\
    \ {\n        // Go through the range of right to left cars\n        for (y, r1)\
    \ in rl_ranges.iter() {\n            // if the two cars are colliding\n      \
    \      if r.start >= r1.start && r.start <= r1.end {\n                // make\
    \ sure we don't count the same collision twice\n                if coll_set.insert((*x,\
    \ *y)) {\n                    coll_count += 1;\n                }\n          \
    \  }\n        }\n    }\n    coll_count\n}\n\nfn main() {\n    let candidate =\
    \ car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpjc1l37fh.rs:13:25\n   |\n13 |     let mut lr_ranges = HashMap::new();\n\
    \   |                         ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpjc1l37fh.rs:14:25\n\
    \   |\n14 |     let mut rl_ranges = HashMap::new();\n   |                    \
    \     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0422]: cannot find\
    \ struct, variant or union type `Range` in this scope\n  --> /tmp/tmpjc1l37fh.rs:16:25\n\
    \   |\n16 |     lr_ranges.insert(0, Range { start: -1, end: 1 });\n   |      \
    \                   ^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ one of these items\n   |\n1  | use std::collections::btree_map::Range;\n   |\n\
    1  | use std::collections::btree_set::Range;\n   |\n1  | use std::ops::Range;\n\
    \   |\n\nerror[E0422]: cannot find struct, variant or union type `Range` in this\
    \ scope\n  --> /tmp/tmpjc1l37fh.rs:18:25\n   |\n18 |     rl_ranges.insert(1, Range\
    \ { start: 1, end: -1 });\n   |                         ^^^^^ not found in this\
    \ scope\n   |\nhelp: consider importing one of these items\n   |\n1  | use std::collections::btree_map::Range;\n\
    \   |\n1  | use std::collections::btree_set::Range;\n   |\n1  | use std::ops::Range;\n\
    \   |\n\nerror[E0422]: cannot find struct, variant or union type `Range` in this\
    \ scope\n  --> /tmp/tmpjc1l37fh.rs:23:29\n   |\n23 |         lr_ranges.insert(i,\
    \ Range { start: -i, end: i });\n   |                             ^^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  |\
    \ use std::collections::btree_map::Range;\n   |\n1  | use std::collections::btree_set::Range;\n\
    \   |\n1  | use std::ops::Range;\n   |\n\nerror[E0422]: cannot find struct, variant\
    \ or union type `Range` in this scope\n  --> /tmp/tmpjc1l37fh.rs:25:29\n   |\n\
    25 |         rl_ranges.insert(i, Range { start: i, end: -i });\n   |     "
  exit_code: 1
  status: SyntaxError
