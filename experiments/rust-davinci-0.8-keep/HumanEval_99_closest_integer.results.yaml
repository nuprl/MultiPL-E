name: HumanEval_99_closest_integer
language: rust
results:
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  value.parse::<f64>().unwrap().round() as isize\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num >= 0.0 {\n        (num +\
    \ 0.5).floor() as isize\n    } else {\n        (num - 0.5).ceil() as isize\n \
    \   }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let float_value = value.parse::<f64>().unwrap();\n    if float_value > 0.0\
    \ {\n        float_value.ceil() as isize\n    } else {\n        float_value.floor()\
    \ as isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n  \
    \  assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpt5_hlt76.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  (value.parse::<f64>().unwrap() + 0.5).trunc() as isize\n}\n\nfn main() {\n\
    \    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-15`,\n right: `-16`', /tmp/tmpzio5qzpf.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let base: f64 = value.parse().unwrap();\n    let int = base.round() as isize;\n\
    \    return int;\n}\n\nfn main() {\n    let candidate = closest_integer;\n   \
    \ assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  if value.starts_with('-') {\n        let value: isize = value.parse().unwrap();\n\
    \        value - 1\n    } else {\n        let value: isize = value.parse().unwrap();\n\
    \        value + 1\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `11`,\n right: `10`', /tmp/tmpv3y5b6hc.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  match value.parse::<f64>() {\n        Ok(val) => {\n            if val > 0.0\
    \ {\n                val.ceil() as isize\n            } else {\n             \
    \   val.floor() as isize\n            }\n        }\n        Err(_) => -1,\n  \
    \  }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmp47u3iocj.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  if value.contains(\".\") {\n        value.split(\".\").next().unwrap().parse::<isize>().unwrap()\n\
    \    } else {\n        value.parse::<isize>().unwrap()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmpqphk526k.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  value.parse::<f64>().unwrap().round() as isize\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num = value.parse::<f64>().unwrap();\n    if num < 0.0 {\n        (num\
    \ - 0.5).ceil() as isize\n    } else {\n        (num + 0.5).floor() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  // Implement the function here\n    let value = value.parse::<f64>().unwrap();\n\
    \    let value = if value.is_sign_positive() {\n        value.floor()\n    } else\
    \ {\n        value.ceil()\n    };\n    value as isize\n}\n\nfn main() {\n    let\
    \ candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")),\
    \ 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmp2dc7e7p2.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let number: f64 = value.parse().unwrap();\n    if number.fract() >= 0.5 {\n\
    \        return (number + 1.0).round() as isize;\n    }\n    number.round() as\
    \ isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmp_ziv9pit.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  value.parse::<f64>().unwrap().round() as isize\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  if let Ok(val) = value.parse::<f64>() {\n        return val.round() as isize;\n\
    \    }\n    return 0;\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let float = value.parse::<f64>().unwrap();\n    let diff = (float - float.floor()).abs();\n\
    \    let diff_ceil = (float - float.ceil()).abs();\n    if diff <= diff_ceil {\n\
    \        float.floor() as isize\n    } else {\n        float.ceil() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmp7s8buh_w.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let i: f64 = value.parse().unwrap();\n    i.round() as isize\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let raw_value = value.parse::<f64>().unwrap();\n    let raw_value_as_isize\
    \ = raw_value as isize;\n    let is_positive = raw_value >= 0.0;\n    let is_closer_to_raw_value\
    \ = if is_positive {\n        raw_value - raw_value_as_isize as f64 <= 0.5\n \
    \   } else {\n        raw_value_as_isize as f64 - raw_value <= 0.5\n    };\n \
    \   if is_closer_to_raw_value {\n        raw_value_as_isize\n    } else {\n  \
    \      if is_positive {\n            raw_value_as_isize + 1\n        } else {\n\
    \            raw_value_as_isize - 1\n        }\n    }\n}\n\nfn main() {\n    let\
    \ candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")),\
    \ 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmpyscdtz_v.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  value.parse::<f64>().unwrap().round() as isize\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let parsed = value.parse::<f64>().unwrap();\n    if parsed.fract() == 0.0 {\n\
    \        return parsed as isize;\n    }\n    if parsed.fract() >= 0.5 {\n    \
    \    return (parsed.ceil()) as isize;\n    }\n    parsed.floor() as isize\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  value.parse::<f64>().unwrap().round() as isize\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.is_sign_positive() {\n\
    \        (value + 0.5).floor() as isize\n    } else {\n        (value - 0.5).ceil()\
    \ as isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n  \
    \  assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let number: f64 = value.parse().unwrap();\n    return number.round() as isize;\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let i = value.parse::<f64>().unwrap();\n    let r = if i < 0.0 {\n        i.floor()\n\
    \    } else {\n        i.ceil()\n    };\n    r as isize\n}\n\nfn main() {\n  \
    \  let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpox3b96nh.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let rounded = value.round();\n\
    \    if rounded == value {\n        value as isize\n    } else {\n        if rounded\
    \ > value {\n            rounded as isize - 1\n        } else {\n            rounded\
    \ as isize + 1\n        }\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmpgdezvom7.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let n = value.parse::<f64>().unwrap();\n    if n.fract() >= 0.5 {\n       \
    \ n.ceil() as isize\n    } else {\n        n.floor() as isize\n    }\n}\n\nfn\
    \ main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    num.round() as isize\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let parsed = value.parse::<f64>().unwrap();\n    if (parsed - parsed.floor())\
    \ == 0.5 {\n        if parsed.is_sign_positive() {\n            return (parsed\
    \ + 1.0).floor() as isize;\n        } else {\n            return (parsed - 1.0).floor()\
    \ as isize;\n        }\n    }\n    return parsed.round() as isize;\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-17`,\n right: `-16`', /tmp/tmp3i1fziyx.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let number: f64 = value.parse().unwrap();\n    let pos_number = number.abs();\n\
    \    let down_number = pos_number.floor();\n    let up_number = pos_number.ceil();\n\
    \    if down_number == up_number {\n        if number > 0.0 {\n            up_number\
    \ as isize\n        } else {\n            down_number as isize * -1\n        }\n\
    \    } else if down_number < up_number {\n        if number > 0.0 {\n        \
    \    if number - down_number > up_number - number {\n                up_number\
    \ as isize\n            } else {\n                down_number as isize\n     \
    \       }\n        } else {\n            if down_number - number > number - up_number\
    \ {\n                down_number as isize * -1\n            } else {\n       \
    \         up_number as isize * -1\n            }\n        }\n    } else {\n  \
    \      0\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmpd8fvcosr.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num >= 0.0 {\n        (num +\
    \ 0.5).floor() as isize\n    } else {\n        (num - 0.5).ceil() as isize\n \
    \   }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value < 0.0 {\n        return\
    \ value.ceil() as isize;\n    }\n    return value.floor() as isize;\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmpm6fl24yn.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.ceil() - value > 0.5\
    \ {\n        value.floor() as isize\n    } else {\n        value.ceil() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-15`,\n right: `-16`', /tmp/tmpz9cdmcsu.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let float_val = value.parse::<f64>().unwrap();\n    float_val.round() as isize\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let val: f64 = value.parse().unwrap();\n    let val_int: isize = val.round()\
    \ as isize;\n    let val_fractional = val.fract();\n    val_int - val_fractional\
    \ as isize + val_fractional.abs() as isize\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let float_value = value.parse::<f64>().unwrap();\n    float_value.round() as\
    \ isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut res = 0;\n    if let Ok(val) = value.parse::<f64>() {\n        res\
    \ = val.round() as isize;\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let val = value.parse::<f64>().unwrap();\n    let round = val.round();\n  \
    \  if val > 0.0 {\n        if round - val > 0.5 {\n            round as isize\
    \ - 1\n        } else {\n            round as isize\n        }\n    } else {\n\
    \        if val - round > 0.5 {\n            round as isize + 1\n        } else\
    \ {\n            round as isize\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  // TODO\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpsg16n84y.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value = value.parse::<f64>().unwrap();\n    if value - value.floor() <\
    \ 0.5 {\n        value.floor() as isize\n    } else {\n        value.ceil() as\
    \ isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-15`,\n right: `-16`', /tmp/tmpmqth4co3.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let rounded = value.parse::<f64>().unwrap().round();\n    rounded as isize\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value == value.trunc() {\n\
    \        return value as isize;\n    }\n    if value.trunc() == value.ceil() {\n\
    \        return value.ceil() as isize;\n    }\n    if value < 0.0 {\n        return\
    \ value.ceil() as isize;\n    }\n    return value.floor() as isize;\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmpvjuiet4e.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let flt: f64 = value.parse().unwrap();\n    if flt > 0.0 {\n        return\
    \ (flt + 0.5).floor() as isize;\n    } else {\n        return (flt - 0.5).ceil()\
    \ as isize;\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n \
    \   assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value = value.parse::<f64>().unwrap();\n    let value = if value < 0.0\
    \ {\n        value - 0.5\n    } else {\n        value + 0.5\n    };\n    value.round()\
    \ as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `11`,\n right: `10`', /tmp/tmpdbht9q0r.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  value.parse::<f64>().unwrap().round() as isize\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let n = value.parse::<f64>().unwrap();\n    if n.fract() < 0.5 {\n        n.floor()\
    \ as isize\n    } else {\n        n.ceil() as isize\n    }\n}\n\nfn main() {\n\
    \    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let parsed_value = value.parse::<f64>().unwrap();\n    let mut rem = parsed_value.fract();\n\
    \    if rem == 0.5 {\n        let mut result = parsed_value.round() as isize;\n\
    \        if result > 0 {\n            result += 1;\n        } else {\n       \
    \     result -= 1;\n        }\n        return result;\n    }\n    parsed_value.round()\
    \ as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmp1r4cpoob.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let tmp: f64 = value.parse().unwrap();\n    if tmp >= 0.0 {\n        return\
    \ tmp.ceil() as isize;\n    } else {\n        return tmp.floor() as isize;\n \
    \   }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmptw6k9bu7.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  value.parse::<f64>().unwrap().round() as isize\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  return if value.contains(\".\") {\n        value.parse::<f64>().unwrap().round()\
    \ as isize\n    } else {\n        value.parse::<isize>().unwrap()\n    };\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let float_value = value.parse::<f64>().unwrap();\n    let int_value = float_value.round()\
    \ as isize;\n    if (float_value - float_value.floor()) < 0.5 {\n        int_value\n\
    \    } else {\n        int_value + 1\n    }\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpm2c989vb.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    value.round() as isize\n}\n\n\
    fn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  // Complete this function\n    let mut value = value.parse::<f64>().unwrap();\n\
    \    //println!(\"{}\", value);\n    let mut positive = true;\n    if value <\
    \ 0.0 {\n        positive = false;\n        value = value * -1.0;\n    }\n   \
    \ //println!(\"{}\", value);\n    let mut integer = value.trunc();\n    //println!(\"\
    {}\", integer);\n    let float = value - integer;\n    //println!(\"{}\", float);\n\
    \    if float >= 0.5 {\n        integer += 1.0;\n    }\n    //println!(\"{}\"\
    , integer);\n    if positive {\n        integer as isize\n    } else {\n     \
    \   -integer as isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  value.parse::<f64>().unwrap().round() as isize\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num = value.parse::<f64>().unwrap();\n    if num < 0.0 {\n        num.ceil()\
    \ as isize\n    } else {\n        num.floor() as isize\n    }\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmpgml7_idv.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let x = value.parse::<f64>().unwrap();\n    let s = x.round() as isize;\n \
    \   if x < 0.0 {\n        s + 1\n    } else {\n        s\n    }\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-15`,\n right: `-16`', /tmp/tmpagv69zpl.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  if let Ok(num) = value.parse::<f64>() {\n        num.round() as isize\n   \
    \ } else {\n        0\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  return value.parse::<f64>().unwrap().round() as isize;\n}\n\nfn main() {\n\
    \    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let integral = value.floor();\n\
    \    let fractional = value - integral;\n    if fractional >= 0.5 {\n        (integral\
    \ + 1.0) as isize\n    } else {\n        integral as isize\n    }\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-15`,\n right: `-16`', /tmp/tmprvdd62rj.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut num: f64 = value.parse().unwrap();\n    if num > 0.0 {\n        num.ceil()\
    \ as isize\n    } else {\n        num.floor() as isize\n    }\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpl0euona6.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let float = value.parse::<f64>().unwrap();\n    float.round() as isize\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let mut floor = value.floor();\n\
    \    let mut ceil = value.ceil();\n    let mut result = 0.0;\n    if floor < 0.0\
    \ {\n        if value - floor > ceil - value {\n            result = ceil;\n \
    \       } else {\n            result = floor;\n        }\n    } else {\n     \
    \   if value - floor > ceil - value {\n            result = ceil;\n        } else\
    \ {\n            result = floor;\n        }\n    }\n    result as isize\n}\n\n\
    fn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmpsbhl8mij.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num = value.parse::<f64>().unwrap();\n    let (x, _) = num.modf();\n  \
    \  if x.abs() >= 0.5 {\n        if num >= 0.0 {\n            return (num + 1.0).trunc()\
    \ as isize;\n        } else {\n            return (num - 1.0).trunc() as isize;\n\
    \        }\n    } else {\n        return num.trunc() as isize;\n    }\n}\n\nfn\
    \ main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `modf` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpla99oe4_.rs:16:22\n   |\n16 |     let (x, _) = num.modf();\n\
    \   |                      ^^^^ method not found in `f64`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let v: f64 = value.parse().unwrap();\n    v.round() as isize\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let n = value.parse::<f64>().unwrap();\n    if (n - n.floor()).abs() > (n -\
    \ n.ceil()).abs() {\n        n.ceil() as isize\n    } else {\n        n.floor()\
    \ as isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n  \
    \  assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmp7l2r8vh1.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut result = 0;\n    let mut diff = isize::max_value();\n    for i in 1..=20\
    \ {\n        let diff_from_i = (value.parse::<f64>().unwrap() - i as f64).abs();\n\
    \        if diff_from_i < diff {\n            diff = diff_from_i;\n          \
    \  result = i;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpingt999z.rs:19:26\n   |\n\
    19 |         if diff_from_i < diff {\n   |                          ^^^^ expected\
    \ `f64`, found `isize`\n   |\nhelp: you can convert an `isize` to an `f64`, producing\
    \ the floating point representation of the integer, rounded if necessary\n   |\n\
    19 |         if diff_from_i < diff as f64 {\n   |                            \
    \   ++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpingt999z.rs:20:20\n\
    \   |\n16 |     let mut diff = isize::max_value();\n   |                    ------------------\
    \ expected due to this value\n...\n20 |             diff = diff_from_i;\n   |\
    \                    ^^^^^^^^^^^ expected `isize`, found `f64`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    value.round() as isize\n}\n\n\
    fn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    num.round() as isize\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let parsed = value.parse::<f64>().unwrap();\n    let positive = parsed.abs();\n\
    \    let remainder = positive.fract();\n    let floor = positive.floor();\n  \
    \  let ceiling = positive.ceil();\n    if remainder < 0.5 {\n        if parsed\
    \ > 0.0 {\n            floor as isize\n        } else {\n            -floor as\
    \ isize\n        }\n    } else {\n        if parsed > 0.0 {\n            ceiling\
    \ as isize\n        } else {\n            -ceiling as isize\n        }\n    }\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let v = value.parse::<f64>().unwrap();\n    return v.round() as isize;\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    let mut res = num.round() as isize;\n\
    \    let diff = num - res as f64;\n    if diff.abs() == 0.5 {\n        res +=\
    \ 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpwl7lk370.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let integer: isize = value.parse().unwrap();\n    if value.contains(\".\")\
    \ {\n        let decimal: isize = value.split(\".\").last().unwrap().parse().unwrap();\n\
    \        if decimal >= 5 {\n            integer + 1\n        } else {\n      \
    \      integer\n        }\n    } else {\n        integer\n    }\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value:\
    \ ParseIntError { kind: InvalidDigit }', /tmp/tmpeg7rgvoa.rs:15:40\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  value.parse::<f64>().unwrap().round() as isize\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let floor = value.floor();\n\
    \    let ceil = value.ceil();\n    if value - floor < ceil - value {\n       \
    \ floor as isize\n    } else {\n        ceil as isize\n    }\n}\n\nfn main() {\n\
    \    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-15`,\n right: `-16`', /tmp/tmpjcf4ta9l.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut val: f64 = value.parse().unwrap();\n    if val.is_sign_negative() {\n\
    \        val *= -1.0;\n    }\n    let mut result = val.floor() as isize;\n   \
    \ if val.ceil() - val < 0.5 {\n        result = val.ceil() as isize;\n    }\n\
    \    if value.chars().next().unwrap() == '-' {\n        result *= -1;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmpf2bbf7o2.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  return value.parse::<f64>().unwrap().round() as isize;\n}\n\nfn main() {\n\
    \    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let val: f64 = value.parse().unwrap();\n    let val = val.round();\n    val\
    \ as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let f = value.parse::<f64>().unwrap();\n    let mut n = f.floor() as isize;\n\
    \    let rounded = (f + 0.5).floor() as isize;\n    if rounded > n {\n       \
    \ n += 1;\n    }\n    n\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-15`,\n right: `-16`', /tmp/tmpwpyuauvn.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num = value.parse::<f64>().unwrap();\n    let res = num.round();\n    if\
    \ res > 0.0 {\n        res as isize\n    } else {\n        (res - 1.0) as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-17`,\n right: `-16`', /tmp/tmp3g6qqfcp.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let float = value.parse::<f64>().unwrap();\n    float.round() as isize\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    (value + if value < 0.0 { -0.5\
    \ } else { 0.5 }).round() as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `11`,\n right: `10`', /tmp/tmp4gzxz1mu.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let parsed = value.parse::<f64>().unwrap();\n    let rounded = parsed.round();\n\
    \    rounded as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  return value.parse::<f64>().unwrap().round() as isize;\n}\n\nfn main() {\n\
    \    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let f: f64 = value.parse().unwrap();\n    let i: isize = f.round() as isize;\n\
    \    return i;\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let n = value.round() as isize;\n\
    \    n\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let left = value.floor() as isize;\n\
    \    let right = value.ceil() as isize;\n    if (value - left as f64).abs() <\
    \ (value - right as f64).abs() {\n        left\n    } else {\n        right\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-15`,\n right: `-16`', /tmp/tmpyifo6rf2.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let rem = value % 1.0;\n    if\
    \ rem == 0.5 {\n        if value > 0.0 {\n            return (value + 0.5) as\
    \ isize;\n        } else {\n            return (value - 0.5) as isize;\n     \
    \   }\n    }\n    return value.round() as isize;\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  value.parse::<f64>().unwrap().round() as isize\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value = value.parse::<f64>().unwrap();\n    let v_int = value.round() as\
    \ isize;\n    let v_flt = value.abs() as f64;\n    let mut v_diff = (v_flt - v_int\
    \ as f64).abs();\n    let mut v_candidate = v_int;\n    if v_diff > 0.5 {\n  \
    \      v_candidate += 1;\n        v_diff = 1.0 - v_diff;\n    }\n    if value\
    \ < 0.0 {\n        -v_candidate\n    } else {\n        v_candidate\n    }\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `15`,\n right: `-16`', /tmp/tmpeuhr3blt.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let x = value.parse::<f64>().unwrap();\n    let mut floor = x.floor();\n  \
    \  let mut ceil = x.ceil();\n    let mid = x.abs() - floor.abs();\n    let diff\
    \ = (ceil - x).abs();\n    if mid < diff {\n        floor as isize\n    } else\
    \ {\n        ceil as isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let parsed = value.parse::<f64>().unwrap();\n    let rounded = parsed.round();\n\
    \    rounded as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  value.parse::<f64>().unwrap().round() as isize\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let input: f64 = value.parse().unwrap();\n    let mut output: isize = 0;\n\
    \    let mut diff: f64 = 9999999.0;\n    for i in -1000..=1000 {\n        let\
    \ abs_diff = (input - i as f64).abs();\n        if abs_diff < diff {\n       \
    \     diff = abs_diff;\n            output = i;\n        }\n    }\n    output\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmpizoh36_b.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  return value.parse::<f64>().unwrap().round() as isize;\n}\n\nfn main() {\n\
    \    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let float_num: f64 = value.parse().unwrap();\n    if float_num.floor() == float_num.ceil()\
    \ {\n        float_num.floor() as isize\n    } else if float_num.floor() >= 0.0\
    \ {\n        if float_num - float_num.floor() < 0.5 {\n            float_num.floor()\
    \ as isize\n        } else {\n            float_num.ceil() as isize\n        }\n\
    \    } else {\n        if float_num.floor() - float_num < 0.5 {\n            float_num.floor()\
    \ as isize\n        } else {\n            float_num.ceil() as isize\n        }\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value = value.parse::<f64>().unwrap();\n    let (floor, ceil) = (value.floor(),\
    \ value.ceil());\n    if (value - floor).abs() < (value - ceil).abs() {\n    \
    \    floor as isize\n    } else {\n        ceil as isize\n    }\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-15`,\n right: `-16`', /tmp/tmpivu5w6zn.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value = value.parse::<f64>().unwrap();\n    if value.fract() >= 0.5 {\n\
    \        value.ceil() as isize\n    } else {\n        value.floor() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let x = value.parse::<f64>().unwrap();\n    if x < 0.0 {\n        return (x\
    \ - 0.5).floor() as isize;\n    }\n    (x + 0.5).floor() as isize\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  value.parse::<f64>().unwrap().round() as isize\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let v: f64 = value.parse().unwrap();\n    if v > 0.0 {\n        v.round() as\
    \ isize\n    } else {\n        v.ceil() as isize\n    }\n}\n\nfn main() {\n  \
    \  let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-15`,\n right: `-16`', /tmp/tmpv9m4l8oo.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num = value.parse::<f64>().unwrap();\n    if num.is_sign_positive() {\n\
    \        (num + 0.5).floor() as isize\n    } else {\n        (num - 0.5).ceil()\
    \ as isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n  \
    \  assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let r = value.parse::<f64>().unwrap();\n    if r - r.floor() == 0.5 {\n   \
    \     return if r.is_sign_positive() {\n            r.ceil() as isize\n      \
    \  } else {\n            r.floor() as isize\n        };\n    }\n    r.round()\
    \ as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value.is_sign_positive() {\n\
    \        return value.ceil() as isize;\n    }\n    value.floor() as isize\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmppvmpbcqo.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let number: f64 = value.parse().unwrap();\n    if number.is_sign_positive()\
    \ {\n        number.ceil() as isize\n    } else {\n        number.floor() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpurd6i1jd.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value = value.parse::<f64>().unwrap();\n    let mut res = value.round();\n\
    \    if res == value {\n        res = value.round() + 1.0;\n    }\n    res as\
    \ isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `11`,\n right: `10`', /tmp/tmp9_2_h2hf.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  // If the value is a whole number, just cast it to an integer.\n    if value.as_str().contains(\"\
    .\") == false {\n        return value.parse::<isize>().unwrap();\n    }\n    //\
    \ Otherwise, find the decimal place and the values before and after.\n    let\
    \ mut decimal_index = 0;\n    let mut decimal_value = 0;\n    let mut before_value\
    \ = 0;\n    let mut after_value = 0;\n    for (index, character) in value.chars().enumerate()\
    \ {\n        if character == '.' {\n            decimal_index = index;\n     \
    \   } else if index == decimal_index - 1 {\n            before_value = character.to_digit(10).unwrap()\
    \ as isize;\n        } else if index == decimal_index + 1 {\n            after_value\
    \ = character.to_digit(10).unwrap() as isize;\n        }\n    }\n    // If the\
    \ value after the decimal is greater than 5, add 1 to the value\n    // before\
    \ the decimal.\n    if after_value > 5 {\n        before_value += 1;\n    }\n\
    \    // Return the before value as an integer.\n    before_value\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp1k6wcxg8.rs:27:28\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let r = value.parse::<f64>().unwrap();\n    let r_abs = r.abs();\n    if r_abs\
    \ - r_abs.floor() >= 0.5 {\n        return (r + r.signum()).round() as isize;\n\
    \    }\n    r.round() as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmprg332egy.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let val: f64 = value.parse().unwrap();\n    val.round() as isize\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let f = value.parse::<f64>().unwrap();\n    let rounded = f.round();\n    rounded\
    \ as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let f: f64 = value.parse().unwrap();\n    let i: isize = f.round() as isize;\n\
    \    i\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let n = value.parse::<f64>().unwrap();\n    n.round() as isize\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num = value.parse::<f64>().unwrap();\n    if num < 0.0 {\n        return\
    \ num.ceil() as isize;\n    }\n    num.floor() as isize\n}\n\nfn main() {\n  \
    \  let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmp5e2nz0gr.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value >= 0.0 {\n        (value\
    \ + 0.5).floor() as isize\n    } else {\n        (value - 0.5).ceil() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    return value.round() as isize;\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  if let Ok(f) = value.parse::<f64>() {\n        return f.round() as isize;\n\
    \    }\n    0\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  // TODO\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpu14xj0f0.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    num.round() as isize\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  value.parse::<f64>().unwrap().round() as isize\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  value.parse::<f64>().unwrap().round() as isize\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let float_value = value.parse::<f64>().unwrap();\n    return float_value.round()\
    \ as isize;\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  value.parse::<f64>().unwrap().round() as isize\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value = value.parse::<f64>().unwrap();\n    let abs_value = value.abs();\n\
    \    if abs_value == abs_value.floor() {\n        value.round() as isize\n   \
    \ } else {\n        if value < 0.0 {\n            (abs_value.floor() - 1.0) as\
    \ isize * -1\n        } else {\n            abs_value.floor() as isize\n     \
    \   }\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmpkbbu4r81.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let mut new_value = value.round();\n\
    \    if value.abs() - new_value.abs() < 0.5 {\n        new_value\n    } else {\n\
    \        new_value += (value / value.abs()).round();\n        new_value\n    }\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy24uscig.rs:18:9\n   |\n\
    14 | fn closest_integer(value: String) -> isize {\n   |                      \
    \                ----- expected `isize` because of return type\n...\n18 |    \
    \     new_value\n   |         ^^^^^^^^^ expected `isize`, found `f64`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpy24uscig.rs:21:9\n   |\n14 | fn closest_integer(value:\
    \ String) -> isize {\n   |                                      ----- expected\
    \ `isize` because of return type\n...\n21 |         new_value\n   |         ^^^^^^^^^\
    \ expected `isize`, found `f64`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let rounded_value = value.round();\n\
    \    let rounded_value_integer = rounded_value as isize;\n    if value > 0.0 {\n\
    \        if rounded_value_integer > value as isize {\n            rounded_value_integer\
    \ - 1\n        } else {\n            rounded_value_integer\n        }\n    } else\
    \ {\n        if rounded_value_integer < value as isize {\n            rounded_value_integer\
    \ + 1\n        } else {\n            rounded_value_integer\n        }\n    }\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmprm3jxz0h.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  value.parse::<f64>().unwrap().round() as isize\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let float_val = value.parse::<f64>().unwrap();\n    (float_val + 0.5).floor()\
    \ as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-15`,\n right: `-16`', /tmp/tmpbiglwx71.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  if value.contains(\".\") {\n        let num: f64 = value.parse().unwrap();\n\
    \        let temp: isize = ((num - num.trunc()) * 10.0).abs() as isize;\n    \
    \    if temp >= 5 {\n            num.ceil() as isize\n        } else {\n     \
    \       num.floor() as isize\n        }\n    } else {\n        value.parse().unwrap()\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-15`,\n right: `-16`', /tmp/tmpj_7ru2wc.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let mut distance: f64 = (value\
    \ * 2.0).abs();\n    let mut closest_i64: i64 = value.round() as i64;\n    let\
    \ mut closest_isize: isize = closest_i64 as isize;\n    for i in -10..10 {\n \
    \       let i_f64: f64 = i as f64;\n        let d: f64 = (value - i_f64).abs();\n\
    \        if d < distance {\n            distance = d;\n            closest_i64\
    \ = i;\n            closest_isize = i as isize;\n        }\n    }\n    closest_isize\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `10`', /tmp/tmpne4ks079.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let number: f64 = value.parse().unwrap();\n    let int: isize = number.round()\
    \ as isize;\n    return int;\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  value.parse::<f64>().unwrap().round() as isize\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value < 0.0 {\n        return\
    \ value.ceil() as isize;\n    }\n    value.floor() as isize\n}\n\nfn main() {\n\
    \    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmp98zfeyky.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  // This is just a wrapper so that the closest_integer_by_sign\n    // can be\
    \ called with a simpler signature.\n    return closest_integer_by_sign(value,\
    \ 1);\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `closest_integer_by_sign` in this scope\n\
    \  --> /tmp/tmpsftdpd5q.rs:17:12\n   |\n17 |     return closest_integer_by_sign(value,\
    \ 1);\n   |            ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let v: f64 = value.parse().unwrap();\n    let abs = v.abs();\n    let r = abs.round();\n\
    \    if r == abs {\n        v as isize\n    } else {\n        if abs < r {\n \
    \           (v + 1.0) as isize\n        } else {\n            (v - 1.0) as isize\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n  \
    \  assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-14`,\n right: `-16`', /tmp/tmp7k4c42gm.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let float = value.parse::<f64>().unwrap();\n    float.round() as isize\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  value.parse::<f64>().unwrap().round() as isize\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num = value.parse::<f64>().unwrap();\n    let ret = num.round();\n    if\
    \ ret > 0.0 {\n        return ret as isize;\n    } else {\n        return ret\
    \ as isize - 1;\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-17`,\n right: `-16`', /tmp/tmplt6lcekg.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value < 0.0 {\n        return\
    \ value.ceil() as isize;\n    }\n    value.floor() as isize\n}\n\nfn main() {\n\
    \    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmp_k0wu4sh.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let f: f64 = value.parse().unwrap();\n    if f.fract() < 0.5 {\n        f as\
    \ isize\n    } else {\n        f.ceil() as isize\n    }\n}\n\nfn main() {\n  \
    \  let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-15`,\n right: `-16`', /tmp/tmpfajg67vk.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let v: f64 = value.parse().unwrap();\n    if v > 0.0 {\n        return v.ceil()\
    \ as isize;\n    } else {\n        return v.floor() as isize;\n    }\n}\n\nfn\
    \ main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmp4an5c9_q.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let result = value.parse::<f64>().unwrap();\n    result.round() as isize\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value = value.parse::<f64>().unwrap();\n    let dif = value.abs().fract();\n\
    \    if dif < 0.5 {\n        value.round() as isize\n    } else {\n        value.round()\
    \ as isize + value.signum() as isize\n    }\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpt8kw_5if.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num = value.parse::<f64>().unwrap();\n    let round = num.round();\n  \
    \  if round < num {\n        return round as isize + 1;\n    }\n    round as isize\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-15`,\n right: `-16`', /tmp/tmpnnnec187.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    if num < 0.0 {\n        return\
    \ num.ceil() as isize;\n    } else {\n        return num.floor() as isize;\n \
    \   }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmpubp9k9cy.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let fval: f64 = value.parse().unwrap();\n    if fval.abs() - fval.abs().floor()\
    \ == 0.5 {\n        if fval.is_sign_positive() {\n            (fval + 1.0).round()\
    \ as isize\n        } else {\n            (fval - 1.0).round() as isize\n    \
    \    }\n    } else {\n        fval.round() as isize\n    }\n}\n\nfn main() {\n\
    \    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpw7vepaai.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let number: f64 = value.parse().unwrap();\n    if number.fract() >= 0.5 {\n\
    \        (number + 1.0).round() as isize\n    } else {\n        number.round()\
    \ as isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n  \
    \  assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmp33l1fxp8.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let number: f64 = value.parse().unwrap();\n    let x: isize = number.trunc()\
    \ as isize;\n    let mut x1: isize = 0;\n    let mut x2: isize = 0;\n    if number\
    \ - x as f64 > 0.5 {\n        x1 = x + 1;\n        x2 = x;\n    } else {\n   \
    \     x1 = x;\n        x2 = x - 1;\n    }\n    let mut y1: f64 = (x1 as f64 -\
    \ number).abs();\n    let mut y2: f64 = (x2 as f64 - number).abs();\n    if y1\
    \ > y2 {\n        x1\n    } else {\n        x2\n    }\n}\n\nfn main() {\n    let\
    \ candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")),\
    \ 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `10`', /tmp/tmpnc_938df.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  // If a number is equidistant from two integers,\n    // the one you should\
    \ return is the one that is the farthest from zero.\n    // For example closest_integer(\"\
    14.5\") should return 15 and\n    // closest_integer(\"-14.5\") should return\
    \ -15.\n    let float_value = value.parse::<f64>().unwrap();\n    let ceil_value\
    \ = float_value.ceil();\n    let floor_value = float_value.floor();\n    if ceil_value\
    \ - float_value == 0.5 {\n        if float_value >= 0.0 {\n            ceil_value\
    \ as isize\n        } else {\n            floor_value as isize\n        }\n  \
    \  } else {\n        if float_value - floor_value > ceil_value - float_value {\n\
    \            ceil_value as isize\n        } else {\n            floor_value as\
    \ isize\n        }\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    let sign = value.signum();\n\
    \    let value = value.abs();\n    let lower = value.floor() as isize;\n    let\
    \ upper = value.ceil() as isize;\n    if value - lower as f64 < upper as f64 -\
    \ value {\n        sign * lower\n    } else {\n        sign * upper\n    }\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error: expected one of `,` or `}`, found `*`\n  --> /tmp/tmpg3exio9m.rs:21:14\n\
    \   |\n20 |     if value - lower as f64 < upper as f64 - value {\n   |       \
    \                                       ----- while parsing this struct\n21 |\
    \         sign * lower\n   |              ^ expected one of `,` or `}`\n\nerror:\
    \ `<` is interpreted as a start of generic arguments for `f64`, not a comparison\n\
    \  --> /tmp/tmpg3exio9m.rs:20:29\n   |\n20 |     if value - lower as f64 < upper\
    \ as f64 - value {\n   |                             ^ -------- interpreted as\
    \ generic arguments\n   |                             |\n   |                \
    \             not interpreted as comparison\n   |\nhelp: try comparing the cast\
    \ value\n   |\n20 |     if value - (lower as f64) < upper as f64 - value {\n \
    \  |                +            +\n\nerror[E0277]: cannot multiply `f64` by `isize`\n\
    \  --> /tmp/tmpg3exio9m.rs:21:14\n   |\n21 |         sign * lower\n   |      \
    \        ^ no implementation for `f64 * isize`\n   |\n   = help: the trait `Mul<isize>`\
    \ is not implemented for `f64`\n   = help: the following other types implement\
    \ trait `Mul<Rhs>`:\n             <&'a f32 as Mul<f32>>\n             <&'a f64\
    \ as Mul<f64>>\n             <&'a i128 as Mul<i128>>\n             <&'a i16 as\
    \ Mul<i16>>\n             <&'a i32 as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n\
    \             <&'a i8 as Mul<i8>>\n             <&'a isize as Mul<isize>>\n  \
    \         and 49 others\n\nerror[E0277]: cannot multiply `f64` by `isize`\n  -->\
    \ /tmp/tmpg3exio9m.rs:23:14\n   |\n23 |         sign * upper\n   |           \
    \   ^ no implementation for `f64 * isize`\n   |\n   = help: the trait `Mul<isize>`\
    \ is not implemented for `f64`\n   = help: the following other types implement\
    \ trait `Mul<Rhs>`:\n             <&'a f32 as Mul<f32>>\n             <&'a f64\
    \ as Mul<f64>>\n             <&'a i128 as Mul<i128>>\n             <&'a i16 as\
    \ Mul<i16>>\n             <&'a i32 as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n\
    \             <&'a i8 as Mul<i8>>\n             <&'a isize as Mul<isize>>\n  \
    \         and 49 others\n\nerror: aborting due to 4 previous err"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value = value.parse::<f64>().unwrap();\n    let dist_to_lower = value -\
    \ value.floor();\n    let dist_to_upper = value.ceil() - value;\n    if dist_to_lower\
    \ < dist_to_upper {\n        value.floor() as isize\n    } else {\n        value.ceil()\
    \ as isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n  \
    \  assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-15`,\n right: `-16`', /tmp/tmpvjxb05fo.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  value.parse::<f64>().unwrap().round() as isize\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    num.round() as isize\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    (value + 0.5).trunc() as isize\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-15`,\n right: `-16`', /tmp/tmpeyuvtk1n.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    num.round() as isize\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  if value.contains(\".\") {\n        let split = value.split(\".\").collect::<Vec<&str>>();\n\
    \        let part = split[0].parse::<isize>().unwrap();\n        let decimal =\
    \ split[1].parse::<isize>().unwrap();\n        if decimal >= 5 {\n           \
    \ part + 1\n        } else {\n            part\n        }\n    } else {\n    \
    \    value.parse::<isize>().unwrap()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-14`,\n right: `-16`', /tmp/tmprkhxbpwg.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  value.parse::<f64>().unwrap().round() as isize\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let f: f64 = value.parse().unwrap();\n    let i: isize = f.round() as isize;\n\
    \    return i;\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let val: f64 = value.parse().unwrap();\n    if val < 0.0 {\n        val.ceil()\
    \ as isize\n    } else {\n        val.floor() as isize\n    }\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmpbf182mnq.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut num = value.parse::<f64>().unwrap();\n    let decimal_point = num.fract();\n\
    \    if decimal_point >= 0.5 {\n        num += 1.0;\n    }\n    return num.round()\
    \ as isize;\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmplnu_9swt.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let float_value = value.parse::<f64>().unwrap();\n    let round_value = float_value.round();\n\
    \    round_value as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let flt = value.parse::<f64>().unwrap();\n    flt.round() as isize\n}\n\nfn\
    \ main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let float = value.parse::<f64>().unwrap();\n    if float >= 0.0 {\n       \
    \ (float + 0.5).floor() as isize\n    } else {\n        (float - 0.5).ceil() as\
    \ isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  value.parse::<f64>().unwrap().round() as isize\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let v: f64 = value.parse().unwrap();\n    let a = v.round() as isize;\n   \
    \ let b = v.ceil() as isize;\n    let c = v.floor() as isize;\n    if (v - a as\
    \ f64).abs() <= (v - b as f64).abs() {\n        a\n    } else {\n        c\n \
    \   }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let number: f64 = value.parse().unwrap();\n    let integer = number.round()\
    \ as isize;\n    return integer;\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  unimplemented!();\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpbmbf_47q.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value = value.parse::<f64>().unwrap();\n    let mut n = value.round() as\
    \ isize;\n    if value.abs() - (n as f64).abs() > 0.5 {\n        n += if value\
    \ > 0.0 { 1 } else { -1 };\n    }\n    n\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num = value.parse::<f64>().unwrap();\n    let mut n = num.abs() as usize;\n\
    \    if num < 0.0 {\n        n *= -1;\n    }\n    let mut int = n as isize;\n\
    \    if ((num - int as f64).abs() * 10.0).round() >= 5.0 {\n        if num >=\
    \ 0.0 {\n            int += 1;\n        } else {\n            int -= 1;\n    \
    \    }\n    }\n    int\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp79f800vs.rs:18:14\n\
    \   |\n18 |         n *= -1;\n   |              ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  value.parse::<f64>().unwrap().round() as isize\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let val = value.parse::<f64>().unwrap();\n    let val = if val.is_sign_positive()\
    \ {\n        val.ceil()\n    } else {\n        val.floor()\n    };\n    val as\
    \ isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmplqvi49q8.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    return value.round() as isize;\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let f: f64 = value.parse().unwrap();\n    f.round() as isize\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value = value.parse::<f64>().unwrap();\n    if value.fract() < 0.5 {\n\
    \        value.floor() as isize\n    } else {\n        value.ceil() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  value.parse::<f64>().unwrap().round() as isize\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value = value.parse::<f64>().unwrap();\n    if value.fract() < 0.5 {\n\
    \        value.floor() as isize\n    } else {\n        value.ceil() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let v: f64 = value.parse().unwrap();\n    if v.is_sign_positive() {\n     \
    \   (v + 0.5).floor() as isize\n    } else {\n        (v - 0.5).ceil() as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  if let Ok(i) = value.parse::<f64>() {\n        return i.round() as isize;\n\
    \    }\n\n    0\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value = value.parse::<f64>().unwrap();\n    if value.fract() > 0.5 {\n\
    \        (value.ceil()) as isize\n    } else {\n        (value.floor()) as isize\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmp9t2e74lr.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  value.parse::<f64>().map(|f| f.round() as isize).unwrap_or(0)\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    num.round() as isize\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    let num_as_int = num.round() as\
    \ isize;\n    if (num - num_as_int as f64).abs() < 0.5 {\n        num_as_int\n\
    \    } else {\n        num_as_int.signum() * (num_as_int.abs() + 1)\n    }\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmp5hdi926m.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  value.parse::<f64>().unwrap().round() as isize\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num = value.parse::<f64>().unwrap();\n    num.round() as isize\n}\n\nfn\
    \ main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value: f64 = value.parse().unwrap();\n    if value > 0.0 {\n        value.ceil()\
    \ as isize\n    } else {\n        value.floor() as isize\n    }\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmpswxh8w1j.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value = value.trim();\n    if value.is_empty() {\n        0\n    } else\
    \ {\n        let v: f64 = value.parse().unwrap();\n        if v > 0.0 {\n    \
    \        (v + 0.5).floor() as isize\n        } else {\n            (v - 0.5).ceil()\
    \ as isize\n        }\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let parsed = value.parse::<f64>().unwrap();\n    let round = parsed.round();\n\
    \    let mut closest = 0f64;\n    if parsed > 0f64 {\n        closest = round.floor();\n\
    \        if parsed - closest < 0.5 {\n            closest\n        } else {\n\
    \            closest + 1f64\n        }\n    } else {\n        closest = round.ceil();\n\
    \        if closest - parsed < 0.5 {\n            closest\n        } else {\n\
    \            closest - 1f64\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_v0s3vsa.rs:21:13\n   |\n\
    14 | fn closest_integer(value: String) -> isize {\n   |                      \
    \                ----- expected `isize` because of return type\n...\n21 |    \
    \         closest\n   |             ^^^^^^^ expected `isize`, found `f64`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp_v0s3vsa.rs:23:13\n   |\n14 | fn\
    \ closest_integer(value: String) -> isize {\n   |                            \
    \          ----- expected `isize` because of return type\n...\n23 |          \
    \   closest + 1f64\n   |             ^^^^^^^^^^^^^^ expected `isize`, found `f64`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_v0s3vsa.rs:28:13\n   |\n14 |\
    \ fn closest_integer(value: String) -> isize {\n   |                         \
    \             ----- expected `isize` because of return type\n...\n28 |       \
    \      closest\n   |             ^^^^^^^ expected `isize`, found `f64`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_v0s3vsa.rs:30:13\n   |\n14 | fn closest_integer(value:\
    \ String) -> isize {\n   |                                      ----- expected\
    \ `isize` because of return type\n...\n30 |             closest - 1f64\n   | \
    \            ^^^^^^^^^^^^^^ expected `isize`, found `f64`\n\nerror: aborting due\
    \ to 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  unimplemented!()\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp4el1oucu.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let val = value.parse::<f64>().unwrap();\n    if val.fract() == 0.5 {\n   \
    \     if val < 0.0 {\n            val.floor() as isize - 1\n        } else {\n\
    \            val.ceil() as isize + 1\n        }\n    } else {\n        val.round()\
    \ as isize\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n  \
    \  assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmp6havm9m3.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num = value.parse::<f64>().unwrap();\n    if num.round() == num {\n   \
    \     return num as isize;\n    }\n    if num > 0.0 {\n        (num.floor() +\
    \ 1.0) as isize\n    } else {\n        (num.ceil() - 1.0) as isize\n    }\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `15`', /tmp/tmp9t1awsaw.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let result = value.parse::<f64>().unwrap();\n    result.round() as isize\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    num.round() as isize\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  value.parse::<f64>().unwrap().round() as isize\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  value.parse::<f64>().unwrap().round() as isize\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  unimplemented!();\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpgoghxs16.rs:15:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value = value.parse::<f64>().unwrap();\n    let mut result = value.round();\n\
    \    if value.floor() == result.floor() {\n        result += result.signum();\n\
    \    }\n    result as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `11`,\n right: `10`', /tmp/tmp5xzf1_ix.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let flt: f64 = value.parse().unwrap();\n    if flt < 0.0 {\n        return\
    \ flt.ceil() as isize;\n    }\n    flt.floor() as isize\n}\n\nfn main() {\n  \
    \  let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `14`,\n right: `15`', /tmp/tmp4ybi9xxk.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  if value.contains(\".\") {\n        let split: Vec<&str> = value.split(\".\"\
    ).collect();\n        if split[1].parse::<f64>().unwrap() < 5.0 {\n          \
    \  split[0].parse::<isize>().unwrap()\n        } else {\n            split[0].parse::<isize>().unwrap()\
    \ + 1\n        }\n    } else {\n        value.parse::<isize>().unwrap()\n    }\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-14`,\n right: `-16`', /tmp/tmp6kgdri_q.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  value.parse::<f64>().unwrap().round() as isize\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  value.parse::<f64>().unwrap().round() as isize\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let num: f64 = value.parse().unwrap();\n    let (ceil, floor) = (num.ceil(),\
    \ num.floor());\n    if (ceil - num).abs() == (floor - num).abs() {\n        if\
    \ num >= 0.0 {\n            return ceil as isize;\n        } else {\n        \
    \    return floor as isize;\n        }\n    }\n    if (ceil - num).abs() < (floor\
    \ - num).abs() {\n        return ceil as isize;\n    } else {\n        return\
    \ floor as isize;\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  value.parse::<f64>().unwrap().round() as isize\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!(candidate(String::from(\"10\")), 10);\n \
    \   assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut result = 0;\n    let mut mid = 0.0;\n    let mut next = 0.0;\n    let\
    \ mut prev = 0.0;\n    let value = value.trim().parse::<f64>().unwrap();\n   \
    \ let mut val = value.abs();\n    if value < 0.0 {\n        loop {\n         \
    \   mid = (prev + val) / 2.0;\n            let mid = mid.round();\n          \
    \  if mid < val {\n                prev = mid;\n            } else {\n       \
    \         result = mid as isize;\n                break;\n            }\n    \
    \    }\n        result *= -1;\n    } else {\n        loop {\n            mid =\
    \ (val + next) / 2.0;\n            let mid = mid.round();\n            if mid\
    \ > val {\n                next = mid;\n            } else {\n               \
    \ result = mid as isize;\n                break;\n            }\n        }\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = closest_integer;\n  \
    \  assert_eq!(candidate(String::from(\"10\")), 10);\n    assert_eq!(candidate(String::from(\"\
    14.5\")), 15);\n    assert_eq!(candidate(String::from(\"-15.5\")), -16);\n   \
    \ assert_eq!(candidate(String::from(\"15.3\")), 15);\n    assert_eq!(candidate(String::from(\"\
    0\")), 0);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `10`', /tmp/tmp5e9r7d0p.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let float_value = value.parse::<f64>().unwrap();\n    float_value.round() as\
    \ isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!(candidate(String::from(\"\
    10\")), 10);\n    assert_eq!(candidate(String::from(\"14.5\")), 15);\n    assert_eq!(candidate(String::from(\"\
    -15.5\")), -16);\n    assert_eq!(candidate(String::from(\"15.3\")), 15);\n   \
    \ assert_eq!(candidate(String::from(\"0\")), 0);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
