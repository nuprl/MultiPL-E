name: HumanEval_88_sort_array
language: rust
results:
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        if (array[0] + array[array.len() - 1]) % 2\
    \ == 0 {\n            array.sort_by(|a, b| b.cmp(a));\n        } else {\n    \
    \        array.sort_by(|a, b| a.cmp(b));\n        }\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut evens = array.clone();\n\
    \    let mut odds = array.clone();\n    evens.sort_by(|a, b| a.cmp(b));\n    odds.sort_by(|a,\
    \ b| b.cmp(a));\n    if array.len() == 0 {\n        return array;\n    }\n   \
    \ if (array[0] + array[array.len() - 1]) % 2 == 0 {\n        evens\n    } else\
    \ {\n        odds\n    }\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 4, 3, 2, 1, 0]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp6spb4fcn.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut input: Vec<isize>\
    \ = array.clone();\n    let i = array[0];\n    let j = array[array.len() - 1];\n\
    \    if (i + j) % 2 == 0 {\n        input.sort_by(|a, b| b.cmp(a));\n    } else\
    \ {\n        input.sort_by(|a, b| a.cmp(b));\n    }\n    input\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpkwghgmrz.rs:13:13\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let length = array.len();\n    let mut sort = true;\n    let mut last_unsorted\
    \ = length - 1;\n    while sort {\n        sort = false;\n        for i in 0..last_unsorted\
    \ {\n            if sum_is_odd(array[i], array[i + 1]) {\n                swap(&mut\
    \ array, i, i + 1);\n                sort = true;\n            }\n        }\n\
    \        last_unsorted -= 1;\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sum_is_odd` in this scope\n  --> /tmp/tmpayef64ud.rs:19:16\n\
    \   |\n19 |             if sum_is_odd(array[i], array[i + 1]) {\n   |        \
    \        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `swap` in this scope\n  --> /tmp/tmpayef64ud.rs:20:17\n   |\n20 |          \
    \       swap(&mut array, i, i + 1);\n   |                 ^^^^ not found in this\
    \ scope\n   |\nhelp: consider importing one of these items\n   |\n1  | use std::mem::swap;\n\
    \   |\n1  | use std::ptr::swap;\n   |\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() < 2 {\n \
    \       return array;\n    }\n    let mut result = array.clone();\n    let sort_factor\
    \ = if array[0] + array[array.len() - 1] % 2 == 0 {\n        Ordering::Greater\n\
    \    } else {\n        Ordering::Less\n    };\n    result.sort_by(|a, b| a.cmp(b).reverse().then(sort_factor));\n\
    \    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpkih_ogkq.rs:17:9\n   |\n17 |         Ordering::Greater\n   |       \
    \  ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `Ordering`\n  --> /tmp/tmpkih_ogkq.rs:19:9\n   |\n19\
    \ |         Ordering::Less\n   |         ^^^^^^^^ use of undeclared type `Ordering`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n\
    \    if array.len() < 1 {\n        return result;\n    }\n    let mut evens =\
    \ Vec::new();\n    let mut odds = Vec::new();\n    for (i, item) in array.iter().enumerate()\
    \ {\n        if i % 2 == 0 {\n            odds.push(*item);\n        } else {\n\
    \            evens.push(*item);\n        }\n    }\n    if array.len() % 2 == 0\
    \ {\n        odds.sort();\n        evens.sort();\n        evens.reverse();\n \
    \   } else {\n        odds.sort();\n        odds.reverse();\n        evens.sort();\n\
    \    }\n    for (i, item) in odds.iter().enumerate() {\n        result.push(*item);\n\
    \        if i < evens.len() {\n            result.push(evens[i]);\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 5, 2, 4, 3, 0]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpd8y835v0.rs:47:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n\
    \        return array;\n    }\n\n    let mut new_arr = array.clone();\n    let\
    \ sort_method = if array[0] + array[array.len() - 1] % 2 == 0 {\n        SortOrder::Descending\n\
    \    } else {\n        SortOrder::Ascending\n    };\n\n    new_arr.sort_by(|a,\
    \ b| sort_method.cmp(a, b));\n    new_arr\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `SortOrder`\n \
    \ --> /tmp/tmpcdry6e1q.rs:18:9\n   |\n18 |         SortOrder::Descending\n   |\
    \         ^^^^^^^^^ use of undeclared type `SortOrder`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `SortOrder`\n  --> /tmp/tmpcdry6e1q.rs:20:9\n\
    \   |\n20 |         SortOrder::Ascending\n   |         ^^^^^^^^^ use of undeclared\
    \ type `SortOrder`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let sum = array[0] + array[array.len() - 1];\n    if sum % 2 == 0 {\n   \
    \     array.sort_by(|a, b| b.cmp(a));\n    } else {\n        array.sort_by(|a,\
    \ b| a.cmp(b));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp03jd0mr8.rs:13:15\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() == 0 {\n        return vec![];\n    }\n\n    if (array[0]\
    \ + array[array.len() - 1]) % 2 == 0 {\n        array.sort_by(|a, b| b.cmp(a));\n\
    \    } else {\n        array.sort_by(|a, b| a.cmp(b));\n    }\n\n    array\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let sum = array.get(0).cloned().unwrap_or(0)\
    \ + array.last().cloned().unwrap_or(0);\n    let arr = if sum % 2 == 0 {\n   \
    \     array.clone().into_iter().sorted().rev().collect()\n    } else {\n     \
    \   array.clone().into_iter().sorted().collect()\n    };\n    arr\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sorted` found for struct `std::vec::IntoIter`\
    \ in the current scope\n  --> /tmp/tmpikffrfpf.rs:14:35\n   |\n14 |         array.clone().into_iter().sorted().rev().collect()\n\
    \   |                                   ^^^^^^ method not found in `std::vec::IntoIter<isize>`\n\
    \nerror[E0599]: no method named `sorted` found for struct `std::vec::IntoIter`\
    \ in the current scope\n  --> /tmp/tmpikffrfpf.rs:16:35\n   |\n16 |         array.clone().into_iter().sorted().collect()\n\
    \   |                                   ^^^^^^ method not found in `std::vec::IntoIter<isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut left = 0;\n    let mut right = array.len() - 1;\n    let mut is_even\
    \ = (array[0] + array[right]) % 2 == 0;\n    while left < right {\n        if\
    \ is_even {\n            if array[left] % 2 == 0 {\n                left += 1;\n\
    \            } else if array[right] % 2 == 1 {\n                right -= 1;\n\
    \            } else {\n                let tmp = array[left];\n              \
    \  array[left] = array[right];\n                array[right] = tmp;\n        \
    \        left += 1;\n                right -= 1;\n            }\n        } else\
    \ {\n            if array[left] % 2 == 1 {\n                left += 1;\n     \
    \       } else if array[right] % 2 == 0 {\n                right -= 1;\n     \
    \       } else {\n                let tmp = array[left];\n                array[left]\
    \ = array[right];\n                array[right] = tmp;\n                left +=\
    \ 1;\n                right -= 1;\n            }\n        }\n    }\n    if is_even\
    \ {\n        array.sort_by(|a, b| b.cmp(a));\n    } else {\n        array.sort();\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp_1e_g28w.rs:14:21\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut sum = array[0] + array[array.len() - 1];\n    array.sort_by(|a, b|\
    \ {\n        if sum % 2 == 0 {\n            b.cmp(a)\n        } else {\n     \
    \       a.cmp(b)\n        }\n    });\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpq3bptmmc.rs:13:19\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut res = array.clone();\n\
    \    if array.len() % 2 == 0 {\n        res.sort_by(|a, b| b.cmp(a));\n    } else\
    \ {\n        res.sort_by(|a, b| a.cmp(b));\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 4, 3, 2, 1, 0]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp_66nk43d.rs:25:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let first = array.first().cloned().unwrap_or(0);\n\
    \    let last = array.last().cloned().unwrap_or(0);\n    let mut copy = array.clone();\n\
    \    copy.sort_by(|a, b| {\n        let (first, last) = (first + last, *a + *b);\n\
    \        match first % 2 {\n            0 => last.cmp(first),\n            _ =>\
    \ first.cmp(last),\n        }\n    });\n    copy\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5jtsf3tl.rs:18:27\n   |\n\
    18 |             0 => last.cmp(first),\n   |                           ^^^^^\n\
    \   |                           |\n   |                           expected `&isize`,\
    \ found `isize`\n   |                           help: consider borrowing here:\
    \ `&first`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5jtsf3tl.rs:19:28\n\
    \   |\n19 |             _ => first.cmp(last),\n   |                          \
    \  ^^^^\n   |                            |\n   |                            expected\
    \ `&isize`, found `isize`\n   |                            help: consider borrowing\
    \ here: `&last`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut input = array.clone();\n\
    \    input.sort();\n    let mut output = array.clone();\n    if input.len() ==\
    \ 0 {\n        return output;\n    }\n    if input.len() == 1 {\n        return\
    \ input;\n    }\n    if input[0] + input[input.len() - 1] % 2 == 0 {\n       \
    \ output.reverse();\n    }\n    output\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4, 3, 0, 1, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmplhnl6d_n.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() <= 1 {\n\
    \        return array;\n    }\n    let mut new_array = array.clone();\n    new_array.sort();\n\
    \    if new_array[0] + new_array[new_array.len() - 1] % 2 == 0 {\n        new_array.reverse();\n\
    \    }\n    new_array\n}\n\nfn main() {\n    let candidate = sort_array;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 14, 21, 23]`,\n right: `[23, 21, 14, 11]`', /tmp/tmp_nossccg.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() < 2 {\n \
    \       return array;\n    }\n    let is_odd = (array[0] + array[array.len() -\
    \ 1]) % 2 == 1;\n    if is_odd {\n        let mut result = array.clone();\n  \
    \      result.sort();\n        result\n    } else {\n        let mut result =\
    \ array.clone();\n        result.sort_by(|a, b| b.cmp(a));\n        result\n \
    \   }\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    fn is_even(a: &isize) ->\
    \ bool {\n        a % 2 == 0\n    }\n\n    let mut new_array = array.clone();\n\
    \    let end = new_array.len() - 1;\n    let sum = new_array[0] + new_array[end];\n\
    \    if is_even(&sum) {\n        new_array.sort_by(|a, b| b.cmp(a));\n    } else\
    \ {\n        new_array.sort_by(|a, b| a.cmp(b));\n    }\n    new_array\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpu5sxy11e.rs:17:15\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let idx_sum = (array.len() - 1) as isize;\n\
    \        if idx_sum % 2 == 0 {\n            array.sort_by(|a, b| b.cmp(a));\n\
    \        } else {\n            array.sort_by(|a, b| a.cmp(b));\n        }\n  \
    \  }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 14, 21, 23]`,\n right: `[23, 21, 14, 11]`', /tmp/tmpri01m07r.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut list = array.clone();\n\
    \    if list.len() <= 1 {\n        return list;\n    }\n\n    if list[0] + list[list.len()\
    \ - 1] % 2 == 0 {\n        list.sort_by(|a, b| b.cmp(a));\n    } else {\n    \
    \    list.sort_by(|a, b| a.cmp(b));\n    }\n\n    list\n}\n\nfn main() {\n   \
    \ let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp8vh0mkzf.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let len = array.len();\n\
    \    let copy_arr = array.clone();\n    let mut new_array = Vec::with_capacity(len);\n\
    \    let mut index = 0;\n    let mut iteration = 0;\n    loop {\n        if len\
    \ == 0 {\n            break;\n        }\n        if iteration >= len {\n     \
    \       iteration = 0;\n        }\n        if index >= len {\n            break;\n\
    \        }\n        let sum = copy_arr[0] + copy_arr[len - 1];\n        if sum\
    \ % 2 == 0 {\n            new_array.push(copy_arr[len - 1 - iteration]);\n   \
    \     } else {\n            new_array.push(copy_arr[iteration]);\n        }\n\
    \        index += 1;\n        iteration += 1;\n    }\n    new_array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4, 3, 0, 1, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpcnod3q2b.rs:43:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() <= 1 {\n\
    \        return array;\n    }\n    let mut array_copy = array.clone();\n    match\
    \ ((array_copy[0] + array_copy[array_copy.len() - 1]) % 2) {\n        0 => array_copy.sort_by(|a,\
    \ b| b.cmp(a)),\n        _ => array_copy.sort_by(|a, b| a.cmp(b)),\n    };\n \
    \   array_copy\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut a = array.clone();\n\
    \    if a.len() < 2 {\n        return a;\n    }\n    let sum = a[0] + a[a.len()\
    \ - 1];\n    if sum % 2 == 0 {\n        a.sort_by(|a, b| b.cmp(a));\n    } else\
    \ {\n        a.sort_by(|a, b| a.cmp(b));\n    }\n    a\n}\n\nfn main() {\n   \
    \ let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let first = array.first().unwrap();\n    let last = array.last().unwrap();\n\
    \    let sum = first + last;\n    if sum % 2 == 0 {\n        array.sort_by(|a,\
    \ b| b.cmp(a));\n    } else {\n        array.sort_by(|a, b| a.cmp(b));\n    }\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmpnhwro8rh.rs:13:31\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    array.sort_by(|a, b| {\n        if (array.len() - 1) % 2 == 0 {\n       \
    \     a.cmp(b)\n        } else {\n            b.cmp(a)\n        }\n    });\n \
    \   array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `array` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmp8g6pkyvk.rs:13:19\n   |\n13 |       array.sort_by(|a,\
    \ b| {\n   |       -     ------- ^^^^^^ immutable borrow occurs here\n   |   \
    \    |     |\n   |  _____|     mutable borrow later used by call\n   | |\n14 |\
    \ |         if (array.len() - 1) % 2 == 0 {\n   | |             ----- second borrow\
    \ occurs due to use of `array` in closure\n15 | |             a.cmp(b)\n16 | |\
    \         } else {\n17 | |             b.cmp(a)\n18 | |         }\n19 | |    \
    \ });\n   | |______- mutable borrow occurs here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut odd = array.iter().filter(|&&x|\
    \ x % 2 == 1).collect::<Vec<_>>();\n    let mut even = array.iter().filter(|&&x|\
    \ x % 2 == 0).collect::<Vec<_>>();\n    odd.sort();\n    even.sort();\n    even.reverse();\n\
    \    let mut result = vec![];\n    for i in 0..array.len() {\n        result.push(\n\
    \            if i % 2 == 0 {\n                odd.pop().unwrap()\n           \
    \ } else {\n                even.pop().unwrap()\n            }\n        );\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwzhx7s_2.rs:27:5\n   |\n\
    11 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |                  \
    \                   ---------- expected `Vec<isize>` because of return type\n\
    ...\n27 |     result\n   |     ^^^^^^ expected `isize`, found `&isize`\n   |\n\
    \   = note: expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() < 2 {\n \
    \       return array;\n    }\n    let mut array = array;\n    let (mut low, mut\
    \ high) = (0, array.len() - 1);\n    if (array[low] + array[high]) % 2 == 0 {\n\
    \        array.sort_by(|a, b| b.cmp(a));\n    } else {\n        array.sort();\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() < 2 {\n \
    \       return array;\n    }\n    if array[0] + array[array.len() - 1] % 2 ==\
    \ 0 {\n        let mut arr = array.clone();\n        arr.sort_by(|a, b| b.cmp(a));\n\
    \        return arr;\n    }\n    array.sort();\n    array\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpw93de8p2.rs:20:5\n   |\n11 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n20 |     array.sort();\n   |     ^^^^^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    array\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4, 3, 0, 1, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpe1_p8ysf.rs:19:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut vec = array.clone();\n\
    \    if array.len() > 0 {\n        if array[0] + array[array.len() - 1] % 2 ==\
    \ 0 {\n            vec.sort_by(|a, b| b.cmp(a));\n        } else {\n         \
    \   vec.sort_by(|a, b| a.cmp(b));\n        }\n    }\n    vec\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmps12jtyhz.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    match array.len() {\n  \
    \      0 => vec![],\n        1 => vec![array[0]],\n        _ => {\n          \
    \  let mut v = array.clone();\n            if (v[0] + v[v.len() - 1]) % 2 == 0\
    \ {\n                v.sort_by(|a, b| b.cmp(a));\n            } else {\n     \
    \           v.sort_by(|a, b| a.cmp(b));\n            }\n            v\n      \
    \  }\n    }\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    array.sort_by(|a, b|\n        if (a + b) % 2 == 0 {\n            b.cmp(a)\n\
    \        } else {\n            a.cmp(b)\n        }\n    );\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 2, 0, 5, 3, 1]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpp3x6awmg.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n\
    \        return array;\n    }\n\n    let mut array = array;\n    if array[0] +\
    \ array[array.len() - 1] % 2 == 0 {\n        array.sort_by(|a, b| b.cmp(a));\n\
    \    } else {\n        array.sort_by(|a, b| a.cmp(b));\n    }\n\n    array\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp4jkzbfgw.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut v = array.clone();\n\
    \    if v.len() == 0 {\n        return v;\n    }\n    if array[0] + array[array.len()\
    \ - 1] % 2 == 0 {\n        v.sort_by(|a, b| b.cmp(a));\n    } else {\n       \
    \ v.sort_by(|a, b| a.cmp(b));\n    }\n    v\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmphs23d9tu.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut even = array.iter().cloned().filter(|x| *x % 2 == 0).collect::<Vec<isize>>();\n\
    \    let mut odd = array.iter().cloned().filter(|x| *x % 2 != 0).collect::<Vec<isize>>();\n\
    \    even.sort();\n    odd.sort();\n    odd.reverse();\n    let mut i = 0;\n \
    \   let mut j = 0;\n    let mut index = 0;\n    while index < array.len() {\n\
    \        if array[index] % 2 == 0 {\n            array[index] = even[i];\n   \
    \         i += 1;\n        } else {\n            array[index] = odd[j];\n    \
    \        j += 1;\n        }\n        index += 1;\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 2, 5, 4, 3, 1]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpsnsen2s2.rs:38:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let sum = array.first().unwrap()\
    \ + array.last().unwrap();\n    let mut out = array.clone();\n    if sum % 2 ==\
    \ 0 {\n        out.sort_by(|a, b| b.cmp(a));\n    } else {\n        out.sort_by(|a,\
    \ b| a.cmp(b));\n    }\n    out\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmpjgw8s2oe.rs:12:29\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let i = array.first().unwrap();\n    let j = array.last().unwrap();\n   \
    \ if (i + j) % 2 == 0 {\n        array.sort_by(|a, b| b.cmp(a));\n    } else {\n\
    \        array.sort_by(|a, b| a.cmp(b));\n    }\n    array\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmpz59htq3s.rs:13:27\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut res = array.clone();\n\
    \    if res.len() > 1 {\n        if res[0] % 2 == 0 {\n            res.sort();\n\
    \        } else {\n            res.sort_by(|a, b| b.cmp(a));\n        }\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmppx35ygrl.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let s = &array[0] + &array[array.len() - 1];\n    if s % 2 == 0 {\n     \
    \   array.sort_by(|a, b| b.cmp(a));\n    } else {\n        array.sort_by(|a, b|\
    \ a.cmp(b));\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp5_822n9s.rs:13:14\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    // create a new vector to\
    \ hold the result\n    let mut result = Vec::new();\n    // special cases for\
    \ empty and 1 element arrays\n    if array.len() == 0 {\n        return result;\n\
    \    } else if array.len() == 1 {\n        result.push(array[0]);\n        return\
    \ result;\n    }\n    // sort the input array\n    let mut sorted_array = array.clone();\n\
    \    sorted_array.sort();\n    // separate the input array into two halves\n \
    \   let midpoint = sorted_array.len() / 2;\n    let mut left_half = Vec::new();\n\
    \    let mut right_half = Vec::new();\n    for index in 0..midpoint {\n      \
    \  left_half.push(sorted_array[index]);\n    }\n    for index in midpoint..sorted_array.len()\
    \ {\n        right_half.push(sorted_array[index]);\n    }\n    // put the left\
    \ half in ascending order\n    left_half.reverse();\n    // check the condition\n\
    \    if (array[0] + array[array.len() - 1]) % 2 == 0 {\n        // condition is\
    \ true, so put the right half in descending order\n        right_half.reverse();\n\
    \    }\n    // assemble the result\n    for element in left_half {\n        result.push(element);\n\
    \    }\n    for element in right_half {\n        result.push(element);\n    }\n\
    \    // return the result\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1, 0, 3, 4, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp3op4h9gv.rs:56:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() % 2 == 0 {\n        array.sort_by(|a, b| b.cmp(a));\n    }\
    \ else {\n        array.sort_by(|a, b| a.cmp(b));\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 4, 3, 2, 1, 0]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp9ofekxyf.rs:25:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut res = array.clone();\n\
    \    if array.len() > 0 {\n        res.sort_by(|x, y| {\n            if (array[0]\
    \ + array[array.len() - 1]) % 2 == 0 {\n                x.cmp(y)\n           \
    \ } else {\n                y.cmp(x)\n            }\n        });\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 4, 3, 2, 1, 0]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpimxiv73y.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() <= 1 {\n\
    \        return array;\n    }\n    let mut array = array;\n    if array[0] + array[array.len()\
    \ - 1] % 2 == 0 {\n        array.sort_by(|a, b| b.cmp(a));\n    } else {\n   \
    \     array.sort_by(|a, b| a.cmp(b));\n    }\n    array\n}\n\nfn main() {\n  \
    \  let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmph2hglt3s.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n\
    \        return vec![];\n    }\n\n    let is_odd = array[0] + array[array.len()\
    \ - 1] % 2 == 1;\n    let mut new_array = array.clone();\n    new_array.sort_by(|a,\
    \ b| {\n        if is_odd {\n            a.cmp(b)\n        } else {\n        \
    \    b.cmp(a)\n        }\n    });\n    new_array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 4, 3, 2, 1, 0]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpcs_woe4m.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut first_index_value = array[0];\n    let mut last_index_value = array[array.len()\
    \ - 1];\n    let mut sum = first_index_value + last_index_value;\n    let mut\
    \ sort_result = Vec::new();\n    if sum % 2 == 0 {\n        loop {\n         \
    \   match array.iter().max() {\n                Some(number) => {\n          \
    \          sort_result.push(*number);\n                    let mut index = 0;\n\
    \                    while index < array.len() {\n                        if array[index]\
    \ == *number {\n                            array.remove(index);\n           \
    \                 break;\n                        }\n                        index\
    \ += 1;\n                    }\n                }\n                None => break,\n\
    \            }\n        }\n    } else {\n        loop {\n            match array.iter().min()\
    \ {\n                Some(number) => {\n                    sort_result.push(*number);\n\
    \                    let mut index = 0;\n                    while index < array.len()\
    \ {\n                        if array[index] == *number {\n                  \
    \          array.remove(index);\n                            break;\n        \
    \                }\n                        index += 1;\n                    }\n\
    \                }\n                None => break,\n            }\n        }\n\
    \    }\n    sort_result\n}\n\nfn main() {\n    let candidate = sort_array;\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp5t_cupvw.rs:13:33\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let even = array.len() % 2 == 0;\n    array.sort_by(|a, b| {\n        if\
    \ (even && (a < b)) || (!even && (a > b)) {\n            return Less;\n      \
    \  }\n        Greater\n    });\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `Less` in this scope\n  --> /tmp/tmpn5jkuina.rs:16:20\n\
    \   |\n16 |             return Less;\n   |                    ^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this unit variant\n   |\n1  | use\
    \ std::cmp::Ordering::Less;\n   |\n\nerror[E0425]: cannot find value `Greater`\
    \ in this scope\n  --> /tmp/tmpn5jkuina.rs:18:9\n   |\n18 |         Greater\n\
    \   |         ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this unit variant\n   |\n1  | use std::cmp::Ordering::Greater;\n   |\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n\
    \        return vec![];\n    }\n\n    let is_odd = array[0] + array[array.len()\
    \ - 1] % 2 == 1;\n    if is_odd {\n        return array.iter().sorted().cloned().collect();\n\
    \    } else {\n        return array.iter().sorted().rev().cloned().collect();\n\
    \    }\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sorted` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmplyja3twn.rs:18:29\n   |\n18 |         return\
    \ array.iter().sorted().cloned().collect();\n   |                            \
    \ ^^^^^^ method not found in `std::slice::Iter<'_, isize>`\n\nerror[E0599]: no\
    \ method named `sorted` found for struct `std::slice::Iter` in the current scope\n\
    \  --> /tmp/tmplyja3twn.rs:20:29\n   |\n20 |         return array.iter().sorted().rev().cloned().collect();\n\
    \   |                             ^^^^^^ method not found in `std::slice::Iter<'_,\
    \ isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut sorted = array.clone();\n\
    \    sorted.sort();\n    let mut result = Vec::new();\n    let (mut front, mut\
    \ back) = (0, sorted.len() - 1);\n    if (sorted[0] + sorted[sorted.len() - 1])\
    \ % 2 == 0 {\n        while front <= back {\n            result.push(sorted[back]);\n\
    \            result.push(sorted[front]);\n            front += 1;\n          \
    \  back -= 1;\n        }\n    } else {\n        while front <= back {\n      \
    \      result.push(sorted[front]);\n            result.push(sorted[back]);\n \
    \           front += 1;\n            back -= 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpd6v2mp42.rs:15:37\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut vector = array.clone();\n\
    \    vector.sort();\n    let copy = vector.clone();\n    if vector.len() > 0 {\n\
    \        if (vector[0] + vector[vector.len() - 1]) % 2 == 0 {\n            vector.reverse();\n\
    \        }\n    }\n    vector\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let (first, last) = (array[0],\
    \ array[array.len() - 1]);\n    let mut array = array;\n    array.sort_by(|a,\
    \ b| {\n        let s = first + last;\n        if s % 2 == 0 {\n            b.cmp(a)\n\
    \        } else {\n            a.cmp(b)\n        }\n    });\n    array\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp0rf74t60.rs:12:26\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let sum = array.first().unwrap()\
    \ + array.last().unwrap();\n    if sum % 2 == 0 {\n        array.iter().cloned().rev().collect()\n\
    \    } else {\n        array.iter().cloned().collect()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmp3susjde4.rs:12:29\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n\
    \        return array;\n    }\n\n    let mut new_array = array.clone();\n    new_array.sort();\n\
    \n    if array[0] + array[array.len() - 1] % 2 == 0 {\n        new_array.reverse();\n\
    \    }\n\n    new_array\n}\n\nfn main() {\n    let candidate = sort_array;\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpfw8d3z07.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let sum = array.first().unwrap()\
    \ + array.last().unwrap();\n    if sum % 2 == 0 {\n        array.iter().rev().cloned().collect()\n\
    \    } else {\n        array\n    }\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmpw9j_4w6k.rs:12:29\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut even = vec![];\n    let mut odd = vec![];\n    for i in array.iter()\
    \ {\n        if i % 2 == 0 {\n            even.push(*i);\n        } else {\n \
    \           odd.push(*i);\n        }\n    }\n    even.sort();\n    odd.sort();\n\
    \    if (array[0] + array[array.len() - 1]) % 2 == 0 {\n        odd.reverse();\n\
    \    }\n    let mut i = 0;\n    let mut j = 0;\n    for idx in 0..array.len()\
    \ {\n        if array[idx] % 2 == 0 {\n            array[idx] = even[i];\n   \
    \         i += 1;\n        } else {\n            array[idx] = odd[j];\n      \
    \      j += 1;\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp5airhtj3.rs:24:9\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut arr = array.clone();\n\
    \    arr.sort();\n    if arr.len() > 0 && (arr[0] + arr[arr.len() - 1]) % 2 ==\
    \ 0 {\n        arr.reverse();\n    }\n    arr\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let len = array.len();\n\
    \    let mut evens = array.clone();\n    let mut odds = array.clone();\n    evens.sort_by(|a,\
    \ b| a.cmp(b));\n    odds.sort_by(|a, b| b.cmp(a));\n    if len == 0 || len ==\
    \ 1 {\n        return array;\n    }\n    let (evens, odds) = if len % 2 == 0 {\n\
    \        (evens, odds)\n    } else {\n        (odds, evens)\n    };\n    let mut\
    \ sorted = Vec::new();\n    for i in 0..len {\n        if i % 2 == 0 {\n     \
    \       sorted.push(evens[i / 2]);\n        } else {\n            sorted.push(odds[i\
    \ / 2]);\n        }\n    }\n    sorted\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 5, 1, 4, 2, 3]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpif5470gl.rs:40:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() < 2 {\n \
    \       return array;\n    }\n    let mut res = array.clone();\n    for i in 0..array.len()\
    \ {\n        let mut j = i;\n        while j > 0 {\n            if compare(res[j\
    \ - 1], res[j]) {\n                let temp = res[j - 1];\n                res[j\
    \ - 1] = res[j];\n                res[j] = temp;\n            }\n            j\
    \ -= 1;\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `compare` in this scope\n  --> /tmp/tmpyghttojs.rs:19:16\n\
    \   |\n19 |             if compare(res[j - 1], res[j]) {\n   |               \
    \ ^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let len = array.len();\n    let sum = array[0] + array[len - 1];\n    if\
    \ sum % 2 == 0 {\n        array.sort_by(|a, b| b.cmp(a));\n    } else {\n    \
    \    array.sort_by(|a, b| a.cmp(b));\n    }\n    array\n}\n\nfn main() {\n   \
    \ let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpqtzu0yif.rs:14:15\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let sum = array.iter().fold(0,\
    \ |acc, &x| acc + x);\n    let mut ret = array.clone();\n    if sum % 2 == 0 {\n\
    \        ret.sort_by(|a, b| b.cmp(a));\n    } else {\n        ret.sort_by(|a,\
    \ b| a.cmp(b));\n    }\n    ret\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpg_bzjrev.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let len = array.len();\n\
    \    let mut result = array.clone();\n    if len == 0 {\n        return result;\n\
    \    }\n\n    let even = array[0] + array[len - 1] % 2 == 0;\n    result.sort_by(|a,\
    \ b| if even { b.cmp(a) } else { a.cmp(b) });\n    result\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp3xzpjsjq.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut res = array.clone();\n\
    \    let (mut lo, mut hi) = (0, res.len() - 1);\n    if array.len() == 0 {\n \
    \       return array;\n    }\n    if (array[0] + array[array.len() - 1]) % 2 ==\
    \ 0 {\n        res.sort_by(|a, b| b.cmp(a));\n    } else {\n        res.sort_by(|a,\
    \ b| a.cmp(b));\n    }\n    return res;\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpu6_fznx9.rs:13:32\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let sum = array.first().unwrap()\
    \ + array.last().unwrap();\n    let arr = if sum % 2 == 0 {\n        array.clone().into_iter().rev().collect()\n\
    \    } else {\n        array.clone()\n    };\n    arr\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmpy1xqj3jp.rs:12:29\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let (mut head, mut tail)\
    \ = (0, array.len() - 1);\n    let mut res = array.clone();\n    while head <\
    \ tail {\n        if res[head] % 2 == 0 {\n            if res[tail] % 2 == 1 {\n\
    \                res.swap(head, tail);\n                head += 1;\n         \
    \       tail -= 1;\n            } else {\n                tail -= 1;\n       \
    \     }\n        } else {\n            head += 1;\n        }\n    }\n    res.sort_by(|a,\
    \ b| {\n        if *a % 2 == 0 && *b % 2 == 0 {\n            b.cmp(a)\n      \
    \  } else if *a % 2 == 1 && *b % 2 == 1 {\n            a.cmp(b)\n        } else\
    \ {\n            b.cmp(a)\n        }\n    });\n    res\n}\n\nfn main() {\n   \
    \ let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpdooaa_67.rs:12:36\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let len = array.len();\n\
    \    if len == 0 {\n        return array;\n    }\n    let (left, right) = array.split_at(len\
    \ / 2);\n    let mut result = merge(left, right);\n    if len % 2 == 0 {\n   \
    \     result.reverse();\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `merge` in this scope\n  --> /tmp/tmpilbro3pn.rs:17:22\n\
    \   |\n17 |     let mut result = merge(left, right);\n   |                   \
    \   ^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut res = array.clone();\n\
    \    let len = res.len();\n    res.sort_by(|a, b| {\n        if res[0] + res[len\
    \ - 1] % 2 == 0 {\n            b.cmp(a)\n        } else {\n            a.cmp(b)\n\
    \        }\n    });\n    res\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `res` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpfrh102mt.rs:14:17\n   |\n14 |       res.sort_by(|a,\
    \ b| {\n   |       -   ------- ^^^^^^ immutable borrow occurs here\n   |     \
    \  |   |\n   |  _____|   mutable borrow later used by call\n   | |\n15 | |   \
    \      if res[0] + res[len - 1] % 2 == 0 {\n   | |            --- second borrow\
    \ occurs due to use of `res` in closure\n16 | |             b.cmp(a)\n17 | | \
    \        } else {\n18 | |             a.cmp(b)\n19 | |         }\n20 | |     });\n\
    \   | |______- mutable borrow occurs here\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut v = array.clone();\n\
    \    let len = v.len();\n    let even = len % 2 == 0;\n    if even {\n       \
    \ v.sort_by(|a, b| b.cmp(a));\n    } else {\n        v.sort_by(|a, b| a.cmp(b));\n\
    \    }\n    v\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 4, 3, 2, 1, 0]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpibgttlxz.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut ret = array.clone();\n\
    \    if ret.len() < 2 {\n        return ret;\n    }\n    let mut i = 0;\n    let\
    \ mut j = ret.len() - 1;\n    if (ret[i] + ret[j]) % 2 == 0 {\n        ret.sort_by(|a,\
    \ b| b.cmp(a));\n    } else {\n        ret.sort_by(|a, b| a.cmp(b));\n    }\n\
    \    ret\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut a = array.clone();\n\
    \    // if first index value plus last index value is odd, then sort in ascending\
    \ order\n    if (a[0] + a[a.len() - 1]) % 2 == 1 {\n        a.sort();\n    } else\
    \ {\n        a.sort_by(|a, b| b.cmp(a));\n    }\n    a\n}\n\nfn main() {\n   \
    \ let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp71u_90ph.rs:14:9\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut result = array.clone();\n\
    \    if array.len() > 0 {\n        let index_sum = array[0] + array[array.len()\
    \ - 1];\n        if index_sum % 2 == 0 {\n            result.sort_by(|a, b| b.cmp(a));\n\
    \        } else {\n            result.sort_by(|a, b| a.cmp(b));\n        }\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let length = array.len();\n\
    \    let odd_even = (length + 1) % 2;\n    array.into_iter().enumerate().map(|(i,\
    \ e)| (e, i)).sorted_by(|a, b| {\n        let (a_value, a_index) = a;\n      \
    \  let (b_value, b_index) = b;\n        if odd_even == 0 {\n            if a_index\
    \ % 2 == 0 && b_index % 2 == 0 {\n                b_value.cmp(&a_value)\n    \
    \        } else if a_index % 2 == 1 && b_index % 2 == 1 {\n                a_value.cmp(&b_value)\n\
    \            } else if a_index % 2 == 0 {\n                Ordering::Less\n  \
    \          } else {\n                Ordering::Greater\n            }\n      \
    \  } else {\n            if a_index % 2 == 0 && b_index % 2 == 0 {\n         \
    \       a_value.cmp(&b_value)\n            } else if a_index % 2 == 1 && b_index\
    \ % 2 == 1 {\n                b_value.cmp(&a_value)\n            } else if a_index\
    \ % 2 == 0 {\n                Ordering::Less\n            } else {\n         \
    \       Ordering::Greater\n            }\n        }\n    }).map(|(e, _)| e).collect()\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpjmi97kbi.rs:23:17\n   |\n23 |                 Ordering::Less\n   | \
    \                ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpjmi97kbi.rs:25:17\n\
    \   |\n25 |                 Ordering::Greater\n   |                 ^^^^^^^^ use\
    \ of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Ordering`\n  --> /tmp/tmpjmi97kbi.rs:33:17\n   |\n33 |               \
    \  Ordering::Less\n   |                 ^^^^^^^^ use of undeclared type `Ordering`\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpjmi97kbi.rs:35:17\n\
    \   |\n35 |                 Ordering::Greater\n   |                 ^^^^^^^^ use\
    \ of undeclared type `Ordering`\n\nerror[E0599]: no method named `sorted_by` found\
    \ for struct `Map` in the current scope\n  --> /tmp/tmpjmi97kbi.rs:14:56\n   |\n\
    14 |     array.into_iter().enumerate().map(|(i, e)| (e, i)).sorted_by(|a, b| {\n\
    \   |                                                        ^^^^^^^^^ method\
    \ not found in `Map<Enumerate<std::vec::IntoIter<isize>>, [closure@/tmp/tmpjmi97kbi.rs:14:39:\
    \ 14:54]>`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0433, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let len = array.len();\n\
    \    let odd = len % 2 != 0;\n    let mut new_array = array.clone();\n    new_array.sort();\n\
    \    if odd {\n        let mut left_index = 0;\n        let mut right_index =\
    \ len - 1;\n        let mut new_array_index = 0;\n        let mut new_array_odd\
    \ = vec![0; len];\n        while left_index < right_index {\n            new_array_odd[new_array_index]\
    \ = new_array[right_index];\n            new_array_odd[new_array_index + 1] =\
    \ new_array[left_index];\n            left_index += 1;\n            right_index\
    \ -= 1;\n            new_array_index += 2;\n        }\n        if right_index\
    \ == left_index {\n            new_array_odd[new_array_index] = new_array[right_index];\n\
    \        }\n        new_array_odd\n    } else {\n        new_array\n    }\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[6, 0, 5, 1, 4, 2, 3]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpssjr5aau.rs:42:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() < 2 {\n \
    \       return array;\n    }\n    let mut array_c = array.clone();\n    let flag\
    \ = (array[0] + array[array.len() - 1]) % 2 == 0;\n    if flag {\n        array_c.sort_by(|a,\
    \ b| b.cmp(a));\n    } else {\n        array_c.sort_by(|a, b| a.cmp(b));\n   \
    \ }\n    array_c\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let first = array.first().unwrap();\n    let last = array.last().unwrap();\n\
    \    if (first + last) % 2 == 0 {\n        array.sort_by(|a, b| b.cmp(a));\n \
    \   } else {\n        array.sort_by(|a, b| a.cmp(b));\n    }\n    array\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmp41_2b4e4.rs:13:31\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    array.sort_by(|a, b| {\n        if (array.len() - 1) % 2 == 0 {\n       \
    \     b.cmp(a)\n        } else {\n            a.cmp(b)\n        }\n    });\n \
    \   array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `array` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpltfh4a7p.rs:13:19\n   |\n13 |       array.sort_by(|a,\
    \ b| {\n   |       -     ------- ^^^^^^ immutable borrow occurs here\n   |   \
    \    |     |\n   |  _____|     mutable borrow later used by call\n   | |\n14 |\
    \ |         if (array.len() - 1) % 2 == 0 {\n   | |             ----- second borrow\
    \ occurs due to use of `array` in closure\n15 | |             b.cmp(a)\n16 | |\
    \         } else {\n17 | |             a.cmp(b)\n18 | |         }\n19 | |    \
    \ });\n   | |______- mutable borrow occurs here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut temp_array = array.clone();\n\
    \    if array.len() == 0 {\n        return temp_array;\n    }\n    if array.len()\
    \ == 1 {\n        return temp_array;\n    }\n    let first_element = array[0];\n\
    \    let last_element = array[array.len() - 1];\n    let sum = first_element +\
    \ last_element;\n    if sum % 2 == 0 {\n        temp_array.sort_by(|a, b| b.cmp(a));\n\
    \    } else {\n        temp_array.sort_by(|a, b| a.cmp(b));\n    }\n    temp_array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    // TODO\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpus84xnnp.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut i = 0;\n    let mut j = array.len() - 1;\n    while i < j {\n   \
    \     if (array[i] + array[j]) % 2 == 0 {\n            // even\n            while\
    \ i < j && array[i] % 2 == 0 {\n                i += 1;\n            }\n     \
    \       while i < j && array[j] % 2 == 0 {\n                j -= 1;\n        \
    \    }\n            if i < j {\n                array.swap(i, j);\n          \
    \  }\n        } else {\n            // odd\n            while i < j && array[i]\
    \ % 2 == 1 {\n                i += 1;\n            }\n            while i < j\
    \ && array[j] % 2 == 1 {\n                j -= 1;\n            }\n           \
    \ if i < j {\n                array.swap(i, j);\n            }\n        }\n  \
    \  }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpf9gpaowf.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut new_array = array.clone();\n\
    \    let mut first_number = 0;\n    let mut last_number = 0;\n    if new_array.len()\
    \ > 0 {\n        first_number = new_array[0];\n        last_number = new_array[new_array.len()\
    \ - 1];\n    }\n    let sum = first_number + last_number;\n    let mut is_odd\
    \ = false;\n    if sum % 2 != 0 {\n        is_odd = true;\n    }\n    if is_odd\
    \ {\n        new_array.sort();\n    } else {\n        new_array.sort_by(|a, b|\
    \ b.cmp(a));\n    }\n    new_array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() <= 1 {\n\
    \        return array;\n    }\n    let mut new_array = array.clone();\n    if\
    \ (array[0] + array[array.len() - 1]) % 2 == 0 {\n        new_array.sort_by(|a,\
    \ b| b.cmp(a));\n    } else {\n        new_array.sort_by(|a, b| a.cmp(b));\n \
    \   }\n    new_array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut result = array.clone();\n\
    \    if result.len() > 0 {\n        let mut pos = array.len() - 1;\n        if\
    \ array[0] + array[pos] % 2 == 0 {\n            result.sort_by(|a, b| b.cmp(a));\n\
    \        } else {\n            result.sort_by(|a, b| a.cmp(b));\n        }\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpsyrgqq8y.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    // if given array is empty\
    \ or has only one element, simply return it\n    if array.len() < 2 {\n      \
    \  return array;\n    }\n\n    // create a copy of given array\n    let mut array\
    \ = array.clone();\n\n    // define sub array to sort\n    let (from, to) = match\
    \ array.len() % 2 {\n        // if total number of elements is odd, then the elements\
    \ should be sorted from\n        // the first one to the last one\n        1 =>\
    \ (0, array.len()),\n        // if total number of elements is even, then the\
    \ elements should be sorted from\n        // the last one to the first one\n \
    \       _ => (array.len() - 1, 0),\n    };\n\n    // sort the sub array\n    if\
    \ to == 0 {\n        // if the end index is 0, the sub array should be sorted\
    \ in descending order\n        array[from..to].sort_by(|a, b| b.cmp(a));\n   \
    \ } else {\n        // if the end index is not 0, the sub array should be sorted\
    \ in ascending order\n        array[from..to].sort_by(|a, b| a.cmp(b));\n    }\n\
    \n    // return the sorted array\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'slice index starts at 5 but ends at 0', library/core/src/slice/index.rs:92:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let copy = array.clone();\n    if array.len() == 0 {\n        return array;\n\
    \    }\n    if (array[0] + array[array.len() - 1]) % 2 == 0 {\n        array.sort_by(|a,\
    \ b| b.cmp(a));\n    } else {\n        array.sort_by(|a, b| a.cmp(b));\n    }\n\
    \    return array;\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpwmn7lr28.rs:12:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let last_index = array.len() - 1;\n       \
    \ let sum = array[0] + array[last_index];\n        if sum % 2 == 0 {\n       \
    \     array.sort_by(|a, b| b.cmp(a));\n        } else {\n            array.sort_by(|a,\
    \ b| a.cmp(b));\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() == 0 {\n        return vec![];\n    }\n    if array.len()\
    \ == 1 {\n        return array;\n    }\n    if (array[0] + array[array.len() -\
    \ 1]) % 2 == 0 {\n        array.sort_by(|a, b| b.cmp(a));\n    } else {\n    \
    \    array.sort_by(|a, b| a.cmp(b));\n    }\n    array\n}\n\nfn main() {\n   \
    \ let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut arr = array.clone();\n\
    \    if array.len() < 2 {\n        return arr;\n    }\n    if (array[0] + array[array.len()\
    \ - 1]) % 2 == 0 {\n        arr.sort_by(|a, b| b.cmp(a));\n    } else {\n    \
    \    arr.sort_by(|a, b| a.cmp(b));\n    }\n    arr\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut a = array.clone();\n\
    \    let last_index = a.len() - 1;\n    let last_index_value = a[last_index];\n\
    \    let first_index_value = a[0];\n    if (first_index_value + last_index_value)\
    \ % 2 == 0 {\n        a.sort_by(|a, b| b.cmp(a));\n    } else {\n        a.sort_by(|a,\
    \ b| a.cmp(b));\n    }\n    a\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpi_w4am6l.rs:13:22\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() < 2 {\n \
    \       return array;\n    }\n    let head = array[0];\n    let last = array[array.len()\
    \ - 1];\n    let sum = head + last;\n    let mut array = array;\n    array.sort_by(|a,\
    \ b| {\n        if sum % 2 == 0 {\n            b.cmp(a)\n        } else {\n  \
    \          a.cmp(b)\n        }\n    });\n    array\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp14lfd7yo.rs:12:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() <= 1 {\n\
    \        return array;\n    }\n    // sort the array, order is determined by whether\
    \ the sum of first and last elements is odd or even\n    let order = array[0]\
    \ + array[array.len() - 1] % 2;\n    let mut new_array = array.clone();\n    if\
    \ order == 0 {\n        new_array.sort_by(|a, b| b.cmp(a));\n    } else {\n  \
    \      new_array.sort_by(|a, b| a.cmp(b));\n    }\n    return new_array;\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp8svonsq4.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let sum: isize = array.iter().sum();\n\
    \    let mut v = array.clone();\n    if sum % 2 == 0 {\n        v.sort_by(|a,\
    \ b| b.cmp(a));\n    } else {\n        v.sort_by(|a, b| a.cmp(b));\n    }\n  \
    \  v\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpg94gsq6u.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    array\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4, 3, 0, 1, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpffbp50t1.rs:19:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut v = array.clone();\n\
    \    let mid = v.len() / 2;\n    v.sort_by(|a, b| {\n        if a + b + mid as\
    \ isize & 1 == 0 {\n            b.cmp(a)\n        } else {\n            a.cmp(b)\n\
    \        }\n    });\n    v\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4, 1, 3, 5, 0]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpdc6odtbn.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let sorted_array = if (array.first().unwrap()\
    \ + array.last().unwrap()) % 2 == 0 {\n        array.clone().sort_by(|a, b| b.cmp(a))\n\
    \    } else {\n        array.clone().sort_by(|a, b| a.cmp(b))\n    };\n    sorted_array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcl57r0vo.rs:17:5\n   |\n\
    11 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |                  \
    \                   ---------- expected `Vec<isize>` because of return type\n\
    ...\n17 |     sorted_array\n   |     ^^^^^^^^^^^^ expected struct `Vec`, found\
    \ `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type\
    \ `()`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let sum = array.first().unwrap()\
    \ + array.last().unwrap();\n    if sum % 2 == 0 {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    } else {\n        array.sort_by(|a, b| a.cmp(b));\n    }\n \
    \   array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpd0w18aez.rs:14:9\n   |\n11 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n14 |         array.sort_by(|a, b| b.cmp(a));\n  \
    \ |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]:\
    \ cannot borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpd0w18aez.rs:16:9\n\
    \   |\n11 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n16 |\
    \         array.sort_by(|a, b| a.cmp(b));\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let sum: isize = array.iter().take(2).sum();\n\
    \    match sum % 2 {\n        0 => array.clone().into_iter().rev().collect(),\n\
    \        _ => array.clone().into_iter().sorted().collect(),\n    }\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sorted` found for struct `std::vec::IntoIter`\
    \ in the current scope\n  --> /tmp/tmp5fyayn8l.rs:15:40\n   |\n15 |         _\
    \ => array.clone().into_iter().sorted().collect(),\n   |                     \
    \                   ^^^^^^ method not found in `std::vec::IntoIter<isize>`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let sum = array.first().cloned().unwrap_or(0)\
    \ + array.last().cloned().unwrap_or(0);\n    let mut temp_array = array.clone();\n\
    \    temp_array.sort();\n    if sum % 2 == 0 {\n        temp_array.reverse();\n\
    \    }\n    temp_array\n}\n\nfn main() {\n    let candidate = sort_array;\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() <= 1 {\n\
    \        return array;\n    }\n    let mut sorted_arr = array.clone();\n    sorted_arr.sort();\n\
    \    if (array[0] + array[array.len() - 1]) % 2 == 0 {\n        sorted_arr.reverse();\n\
    \    }\n    sorted_arr\n}\n\nfn main() {\n    let candidate = sort_array;\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut temp_array = array.clone();\n\
    \    let length = temp_array.len();\n    let sum = (array[0] + array[length -\
    \ 1]) % 2;\n    if sum == 0 {\n        temp_array.sort_by(|a, b| b.cmp(a));\n\
    \    } else {\n        temp_array.sort_by(|a, b| a.cmp(b));\n    }\n    temp_array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpdaqrg4ye.rs:14:16\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut s_array = array.clone();\n\
    \    let sum = array[0] + array[array.len() - 1];\n    s_array.sort_by(|a, b|\
    \ {\n        if sum % 2 == 0 {\n            b.cmp(a)\n        } else {\n     \
    \       a.cmp(b)\n        }\n    });\n    s_array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp0p980hra.rs:13:15\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let front = array.remove(0);\n        let back\
    \ = array.pop().unwrap();\n        if (front + back) % 2 == 0 {\n            array.sort_by(|a,\
    \ b| b.cmp(a));\n        } else {\n            array.sort_by(|a, b| a.cmp(b));\n\
    \        }\n        vec![front, array, vec![back]].concat()\n    } else {\n  \
    \      array\n    }\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1qwk3ljk.rs:21:21\n   |\n\
    21 |         vec![front, array, vec![back]].concat()\n   |                   \
    \  ^^^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type\
    \ `isize`\n            found struct `Vec<isize>`\n\nerror[E0599]: the method `concat`\
    \ exists for struct `Vec<isize, _>`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmp1qwk3ljk.rs:21:40\n   |\n21 |         vec![front, array, vec![back]].concat()\n\
    \   |                                        ^^^^^^ method cannot be called on\
    \ `Vec<isize, _>` due to unsatisfied trait bounds\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `[isize]: Concat<_>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() <= 1 {\n\
    \        return array;\n    }\n    let is_odd = (array[0] + array[array.len()\
    \ - 1]) % 2 == 1;\n    let mut new_array = array.clone();\n    let mut sorted_vector:\
    \ Vec<&isize> = new_array.iter().collect();\n    if is_odd {\n        sorted_vector.sort_by(|a,\
    \ b| a.cmp(b));\n    } else {\n        sorted_vector.sort_by(|a, b| b.cmp(a));\n\
    \    }\n    sorted_vector.iter().map(|i| **i).collect()\n}\n\nfn main() {\n  \
    \  let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    //if array.len() < 2 { return\
    \ array }\n    let mut arr: Vec<isize> = array.clone();\n    if array.len() >\
    \ 1 {\n        let mut left: Vec<isize> = vec![];\n        let mut right: Vec<isize>\
    \ = vec![];\n        let mut pivot: isize = array[0];\n        for i in 1..array.len()\
    \ {\n            if array[i] < pivot {\n                left.push(array[i]);\n\
    \            } else {\n                right.push(array[i]);\n            }\n\
    \        }\n        let (mut left_v, mut right_v) = (sort_array(left), sort_array(right));\n\
    \        if ((left_v.len() + right_v.len()) & 1) == 0 {\n            left_v.reverse();\n\
    \            right_v.reverse();\n        }\n        arr.clear();\n        arr.append(&mut\
    \ left_v);\n        arr.push(pivot);\n        arr.append(&mut right_v);\n    }\n\
    \    arr\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 0, 2, 6, 5, 4, 3]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpdb4f3lsl.rs:43:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut result = array.clone();\n\
    \    let mut sorted = false;\n    let step = (result.len() - 1) as isize;\n  \
    \  let mut start = 0;\n    let mut end = result.len() - 1;\n    let is_odd = step\
    \ % 2 == 1;\n    while !sorted {\n        sorted = true;\n        for i in start..end\
    \ {\n            let is_odd_pair = ((i as isize) + step) % 2 == 1;\n         \
    \   if (is_odd && result[i] > result[i + 1]) || (!is_odd && is_odd_pair && result[i]\
    \ < result[i + 1]) {\n                sorted = false;\n                result.swap(i,\
    \ i + 1);\n            }\n        }\n        end -= 1;\n        for i in (start..end).rev()\
    \ {\n            let is_odd_pair = ((i as isize) + step) % 2 == 1;\n         \
    \   if (is_odd && result[i] < result[i + 1]) || (!is_odd && is_odd_pair && result[i]\
    \ > result[i + 1]) {\n                sorted = false;\n                result.swap(i,\
    \ i + 1);\n            }\n        }\n        start += 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpt3iueu9w.rs:14:16\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    //\n\n    let mut sort_desc\
    \ = false;\n    if let Some(head) = array.first() {\n        if let Some(tail)\
    \ = array.last() {\n            if (head + tail) % 2 == 0 {\n                sort_desc\
    \ = true;\n            }\n        }\n    }\n\n    if sort_desc {\n        array.clone().into_iter().rev().collect()\n\
    \    } else {\n        array\n    }\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4, 3, 0, 1, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpcy56wmws.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() < 2 {\n \
    \       return array;\n    }\n    let mut array = array;\n    match (array[0],\
    \ array[array.len() - 1]) {\n        (0, 0) => return array,\n        (x, y) =>\
    \ match (x + y) % 2 {\n            0 => array.sort_by(|a, b| b.cmp(a)),\n    \
    \        _ => array.sort_by(|a, b| a.cmp(b)),\n        },\n    }\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let (mut odd, mut even)\
    \ = array.iter().partition(|i| i % 2 == 1);\n    odd.sort();\n    even.sort_by(|a,\
    \ b| b.cmp(a));\n    odd.iter().chain(even.iter()).cloned().collect()\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmpmuji0xtp.rs:12:60\n\
    \   |\n12 |     let (mut odd, mut even) = array.iter().partition(|i| i % 2 ==\
    \ 1);\n   |                                                          - ^ - {integer}\n\
    \   |                                                          |\n   |       \
    \                                                   &&isize\n   |\nhelp: `%` can\
    \ be used on `isize`, you can dereference `i`\n   |\n12 |     let (mut odd, mut\
    \ even) = array.iter().partition(|i| *i % 2 == 1);\n   |                     \
    \                                     +\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n\
    \        return array;\n    }\n    let mut ret = array.clone();\n    let (mut\
    \ i, mut j) = (0, ret.len() - 1);\n    while i < j {\n        if (ret[i] % 2 ==\
    \ 0) && (ret[j] % 2 == 1) {\n            ret.swap(i, j);\n            i += 1;\n\
    \            j -= 1;\n        } else if ret[i] % 2 == 1 {\n            i += 1;\n\
    \        } else if ret[j] % 2 == 0 {\n            j -= 1;\n        } else {\n\
    \            i += 1;\n            j -= 1;\n        }\n    }\n    if ret.len()\
    \ % 2 == 1 {\n        ret.sort();\n    } else {\n        ret.sort_by(|a, b| b.cmp(a));\n\
    \    }\n    ret\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 4, 3, 2, 1, 0]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpklew7tr1.rs:43:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n\
    \        return array;\n    }\n    let mut result = array.clone();\n    let first\
    \ = result[0];\n    let last = result[result.len() - 1];\n    let mut sorted =\
    \ if (first + last) % 2 == 0 {\n        result.sort_by(|a, b| b.cmp(a));\n   \
    \     true\n    } else {\n        result.sort_by(|a, b| a.cmp(b));\n        false\n\
    \    };\n    for idx in 1..result.len() - 1 {\n        if sorted {\n         \
    \   result[idx] = array[array.len() - idx - 1];\n        } else {\n          \
    \  result[idx] = array[idx];\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 4, 3, 0, 1, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp1zbbr1rb.rs:39:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp_323160s.rs:12:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    // TODO\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpq4h3cddr.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    array\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4, 3, 0, 1, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpcvmztxfn.rs:19:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n\
    \        return vec![];\n    }\n\n    let sum: isize = array[0] + array[array.len()\
    \ - 1];\n    if sum % 2 == 0 {\n        array.sort_by(|a, b| b.cmp(a));\n    }\
    \ else {\n        array.sort_by(|a, b| a.cmp(b));\n    }\n\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpggqn_r6p.rs:18:9\n   |\n11 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n18 |         array.sort_by(|a, b| b.cmp(a));\n  \
    \ |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]:\
    \ cannot borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpggqn_r6p.rs:20:9\n\
    \   |\n11 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n20 |\
    \         array.sort_by(|a, b| a.cmp(b));\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let n = array.len();\n \
    \   if n < 2 {\n        return array;\n    }\n    let mut v = array.clone();\n\
    \    //if sum of first and last element is odd, sort it ascending, otherwise,\
    \ descending\n    let ord = if v[0] + v[n - 1] % 2 == 0 {\n        Ordering::Less\n\
    \    } else {\n        Ordering::Greater\n    };\n    v.sort_by(|a, b| a.cmp(b).reverse().then(b.cmp(a)));\n\
    \    v\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpqeh3qn5w.rs:19:9\n   |\n19 |         Ordering::Less\n   |         ^^^^^^^^\
    \ use of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `Ordering`\n  --> /tmp/tmpqeh3qn5w.rs:21:9\n   |\n21 |     \
    \    Ordering::Greater\n   |         ^^^^^^^^ use of undeclared type `Ordering`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut result = array.clone();\n\
    \    let index = array.len() - 1;\n    let fst = array[0];\n    let lst = array[index];\n\
    \    let sum = fst + lst;\n    match sum % 2 {\n        0 => result.sort_by(|a,\
    \ b| b.cmp(a)),\n        _ => result.sort_by(|a, b| a.cmp(b)),\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpgtxx_bu0.rs:13:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut vec = array.clone();\n\
    \    vec.sort();\n    vec\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpychgqckm.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n\
    \        return vec![];\n    }\n\n    let mut new_array = array.clone();\n   \
    \ if array[0] + array[array.len() - 1] % 2 == 0 {\n        new_array.sort_by(|a,\
    \ b| b.cmp(a));\n    } else {\n        new_array.sort_by(|a, b| a.cmp(b));\n \
    \   }\n\n    new_array\n}\n\nfn main() {\n    let candidate = sort_array;\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpjkypt7es.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let (mut v1, mut v2) = array.iter().partition(|x|\
    \ x % 2 == 0);\n    v1.sort();\n    v2.sort();\n    v2.reverse();\n    let mut\
    \ v3 = v1.iter().cloned().chain(v2.iter().cloned()).collect::<Vec<isize>>();\n\
    \    if array.len() == 0 || array.len() == 1 {\n        v3\n    } else {\n   \
    \     let (mut v3, mut v4) = v3.iter().partition(|x| x % 2 == 0);\n        v3.sort();\n\
    \        v4.sort();\n        v4.reverse();\n        v3.iter().cloned().chain(v4.iter().cloned()).collect::<Vec<isize>>()\n\
    \    }\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmpqzg_6mc3.rs:12:57\n\
    \   |\n12 |     let (mut v1, mut v2) = array.iter().partition(|x| x % 2 == 0);\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &&isize\n   |\nhelp: `%` can be\
    \ used on `isize`, you can dereference `x`\n   |\n12 |     let (mut v1, mut v2)\
    \ = array.iter().partition(|x| *x % 2 == 0);\n   |                           \
    \                            +\n\nerror[E0369]: cannot mod `&&isize` by `{integer}`\n\
    \  --> /tmp/tmpqzg_6mc3.rs:20:58\n   |\n20 |         let (mut v3, mut v4) = v3.iter().partition(|x|\
    \ x % 2 == 0);\n   |                                                        -\
    \ ^ - {integer}\n   |                                                        |\n\
    \   |                                                        &&isize\n   |\nhelp:\
    \ `%` can be used on `isize`, you can dereference `x`\n   |\n20 |         let\
    \ (mut v3, mut v4) = v3.iter().partition(|x| *x % 2 == 0);\n   |             \
    \                                           +\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    // Calculate the sum of\
    \ the first and last elements of the array\n    let sum: isize = array.first().unwrap()\
    \ + array.last().unwrap();\n    let mut new_array = array.clone();\n    // If\
    \ the sum is even, sort in reverse\n    if sum % 2 == 0 {\n        new_array.sort_by(|a,\
    \ b| b.cmp(a));\n    } else {\n        // Else, sort normally\n        new_array.sort();\n\
    \    }\n    new_array\n}\n\nfn main() {\n    let candidate = sort_array;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmpul9kgrtt.rs:13:36\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let sum: isize = array.iter().fold(0,\
    \ |acc, &x| acc + x);\n    let mut tmp = array.clone();\n    if sum % 2 == 0 {\n\
    \        tmp.sort_by(|a, b| b.cmp(a));\n    } else {\n        tmp.sort_by(|a,\
    \ b| a.cmp(b));\n    }\n    tmp\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpqdy64kxp.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    // 1. Get the original array\n\
    \    // 2. Get the sum of the first and last value of the array\n    // 3. If\
    \ the sum is even, sort the array in descending order\n    // 4. If the sum is\
    \ odd, sort the array in ascending order\n    // 5. Return the sorted array\n\
    \    let mut copy = array.clone();\n    if array.is_empty() {\n        copy\n\
    \    } else {\n        let (first, last) = (array[0], array[array.len() - 1]);\n\
    \        if (first + last) % 2 == 0 {\n            copy.sort_by(|a, b| b.cmp(a));\n\
    \        } else {\n            copy.sort_by(|a, b| a.cmp(b));\n        }\n   \
    \     copy\n    }\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut array = array;\n    let s = array[0]\
    \ + array[array.len() - 1];\n    if s % 2 == 0 {\n        array.sort_by(|a, b|\
    \ b.cmp(a));\n    } else {\n        array.sort_by(|a, b| a.cmp(b));\n    }\n \
    \   array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut result = array.clone();\n\
    \    let result_len = result.len();\n    if result_len == 0 {\n        return\
    \ result;\n    }\n    if result_len == 1 {\n        return result;\n    }\n  \
    \  if (result[0] + result[result_len - 1]) % 2 == 0 {\n        result.sort_by(|a,\
    \ b| b.cmp(a));\n    } else {\n        result.sort_by(|a, b| a.cmp(b));\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut sorted_array = array.clone();\n\
    \    sorted_array.sort();\n    let last_index = sorted_array.len() - 1;\n    let\
    \ (first_value, last_value) =\n        (sorted_array[0], sorted_array[last_index]);\n\
    \    let sum = first_value + last_value;\n    if sum % 2 == 0 {\n        sorted_array.reverse();\n\
    \    }\n    sorted_array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmps44gllqw.rs:14:22\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut v = array.clone();\n\
    \    v.sort();\n    if array.len() > 0 && (array[0] + array[array.len() - 1])\
    \ % 2 == 0 {\n        v.reverse();\n    }\n    v\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() < 2 {\n \
    \       return array;\n    }\n    let (mut lo, mut hi) = (0, array.len() - 1);\n\
    \    let sorted_array = sort_array_inner(array, lo, hi);\n    if (sorted_array[lo]\
    \ + sorted_array[hi]) % 2 == 0 {\n        sorted_array.reverse();\n    }\n   \
    \ sorted_array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sort_array_inner` in this scope\n \
    \ --> /tmp/tmp5ngfuai9.rs:16:24\n   |\n16 |     let sorted_array = sort_array_inner(array,\
    \ lo, hi);\n   |                        ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut a: Vec<isize> =\
    \ array.clone();\n    if a.len() > 0 {\n        if a[0] % 2 == 0 {\n         \
    \   a.sort();\n        } else {\n            a.sort_by(|a, b| b.cmp(a));\n   \
    \     }\n    }\n    a\n}\n\nfn main() {\n    let candidate = sort_array;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp9un03i1t.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut ret = array.clone();\n\
    \    let sum = ret[0] + ret[ret.len() - 1];\n    if sum % 2 == 0 {\n        ret.sort_by(|a,\
    \ b| b.cmp(a));\n    } else {\n        ret.sort_by(|a, b| a.cmp(b));\n    }\n\
    \    ret\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpaiapb2ax.rs:13:15\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut result = array.clone();\n\
    \    let first = array[0];\n    let last = array[array.len() - 1];\n    if (first\
    \ + last) % 2 == 0 {\n        result.sort_by(|a, b| b.cmp(a));\n    } else {\n\
    \        result.sort_by(|a, b| a.cmp(b));\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpj4vid1gq.rs:13:17\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut result = array.clone();\n\
    \    if result.len() == 0 {\n        return result;\n    }\n    if result.len()\
    \ == 1 {\n        return result;\n    }\n    let mut start = 0;\n    let mut end\
    \ = result.len() - 1;\n    while start <= end {\n        let sum = result[start]\
    \ + result[end];\n        if sum % 2 == 0 {\n            result.swap(start, end);\n\
    \        }\n        start += 1;\n        end -= 1;\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4, 3, 0, 1, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpnrfsvjz4.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    array.sort_by(|a, b| {\n        if a.is_even() && b.is_even() {\n       \
    \     if a > b {\n                Ordering::Less\n            } else {\n     \
    \           Ordering::Greater\n            }\n        } else if a.is_odd() &&\
    \ b.is_odd() {\n            if a > b {\n                Ordering::Greater\n  \
    \          } else {\n                Ordering::Less\n            }\n        }\
    \ else if a.is_even() && b.is_odd() {\n            Ordering::Less\n        } else\
    \ {\n            Ordering::Greater\n        }\n    });\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmphicj37hk.rs:16:17\n   |\n16 |                 Ordering::Less\n   | \
    \                ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmphicj37hk.rs:18:17\n\
    \   |\n18 |                 Ordering::Greater\n   |                 ^^^^^^^^ use\
    \ of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Ordering`\n  --> /tmp/tmphicj37hk.rs:22:17\n   |\n22 |               \
    \  Ordering::Greater\n   |                 ^^^^^^^^ use of undeclared type `Ordering`\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmphicj37hk.rs:24:17\n\
    \   |\n24 |                 Ordering::Less\n   |                 ^^^^^^^^ use\
    \ of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Ordering`\n  --> /tmp/tmphicj37hk.rs:27:13\n   |\n27 |             Ordering::Less\n\
    \   |             ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmphicj37hk.rs:29:13\n\
    \   |\n29 |             Ordering::Greater\n   |             ^^^^^^^^ use of undeclared\
    \ type `Ordering`\n\nerror[E0599]: no method named `is_even` found for reference\
    \ `&isize` in the current scope\n  --> /tmp/tmphicj37hk.rs:14:14\n   |\n14 | \
    \        if a.is_even() && b.is_even() {\n   |              ^^^^^^^ method not\
    \ found in `&isize`\n\nerror[E0599]: no method named `is_even` found for reference\
    \ `&isize` in the current scope\n  --> /tmp/tmphicj37hk.rs:14:29\n   |\n14 | \
    \        if a.is_even() && b.is_even() {\n   |                             ^^^^^^^\
    \ method not found in `&isize`\n\nerror[E0599]: no method named `is_odd` found\
    \ for reference `&isize` in the current scope\n  --> /tmp/tmphicj37hk.rs:20:21\n\
    \   |\n20 |         } else if a.is_odd() && b.is_odd() {\n   |               \
    \      ^^^^^^ method not found in `&isize`\n\nerror[E0599]: no method named `is_odd`\
    \ found for reference `&isize` in the current scope\n  --> /tmp/tmphicj37hk.rs:2"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut result = array.clone();\n\
    \    let index = array.len() - 1;\n    let sum = array[0] + array[index];\n  \
    \  if sum % 2 == 0 {\n        result.sort_by(|a, b| b.cmp(a));\n    } else {\n\
    \        result.sort_by(|a, b| a.cmp(b));\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp9xy8hr8k.rs:13:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut odd_vec = Vec::new();\n\
    \    let mut even_vec = Vec::new();\n    let mut sort_array = array.clone();\n\
    \    if array.len() > 0 {\n        if array[0] + array[array.len() - 1] % 2 ==\
    \ 0 {\n            sort_array.sort_by(|a, b| b.cmp(a));\n        } else {\n  \
    \          sort_array.sort_by(|a, b| a.cmp(b));\n        }\n    }\n    //pick\
    \ all odd numbers and sort\n    for i in 0..array.len() {\n        if array[i]\
    \ % 2 != 0 {\n            odd_vec.push(array[i]);\n        }\n    }\n    odd_vec.sort_by(|a,\
    \ b| a.cmp(b));\n    //pick all even numbers and sort\n    for i in 0..array.len()\
    \ {\n        if array[i] % 2 == 0 {\n            even_vec.push(array[i]);\n  \
    \      }\n    }\n    even_vec.sort_by(|a, b| b.cmp(a));\n    //merge odd and even\
    \ numbers\n    let mut cnt = 0;\n    for i in 0..sort_array.len() {\n        if\
    \ sort_array[i] % 2 != 0 {\n            sort_array[i] = odd_vec[cnt];\n      \
    \      cnt += 1;\n        }\n    }\n    cnt = 0;\n    for i in 0..sort_array.len()\
    \ {\n        if sort_array[i] % 2 == 0 {\n            sort_array[i] = even_vec[cnt];\n\
    \            cnt += 1;\n        }\n    }\n    sort_array\n}\n\nfn main() {\n \
    \   let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 1, 2, 3, 0, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp0vg3v4uw.rs:58:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    // return array.sort_by(|a,\
    \ b| b.cmp(a));\n    // return array.sort_by(|a, b| a.cmp(b));\n    let sum: isize\
    \ = array.iter().sum();\n    if sum % 2 == 0 {\n        return array.sort_by(|a,\
    \ b| b.cmp(a));\n    } else {\n        return array.sort_by(|a, b| a.cmp(b));\n\
    \    }\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2rt3ggbr.rs:16:16\n   |\n\
    11 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |                  \
    \                   ---------- expected `Vec<isize>` because of return type\n\
    ...\n16 |         return array.sort_by(|a, b| b.cmp(a));\n   |               \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n           found unit type `()`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut arr = array.clone();\n\
    \    if arr.len() < 2 {\n        return arr;\n    }\n    let is_odd = |x: usize|\
    \ {\n        let mut x = x;\n        while x > 0 {\n            x -= 2;\n    \
    \    }\n        x == 0\n    };\n    let left = 0;\n    let right = arr.len() -\
    \ 1;\n    if is_odd(arr[left] + arr[right]) {\n        arr.sort();\n    } else\
    \ {\n        arr.sort_by(|a, b| b.cmp(a));\n    }\n    arr\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3bunz611.rs:25:15\n   |\n\
    25 |     if is_odd(arr[left] + arr[right]) {\n   |               ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n25 |     if is_odd((arr[left]\
    \ + arr[right]).try_into().unwrap()) {\n   |               +                 \
    \     +++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let len = array.len();\n\
    \    let mut new_array = array.clone();\n    if (len == 0) || (len == 1) {\n \
    \       return new_array;\n    }\n\n    let sum = new_array[0] + new_array[len\
    \ - 1];\n    if sum % 2 == 0 {\n        new_array.sort_by(|a, b| b.cmp(a));\n\
    \    } else {\n        new_array.sort_by(|a, b| a.cmp(b));\n    }\n    new_array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n\
    \        return array;\n    }\n    let mut array = array;\n    if (array[0] +\
    \ array[array.len() - 1]) % 2 == 0 {\n        array.sort_by(|a, b| b.cmp(a));\n\
    \    } else {\n        array.sort_by(|a, b| a.cmp(b));\n    }\n    array\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() < 2 {\n \
    \       return array;\n    }\n    let mut arr = array.clone();\n    let sum =\
    \ arr[0] + arr[arr.len() - 1];\n    if sum % 2 == 0 {\n        arr.sort_by(|a,\
    \ b| b.cmp(a));\n    } else {\n        arr.sort_by(|a, b| a.cmp(b));\n    }\n\
    \    arr\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    match array.len() {\n  \
    \      0 => vec![],\n        1 => vec![array[0]],\n        len => sort(array,\
    \ 0, len - 1),\n    }\n}\n\nfn main() {\n    let candidate = sort_array;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sort` in this scope\n  --> /tmp/tmpu189ohal.rs:15:16\n\
    \   |\n15 |         len => sort(array, 0, len - 1),\n   |                ^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() <= 1 {\n\
    \        return array;\n    }\n    let odd_or_even = if array[0] + array[array.len()\
    \ - 1] % 2 == 0 {\n        SortOrder::Descending\n    } else {\n        SortOrder::Ascending\n\
    \    };\n    let mut vec: Vec<_> = array.iter().cloned().collect();\n    vec.sort_by(|a,\
    \ b| a.cmp(b).reverse());\n    vec\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `SortOrder`\n \
    \ --> /tmp/tmpw69g0lre.rs:16:9\n   |\n16 |         SortOrder::Descending\n   |\
    \         ^^^^^^^^^ use of undeclared type `SortOrder`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `SortOrder`\n  --> /tmp/tmpw69g0lre.rs:18:9\n\
    \   |\n18 |         SortOrder::Ascending\n   |         ^^^^^^^^^ use of undeclared\
    \ type `SortOrder`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n\
    \        return array;\n    }\n\n    let mut array = array;\n    if (array[0]\
    \ + array[array.len() - 1]) % 2 == 0 {\n        array.sort_by(|a, b| b.cmp(a));\n\
    \    } else {\n        array.sort_by(|a, b| a.cmp(b));\n    }\n\n    array\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() < 2 {\n \
    \       return array;\n    }\n    let mut array = array;\n    let is_even = array[0]\
    \ + array[array.len() - 1] % 2 == 0;\n    array.sort_by(|a, b| if is_even { b.cmp(a)\
    \ } else { a.cmp(b) });\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp0swbamhk.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut result = array.clone();\n\
    \    let len = result.len();\n    let (mut first, mut last) = (0, len - 1);\n\
    \    let even = (array[0] + array[len - 1]) % 2 == 0;\n    result.sort_by(|a,\
    \ b| {\n        let a = *a;\n        let b = *b;\n        if even {\n        \
    \    if a % 2 == 0 && b % 2 == 0 {\n                b.cmp(&a)\n            } else\
    \ if a % 2 == 0 {\n                b.cmp(&a)\n            } else if b % 2 == 0\
    \ {\n                a.cmp(&b)\n            } else {\n                a.cmp(&b)\n\
    \            }\n        } else {\n            if a % 2 == 0 && b % 2 == 0 {\n\
    \                a.cmp(&b)\n            } else if a % 2 == 0 {\n             \
    \   a.cmp(&b)\n            } else if b % 2 == 0 {\n                b.cmp(&a)\n\
    \            } else {\n                b.cmp(&a)\n            }\n        }\n \
    \   });\n    while first < last {\n        if even {\n            result.swap(first,\
    \ last);\n        }\n        first += 1;\n        last -= 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmplw2kngrx.rs:14:37\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n\
    \        return array;\n    }\n    if array.len() == 1 {\n        return array;\n\
    \    }\n    let mut a = array.clone();\n    let mut i = 0;\n    let l = a.len();\n\
    \    while i < l {\n        let mut j = i + 1;\n        while j < l {\n      \
    \      if sum_index_value(&a, i, j) % 2 == 0 {\n                a.swap(i, j);\n\
    \            }\n            j += 1;\n        }\n        i += 1;\n    }\n    a\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sum_index_value` in this scope\n  -->\
    \ /tmp/tmpb4gpkcz7.rs:24:16\n   |\n24 |             if sum_index_value(&a, i,\
    \ j) % 2 == 0 {\n   |                ^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        if array[0] + array[array.len() - 1] % 2 ==\
    \ 0 {\n            array.sort_by(|a, b| b.cmp(a));\n        } else {\n       \
    \     array.sort_by(|a, b| a.cmp(b));\n        }\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpbf5ua2u1.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    array\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4, 3, 0, 1, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp6ei_ioqu.rs:19:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    let mut is_odd = true;\n    if !array.is_empty() {\n        is_odd = (array[0]\
    \ + array[array.len() - 1]) % 2 == 1;\n    }\n    if is_odd {\n        array.sort();\n\
    \    } else {\n        array.sort_by(|a, b| b.cmp(a));\n    }\n    array\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n\
    \        return array;\n    }\n    let sum: isize = array[0] + array[array.len()\
    \ - 1];\n    if sum % 2 == 0 {\n        array.sort_by(|a, b| b.cmp(a));\n    }\
    \ else {\n        array.sort_by(|a, b| a.cmp(b));\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp6w2jujsc.rs:17:9\n   |\n11 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n17 |         array.sort_by(|a, b| b.cmp(a));\n  \
    \ |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]:\
    \ cannot borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmp6w2jujsc.rs:19:9\n\
    \   |\n11 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n19 |\
    \         array.sort_by(|a, b| a.cmp(b));\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let l = array.len();\n \
    \   if l == 0 {\n        return vec![];\n    }\n    if l == 1 {\n        return\
    \ array;\n    }\n    if (array[0] + array[l - 1]) % 2 == 0 {\n        let mut\
    \ tmp = array.clone();\n        tmp.sort();\n        tmp.reverse();\n        return\
    \ tmp;\n    } else {\n        let mut tmp = array.clone();\n        tmp.sort();\n\
    \        return tmp;\n    }\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut v = array.clone();\n\
    \    let first = v[0];\n    let last = v[v.len() - 1];\n    let sum = first +\
    \ last;\n    v.sort_by(|a, b| {\n        if sum % 2 == 0 {\n            a.cmp(b)\n\
    \        } else {\n            b.cmp(a)\n        }\n    });\n    v\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpa_07g91y.rs:13:17\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut vec = array.clone();\n\
    \    if vec.len() <= 1 {\n        return vec;\n    }\n    let sum = vec[0] + vec[vec.len()\
    \ - 1];\n    if sum % 2 == 0 {\n        vec.sort_by(|a, b| b.cmp(a));\n    } else\
    \ {\n        vec.sort_by(|a, b| a.cmp(b));\n    }\n    vec\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let n = array.len();\n \
    \   let mut result = array.clone();\n    let sum = array[0] + array[n - 1];\n\
    \    if sum % 2 == 0 {\n        result.sort_by(|a, b| b.cmp(a));\n    } else {\n\
    \        result.sort_by(|a, b| a.cmp(b));\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp87wxh3zz.rs:14:15\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut output: Vec<isize>\
    \ = array.clone();\n    if array.len() > 1 {\n        if array[0] + array[array.len()\
    \ - 1] % 2 == 0 {\n            output.sort_by(|a, b| b.cmp(a));\n        } else\
    \ {\n            output.sort_by(|a, b| a.cmp(b));\n        }\n    }\n    output\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpom6os8xl.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    match array.len() {\n  \
    \      0 => vec![],\n        1 => vec![array[0]],\n        _ => {\n          \
    \  if (array[0] + array[array.len() - 1]) % 2 == 0 {\n                let mut\
    \ array = array;\n                array.sort_by(|a, b| b.cmp(a));\n          \
    \      array\n            } else {\n                let mut array = array;\n \
    \               array.sort_by(|a, b| a.cmp(b));\n                array\n     \
    \       }\n        }\n    }\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n\
    \        return array;\n    }\n    let mut array_cp = array.clone();\n    if (array[0]\
    \ + array[array.len() - 1]) % 2 == 0 {\n        array_cp.sort_by(|a, b| b.cmp(a));\n\
    \    } else {\n        array_cp.sort_by(|a, b| a.cmp(b));\n    }\n    array_cp\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    // TODO implement\n    let\
    \ mut result: Vec<isize> = Vec::new();\n    for i in array {\n        result.push(i);\n\
    \    }\n    if array.is_empty() {\n        return result;\n    } else if array.len()\
    \ == 1 {\n        return result;\n    } else if array.len() == 2 {\n        if\
    \ array[0] > array[1] {\n            result.swap(0, 1);\n        }\n        return\
    \ result;\n    } else {\n        if array[0] + array[array.len() - 1] % 2 == 0\
    \ {\n            result.sort();\n            result.reverse();\n        } else\
    \ {\n            result.sort();\n        }\n        return result;\n    }\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `array`\n   --> /tmp/tmp9oto7vvx.rs:17:8\n\
    \    |\n11  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \       ----- move occurs because `array` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n...\n14  |     for i in array {\n    |         \
    \     ----- `array` moved due to this implicit call to `.into_iter()`\n...\n17\
    \  |     if array.is_empty() {\n    |        ^^^^^^^^^^^^^^^^ value borrowed here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `array`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n14  |     for i in &array\
    \ {\n    |              +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    match (&array[0], &array[array.len() - 1]) {\n        (a, b) if a + b % 2\
    \ == 0 => array.sort(),\n        _ => array.sort_by(|a, b| b.cmp(a)),\n    };\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp4jt_iond.rs:13:13\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    // your code here\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpppoc8t61.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut arr = array.clone();\n\
    \    let n = arr.len();\n    let m = n / 2;\n    let sum = arr[0] + arr[n - 1];\n\
    \    if sum % 2 == 0 {\n        for i in 0..m {\n            arr.swap(i, n - i\
    \ - 1);\n        }\n    }\n    arr.sort();\n    arr\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp5qe3s40r.rs:15:15\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let (start, end) = (array[0],\
    \ array[array.len() - 1]);\n    let sum = start + end;\n    let mut result = array.clone();\n\
    \    result.sort_by(|a, b| if sum % 2 == 0 { b.cmp(a) } else { a.cmp(b) });\n\
    \    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpxfl3rkr8.rs:12:25\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut new_array = Vec::with_capacity(array.len());\n\
    \    let mut even = Vec::new();\n    let mut odd = Vec::new();\n    for i in array\
    \ {\n        if i % 2 == 0 {\n            even.push(i);\n        } else {\n  \
    \          odd.push(i);\n        }\n    }\n    even.sort();\n    odd.sort();\n\
    \    odd.reverse();\n    new_array.append(&mut even);\n    new_array.append(&mut\
    \ odd);\n    new_array\n}\n\nfn main() {\n    let candidate = sort_array;\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 2, 4, 5, 3, 1]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpaccadavz.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut sorted = array.clone();\n\
    \    if array.len() > 0 {\n        if ((array[0] + array[array.len() - 1]) % 2)\
    \ == 0 {\n            sorted.sort_by(|a, b| b.cmp(a));\n        } else {\n   \
    \         sorted.sort_by(|a, b| a.cmp(b));\n        }\n    }\n    sorted\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut res = array.clone();\n\
    \    if res.len() > 1 {\n        if (res[0] + res[res.len() - 1]) % 2 == 0 {\n\
    \            res.sort_by(|a, b| b.cmp(a));\n        } else {\n            res.sort_by(|a,\
    \ b| a.cmp(b));\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut v = array.clone();\n\
    \    let mut l = 0;\n    let mut r = v.len() - 1;\n    loop {\n        while l\
    \ < r && (v[l] + v[r]) % 2 == 0 {\n            l += 1;\n        }\n        while\
    \ l < r && (v[l] + v[r]) % 2 == 1 {\n            r -= 1;\n        }\n        if\
    \ l < r {\n            v.swap(l, r);\n        } else {\n            break;\n \
    \       }\n    }\n    for i in 0..v.len() {\n        for j in i + 1..v.len() {\n\
    \            if (v[i] + v[j]) % 2 == 0 && v[i] > v[j] {\n                v.swap(i,\
    \ j);\n            }\n            if (v[i] + v[j]) % 2 == 1 && v[i] < v[j] {\n\
    \                v.swap(i, j);\n            }\n        }\n    }\n    v\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpj934d1ct.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut result = array.clone();\n\
    \    if result.len() > 0 {\n        if result.len() % 2 == 0 {\n            result.sort_by(|a,\
    \ b| b.cmp(a));\n        } else {\n            result.sort_by(|a, b| a.cmp(b));\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 4, 3, 2, 1, 0]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpddg_xi5_.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut new_array = array.clone();\n\
    \    new_array.sort();\n    new_array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmplbibph80.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut result = array.clone();\n\
    \    let sum = result[0] + result[result.len() - 1];\n    if sum % 2 == 0 {\n\
    \        result.sort_by(|a, b| b.cmp(a));\n    } else {\n        result.sort_by(|a,\
    \ b| a.cmp(b));\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp0jn8iqc4.rs:13:15\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut new_array = array.clone();\n\
    \    // new_array.sort();\n    match new_array.is_empty() {\n        true => new_array,\n\
    \        false => {\n            match (new_array[0] + new_array[new_array.len()\
    \ - 1]) % 2 {\n                0 => new_array.sort_by(|a, b| b.cmp(a)),\n    \
    \            _ => new_array.sort_by(|a, b| a.cmp(b)),\n            }\n       \
    \     new_array\n        }\n    }\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut ret = array.clone();\n\
    \    let len = ret.len();\n    if len < 2 {\n        return ret;\n    }\n    if\
    \ len % 2 == 0 {\n        ret.sort_by(|a, b| b.cmp(a));\n    } else {\n      \
    \  ret.sort_by(|a, b| a.cmp(b));\n    }\n    ret\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 4, 3, 2, 1, 0]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp5q_qbhma.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n\
    \        return array;\n    }\n    if array.len() % 2 == 0 {\n        array.sort_by(|a,\
    \ b| b.cmp(a));\n    } else {\n        array.sort_by(|a, b| a.cmp(b));\n    }\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpta6um3ya.rs:16:9\n   |\n11 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n16 |         array.sort_by(|a, b| b.cmp(a));\n  \
    \ |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]:\
    \ cannot borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpta6um3ya.rs:18:9\n\
    \   |\n11 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n18 |\
    \         array.sort_by(|a, b| a.cmp(b));\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0596`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() == 0 {\n        return array;\n    }\n    if array.len() ==\
    \ 1 {\n        return array;\n    }\n    let mut even_odd_sort = false;\n    if\
    \ array[0] + array[array.len() - 1] % 2 == 0 {\n        even_odd_sort = true;\n\
    \    }\n    array.sort();\n    if even_odd_sort {\n        array.reverse();\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpyucedve8.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let len = array.len();\n\
    \    let mut v: Vec<isize> = array.clone();\n    for i in 0..len {\n        if\
    \ (i + len) % 2 == 0 {\n            v[i] = array[len - i - 1];\n        }\n  \
    \  }\n    v.sort();\n    v\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 4, 4, 5, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpsys8ojdb.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    // TODO\n    let mut new_arr\
    \ = array.clone();\n    let last_elem = new_arr.len()-1;\n    let mut is_odd =\
    \ false;\n    if new_arr.len() > 0 {\n        if (new_arr[0] + new_arr[last_elem])\
    \ % 2 != 0 {\n            is_odd = true;\n        }\n    }\n\n    if is_odd {\n\
    \        new_arr.sort();\n    } else {\n        new_arr.sort_by(|a, b| b.cmp(a));\n\
    \    }\n\n    new_arr\n}\n\nfn main() {\n    let candidate = sort_array;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpmc81ztsy.rs:14:21\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let mut i = 0;\n        let mut j = array.len()\
    \ - 1;\n        while i <= j {\n            if (i + j) % 2 == 0 {\n          \
    \      if array[i] < array[j] {\n                    let temp = array[i];\n  \
    \                  array[i] = array[j];\n                    array[j] = temp;\n\
    \                }\n            } else {\n                if array[i] > array[j]\
    \ {\n                    let temp = array[i];\n                    array[i] =\
    \ array[j];\n                    array[j] = temp;\n                }\n       \
    \     }\n            i += 1;\n            j -= 1;\n        }\n    }\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1, 0, 3, 4, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp2f888sie.rs:41:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let sum = array.first().unwrap()\
    \ + array.last().unwrap();\n    let mut array = array;\n    if sum % 2 == 0 {\n\
    \        array.sort_by(|a, b| b.cmp(a));\n    } else {\n        array.sort();\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmpds_gpvy7.rs:12:29\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let array_size = array.len();\n\
    \    let mut v: Vec<isize> = array.to_vec();\n    if array_size == 0 {\n     \
    \   return v;\n    }\n    let sum_of_indices = (array_size - 1) as isize + 0;\n\
    \    let mut sorted_array: Vec<isize> = Vec::new();\n    if sum_of_indices % 2\
    \ == 0 {\n        sorted_array = v.drain(..).rev().collect();\n    } else {\n\
    \        sorted_array = v.drain(..).collect();\n    }\n    sorted_array\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4, 3, 0, 1, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp_0idawcn.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut tmp = array.clone();\n    let mut\
    \ sum: isize = 0;\n    for num in &tmp {\n        sum += num;\n    }\n    if sum\
    \ % 2 == 0 {\n        tmp.sort_by(|a, b| b.cmp(a));\n    } else {\n        tmp.sort_by(|a,\
    \ b| a.cmp(b));\n    }\n    tmp\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpssjj6lit.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut vec = array.clone();\n\
    \    if vec.len() > 0 {\n        let first = vec[0];\n        let last = vec[vec.len()\
    \ - 1];\n        if (first + last) % 2 == 0 {\n            vec.sort_by(|a, b|\
    \ b.cmp(a));\n        } else {\n            vec.sort_by(|a, b| a.cmp(b));\n  \
    \      }\n    }\n    vec\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    // unimplemented!();\n \
    \   let mut tmp = Vec::new();\n    let mut result = Vec::new();\n    let mut tmp_result\
    \ = Vec::new();\n    let mut tmp_result_reverse = Vec::new();\n    for i in 0..array.len()\
    \ {\n        tmp.push(array[i]);\n    }\n    tmp.sort();\n    if tmp.len() ==\
    \ 0 {\n        return tmp;\n    }\n    if (tmp[0] + tmp[tmp.len() - 1]) % 2 ==\
    \ 0 {\n        tmp_result.push(tmp[tmp.len() - 1]);\n        for i in 0..tmp.len()\
    \ - 1 {\n            tmp_result.push(tmp[i]);\n        }\n        for i in 0..tmp_result.len()\
    \ {\n            tmp_result_reverse.push(tmp_result[tmp_result.len() - 1 - i]);\n\
    \        }\n        return tmp_result_reverse;\n    } else {\n        return tmp;\n\
    \    }\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmppcb1b1x0.rs:14:22\n\
    \   |\n14 |     let mut result = Vec::new();\n   |         ----------   ^^^^^^^^\
    \ cannot infer type for type parameter `T`\n   |         |\n   |         consider\
    \ giving `result` the explicit type `Vec<T>`, where the type parameter `T` is\
    \ specified\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        let mut index = 0;\n        while index < array.len()\
    \ {\n            let next_index = (index + 1) % array.len();\n            if (array[index]\
    \ % 2 == 0 && array[next_index] % 2 == 1)\n                || (array[index] %\
    \ 2 == 1 && array[next_index] % 2 == 0)\n            {\n                array.swap(index,\
    \ next_index);\n            }\n            index += 1;\n        }\n        array.sort();\n\
    \        if array[0] % 2 == 0 {\n            array.reverse();\n        }\n   \
    \ }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 4, 3, 2, 1, 0]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpvztmdt1h.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n\
    \        return array;\n    }\n    let mut sorted = array.clone();\n    sorted.sort();\n\
    \    if array[0] + array[array.len() - 1] % 2 == 0 {\n        sorted.reverse();\n\
    \    }\n    sorted\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp3w5wmnlv.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    // sort all odd numbers\
    \ in descending order, then even numbers in ascending order\n    let mut odds:\
    \ Vec<isize> = array.iter().filter(|x| x % 2 == 1).cloned().collect();\n    let\
    \ mut evens: Vec<isize> = array.iter().filter(|x| x % 2 == 0).cloned().collect();\n\
    \    odds.sort_by(|a, b| b.cmp(a));\n    evens.sort_by(|a, b| a.cmp(b));\n   \
    \ odds.append(&mut evens);\n    odds\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmpp9j5fioj.rs:13:58\n\
    \   |\n13 |     let mut odds: Vec<isize> = array.iter().filter(|x| x % 2 == 1).cloned().collect();\n\
    \   |                                                        - ^ - {integer}\n\
    \   |                                                        |\n   |         \
    \                                               &&isize\n   |\nhelp: `%` can be\
    \ used on `isize`, you can dereference `x`\n   |\n13 |     let mut odds: Vec<isize>\
    \ = array.iter().filter(|x| *x % 2 == 1).cloned().collect();\n   |           \
    \                                             +\n\nerror[E0369]: cannot mod `&&isize`\
    \ by `{integer}`\n  --> /tmp/tmpp9j5fioj.rs:14:59\n   |\n14 |     let mut evens:\
    \ Vec<isize> = array.iter().filter(|x| x % 2 == 0).cloned().collect();\n   | \
    \                                                        - ^ - {integer}\n   |\
    \                                                         |\n   |            \
    \                                             &&isize\n   |\nhelp: `%` can be\
    \ used on `isize`, you can dereference `x`\n   |\n14 |     let mut evens: Vec<isize>\
    \ = array.iter().filter(|x| *x % 2 == 0).cloned().collect();\n   |           \
    \                                              +\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut res = array.clone();\n\
    \    let mut flag = false;\n    res.sort_by(|a, b| a.cmp(b));\n    if (res[0]\
    \ + res[res.len() - 1]) % 2 == 0 {\n        flag = true;\n    }\n    if flag {\n\
    \        res.reverse();\n    }\n    res\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp3fkyxp0c.rs:15:9\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    array.sort_by(|a, b| {\n        let sum = a + b;\n        if sum % 2 == 0\
    \ {\n            b.cmp(a)\n        } else {\n            a.cmp(b)\n        }\n\
    \    });\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 2, 0, 5, 3, 1]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp5whp47jp.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() <= 1 {\n\
    \        return array;\n    }\n    let mut ar = array.clone();\n    ar.sort();\n\
    \    if (ar[0] + ar[ar.len() - 1]) % 2 == 0 {\n        ar.reverse();\n    }\n\
    \    ar\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut result = array.clone();\n\
    \    result.sort();\n    let (first, last) = (result[0], result[result.len() -\
    \ 1]);\n    if (first + last) % 2 == 0 {\n        result.reverse();\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmp9tg7f8fi.rs:14:26\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut copy = array.clone();\n\
    \    copy.sort();\n    if array.len() > 0 && (array[0] + array[array.len() - 1])\
    \ % 2 == 0 {\n        copy.reverse();\n    }\n    copy\n}\n\nfn main() {\n   \
    \ let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut out = array.clone();\n    if array[0]\
    \ % 2 == 0 {\n        out.sort_by(|a, b| b.cmp(a));\n    } else {\n        out.sort_by(|a,\
    \ b| a.cmp(b));\n    }\n    out\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 4, 3, 2, 1, 0]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpufcb5idq.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut v = array.clone();\n\
    \    if v.len() <= 1 {\n        return v;\n    }\n    let mut left: usize = 0;\n\
    \    let mut right: usize = v.len() - 1;\n    let sum = v[left] + v[right];\n\
    \    let _ascending = sum % 2 == 0;\n    while left < right {\n        if _ascending\
    \ {\n            if v[left] < v[right] {\n                let tmp = v[left];\n\
    \                v[left] = v[right];\n                v[right] = tmp;\n      \
    \      }\n        } else {\n            if v[left] > v[right] {\n            \
    \    let tmp = v[left];\n                v[left] = v[right];\n               \
    \ v[right] = tmp;\n            }\n        }\n        left += 1;\n        right\
    \ -= 1;\n    }\n    return v;\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 1, 0, 3, 4, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmptiyxu1m6.rs:44:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut sum = array.iter().fold(0,\
    \ |acc, x| acc + x);\n    let mut array = array;\n    let r = array.len() - 1;\n\
    \    let (mut l, mut i) = (0, 0);\n    while i < r {\n        if sum % 2 == 0\
    \ {\n            if array[l] < array[r] {\n                i += 1;\n         \
    \   } else {\n                array.swap(l, r);\n                l += 1;\n   \
    \             r -= 1;\n            }\n        } else {\n            if array[l]\
    \ > array[r] {\n                i += 1;\n            } else {\n              \
    \  array.swap(l, r);\n                l += 1;\n                r -= 1;\n     \
    \       }\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpgth_itss.rs:12:9\n\
    \   |\n12 |     let mut sum = array.iter().fold(0, |acc, x| acc + x);\n   |  \
    \       ----^^^\n   |         |\n   |         help: remove this `mut`\n   |\n\
    \   = note: `#[warn(unused_mut)]` on by default\n\nerror[E0384]: cannot assign\
    \ twice to immutable variable `r`\n  --> /tmp/tmpgth_itss.rs:23:17\n   |\n14 |\
    \     let r = array.len() - 1;\n   |         -\n   |         |\n   |         first\
    \ assignment to `r`\n   |         help: consider making this binding mutable:\
    \ `mut r`\n...\n23 |                 r -= 1;\n   |                 ^^^^^^ cannot\
    \ assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable\
    \ variable `r`\n  --> /tmp/tmpgth_itss.rs:31:17\n   |\n14 |     let r = array.len()\
    \ - 1;\n   |         -\n   |         |\n   |         first assignment to `r`\n\
    \   |         help: consider making this binding mutable: `mut r`\n...\n31 | \
    \                r -= 1;\n   |                 ^^^^^^ cannot assign twice to immutable\
    \ variable\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\n\
    For more information about this error, try `rustc --explain E0384`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut result = array.clone();\n\
    \    if result.len() > 0 {\n        let (mut front, mut end) = (0, result.len()\
    \ - 1);\n        loop {\n            if front == end {\n                break;\n\
    \            }\n            if (result[front] + result[end]) % 2 == 0 {\n    \
    \            let val = result[front];\n                result[front] = result[end];\n\
    \                result[end] = val;\n            }\n            front += 1;\n\
    \            end -= 1;\n        }\n        result.sort();\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp3085v2pc.rs:25:13\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    // TODO\n    let mut array\
    \ = array;\n    let mut first_index = 0;\n    let mut last_index = array.len()\
    \ - 1;\n    while first_index < last_index {\n        if (array[first_index] +\
    \ array[last_index]) % 2 == 0 {\n            array.swap(first_index, last_index);\n\
    \        }\n        first_index += 1;\n        last_index -= 1;\n    }\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpzq8d24tn.rs:15:26\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    fn sort_array_asc(array:\
    \ &mut Vec<isize>) {\n        let l = array.len();\n        for i in 0..l {\n\
    \            for j in (i + 1)..l {\n                if array[i] > array[j] {\n\
    \                    array.swap(i, j);\n                }\n            }\n   \
    \     }\n    }\n\n    fn sort_array_dsc(array: &mut Vec<isize>) {\n        let\
    \ l = array.len();\n        for i in 0..l {\n            for j in (i + 1)..l {\n\
    \                if array[i] < array[j] {\n                    array.swap(i, j);\n\
    \                }\n            }\n        }\n    }\n\n    let mut array = array;\n\
    \    let l = array.len();\n    if l % 2 == 0 {\n        sort_array_asc(&mut array);\n\
    \    } else {\n        sort_array_dsc(&mut array);\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 14, 21, 23]`,\n right: `[23, 21, 14, 11]`', /tmp/tmpy4t0i2l8.rs:52:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut array = array;\n\
    \    if array.len() > 1 {\n        if array[0] + array[array.len() - 1] % 2 ==\
    \ 0 {\n            array.sort_by(|a, b| b.cmp(a));\n        } else {\n       \
    \     array.sort_by(|a, b| a.cmp(b));\n        }\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpz74sw_3p.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut arr = array.clone();\n\
    \    let mid = arr.len() / 2;\n    let shift = (arr[0] + arr[arr.len() - 1]) %\
    \ 2;\n    match shift {\n        0 => arr.sort_by(|a, b| b.cmp(a)),\n        _\
    \ => arr.sort_by(|a, b| a.cmp(b)),\n    }\n    arr\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'index out of bounds: the len is 0 but the index\
    \ is 0', /tmp/tmpinyhtf7v.rs:14:18\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    let mut result = array.clone();\n\
    \    if array.len() > 0 {\n        let first = array[0];\n        let last = array[array.len()\
    \ - 1];\n        let sum = first + last;\n        if sum % 2 == 0 {\n        \
    \    result.sort_by(|a, b| b.cmp(a));\n        } else {\n            result.sort_by(|a,\
    \ b| a.cmp(b));\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n\
    \        return array;\n    }\n    let mut array = array;\n    let sort_fn = if\
    \ array[0] + array[array.len() - 1] % 2 == 0 {\n        |lhs: &isize, rhs: &isize|\
    \ rhs.cmp(lhs)\n    } else {\n        |lhs: &isize, rhs: &isize| lhs.cmp(rhs)\n\
    \    };\n    array.sort_by(sort_fn);\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpbrevg6xv.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    // TODO: implement me\n\
    \    panic!(\"unimplemented!\");\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'unimplemented!', /tmp/tmpphmoq6nh.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() <= 1 {\n\
    \        return array;\n    }\n    let mut vector = array.clone();\n    if (array[0]\
    \ + array[array.len() - 1]) % 2 == 0 {\n        vector.sort_by(|a, b| b.cmp(a));\n\
    \    } else {\n        vector.sort_by(|a, b| a.cmp(b));\n    }\n    vector\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// * sort_array([]) => []\n\
    /// * sort_array([5]) => [5]\n/// * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2,\
    \ 3, 4, 5]\n/// * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n\
    fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    if array.len() == 0 {\n\
    \        return vec![];\n    }\n\n    let mut sorted_array = array.clone();\n\
    \    sorted_array.sort();\n\n    if array[0] + array[array.len() - 1] % 2 == 0\
    \ {\n        sorted_array.reverse();\n    }\n\n    sorted_array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp47sgxc_8.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
