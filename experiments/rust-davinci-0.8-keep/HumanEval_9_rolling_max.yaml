name: HumanEval_9_rolling_max
language: rust
prompt: "/// From a given list of integers, generate a list of rolling maximum element\
  \ found until given moment\n/// in the sequence.\n/// >>> rolling_max([1, 2, 3,\
  \ 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) ->\
  \ Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
  \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
  \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3,\
  \ 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
completions: ["    let mut rolling_max = Vec::new();\n    rolling_max.push(numbers[0]);\n\
    \    for i in 1..numbers.len() {\n        let max = cmp::max(rolling_max[i - 1],\
    \ numbers[i]);\n        rolling_max.push(max);\n    }\n    rolling_max", "   \
    \ let mut mx = numbers[0];\n    let mut output = vec![mx];\n    for i in numbers[1..].iter()\
    \ {\n        mx = std::cmp::max(mx, *i);\n        output.push(mx);\n    }\n  \
    \  output", "    if numbers.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut numbers = numbers;\n    numbers.reverse();\n\n    let mut rolling_max\
    \ = vec![numbers[0]];\n    for n in numbers.iter().skip(1) {\n        let last_max\
    \ = rolling_max.last().unwrap();\n        rolling_max.push(last_max.max(*n));\n\
    \    }\n\n    rolling_max.reverse();\n    rolling_max", "    let mut result =\
    \ Vec::with_capacity(numbers.len());\n    let mut current_max = numbers[0];\n\
    \    result.push(current_max);\n    for number in numbers.iter().skip(1) {\n \
    \       current_max = std::cmp::max(current_max, *number);\n        result.push(current_max);\n\
    \    }\n    result", "    let mut res = Vec::with_capacity(numbers.len());\n \
    \   let mut current_max = numbers[0];\n    res.push(current_max);\n    for el\
    \ in numbers.iter().skip(1) {\n        if *el > current_max {\n            current_max\
    \ = *el;\n        }\n        res.push(current_max);\n    }\n    res", "    let\
    \ mut max_values = Vec::new();\n    for (i, num) in numbers.iter().enumerate()\
    \ {\n        if i == 0 {\n            max_values.push(*num);\n        } else {\n\
    \            max_values.push(max_values[i - 1].max(*num));\n        }\n    }\n\
    \    max_values", "    use std::cmp::max;\n    let mut rolling_max = vec![];\n\
    \    let mut m = numbers[0];\n    rolling_max.push(m);\n    for i in 1..numbers.len()\
    \ {\n        m = max(m, numbers[i]);\n        rolling_max.push(m);\n    }\n  \
    \  rolling_max", "    let mut result = Vec::new();\n    let mut max_sofar = std::isize::MIN;\n\
    \    for &v in numbers.iter() {\n        max_sofar = std::cmp::max(max_sofar,\
    \ v);\n        result.push(max_sofar);\n    }\n    result", "    let mut max =\
    \ None;\n    let mut new_numbers = Vec::new();\n    for n in numbers {\n     \
    \   if max.is_none() || n > max.unwrap() {\n            max = Some(n);\n     \
    \   }\n        new_numbers.push(max.unwrap());\n    }\n    new_numbers", "   \
    \ let mut acc = vec![];\n    let mut current_max = numbers[0];\n    for num in\
    \ numbers {\n        if num > current_max {\n            current_max = num;\n\
    \        }\n        acc.push(current_max);\n    }\n    acc", "    let mut result\
    \ = Vec::new();\n    let mut max_so_far = std::isize::MIN;\n    for i in numbers\
    \ {\n        if i > max_so_far {\n            max_so_far = i;\n        }\n   \
    \     result.push(max_so_far);\n    }\n    result", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut max = isize::min_value();\n    for i in 0..numbers.len() {\n    \
    \    if numbers[i] > max {\n            max = numbers[i];\n        }\n       \
    \ result.push(max);\n    }\n    result", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut current_max = isize::min_value();\n    for n in numbers {\n     \
    \   if n > current_max {\n            current_max = n;\n        }\n        result.push(current_max);\n\
    \    }\n    result", "    let mut result = Vec::new();\n    let mut max_value\
    \ = 0;\n    for number in numbers {\n        max_value = std::cmp::max(max_value,\
    \ number);\n        result.push(max_value);\n    }\n    result", "    let mut\
    \ maximums = vec![];\n    let mut maximum = isize::min_value();\n    for number\
    \ in numbers {\n        maximum = std::cmp::max(maximum, number);\n        maximums.push(maximum);\n\
    \    }\n    maximums", "    let mut max = numbers[0];\n    let mut rolling_max\
    \ = Vec::new();\n    rolling_max.push(max);\n    for &number in numbers.iter().skip(1)\
    \ {\n        max = std::cmp::max(max, number);\n        rolling_max.push(max);\n\
    \    }\n    rolling_max", "    let mut res = Vec::new();\n    let mut rolling_max\
    \ = 0;\n    for n in numbers {\n        rolling_max = max(rolling_max, n);\n \
    \       res.push(rolling_max);\n    }\n    res", "    use std::cmp::max;\n   \
    \ let mut result = Vec::new();\n    let mut rolling_max = numbers[0];\n    result.push(rolling_max);\n\
    \    for x in numbers[1..].iter() {\n        rolling_max = max(rolling_max, *x);\n\
    \        result.push(rolling_max);\n    }\n    result", "    let mut solution\
    \ = Vec::with_capacity(numbers.len());\n    let mut max = isize::min_value();\n\
    \    for i in numbers {\n        max = max.max(i);\n        solution.push(max);\n\
    \    }\n    solution", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut current_max = numbers[0];\n    result.push(current_max);\n    for\
    \ (i, number) in numbers.iter().enumerate().skip(1) {\n        if number > &current_max\
    \ {\n            current_max = *number;\n        }\n        result.push(current_max);\n\
    \    }\n    result", "    use std::cmp::max;\n    let mut result = Vec::new();\n\
    \    result.push(numbers[0]);\n    for i in 1..numbers.len() {\n        result.push(max(result[i\
    \ - 1], numbers[i]));\n    }\n    result", "    let mut rolling_max = vec![];\n\
    \    let mut max_number = std::isize::MIN;\n    for n in numbers {\n        if\
    \ n > max_number {\n            max_number = n;\n        }\n        rolling_max.push(max_number);\n\
    \    }\n    rolling_max", "    let mut max_elements = Vec::new();\n    let mut\
    \ current_max = None;\n\n    for number in numbers {\n        if let Some(last_max)\
    \ = current_max {\n            if number >= last_max {\n                current_max\
    \ = Some(number);\n            }\n        } else {\n            current_max =\
    \ Some(number);\n        }\n\n        max_elements.push(current_max.unwrap());\n\
    \    }\n\n    max_elements", "    let mut maximums = Vec::new();\n    for number\
    \ in numbers {\n        if maximums.is_empty() {\n            maximums.push(number);\n\
    \        } else {\n            maximums.push(cmp::max(maximums.last().unwrap(),\
    \ &number));\n        }\n    }\n    maximums", "    let mut maxes = Vec::with_capacity(numbers.len());\n\
    \    for i in 0..numbers.len() {\n        let current_max = if i == 0 {\n    \
    \        numbers[i]\n        } else {\n            maxes[i - 1].max(numbers[i])\n\
    \        };\n        maxes.push(current_max);\n    }\n    maxes", "    let mut\
    \ out = Vec::new();\n    let mut curr_max = std::isize::MIN;\n    for &n in numbers.iter()\
    \ {\n        curr_max = std::cmp::max(curr_max, n);\n        out.push(curr_max);\n\
    \    }\n    out", "    // Method one: O(n^2)\n    // let mut result = Vec::new();\n\
    \    // for (i, elem) in numbers.iter().enumerate() {\n    //     let mut max\
    \ = *elem;\n    //     for number in &numbers[..i] {\n    //         if *number\
    \ > max {\n    //             max = *number;\n    //         }\n    //     }\n\
    \    //     result.push(max);\n    // }\n    // result\n\n    // Method two: O(n)\n\
    \    let mut stack = Vec::new();\n    let mut result = Vec::new();\n    for number\
    \ in numbers {\n        if stack.is_empty() || number > stack[stack.len() - 1]\
    \ {\n            stack.push(number);\n        } else {\n            let mut i\
    \ = stack.len() - 1;\n            while !stack.is_empty() && stack[i] > number\
    \ {\n                stack.pop();\n                i -= 1;\n            }\n  \
    \          stack.push(number);\n        }\n        result.push(stack[stack.len()\
    \ - 1]);\n    }\n    result", "    let mut max: Vec<isize> = Vec::new();\n   \
    \ let mut max_so_far = std::isize::MIN;\n    for i in numbers {\n        max_so_far\
    \ = std::cmp::max(max_so_far, i);\n        max.push(max_so_far);\n    }\n    max",
  "    let mut output = Vec::with_capacity(numbers.len());\n    let mut curr_max =\
    \ 0;\n    for num in numbers {\n        curr_max = if num > curr_max { num } else\
    \ { curr_max };\n        output.push(curr_max);\n    }\n    output", "    let\
    \ mut result = Vec::new();\n    let mut current_max = std::isize::MIN;\n    for\
    \ number in numbers {\n        if number > current_max {\n            current_max\
    \ = number;\n        }\n        result.push(current_max);\n    }\n    result",
  "    let mut maximums = Vec::with_capacity(numbers.len());\n    let mut current_max\
    \ = std::isize::MIN;\n    for i in numbers {\n        if i > current_max {\n \
    \           current_max = i;\n        }\n        maximums.push(current_max);\n\
    \    }\n    maximums", "    numbers\n        .iter()\n        .scan(std::isize::MIN,\
    \ |acc, &curr| {\n            *acc = std::cmp::max(*acc, curr);\n            Some(*acc)\n\
    \        })\n        .collect()", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut curr_max = *numbers.first().unwrap();\n    for &n in numbers.iter()\
    \ {\n        curr_max = std::cmp::max(curr_max, n);\n        result.push(curr_max);\n\
    \    }\n    result", "    numbers\n        .into_iter()\n        .scan(None, |state,\
    \ next| {\n            *state = Some(state.map_or(next, |s| s.max(next)));\n \
    \           state.clone()\n        })\n        .collect()", "    let mut result\
    \ = Vec::with_capacity(numbers.len());\n    result.push(numbers[0]);\n    for\
    \ i in 1..numbers.len() {\n        let max = std::cmp::max(result[i - 1], numbers[i]);\n\
    \        result.push(max);\n    }\n    result", "    let mut rolling_max: Vec<isize>\
    \ = vec![numbers[0]];\n    let mut it = numbers.iter();\n    it.next();\n    for\
    \ x in it {\n        rolling_max.push(cmp::max(*x, *rolling_max.last().unwrap()));\n\
    \    }\n    rolling_max", "    let mut max = std::isize::MIN;\n    let mut results\
    \ = Vec::new();\n    for n in numbers {\n        max = std::cmp::max(max, n);\n\
    \        results.push(max);\n    }\n    results", "    let mut max = numbers[0];\n\
    \    let mut results = vec![max];\n    for n in numbers[1..].iter() {\n      \
    \  max = n.max(max);\n        results.push(max);\n    }\n    results", "    let\
    \ mut result = Vec::with_capacity(numbers.len());\n    let mut max = isize::min_value();\n\
    \    for n in numbers {\n        if n > max {\n            max = n;\n        }\n\
    \        result.push(max);\n    }\n    result", "    let mut rolling_max = Vec::with_capacity(numbers.len());\n\
    \    let mut current_max = numbers[0];\n    rolling_max.push(current_max);\n \
    \   for &number in numbers.iter().skip(1) {\n        if number > current_max {\n\
    \            current_max = number;\n        }\n        rolling_max.push(current_max);\n\
    \    }\n    rolling_max", "    let mut maximums = vec![];\n    maximums.push(numbers[0]);\n\
    \    for number in numbers.iter().skip(1) {\n        let last_maximum = maximums.last().unwrap();\n\
    \        if *number > *last_maximum {\n            maximums.push(*number);\n \
    \       } else {\n            maximums.push(*last_maximum);\n        }\n    }\n\
    \    maximums", "    let mut max_value = std::isize::MIN;\n    let mut rolling_max\
    \ = Vec::new();\n    for number in numbers {\n        max_value = std::cmp::max(max_value,\
    \ number);\n        rolling_max.push(max_value);\n    }\n    rolling_max", " \
    \   let mut result = Vec::with_capacity(numbers.len());\n    let mut current_max\
    \ = numbers[0];\n    result.push(current_max);\n    for item in numbers.iter().skip(1)\
    \ {\n        if *item > current_max {\n            current_max = *item;\n    \
    \    }\n        result.push(current_max);\n    }\n    result", "    let n = numbers.len();\n\
    \    let mut window = Vec::with_capacity(n);\n    let mut res = Vec::with_capacity(n);\n\
    \    for i in 0..n {\n        while !window.is_empty() && numbers[i] >= numbers[window[window.len()\
    \ - 1]] {\n            window.pop();\n        }\n        window.push(i);\n   \
    \     res.push(numbers[window[0]]);\n    }\n    res", "    let mut results = Vec::new();\n\
    \    let mut current_max = -100;\n\n    for number in numbers {\n        current_max\
    \ = std::cmp::max(current_max, number);\n        results.push(current_max);\n\
    \    }\n\n    results", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut max_so_far = numbers[0];\n    result.push(max_so_far);\n    for i\
    \ in 1..numbers.len() {\n        max_so_far = max(max_so_far, numbers[i]);\n \
    \       result.push(max_so_far);\n    }\n    result", "    let mut rolling_max\
    \ = Vec::with_capacity(numbers.len());\n    let mut current_max = std::isize::MIN;\n\
    \    for number in numbers {\n        if number > current_max {\n            current_max\
    \ = number;\n        }\n        rolling_max.push(current_max);\n    }\n    rolling_max",
  "    let mut result = Vec::new();\n    let mut max_till_now = -1;\n    for n in\
    \ numbers {\n        if n > max_till_now {\n            max_till_now = n;\n  \
    \      }\n        result.push(max_till_now);\n    }\n    result", "    let mut\
    \ res = Vec::new();\n    let mut maximum = 0;\n    for i in numbers {\n      \
    \  maximum = std::cmp::max(maximum, i);\n        res.push(maximum);\n    }\n \
    \   res", "    let mut result = Vec::new();\n    let mut max = None;\n    for\
    \ number in numbers {\n        match max {\n            None => {\n          \
    \      max = Some(number);\n            }\n            Some(last_max) => {\n \
    \               max = Some(last_max.max(number));\n            }\n        }\n\
    \        result.push(max.unwrap());\n    }\n    result", "    let mut result =\
    \ Vec::with_capacity(numbers.len());\n    let mut max = numbers[0];\n    result.push(max);\n\
    \    for n in numbers.iter().skip(1) {\n        if n > &max {\n            max\
    \ = *n;\n        }\n        result.push(max);\n    }\n    result", "    let mut\
    \ result = Vec::new();\n    let mut max_element = isize::min_value();\n    for\
    \ element in numbers {\n        if element > max_element {\n            max_element\
    \ = element;\n        }\n        result.push(max_element);\n    }\n    result",
  "    let mut max_elements = vec![];\n    let mut max_element = numbers[0];\n   \
    \ max_elements.push(max_element);\n    for i in 1..numbers.len() {\n        if\
    \ numbers[i] > max_element {\n            max_element = numbers[i];\n        }\n\
    \        max_elements.push(max_element);\n    }\n    max_elements", "    let mut\
    \ result = Vec::with_capacity(numbers.len());\n    let mut max_element = std::isize::MIN;\n\
    \    for element in numbers {\n        max_element = max(max_element, element);\n\
    \        result.push(max_element);\n    }\n    result", "    let mut rolling_max:\
    \ Vec<isize> = Vec::new();\n    for &number in numbers.iter() {\n        if rolling_max.is_empty()\
    \ {\n            rolling_max.push(number);\n        } else {\n            let\
    \ current_max = rolling_max.last().unwrap();\n            rolling_max.push(current_max.max(number));\n\
    \        }\n    }\n    rolling_max", "    let mut max = -1;\n    let mut result\
    \ = Vec::with_capacity(numbers.len());\n    for number in numbers {\n        if\
    \ number > max {\n            max = number;\n        }\n        result.push(max);\n\
    \    }\n    result", "    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for number in numbers.iter().skip(1) {\n        max\
    \ = max.max(*number);\n        result.push(max);\n    }\n    result", "    let\
    \ mut max = std::isize::MIN;\n    let mut res = Vec::with_capacity(numbers.len());\n\
    \    for n in numbers {\n        max = std::cmp::max(max, n);\n        res.push(max);\n\
    \    }\n    res", "    let mut max = isize::min_value();\n    let mut rolling_max\
    \ = Vec::new();\n    for n in numbers {\n        max = n.max(max);\n        rolling_max.push(max);\n\
    \    }\n    rolling_max", "    let mut result = Vec::new();\n    let mut max =\
    \ numbers[0];\n    result.push(max);\n    for n in numbers.iter().skip(1) {\n\
    \        if *n > max {\n            max = *n;\n        }\n        result.push(max);\n\
    \    }\n    result", "    let mut result = Vec::new();\n    let mut current_max\
    \ = isize::min_value();\n    for &n in numbers.iter() {\n        current_max =\
    \ current_max.max(n);\n        result.push(current_max);\n    }\n    result",
  "    let mut max_stack = Vec::new();\n    let mut res = Vec::new();\n\n    for number\
    \ in numbers {\n        if number >= max_stack.last().unwrap_or(&number) {\n \
    \           max_stack.push(number);\n        }\n        res.push(max_stack.last().unwrap().clone());\n\
    \    }\n\n    res", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut max = isize::min_value();\n    for n in numbers {\n        if n >\
    \ max {\n            max = n;\n        }\n        result.push(max);\n    }\n \
    \   result", "    numbers\n        .into_iter()\n        .scan(std::isize::MIN,\
    \ |state, x| {\n            *state = *state.max(&x);\n            Some(*state)\n\
    \        })\n        .collect()", "    let mut max_num = None;\n    let mut max_nums\
    \ = Vec::new();\n    for num in numbers {\n        if let Some(max) = max_num\
    \ {\n            if num > max {\n                max_num = Some(num);\n      \
    \      }\n        } else {\n            max_num = Some(num);\n        }\n    \
    \    max_nums.push(max_num.unwrap());\n    }\n    max_nums", "    let mut max_numbers\
    \ = Vec::with_capacity(numbers.len());\n    let mut max_number = isize::min_value();\n\
    \    for number in numbers {\n        max_number = std::cmp::max(max_number, number);\n\
    \        max_numbers.push(max_number);\n    }\n    max_numbers", "    let mut\
    \ max = numbers[0];\n    let mut result = vec![];\n    for number in numbers {\n\
    \        if number > max {\n            max = number;\n        }\n        result.push(max);\n\
    \    }\n    result", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut current_max = std::isize::MIN;\n    for n in numbers {\n        current_max\
    \ = std::cmp::max(current_max, n);\n        result.push(current_max);\n    }\n\
    \    result", "    let mut result = Vec::new();\n    let mut current_max = isize::min_value();\n\
    \    for num in numbers {\n        if num > current_max {\n            current_max\
    \ = num;\n        }\n        result.push(current_max);\n    }\n    result", " \
    \   let mut result = Vec::new();\n    for n in numbers {\n        if result.len()\
    \ == 0 {\n            result.push(n);\n        } else {\n            result.push(std::cmp::max(result[result.len()\
    \ - 1], n));\n        }\n    }\n    result", "    let mut max_number = 0;\n  \
    \  let mut maximums = Vec::new();\n    for number in numbers {\n        max_number\
    \ = std::cmp::max(max_number, number);\n        maximums.push(max_number);\n \
    \   }\n    maximums", "    let mut max_so_far = Vec::with_capacity(numbers.len());\n\
    \    let mut max = numbers[0];\n    max_so_far.push(max);\n    for &number in\
    \ numbers.iter().skip(1) {\n        max = max.max(number);\n        max_so_far.push(max);\n\
    \    }\n    max_so_far", "    let mut max: isize = numbers[0];\n    let mut ret\
    \ = Vec::new();\n    ret.push(max);\n    for i in 1..numbers.len() {\n       \
    \ if numbers[i] > max {\n            max = numbers[i];\n        }\n        ret.push(max);\n\
    \    }\n    ret", "    let mut max: isize = std::isize::MIN;\n    let mut result:\
    \ Vec<isize> = Vec::new();\n    for number in numbers {\n        max = max.max(number);\n\
    \        result.push(max);\n    }\n    result", "    let mut max: isize = 0;\n\
    \    let mut result: Vec<isize> = Vec::new();\n    for i in numbers {\n      \
    \  max = std::cmp::max(max, i);\n        result.push(max);\n    }\n    result",
  "    numbers\n        .into_iter()\n        .scan(isize::min_value(), |state, next|\
    \ {\n            *state = *state.max(&next);\n            Some(*state)\n     \
    \   })\n        .collect()", "    let mut maximums = vec![];\n    let mut current_max\
    \ = isize::min_value();\n    for n in numbers {\n        if n > current_max {\n\
    \            current_max = n;\n        }\n        maximums.push(current_max);\n\
    \    }\n    maximums", "    let mut current_max = numbers[0];\n    let mut results\
    \ = vec![current_max];\n\n    for n in numbers.iter().skip(1) {\n        if n\
    \ > &current_max {\n            current_max = *n;\n        }\n        results.push(current_max);\n\
    \    }\n\n    results", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    if let Some(first) = numbers.first() {\n        result.push(*first);\n  \
    \  }\n    for i in 1..numbers.len() {\n        let max = numbers[i]\n        \
    \    .max(result[i - 1])\n            .max(result[result.len() - 1]);\n      \
    \  result.push(max);\n    }\n    result", "    let mut result = Vec::new();\n\
    \    let mut max = -999;\n    for number in numbers {\n        if number > max\
    \ {\n            max = number;\n        }\n        result.push(max);\n    }\n\
    \    result", "    let mut max = numbers[0];\n    let mut result = vec![max];\n\
    \    for number in numbers.iter().skip(1) {\n        max = number.max(max);\n\
    \        result.push(max);\n    }\n    result", "    let mut rolling_max_numbers\
    \ = Vec::new();\n    let mut rolling_max = 0;\n    for n in numbers {\n      \
    \  rolling_max = std::cmp::max(rolling_max, n);\n        rolling_max_numbers.push(rolling_max);\n\
    \    }\n    rolling_max_numbers", "    let mut accumulator = Vec::new();\n   \
    \ let mut current_max = isize::min_value();\n    for number in numbers {\n   \
    \     if number > current_max {\n            current_max = number;\n        }\n\
    \        accumulator.push(current_max);\n    }\n    accumulator", "    let mut\
    \ max_elems = Vec::with_capacity(numbers.len());\n    let mut local_max = None;\n\
    \    for n in numbers {\n        if let Some(x) = local_max {\n            if\
    \ n > x {\n                local_max = Some(n);\n            }\n        } else\
    \ {\n            local_max = Some(n);\n        }\n        max_elems.push(local_max.unwrap_or(n));\n\
    \    }\n    max_elems", "    let mut rolling_max = vec![];\n    let mut current_max\
    \ = std::isize::MIN;\n    for number in numbers {\n        if number > current_max\
    \ {\n            current_max = number;\n        }\n        rolling_max.push(current_max);\n\
    \    }\n    rolling_max", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    if numbers.len() > 0 {\n        let mut rolling_max = numbers[0];\n     \
    \   result.push(rolling_max);\n        for i in 1..numbers.len() {\n         \
    \   rolling_max = cmp::max(rolling_max, numbers[i]);\n            result.push(rolling_max);\n\
    \        }\n    }\n    result", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut max = numbers[0];\n    result.push(max);\n    for i in 1..numbers.len()\
    \ {\n        if numbers[i] > max {\n            max = numbers[i];\n        }\n\
    \        result.push(max);\n    }\n    result", "    let mut ret = Vec::new();\n\
    \    let mut max = numbers[0];\n    ret.push(max);\n    for &number in numbers.iter().skip(1)\
    \ {\n        if number > max {\n            max = number;\n        }\n       \
    \ ret.push(max);\n    }\n    ret", "    let mut rolling_max: Vec<isize> = vec![];\n\
    \    let mut max_value = std::isize::MIN;\n    for number in numbers {\n     \
    \   max_value = std::cmp::max(max_value, number);\n        rolling_max.push(max_value);\n\
    \    }\n    rolling_max", "    let mut max_found = None;\n    let mut result =\
    \ Vec::new();\n    for number in numbers {\n        match max_found {\n      \
    \      None => max_found = Some(number),\n            Some(max) => max_found =\
    \ Some(max.max(number)),\n        }\n        result.push(max_found.unwrap());\n\
    \    }\n    result", "    let mut res = Vec::with_capacity(numbers.len());\n \
    \   let mut max = numbers[0];\n    res.push(max);\n    for i in numbers.iter().skip(1)\
    \ {\n        if i > &max {\n            max = *i;\n        }\n        res.push(max);\n\
    \    }\n    res", "    let mut rolling_max = Vec::new();\n    let mut max = std::isize::MIN;\n\
    \    for number in numbers {\n        max = std::cmp::max(max, number);\n    \
    \    rolling_max.push(max);\n    }\n    rolling_max", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut max = numbers[0];\n    result.push(max);\n    for i in 1..numbers.len()\
    \ {\n        if numbers[i] > max {\n            max = numbers[i];\n        }\n\
    \        result.push(max);\n    }\n    result", "    let mut max_so_far = numbers[0];\n\
    \    let mut result = vec![max_so_far];\n    for current in numbers.iter().skip(1)\
    \ {\n        max_so_far = std::cmp::max(max_so_far, *current);\n        result.push(max_so_far);\n\
    \    }\n    result", "    numbers\n        .iter()\n        .scan(isize::min_value(),\
    \ |state, x| {\n            *state = std::cmp::max(*state, *x);\n            Some(*state)\n\
    \        })\n        .collect()", "    let mut rolling_maxes = vec![];\n    for\
    \ number in numbers {\n        if rolling_maxes.is_empty() {\n            rolling_maxes.push(number);\n\
    \        } else {\n            rolling_maxes.push(rolling_maxes.last().unwrap().max(number));\n\
    \        }\n    }\n    rolling_maxes", "    let mut rolling_max = Vec::new();\n\
    \    let mut current_max = isize::min_value();\n    for n in numbers {\n     \
    \   current_max = max(current_max, n);\n        rolling_max.push(current_max);\n\
    \    }\n    rolling_max", "    let mut max = numbers[0];\n    let mut result =\
    \ vec![max];\n    for &number in numbers.iter().skip(1) {\n        if number >\
    \ max {\n            max = number;\n        }\n        result.push(max);\n   \
    \ }\n    result", "    let mut max_numbers = vec![];\n    let mut current_max\
    \ = 0;\n    for num in numbers {\n        if num > current_max {\n           \
    \ current_max = num;\n        }\n        max_numbers.push(current_max);\n    }\n\
    \    max_numbers", "    let mut result = Vec::new();\n    let mut max = std::isize::MIN;\n\
    \    for number in numbers {\n        max = std::cmp::max(max, number);\n    \
    \    result.push(max);\n    }\n    result", "    let mut max = isize::min_value();\n\
    \    let mut result = Vec::new();\n    for number in numbers {\n        max =\
    \ max.max(number);\n        result.push(max);\n    }\n    result", "    let mut\
    \ maximum = 0;\n    let mut result = Vec::with_capacity(numbers.len());\n    for\
    \ i in numbers {\n        maximum = max(maximum, i);\n        result.push(maximum);\n\
    \    }\n    result", "    let mut running_max = numbers[0];\n    let mut max_list\
    \ = vec![running_max];\n    for i in 1..numbers.len() {\n        if numbers[i]\
    \ > running_max {\n            running_max = numbers[i];\n        }\n        max_list.push(running_max);\n\
    \    }\n    max_list", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut max = numbers[0];\n    result.push(max);\n    for number in numbers[1..].iter()\
    \ {\n        max = max.max(*number);\n        result.push(max);\n    }\n    result",
  "    numbers\n        .iter()\n        .scan(0, |state, &next| {\n            if\
    \ next > *state {\n                *state = next;\n            }\n           \
    \ Some(*state)\n        })\n        .collect()", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut current_max = numbers[0];\n    result.push(current_max);\n    for\
    \ number in numbers.iter().skip(1) {\n        if *number > current_max {\n   \
    \         current_max = *number;\n        }\n        result.push(current_max);\n\
    \    }\n    result", "    let mut results = Vec::new();\n    let mut max_so_far\
    \ = isize::min_value();\n    for number in numbers {\n        max_so_far = max(max_so_far,\
    \ number);\n        results.push(max_so_far);\n    }\n    results", "    let mut\
    \ output = Vec::with_capacity(numbers.len());\n    let mut current_max = -1;\n\
    \    for (i, n) in numbers.iter().enumerate() {\n        current_max = if *n >\
    \ current_max {\n            *n\n        } else {\n            current_max\n \
    \       };\n        output.push(current_max);\n    }\n    output", "    let mut\
    \ stack = vec![];\n    let mut rolling_max = vec![];\n\n    for n in numbers {\n\
    \        if stack.is_empty() || n > stack[stack.len() - 1] {\n            stack.push(n);\n\
    \        } else {\n            let mut smallest_index = stack.len() - 1;\n   \
    \         while !stack.is_empty() && stack[stack.len() - 1] > n {\n          \
    \      stack.pop();\n                smallest_index -= 1;\n            }\n   \
    \         stack.push(n);\n        }\n        rolling_max.push(stack[smallest_index]);\n\
    \    }\n\n    rolling_max", "    numbers\n        .iter()\n        .scan(isize::min_value(),\
    \ |max, &x| {\n            *max = *max.max(&x);\n            Some(*max)\n    \
    \    })\n        .collect()", "    let mut last_max = numbers[0];\n    let mut\
    \ result = vec![last_max];\n    for number in numbers.iter().skip(1) {\n     \
    \   let max = if *number > last_max {\n            *number\n        } else {\n\
    \            last_max\n        };\n        result.push(max);\n        last_max\
    \ = max;\n    }\n    result", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut current_max = numbers[0];\n    result.push(current_max);\n    for\
    \ i in 1..numbers.len() {\n        if numbers[i] > current_max {\n           \
    \ current_max = numbers[i];\n        }\n        result.push(current_max);\n  \
    \  }\n    result", "    let mut res = Vec::new();\n    let mut max_number = numbers[0];\n\
    \    res.push(max_number);\n    for i in 1..numbers.len() {\n        max_number\
    \ = std::cmp::max(max_number, numbers[i]);\n        res.push(max_number);\n  \
    \  }\n    res", "    let mut result = Vec::new();\n    let mut current_max = 0;\n\
    \    for num in numbers {\n        if num > current_max {\n            current_max\
    \ = num;\n        }\n        result.push(current_max);\n    }\n    result", " \
    \   let mut result = Vec::with_capacity(numbers.len());\n    result.push(numbers[0]);\n\
    \    for number in numbers.iter().skip(1) {\n        result.push(number.max(result.last().unwrap()));\n\
    \    }\n    result", "    let mut max: isize = std::isize::MIN;\n    let mut r:\
    \ Vec<isize> = Vec::new();\n    for n in numbers {\n        max = max.max(n);\n\
    \        r.push(max);\n    }\n    r", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut current_max = numbers[0];\n    result.push(current_max);\n    for\
    \ &number in numbers.iter().skip(1) {\n        current_max = max(current_max,\
    \ number);\n        result.push(current_max);\n    }\n    result", "    let mut\
    \ result = Vec::with_capacity(numbers.len());\n    let mut max_so_far = 0;\n \
    \   for x in numbers {\n        if x > max_so_far {\n            max_so_far =\
    \ x;\n        }\n        result.push(max_so_far);\n    }\n    result", "    let\
    \ mut result = Vec::new();\n    let mut current_max = 0;\n    for i in 0..numbers.len()\
    \ {\n        current_max = std::cmp::max(current_max, numbers[i]);\n        result.push(current_max);\n\
    \    }\n    result", "    let mut max_elements = Vec::new();\n    for i in numbers\
    \ {\n        max_elements.push(max(i, *max_elements.last().unwrap_or(&i)));\n\
    \    }\n    max_elements", '    unimplemented!();', "    let mut result = Vec::new();\n\
    \    let mut max_so_far = numbers[0];\n    result.push(max_so_far);\n    for n\
    \ in numbers.iter().skip(1) {\n        max_so_far = max_so_far.max(*n);\n    \
    \    result.push(max_so_far);\n    }\n    result", "    let mut result = Vec::new();\n\
    \    let mut max = numbers[0];\n    result.push(max);\n    for &n in numbers.iter().skip(1)\
    \ {\n        if n > max {\n            max = n;\n        }\n        result.push(max);\n\
    \    }\n    result", "    let mut ret = Vec::new();\n    let mut max = numbers[0];\n\
    \    ret.push(max);\n    for number in numbers.iter().skip(1) {\n        if *number\
    \ > max {\n            max = *number;\n        }\n        ret.push(max);\n   \
    \ }\n    ret", "    let mut max = 0;\n    let mut maxes = Vec::new();\n    for\
    \ number in numbers {\n        max = std::cmp::max(max, number);\n        maxes.push(max);\n\
    \    }\n    maxes", "    let mut max = numbers[0];\n    let mut result = vec![max];\n\
    \    for n in numbers.iter().skip(1) {\n        max = cmp::max(max, *n);\n   \
    \     result.push(max);\n    }\n    result", "    let mut result = Vec::new();\n\
    \    let mut max = numbers[0];\n    result.push(max);\n    for &number in numbers.iter().skip(1)\
    \ {\n        max = max.max(number);\n        result.push(max);\n    }\n    result",
  "    let mut output = Vec::with_capacity(numbers.len());\n    if numbers.len() ==\
    \ 0 {\n        return output;\n    }\n    output.push(numbers[0]);\n    for n\
    \ in numbers[1..].iter() {\n        output.push(cmp::max(output[output.len() -\
    \ 1], *n));\n    }\n    output", "    let mut max_numbers = Vec::new();\n    let\
    \ mut running_max = numbers[0];\n    max_numbers.push(running_max);\n    for number\
    \ in numbers.iter().skip(1) {\n        if number > &running_max {\n          \
    \  running_max = *number;\n        }\n        max_numbers.push(running_max);\n\
    \    }\n    max_numbers", "    let mut rolling_max = Vec::with_capacity(numbers.len());\n\
    \    let mut current_max = isize::min_value();\n    for number in numbers {\n\
    \        if number > current_max {\n            current_max = number;\n      \
    \  }\n        rolling_max.push(current_max);\n    }\n    rolling_max", "    //\
    \ Create a vector of the same size, to be filled with maximum elements\n    let\
    \ mut rolling_max: Vec<isize> = Vec::with_capacity(numbers.len());\n\n    // Use\
    \ the head of the list as the first element of the rolling maximum\n    rolling_max.push(numbers[0]);\n\
    \n    // Iterate over all elements except the first one, comparing them to\n \
    \   // the value pushed to rolling_max.\n    // Push the maximum value of the\
    \ two to the rolling_max vector.\n    for number in numbers.iter().skip(1) {\n\
    \        rolling_max.push(std::cmp::max(rolling_max[rolling_max.len() - 1], *number));\n\
    \    }\n\n    rolling_max", "    numbers\n        .into_iter()\n        .scan(None,\
    \ |state, x| {\n            let max = state.map_or(x, |s| cmp::max(s, x));\n \
    \           *state = Some(max);\n            Some(max)\n        })\n        .collect()",
  "    let mut result = Vec::new();\n    let mut max = 0;\n    for n in numbers {\n\
    \        max = std::cmp::max(max, n);\n        result.push(max);\n    }\n    result",
  "    let mut result = Vec::new();\n    let mut current_max = std::isize::MIN;\n\
    \    for n in numbers {\n        current_max = std::cmp::max(current_max, n);\n\
    \        result.push(current_max);\n    }\n    result", "    let mut rolling_max:\
    \ Vec<isize> = Vec::new();\n    let mut max = std::isize::MIN;\n    for i in numbers\
    \ {\n        if i > max {\n            max = i;\n        }\n        rolling_max.push(max);\n\
    \    }\n    rolling_max", "    let mut rolling_max: Vec<isize> = Vec::new();\n\
    \    let mut max_value = std::isize::MIN;\n    for number in numbers {\n     \
    \   if number > max_value {\n            max_value = number;\n        }\n    \
    \    rolling_max.push(max_value);\n    }\n    rolling_max", "    let mut max_numbers\
    \ = Vec::new();\n    let mut max_value = isize::min_value();\n    for num in numbers\
    \ {\n        max_value = std::cmp::max(max_value, num);\n        max_numbers.push(max_value);\n\
    \    }\n    max_numbers", "    let mut maxes = Vec::with_capacity(numbers.len());\n\
    \    let mut current_max = std::isize::MIN;\n    for &number in numbers.iter()\
    \ {\n        current_max = current_max.max(number);\n        maxes.push(current_max);\n\
    \    }\n    maxes", "    let mut current_max = numbers[0];\n    let mut result\
    \ = vec![current_max];\n\n    for i in numbers.iter().skip(1) {\n        current_max\
    \ = max(current_max, *i);\n        result.push(current_max);\n    }\n\n    result",
  "    let mut rolling_max = vec![numbers[0]];\n    for i in numbers.iter().skip(1)\
    \ {\n        rolling_max.push(cmp::max(rolling_max.last().unwrap(), i));\n   \
    \ }\n    rolling_max", "    let mut max_so_far = numbers[0];\n    let mut rolling_max\
    \ = Vec::new();\n    rolling_max.push(max_so_far);\n\n    for i in 1..numbers.len()\
    \ {\n        max_so_far = cmp::max(max_so_far, numbers[i]);\n        rolling_max.push(max_so_far);\n\
    \    }\n\n    rolling_max", "    let mut result = Vec::new();\n    let mut max_till_now\
    \ = numbers[0];\n    result.push(max_till_now);\n    for n in numbers.iter().skip(1)\
    \ {\n        max_till_now = isize::max(max_till_now, *n);\n        result.push(max_till_now);\n\
    \    }\n    result", "    let mut result = Vec::new();\n    let mut current_max\
    \ = isize::min_value();\n    for n in numbers {\n        if n > current_max {\n\
    \            current_max = n;\n        }\n        result.push(current_max);\n\
    \    }\n    result", "    let mut result = Vec::new();\n    let mut max = std::isize::MIN;\n\
    \    for i in numbers {\n        if i > max {\n            max = i;\n        }\n\
    \        result.push(max);\n    }\n    result", "    if numbers.is_empty() {\n\
    \        return Vec::new();\n    }\n\n    let mut max_so_far = numbers[0];\n \
    \   let mut rolling_max = Vec::new();\n    rolling_max.push(max_so_far);\n\n \
    \   for number in numbers.iter().skip(1) {\n        if number > &max_so_far {\n\
    \            max_so_far = *number;\n        }\n        rolling_max.push(max_so_far);\n\
    \    }\n\n    rolling_max", "    let mut max = Vec::with_capacity(numbers.len());\n\
    \    let mut current_max = 0;\n    for n in numbers {\n        current_max = std::cmp::max(current_max,\
    \ n);\n        max.push(current_max);\n    }\n    max", "    let mut rolling_max\
    \ = vec![numbers[0]];\n    for n in numbers.iter().skip(1) {\n        rolling_max.push(rolling_max.last().unwrap().max(*n));\n\
    \    }\n    rolling_max", "    let mut result = Vec::new();\n    let mut current_max\
    \ = numbers[0];\n    result.push(current_max);\n    for n in numbers.iter().skip(1)\
    \ {\n        current_max = std::cmp::max(current_max, *n);\n        result.push(current_max);\n\
    \    }\n    result", "    let mut result = Vec::new();\n    let mut current_max\
    \ = numbers[0];\n    result.push(current_max);\n    for i in numbers.iter().skip(1)\
    \ {\n        current_max = std::cmp::max(current_max, *i);\n        result.push(current_max);\n\
    \    }\n    result", "    let mut max_so_far = 0;\n    let mut maxes = Vec::new();\n\
    \    for num in numbers {\n        max_so_far = max(max_so_far, num);\n      \
    \  maxes.push(max_so_far);\n    }\n    maxes", "    let mut result = Vec::new();\n\
    \    let mut max = numbers[0];\n    result.push(max);\n    for &x in numbers.iter().skip(1)\
    \ {\n        max = max.max(x);\n        result.push(max);\n    }\n    result",
  "    let mut maxes = vec![];\n    let mut max = numbers[0];\n    for &number in\
    \ numbers.iter() {\n        max = max.max(number);\n        maxes.push(max);\n\
    \    }\n    maxes", "    let mut max = numbers[0];\n    let mut rolling_max =\
    \ vec![max];\n    for i in 1..numbers.len() {\n        max = max.max(numbers[i]);\n\
    \        rolling_max.push(max);\n    }\n    rolling_max", "    numbers\n     \
    \   .iter()\n        .scan(std::isize::MIN, |max, x| {\n            if *x > *max\
    \ {\n                *max = *x;\n            }\n            Some(*max)\n     \
    \   })\n        .collect()", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut max = numbers[0];\n    result.push(max);\n    for i in 1..numbers.len()\
    \ {\n        if numbers[i] > max {\n            max = numbers[i];\n        }\n\
    \        result.push(max);\n    }\n    result", "    numbers\n        .iter()\n\
    \        .scan(isize::min_value(), |state, item| {\n            if *item > *state\
    \ {\n                *state = *item;\n            }\n            Some(*state)\n\
    \        })\n        .collect()", "    let mut result = Vec::new();\n    let mut\
    \ candidate = std::isize::MIN;\n    for number in numbers {\n        if number\
    \ > candidate {\n            candidate = number;\n        }\n        result.push(candidate);\n\
    \    }\n    result", "    let mut max = std::isize::MIN;\n    let mut out = Vec::new();\n\
    \    for &n in numbers.iter() {\n        if n > max {\n            max = n;\n\
    \        }\n        out.push(max);\n    }\n    out", "    let mut mx = numbers[0];\n\
    \    let mut res = vec![];\n    for i in numbers {\n        mx = if i > mx { i\
    \ } else { mx };\n        res.push(mx);\n    }\n    res", "    if numbers.is_empty()\
    \ {\n        return Vec::new();\n    }\n\n    let mut max = numbers[0];\n    let\
    \ mut indices = vec![max];\n\n    for n in numbers.iter().skip(1) {\n        if\
    \ n > &max {\n            max = *n;\n        }\n        indices.push(max);\n \
    \   }\n\n    indices", "    let mut rolling_max: Vec<isize> = Vec::new();\n  \
    \  let mut max_so_far = isize::min_value();\n    for number in numbers {\n   \
    \     max_so_far = max(max_so_far, number);\n        rolling_max.push(max_so_far);\n\
    \    }\n    rolling_max", "    let mut rolling_max = vec![];\n    let mut max\
    \ = std::isize::MIN;\n    for i in numbers {\n        max = max.max(i);\n    \
    \    rolling_max.push(max);\n    }\n    rolling_max", "    let mut max_val = -1;\n\
    \    let mut numbers = numbers;\n    numbers.reverse();\n    for number in numbers.iter_mut()\
    \ {\n        if *number > max_val {\n            max_val = *number;\n        }\n\
    \        *number = max_val;\n    }\n    numbers.reverse();\n    numbers", "  \
    \  let mut max_so_far = isize::min_value();\n    let mut result = Vec::with_capacity(numbers.len());\n\
    \    for x in numbers {\n        if x > max_so_far {\n            max_so_far =\
    \ x;\n        }\n        result.push(max_so_far);\n    }\n    result", "    let\
    \ mut result = Vec::with_capacity(numbers.len());\n    let mut current_max = numbers[0];\n\
    \    result.push(current_max);\n    for i in 1..numbers.len() {\n        current_max\
    \ = current_max.max(numbers[i]);\n        result.push(current_max);\n    }\n \
    \   result", "    let mut max_so_far = numbers[0];\n    let mut result = vec![max_so_far];\n\
    \    for n in numbers[1..].iter() {\n        if *n > max_so_far {\n          \
    \  max_so_far = *n;\n        }\n        result.push(max_so_far);\n    }\n    result",
  "    let mut result = Vec::with_capacity(numbers.len());\n    let mut max = 0;\n\
    \    for n in numbers {\n        max = std::cmp::max(max, n);\n        result.push(max);\n\
    \    }\n    result", "    let mut max_so_far = 0;\n    let mut result = Vec::new();\n\
    \    for n in numbers {\n        max_so_far = max(max_so_far, n);\n        result.push(max_so_far);\n\
    \    }\n    result", "    let mut max_until_idx = Vec::with_capacity(numbers.len());\n\
    \    let mut current_max = isize::min_value();\n    for i in 0..numbers.len()\
    \ {\n        if numbers[i] > current_max {\n            current_max = numbers[i];\n\
    \        }\n        max_until_idx.push(current_max);\n    }\n    max_until_idx",
  "    numbers\n        .into_iter()\n        .scan(std::isize::MIN, |max, x| {\n\
    \            *max = std::cmp::max(*max, x);\n            Some(*max)\n        })\n\
    \        .collect()", "    let mut max_found_so_far = 0;\n    let mut rolling_max_list\
    \ = Vec::new();\n    for number in numbers {\n        max_found_so_far = if number\
    \ > max_found_so_far {\n            number\n        } else {\n            max_found_so_far\n\
    \        };\n        rolling_max_list.push(max_found_so_far);\n    }\n    rolling_max_list",
  "    if numbers.is_empty() {\n        return vec![];\n    }\n\n    let first = numbers[0];\n\
    \    let mut max = first;\n    let mut result = vec![first];\n\n    for n in numbers.iter().skip(1)\
    \ {\n        max = if n > &max {\n            *n\n        } else {\n         \
    \   max\n        };\n        result.push(max);\n    }\n\n    result", "    let\
    \ mut rolling_max: Vec<isize> = Vec::new();\n    let mut current_max = std::isize::MIN;\n\
    \    for number in numbers {\n        current_max = std::cmp::max(current_max,\
    \ number);\n        rolling_max.push(current_max);\n    }\n    rolling_max", " \
    \   let mut max_so_far = 0;\n    let mut max_values = Vec::new();\n    for i in\
    \ numbers {\n        max_so_far = std::cmp::max(max_so_far, i);\n        max_values.push(max_so_far);\n\
    \    }\n    max_values", "    numbers\n        .iter()\n        .scan(None, |state,\
    \ &item| {\n            *state = match *state {\n                None => Some(item),\n\
    \                Some(last_max) => Some(std::cmp::max(last_max, item)),\n    \
    \        };\n            Some(state.unwrap())\n        })\n        .collect()",
  "    let mut max_until_now = numbers[0];\n    let mut result = vec![max_until_now];\n\
    \    for &number in numbers.iter().skip(1) {\n        if number > max_until_now\
    \ {\n            max_until_now = number;\n        }\n        result.push(max_until_now);\n\
    \    }\n    result", "    numbers\n        .iter()\n        .scan(isize::min_value(),\
    \ |max, x| {\n            *max = *max.max(x);\n            Some(*max)\n      \
    \  })\n        .collect()", "    let mut result = Vec::new();\n    let mut max_found\
    \ = isize::min_value();\n    for i in numbers {\n        max_found = std::cmp::max(max_found,\
    \ i);\n        result.push(max_found);\n    }\n    result", "    let mut rolling_max:\
    \ Vec<isize> = Vec::new();\n    for number in numbers {\n        if rolling_max.is_empty()\
    \ {\n            rolling_max.push(number);\n        } else {\n            rolling_max.push(max(rolling_max[rolling_max.len()\
    \ - 1], number));\n        }\n    }\n    rolling_max", "    numbers\n        .iter()\n\
    \        .scan(0, |state, &x| {\n            *state = (*state).max(x);\n     \
    \       Some(*state)\n        })\n        .collect()", "    let mut current_max\
    \ = numbers[0];\n    let mut result = vec![current_max];\n\n    for number in\
    \ numbers.iter().skip(1) {\n        current_max = isize::max(current_max, *number);\n\
    \        result.push(current_max);\n    }\n\n    result", "    let mut max_so_far\
    \ = -1;\n    let mut result = Vec::new();\n    for &number in numbers.iter() {\n\
    \        max_so_far = max(max_so_far, number);\n        result.push(max_so_far);\n\
    \    }\n    result", "    let mut rolling_max = Vec::new();\n    let mut max =\
    \ numbers[0];\n    rolling_max.push(max);\n    for number in numbers.iter().skip(1)\
    \ {\n        max = cmp::max(max, *number);\n        rolling_max.push(max);\n \
    \   }\n    rolling_max", "    let mut max: isize = 0;\n    let mut result: Vec<isize>\
    \ = Vec::new();\n    for &number in numbers.iter() {\n        max = std::cmp::max(max,\
    \ number);\n        result.push(max);\n    }\n    result", "    let mut result\
    \ = Vec::with_capacity(numbers.len());\n    let mut rolling_max = isize::min_value();\n\
    \    for (i, n) in numbers.iter().enumerate() {\n        rolling_max = max(rolling_max,\
    \ *n);\n        result.push(rolling_max);\n    }\n    result", "    let mut result\
    \ = Vec::new();\n    let mut current_max = *numbers.first().unwrap();\n    for\
    \ &number in numbers.iter() {\n        current_max = std::cmp::max(current_max,\
    \ number);\n        result.push(current_max);\n    }\n    result", "    let mut\
    \ result = Vec::with_capacity(numbers.len());\n    let mut max = std::isize::MIN;\n\
    \    for &number in numbers.iter() {\n        max = max.max(number);\n       \
    \ result.push(max);\n    }\n    result", "    let mut maxes = vec![];\n    for\
    \ (i, num) in numbers.iter().enumerate() {\n        if i == 0 {\n            maxes.push(*num);\n\
    \        } else {\n            maxes.push(std::cmp::max(maxes[i - 1], *num));\n\
    \        }\n    }\n    maxes", "    let mut max = isize::min_value();\n    let\
    \ mut max_vec = Vec::new();\n    for n in numbers {\n        max = max.max(n);\n\
    \        max_vec.push(max);\n    }\n    max_vec", "    let mut rolling_max_list\
    \ = Vec::new();\n    let mut rolling_max = std::isize::MIN;\n    for num in numbers\
    \ {\n        rolling_max = std::cmp::max(rolling_max, num);\n        rolling_max_list.push(rolling_max);\n\
    \    }\n    rolling_max_list", "    numbers\n        .iter()\n        .scan(0,\
    \ |state, &x| {\n            *state = if x > *state { x } else { *state };\n \
    \           Some(*state)\n        })\n        .collect()", "    let mut max =\
    \ 0;\n    let mut result = Vec::new();\n    for num in numbers {\n        if num\
    \ > max {\n            max = num;\n        }\n        result.push(max);\n    }\n\
    \    result", "    let mut res = Vec::with_capacity(numbers.len());\n    let mut\
    \ current_max = None;\n    for n in numbers {\n        match current_max {\n \
    \           None => current_max = Some(n),\n            Some(m) => current_max\
    \ = Some(std::cmp::max(m, n)),\n        }\n        res.push(current_max.unwrap());\n\
    \    }\n    res", "    let mut rolling_max = Vec::new();\n    let mut maximum\
    \ = numbers[0];\n    rolling_max.push(maximum);\n    for x in numbers.iter().skip(1)\
    \ {\n        maximum = cmp::max(maximum, *x);\n        rolling_max.push(maximum);\n\
    \    }\n    rolling_max", "    let mut max_elements = Vec::new();\n    let mut\
    \ max_so_far = numbers[0];\n    max_elements.push(max_so_far);\n    for i in 1..numbers.len()\
    \ {\n        if numbers[i] > max_so_far {\n            max_so_far = numbers[i];\n\
    \        }\n        max_elements.push(max_so_far);\n    }\n    max_elements",
  "    let mut result = Vec::new();\n    let mut current_max = numbers[0];\n    result.push(current_max);\n\
    \    for next in numbers.iter().skip(1) {\n        current_max = std::cmp::max(current_max,\
    \ *next);\n        result.push(current_max);\n    }\n    result", "    let mut\
    \ rolling_max = Vec::with_capacity(numbers.len());\n    let mut current_max =\
    \ 0;\n    for &number in numbers.iter() {\n        current_max = std::cmp::max(current_max,\
    \ number);\n        rolling_max.push(current_max);\n    }\n    rolling_max", " \
    \   let mut maximums = vec![];\n    let mut maximum = numbers[0];\n    for (i,\
    \ number) in numbers.iter().enumerate() {\n        if i == 0 {\n            maximums.push(*number);\n\
    \        } else {\n            if number > &maximum {\n                maximum\
    \ = *number;\n            }\n            maximums.push(maximum);\n        }\n\
    \    }\n    maximums", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut max = numbers[0];\n    result.push(max);\n    for i in 1..numbers.len()\
    \ {\n        if numbers[i] > max {\n            max = numbers[i];\n        }\n\
    \        result.push(max);\n    }\n    result", "    numbers\n        .into_iter()\n\
    \        .scan(isize::min_value(), |max, n| {\n            *max = n.max(*max);\n\
    \            Some(*max)\n        })\n        .collect()"]
stop_tokens:
- "\n}"
