name: HumanEval_76_is_simple_power
language: rust
results:
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    match n.pow(((x as f64).log(n\
    \ as f64) + 0.01) as u32) {\n        x if x == x.trunc() => true,\n        _ =>\
    \ false,\n    }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `trunc` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpws20busq.rs:13:21\n   |\n13 |         x if x == x.trunc()\
    \ => true,\n   |                     ^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut power = n;\n   \
    \ while power < x {\n        power *= n;\n    }\n    power == x\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp_j7eyo8t.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut m = x;\n    while\
    \ m % n == 0 {\n        m /= n;\n    }\n    m == 1\n}\n\nfn main() {\n    let\
    \ candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (1..=x).filter(|&a| a.pow(n\
    \ as u32) == x).count() == 1\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/num/mod.rs:248:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    x.is_power_of(n)\n}\n\n\
    fn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_power_of` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpp02ztpwj.rs:12:7\n   |\n12 |     x.is_power_of(n)\n\
    \   |       ^^^^^^^^^^^ method not found in `isize`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (1..)\n        .take_while(|&i|\
    \ i as isize <= x)\n        .map(|i| n.pow(i))\n        .any(|p| p == x)\n}\n\n\
    fn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/num/mod.rs:248:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    unimplemented!()\n}\n\n\
    fn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmphsfsg7i3.rs:12:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    n.pow(n.trailing_zeros()\
    \ as u32) == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpicf3lwjp.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut m = n;\n    while\
    \ m < x {\n        m *= n;\n    }\n    x == m\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6kr2w9zm.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 0 {\n        return\
    \ false;\n    }\n    let mut v = vec![];\n    let mut t = n;\n    while t <= x\
    \ {\n        v.push(t);\n        t *= n;\n    }\n    v.contains(&x)\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        return\
    \ true;\n    }\n    let mut pow = n;\n    while pow < x {\n        pow *= n;\n\
    \    }\n    return pow == x;\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 { return true;\
    \ }\n    let mut y = n;\n    loop {\n        if y == x { return true; }\n    \
    \    if y > x { return false; }\n        y *= n;\n    }\n}\n\nfn main() {\n  \
    \  let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    x.is_power_of(n)\n}\n\n\
    fn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_power_of` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmplo2bs_pp.rs:12:7\n   |\n12 |     x.is_power_of(n)\n\
    \   |       ^^^^^^^^^^^ method not found in `isize`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let is_power = (x as f64).log(n\
    \ as f64).is_integer();\n    let is_simple = (x as f64).log(2.0).is_integer();\n\
    \    is_power && is_simple\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmp929mmy1c.rs:12:45\n   |\n12 |     let is_power\
    \ = (x as f64).log(n as f64).is_integer();\n   |                             \
    \                ^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method\
    \ named `is_integer` found for type `f64` in the current scope\n  --> /tmp/tmp929mmy1c.rs:13:41\n\
    \   |\n13 |     let is_simple = (x as f64).log(2.0).is_integer();\n   |      \
    \                                   ^^^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    x == n.pow(x.to_string().len()\
    \ as u32)\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwmmr6bgl.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    x == n.pow(x.trailing_zeros()\
    \ as u32)\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpsi4j6t45.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut i = 0;\n    let\
    \ mut v = n;\n    while v <= x {\n        if v == x {\n            return true;\n\
    \        }\n        i += 1;\n        v *= n;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp210dfvni.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let nx = (x as f64).log(n\
    \ as f64).floor();\n    nx.abs() < f64::EPSILON\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpk632hx_w.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut p = n;\n    while\
    \ p < x {\n        p *= n;\n    }\n    p == x\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbv_7oy81.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x < 0 || n <= 0 {\n \
    \       return false;\n    }\n    let mut y = x;\n    while y % n == 0 {\n   \
    \     y /= n;\n    }\n    y == 1\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut i = 1;\n    while\
    \ i.pow(n as u32) <= x {\n        if i.pow(n as u32) == x {\n            return\
    \ true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmpjqoihtb5.rs:13:13\n   |\n13 |     while i.pow(n as u32) <= x {\n\
    \   |             ^^^\n   |\nhelp: you must specify a type for this binding, like\
    \ `i32`\n   |\n12 |     let mut i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror[E0689]:\
    \ can't call method `pow` on ambiguous numeric type `{integer}`\n  --> /tmp/tmpjqoihtb5.rs:14:14\n\
    \   |\n14 |         if i.pow(n as u32) == x {\n   |              ^^^\n   |\nhelp:\
    \ you must specify a type for this binding, like `i32`\n   |\n12 |     let mut\
    \ i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0689`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (1..)\n        .filter(|i|\
    \ i.pow(n as u32) >= x)\n        .take(2)\n        .any(|i| i.pow(n as u32) ==\
    \ x)\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `pow` found for reference `&{integer}` in\
    \ the current scope\n  --> /tmp/tmptne3bexc.rs:13:23\n   |\n13 |         .filter(|i|\
    \ i.pow(n as u32) >= x)\n   |                       ^^^ method not found in `&{integer}`\n\
    \nerror[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmptne3bexc.rs:15:20\n   |\n15 |         .any(|i| i.pow(n as u32)\
    \ == x)\n   |               -    ^^^\n   |               |\n   |             \
    \  you must specify a type for this binding, like `i32`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0599, E0689.\n\
    For more information about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    for i in 1..x {\n      \
    \  if n.pow(i) == x {\n            return true;\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxtftn_49.rs:13:18\n   |\n\
    13 |         if n.pow(i) == x {\n   |                  ^ expected `u32`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `u32` and panic if the\
    \ converted value doesn't fit\n   |\n13 |         if n.pow(i.try_into().unwrap())\
    \ == x {\n   |                   ++++++++++++++++++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x <= 0 || n <= 0 {\n\
    \        return false;\n    }\n    let y = x.checked_pow(x.checked_pow(1).unwrap_or(0)).unwrap_or(0);\n\
    \    x == y\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp13vew6e1.rs:15:27\n   |\n\
    15 |     let y = x.checked_pow(x.checked_pow(1).unwrap_or(0)).unwrap_or(0);\n\
    \   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `u32` and panic if\
    \ the converted value doesn't fit\n   |\n15 |     let y = x.checked_pow(x.checked_pow(1).unwrap_or(0).try_into().unwrap()).unwrap_or(0);\n\
    \   |                                                        ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (0..)\n        .map(|i|\
    \ n.pow(i))\n        .take_while(|&x| x <= x)\n        .any(|x| x == x)\n}\n\n\
    fn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp64jxowr5.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x < 0 || n < 0 {\n  \
    \      return false;\n    }\n    if x == 0 {\n        return n == 0;\n    }\n\
    \    let mut n_power = n;\n    while n_power < x {\n        n_power *= n;\n  \
    \  }\n    x == n_power\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmplzms54mx.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut exp = 1;\n    let\
    \ mut result = n;\n    while result <= x {\n        if result == x {\n       \
    \     return true;\n        }\n        exp += 1;\n        result = n.pow(exp);\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n  \
    \  assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp83fto7ae.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut m = x;\n    while\
    \ m % n == 0 {\n        m /= n;\n    }\n    m == 1\n}\n\nfn main() {\n    let\
    \ candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        return\
    \ true;\n    }\n    (2..x + 1).any(|i| x == n.pow(i as u32))\n}\n\nfn main() {\n\
    \    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/num/mod.rs:248:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    x == n.pow(x.trailing_zeros()\
    \ as u32)\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpd7hhg183.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let xs = format!(\"{}\"\
    , x);\n    let ns = format!(\"{}\", n);\n    if xs.len() % ns.len() != 0 {\n \
    \       return false;\n    }\n    let mut x_slice = xs.chars();\n    let mut prefix\
    \ = String::new();\n    while let Some(c) = x_slice.next() {\n        prefix.push(c);\n\
    \        if prefix.len() == ns.len() {\n            let mut x_prefix = x_slice.clone();\n\
    \            let mut x_prefix_str = String::new();\n            while let Some(c)\
    \ = x_prefix.next() {\n                x_prefix_str.push(c);\n            }\n\
    \            let x_int = prefix.parse::<isize>().unwrap();\n            let x_int_test\
    \ = x_prefix_str.parse::<isize>().unwrap();\n            if x_int_test == 0 {\n\
    \                return false;\n            }\n            if n.pow(x_int_test.to_string().len()\
    \ as u32) != x_int_test {\n                return false;\n            }\n    \
    \        prefix = String::new();\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcz3d7p_1.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut m = n;\n    while\
    \ m * n <= x {\n        m *= n;\n    }\n    m == x\n}\n\nfn main() {\n    let\
    \ candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    x == n.pow(((x as f64).log(n\
    \ as f64)).round() as u32)\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 0 {\n        return\
    \ false;\n    }\n    if n == 0 {\n        return false;\n    }\n    if x == 1\
    \ {\n        return true;\n    }\n    let mut num = n;\n    let mut pow = 1;\n\
    \    while num < x {\n        num *= n;\n        pow += 1;\n    }\n    num ==\
    \ x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    x == n.pow(x.trailing_zeros()\
    \ as u32)\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmppdkzmuiw.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    x == n.pow(1) || x == n.pow(2)\
    \ || x == n.pow(3) || x == n.pow(4) || x == n.pow(5)\n}\n\nfn main() {\n    let\
    \ candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxe09jy6n.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let v: isize = (x as f64).log(n\
    \ as f64).round() as isize;\n    n.pow(v) == x\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkkczeemu.rs:13:11\n   |\n\
    13 |     n.pow(v) == x\n   |           ^ expected `u32`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `u32` and panic if the converted value doesn't\
    \ fit\n   |\n13 |     n.pow(v.try_into().unwrap()) == x\n   |            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    // example: x = 16, n =\
    \ 2\n    // x / n = 8\n\n    // if x = n then true (2 == 2)\n    if x == n {\n\
    \        return true;\n    }\n\n    // if x < n then false (1 < 2)\n    if x <\
    \ n {\n        return false;\n    }\n\n    // if x / n == 1 then true (8 / 2 ==\
    \ 4)\n    if x / n == 1 {\n        return true;\n    }\n\n    // otherwise false\n\
    \    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxpvs1ewv.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (1..=(x as f64).sqrt() as\
    \ isize)\n        .filter(|i| i.pow(x.trailing_zeros() as u32) == x)\n       \
    \ .any(|i| i == n)\n}\n\nfn main() {\n    let candidate = is_simple_power;\n \
    \   assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6vqjd7r8.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x <= 0 || n <= 0 {\n\
    \        return false;\n    }\n    let mut result = n;\n    while result <= x\
    \ {\n        if result == x {\n            return true;\n        }\n        result\
    \ *= n;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp51t9443t.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    x.is_power_of(n)\n}\n\n\
    fn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_power_of` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpnah1n3eh.rs:12:7\n   |\n12 |     x.is_power_of(n)\n\
    \   |       ^^^^^^^^^^^ method not found in `isize`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        true\n\
    \    } else if x == n {\n        true\n    } else if x % n != 0 {\n        false\n\
    \    } else {\n        is_simple_power(x / n, n)\n    }\n}\n\nfn main() {\n  \
    \  let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut i = 1;\n    while\
    \ i.pow(n as u32) < x {\n        i += 1;\n    }\n    i.pow(n as u32) == x\n}\n\
    \nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmp6j6rps7w.rs:13:13\n   |\n13 |     while i.pow(n as u32) < x {\n\
    \   |             ^^^\n   |\nhelp: you must specify a type for this binding, like\
    \ `i32`\n   |\n12 |     let mut i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror[E0689]:\
    \ can't call method `pow` on ambiguous numeric type `{integer}`\n  --> /tmp/tmp6j6rps7w.rs:16:7\n\
    \   |\n16 |     i.pow(n as u32) == x\n   |       ^^^\n   |\nhelp: you must specify\
    \ a type for this binding, like `i32`\n   |\n12 |     let mut i: i32 = 1;\n  \
    \ |         ~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0689`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (1..x + 1).any(|i| i * i\
    \ == x)\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut temp: isize = n;\n\
    \    while temp < x {\n        temp *= n;\n    }\n    if temp == x {\n       \
    \ true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpe5jshlwd.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut s = n;\n    let\
    \ mut i = 1;\n    while s < x {\n        s *= n;\n        i += 1;\n    }\n   \
    \ s == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6mbelvnm.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    x.is_power_of(n)\n}\n\n\
    fn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_power_of` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpsv0jf9j1.rs:12:7\n   |\n12 |     x.is_power_of(n)\n\
    \   |       ^^^^^^^^^^^ method not found in `isize`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut answer = n;\n  \
    \  let mut result = false;\n    while answer < x {\n        answer *= n;\n   \
    \ }\n    if answer == x {\n        result = true;\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpyza8k_g3.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 0 {\n        false\n\
    \    } else {\n        (1..).find(|i| n.pow(*i) == x).is_some()\n    }\n}\n\n\
    fn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/num/mod.rs:248:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        return\
    \ true;\n    }\n    let mut k = 1;\n    while n.pow(k) <= x {\n        if n.pow(k)\
    \ == x {\n            return true;\n        }\n        k += 1;\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 0 || n == 0 {\n\
    \        return false;\n    }\n    x.pow(1 / n as u32) == n\n}\n\nfn main() {\n\
    \    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpa_ybnwtw.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    x.pow(1.0 / n as f64) as\
    \ isize == n\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbnfxom71.rs:12:11\n   |\n\
    12 |     x.pow(1.0 / n as f64) as isize == n\n   |           ^^^^^^^^^^^^^^ expected\
    \ `u32`, found `f64`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    x as f64 == (n as f64).powf(x.trailing_zeros()\
    \ as f64)\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvowiwnnw.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 0 {\n        false\n\
    \    } else {\n        x == n.pow(x.trailing_zeros() as u32)\n    }\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxmqwgugy.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        return\
    \ true;\n    }\n    let mut i = 1;\n    let mut prod = n;\n    while prod < x\
    \ {\n        prod *= n;\n        i += 1;\n    }\n    return prod == x;\n}\n\n\
    fn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut x_ = x;\n    let\
    \ mut n_ = n;\n    while x_ > 1 {\n        if x_ % n_ != 0 {\n            return\
    \ false;\n        }\n        x_ /= n_;\n    }\n    if x_ == n_ {\n        true\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpn_9fj0w0.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    for i in 1.. {\n       \
    \ let p = n.pow(i);\n        if p == x {\n            return true;\n        }\n\
    \        if p > x {\n            return false;\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp55yrxjdy.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    // let mut s = 1;\n    //\
    \ while s < x {\n    //     s *= n;\n    // }\n    // s == x\n    match x.checked_pow(1\
    \ / n) {\n        Some(v) => v * n == x,\n        None => false,\n    }\n}\n\n\
    fn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprxq56cz1.rs:17:25\n   |\n\
    17 |     match x.checked_pow(1 / n) {\n   |                         ^^^^^ expected\
    \ `u32`, found `isize`\n   |\nhelp: you can convert an `isize` to a `u32` and\
    \ panic if the converted value doesn't fit\n   |\n17 |     match x.checked_pow((1\
    \ / n).try_into().unwrap()) {\n   |                         +     +++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 0 {\n        false\n\
    \    } else {\n        (1..=x).any(|i| i.pow(n as u32) == x)\n    }\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/num/mod.rs:248:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (1..)\n        .map(|i|\
    \ n.pow(i))\n        .take_while(|i| i <= &x)\n        .any(|i| i == x)\n}\n\n\
    fn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpp9ud4xva.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (1..=x).any(|i| i.pow(n\
    \ as u32) == x)\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/num/mod.rs:248:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        return\
    \ true;\n    }\n    if n == 1 {\n        return false;\n    }\n    if x < 1 ||\
    \ n < 1 {\n        return false;\n    }\n    let root = ((x as f64).ln() / (n\
    \ as f64).ln()).floor() as isize;\n    root == (x as f64).ln() / (n as f64).ln()\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprmgyt_qg.rs:22:13\n   |\n\
    22 |     root == (x as f64).ln() / (n as f64).ln()\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `f64`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        return\
    \ true;\n    }\n    let mut tmp = n;\n    while tmp < x {\n        tmp *= n;\n\
    \    }\n    tmp == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 { return true;\
    \ }\n    let log = (x as f64).log(n as f64);\n    log.fract() == 0.0\n}\n\nfn\
    \ main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x % n == 0 {\n      \
    \  is_simple_power(x / n, n)\n    } else {\n        x == 1\n    }\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let n = n as f64;\n    let\
    \ x = x as f64;\n    if x == 1.0 {\n        return true;\n    }\n    if x < 1.0\
    \ {\n        return false;\n    }\n    if n.log(x).fract() == 0.0 {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptin_lr45.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        return\
    \ true;\n    }\n    if n == 1 {\n        return false;\n    }\n    for i in 1..x\
    \ / 2 {\n        if n.pow(i) == x {\n            return true;\n        }\n   \
    \ }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9fs54hhj.rs:19:18\n   |\n\
    19 |         if n.pow(i) == x {\n   |                  ^ expected `u32`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `u32` and panic if the\
    \ converted value doesn't fit\n   |\n19 |         if n.pow(i.try_into().unwrap())\
    \ == x {\n   |                   ++++++++++++++++++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        true\n\
    \    } else if x % n != 0 {\n        false\n    } else {\n        is_simple_power(x\
    \ / n, n)\n    }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n   \
    \ assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16), false);\n\
    \    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9, 3), true);\n\
    \    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24, 2), false);\n\
    \    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12, 6), false);\n\
    \    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1, 12), true);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 0 {\n        return\
    \ false;\n    }\n    if n == 0 {\n        return x == 1;\n    }\n    if n == 1\
    \ {\n        return x == 1;\n    }\n    let k = (x as f64).log(n as f64).round()\
    \ as isize;\n    n.pow(k) == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzewv4khx.rs:22:11\n   |\n\
    22 |     n.pow(k) == x\n   |           ^ expected `u32`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `u32` and panic if the converted value doesn't\
    \ fit\n   |\n22 |     n.pow(k.try_into().unwrap()) == x\n   |            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        return\
    \ true;\n    }\n    if n == 1 {\n        return false;\n    }\n    for i in 1..=x\
    \ {\n        if x == n.pow(i) {\n            return true;\n        }\n    }\n\
    \    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpispbobyq.rs:19:23\n   |\n\
    19 |         if x == n.pow(i) {\n   |                       ^ expected `u32`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `u32` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x == n.pow(i.try_into().unwrap())\
    \ {\n   |                        ++++++++++++++++++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    match n.pow(x.to_string().len()\
    \ as u32) {\n        x => x == x,\n        _ => false,\n    }\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp2emwivs1.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut i = 1;\n    let\
    \ mut z = n;\n    while z < x {\n        z *= n;\n        i += 1;\n    }\n   \
    \ z == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpppqiidck.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        return\
    \ true;\n    }\n    if n == 1 {\n        return false;\n    }\n    if x % n !=\
    \ 0 {\n        return false;\n    }\n    is_simple_power(x / n, n)\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    match x.checked_pow(1.0/n\
    \ as f64) {\n        Some(i) => i.ceil() == i.floor(),\n        None => false\n\
    \    }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz2yd6psa.rs:12:25\n   |\n\
    12 |     match x.checked_pow(1.0/n as f64) {\n   |                         ^^^^^^^^^^^^\
    \ expected `u32`, found `f64`\n\nerror[E0599]: no method named `ceil` found for\
    \ type `isize` in the current scope\n  --> /tmp/tmpz2yd6psa.rs:13:22\n   |\n13\
    \ |         Some(i) => i.ceil() == i.floor(),\n   |                      ^^^^\
    \ help: there is an associated function with a similar name: `div_ceil`\n\nerror[E0599]:\
    \ no method named `floor` found for type `isize` in the current scope\n  --> /tmp/tmpz2yd6psa.rs:13:34\n\
    \   |\n13 |         Some(i) => i.ceil() == i.floor(),\n   |                  \
    \                ^^^^^ help: there is an associated function with a similar name:\
    \ `div_floor`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        return\
    \ true;\n    }\n    match isize::pow(n, x.trailing_zeros() as u32) {\n       \
    \ x if x == x => true,\n        _ => false,\n    }\n}\n\nfn main() {\n    let\
    \ candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpdnqfx5yj.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut x = x;\n    let\
    \ mut i = 0;\n    while x % n == 0 {\n        x /= n;\n        i += 1;\n    }\n\
    \    x == 1 && i != 0\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        return\
    \ true;\n    }\n    if n == 1 {\n        return false;\n    }\n    let mut i =\
    \ 1;\n    let mut p = n;\n    while i < x {\n        p *= n;\n        if p ==\
    \ x {\n            return true;\n        }\n        i += 1;\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /tmp/tmpix2_3vdj.rs:21:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut pwr = n;\n    while\
    \ pwr < x {\n        pwr *= n;\n    }\n    pwr == x\n}\n\nfn main() {\n    let\
    \ candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzmmlps3f.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 { return true;\
    \ }\n    let mut exp = 1;\n    let mut res = n;\n    while res < x {\n       \
    \ res *= n;\n        exp += 1;\n    }\n    res == x\n}\n\nfn main() {\n    let\
    \ candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (x as f64).log(n as f64).round()\
    \ == (x as f64).log(n as f64)\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpfcc1wvec.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        return\
    \ true;\n    }\n    (2..x).any(|i| n.pow(i) == x)\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdfeczkok.rs:15:26\n   |\n\
    15 |     (2..x).any(|i| n.pow(i) == x)\n   |                          ^ expected\
    \ `u32`, found `isize`\n   |\nhelp: you can convert an `isize` to a `u32` and\
    \ panic if the converted value doesn't fit\n   |\n15 |     (2..x).any(|i| n.pow(i.try_into().unwrap())\
    \ == x)\n   |                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        true\n\
    \    } else if x % n != 0 {\n        false\n    } else {\n        is_simple_power(x\
    \ / n, n)\n    }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n   \
    \ assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16), false);\n\
    \    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9, 3), true);\n\
    \    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24, 2), false);\n\
    \    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12, 6), false);\n\
    \    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1, 12), true);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (1..)\n        .map(|i|\
    \ n.pow(i))\n        .take_while(|&p| p <= x)\n        .any(|p| p == x)\n}\n\n\
    fn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpidzdfiud.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (x as f64).log(n as f64).fract()\
    \ == 0.0\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbkd5gg8z.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (1..=n).map(|i| n.pow(i\
    \ as u32)).any(|i| i == x)\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwamhlzd5.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 0 {\n        return\
    \ false;\n    }\n    let mut x = x;\n    let mut res = 1.0;\n    while res < x\
    \ as f64 {\n        res *= n as f64;\n    }\n    res == x as f64\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        return\
    \ true;\n    }\n    if n == 1 {\n        return false;\n    }\n    let mut value\
    \ = n;\n    let mut counter = 1;\n    while value < x {\n        value *= n;\n\
    \        counter += 1;\n    }\n    if value == x {\n        return true;\n   \
    \ }\n    return false;\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 0 {\n        return\
    \ true;\n    }\n    let mut i = 1;\n    let mut result = n;\n    while result\
    \ < x {\n        result *= n;\n        i += 1;\n    }\n    result == x\n}\n\n\
    fn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpo_aozand.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut result = x;\n  \
    \  while result % n == 0 {\n        result /= n;\n    }\n    result == 1\n}\n\n\
    fn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let float_x = x as f64;\n\
    \    let float_n = n as f64;\n    let float_result = float_x.ln() / float_n.ln();\n\
    \    let int_result = float_result as isize;\n    int_result as f64 == float_result\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpjif_5y05.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 0 || n == 0 {\n\
    \        return false;\n    }\n    let r = (x as f64).log(n as f64);\n    r.trunc()\
    \ == r\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpf98pv4kn.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        return\
    \ true;\n    }\n    if n == 1 {\n        return false;\n    }\n    let x_f = x\
    \ as f64;\n    let n_f = n as f64;\n    x_f.log(n_f).round() == x_f.log(n_f)\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 0 {\n        return\
    \ false;\n    }\n\n    (1..)\n        .map(|i| n.pow(i))\n        .take_while(|n|\
    \ *n <= x)\n        .rev()\n        .any(|n| x % n == 0)\n}\n\nfn main() {\n \
    \   let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `TakeWhile<Map<RangeFrom<u32>, [closure@/tmp/tmpw_dkcv0u.rs:17:14:\
    \ 17:26]>, [closure@/tmp/tmpw_dkcv0u.rs:18:21: 18:32]>: DoubleEndedIterator` is\
    \ not satisfied\n    --> /tmp/tmpw_dkcv0u.rs:19:10\n     |\n19   |         .rev()\n\
    \     |          ^^^ the trait `DoubleEndedIterator` is not implemented for `TakeWhile<Map<RangeFrom<u32>,\
    \ [closure@/tmp/tmpw_dkcv0u.rs:17:14: 17:26]>, [closure@/tmp/tmpw_dkcv0u.rs:18:21:\
    \ 18:32]>`\n     |\nnote: required by a bound in `rev`\n\nerror[E0599]: the method\
    \ `any` exists for struct `Rev<TakeWhile<Map<RangeFrom<u32>, [closure@/tmp/tmpw_dkcv0u.rs:17:14:\
    \ 17:26]>, [closure@/tmp/tmpw_dkcv0u.rs:18:21: 18:32]>>`, but its trait bounds\
    \ were not satisfied\n  --> /tmp/tmpw_dkcv0u.rs:20:10\n   |\n20 |            .any(|n|\
    \ x % n == 0)\n   |             ^^^ method cannot be called on `Rev<TakeWhile<Map<RangeFrom<u32>,\
    \ [closure@/tmp/tmpw_dkcv0u.rs:17:14: 17:26]>, [closure@/tmp/tmpw_dkcv0u.rs:18:21:\
    \ 18:32]>>` due to unsatisfied trait bounds\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `TakeWhile<Map<RangeFrom<u32>, [closure@/tmp/tmpw_dkcv0u.rs:17:14:\
    \ 17:26]>, [closure@/tmp/tmpw_dkcv0u.rs:18:21: 18:32]>: DoubleEndedIterator`\n\
    \           which is required by `Rev<TakeWhile<Map<RangeFrom<u32>, [closure@/tmp/tmpw_dkcv0u.rs:17:14:\
    \ 17:26]>, [closure@/tmp/tmpw_dkcv0u.rs:18:21: 18:32]>>: Iterator`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    n.pow(x.to_string().parse::<usize>().unwrap())\
    \ == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm6xtbv4c.rs:12:11\n   |\n\
    12 |     n.pow(x.to_string().parse::<usize>().unwrap()) == x\n   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `u32`, found `usize`\n   |\nhelp: you can convert a `usize` to a `u32`\
    \ and panic if the converted value doesn't fit\n   |\n12 |     n.pow(x.to_string().parse::<usize>().unwrap().try_into().unwrap())\
    \ == x\n   |                                                  ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let x_pow = (0..)\n    \
    \    .take_while(|&i| i.pow(n as u32) <= x)\n        .find(|&i| i.pow(n as u32)\
    \ == x);\n    x_pow.is_some()\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmpzprbollc.rs:13:28\n   |\n13 |         .take_while(|&i| i.pow(n\
    \ as u32) <= x)\n   |                       -    ^^^\n   |                   \
    \    |\n   |                       you must specify a type for this binding, like\
    \ `i32`\n\nerror[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmpzprbollc.rs:14:22\n   |\n14 |         .find(|&i| i.pow(n as u32)\
    \ == x);\n   |                 -    ^^^\n   |                 |\n   |        \
    \         you must specify a type for this binding, like `i32`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0689`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x <= 0 || n <= 0 {\n\
    \        return false;\n    }\n    x.is_power_of(n)\n}\n\nfn main() {\n    let\
    \ candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_power_of` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmp5tfegxz9.rs:15:7\n   |\n15 |     x.is_power_of(n)\n\
    \   |       ^^^^^^^^^^^ method not found in `isize`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut p = 1;\n    while\
    \ p < x {\n        p *= n;\n    }\n    p == x\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut i = 1;\n    let\
    \ mut num = n;\n    while num < x {\n        num *= n;\n        i += 1;\n    }\n\
    \    num == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpjve0nfly.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        return\
    \ true;\n    }\n    let mut x = x;\n    let mut n = n;\n    while x % n == 0 {\n\
    \        x /= n;\n        if x == 1 {\n            return true;\n        }\n \
    \   }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n   \
    \ assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16), false);\n\
    \    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9, 3), true);\n\
    \    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24, 2), false);\n\
    \    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12, 6), false);\n\
    \    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1, 12), true);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (1..40).find(|&z| n.pow(z)\
    \ == x).is_some()\n}\n\nfn main() {\n    let candidate = is_simple_power;\n  \
    \  assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/num/mod.rs:248:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let log_n = (x as f64).log(n\
    \ as f64);\n    log_n - log_n.floor() < std::f64::EPSILON\n}\n\nfn main() {\n\
    \    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp58tx6rr8.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (x as f64).log(n as f64).fract()\
    \ == 0.0\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp63ipfipo.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        return\
    \ true;\n    }\n    (1..)\n        .map(|i| n.pow(i))\n        .take_while(|i|\
    \ i <= &x)\n        .find(|i| i == &x)\n        .is_some()\n}\n\nfn main() {\n\
    \    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let k = (x as f64).log(n\
    \ as f64);\n    if k < 0.0 {\n        return false;\n    }\n    let k = k.floor()\
    \ as isize;\n    n.pow(k) == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp78lxrgn8.rs:17:11\n   |\n\
    17 |     n.pow(k) == x\n   |           ^ expected `u32`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `u32` and panic if the converted value doesn't\
    \ fit\n   |\n17 |     n.pow(k.try_into().unwrap()) == x\n   |            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    // Fix this implementation.\
    \ Add your code here:\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpmx0vm_7m.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut y = n;\n    while\
    \ y < x {\n        y *= n;\n    }\n    y == x\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdxy3p1es.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut x = x;\n    let\
    \ mut n = n;\n    while x % n == 0 {\n        x /= n;\n    }\n    x == 1\n}\n\n\
    fn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 && n == 1 {\n\
    \        return true;\n    }\n    if x == 1 || n == 1 {\n        return false;\n\
    \    }\n    if x < 1 || n < 1 {\n        return false;\n    }\n    let mut result\
    \ = 1;\n    let mut counter = 0;\n    while result <= x {\n        if result ==\
    \ x {\n            return true;\n        }\n        result *= n;\n        counter\
    \ += 1;\n        if counter > x {\n            return false;\n        }\n    }\n\
    \    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9829jnxm.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (x == 1 && n == 1) || (x\
    \ == n.pow(1))\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4ra1g8im.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    for i in 1..=20 {\n    \
    \    if n.pow(i) == x {\n            return true;\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/num/mod.rs:248:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        return\
    \ true;\n    }\n    for i in 1.. {\n        let xn = n.pow(i);\n        if xn\
    \ == x {\n            return true;\n        }\n        if xn > x {\n         \
    \   return false;\n        }\n    }\n    unreachable!()\n}\n\nfn main() {\n  \
    \  let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x < n {\n        return\
    \ false;\n    }\n    let mut current_power = n;\n    while current_power < x {\n\
    \        current_power *= n;\n    }\n    current_power == x\n}\n\nfn main() {\n\
    \    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcpgls57v.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        return\
    \ true;\n    }\n    let mut i = 1;\n    while i < x {\n        i *= n;\n    }\n\
    \    i == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x < 0 || n < 0 {\n  \
    \      false\n    } else {\n        x == n.pow(x.to_string().len() as u32)\n \
    \   }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp02qggkg5.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        return\
    \ true;\n    }\n    let mut div = n;\n    while div <= x {\n        if div ==\
    \ x {\n            return true;\n        }\n        div *= n;\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    x.is_power_of(n)\n}\n\n\
    fn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_power_of` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpn3e0kcnl.rs:12:7\n   |\n12 |     x.is_power_of(n)\n\
    \   |       ^^^^^^^^^^^ method not found in `isize`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    n.pow(x.trailing_zeros()\
    \ as u32) == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvp21s_c7.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 0 || n == 0 {\n\
    \        return false;\n    }\n    let res = (x as f64).log(n as f64);\n    res\
    \ == res.trunc()\n}\n\nfn main() {\n    let candidate = is_simple_power;\n   \
    \ assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16), false);\n\
    \    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9, 3), true);\n\
    \    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24, 2), false);\n\
    \    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12, 6), false);\n\
    \    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1, 12), true);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp91361ih3.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut i = 1;\n    let\
    \ mut x_is_simple_power = false;\n    loop {\n        let x_tmp = n.pow(i);\n\
    \        if x_tmp == x {\n            x_is_simple_power = true;\n            break;\n\
    \        } else if x_tmp > x {\n            break;\n        }\n        i += 1;\n\
    \    }\n    x_is_simple_power\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp213kayff.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (0..64).any(|i| n.pow(i)\
    \ == x)\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/num/mod.rs:248:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut res = 1;\n    for\
    \ i in 1.. {\n        res *= n;\n        if res == x {\n            return true;\n\
    \        }\n        if res > x {\n            return false;\n        }\n    }\n\
    \    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpt376t3yk.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut root = 1;\n    while\
    \ root < x {\n        root *= n;\n    }\n    root == x\n}\n\nfn main() {\n   \
    \ let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    for i in 1..(x as f64).sqrt()\
    \ as isize + 1 {\n        if i.pow(n as u32) == x {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/num/mod.rs:248:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x < n {\n        return\
    \ false;\n    }\n    for i in 1..10 {\n        if n.pow(i) == x {\n          \
    \  return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprl69xqdo.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 0 {\n        return\
    \ false;\n    }\n    let result = (n as f64).log(x as f64).is_integer();\n   \
    \ result\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_integer` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpjm7zlx0d.rs:15:43\n   |\n15 |     let result =\
    \ (n as f64).log(x as f64).is_integer();\n   |                               \
    \            ^^^^^^^^^^ method not found in `f64`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut val = n;\n    let\
    \ mut counter = 1;\n    while val <= x {\n        if val == x {\n            return\
    \ true;\n        }\n        val *= n;\n        counter += 1;\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwsmn_pyu.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut p = n;\n    while\
    \ p < x {\n        p *= n;\n    }\n    p == x\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp86f2z9rx.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    //return x.powf(1.0/n as\
    \ f64) == (x.powf(1.0/n as f64)).round();\n    return (x as f64).log(n as f64)\
    \ as isize % 1 == 0;\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp05dlbuya.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        true\n\
    \    } else if x % n != 0 {\n        false\n    } else {\n        is_simple_power(x\
    \ / n, n)\n    }\n}\n\nfn main() {\n    let candidate = is_simple_power;\n   \
    \ assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16), false);\n\
    \    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9, 3), true);\n\
    \    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24, 2), false);\n\
    \    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12, 6), false);\n\
    \    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1, 12), true);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let y = x.trailing_zeros();\n\
    \    (x & (x - 1) == 0) && x.count_ones() == y\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpsatypnq3.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 0 {\n        return\
    \ false;\n    }\n    if n == 0 {\n        return false;\n    }\n    if x == 1\
    \ {\n        return true;\n    }\n    let mut i = 1;\n    while i.pow(n as u32)\
    \ <= x {\n        if i.pow(n as u32) == x {\n            return true;\n      \
    \  }\n        i += 1;\n    }\n    false\n}\n\nfn main() {\n    let candidate =\
    \ is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmpn47nhr1z.rs:22:13\n   |\n22 |     while i.pow(n as u32) <= x {\n\
    \   |             ^^^\n   |\nhelp: you must specify a type for this binding, like\
    \ `i32`\n   |\n21 |     let mut i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror[E0689]:\
    \ can't call method `pow` on ambiguous numeric type `{integer}`\n  --> /tmp/tmpn47nhr1z.rs:23:14\n\
    \   |\n23 |         if i.pow(n as u32) == x {\n   |              ^^^\n   |\nhelp:\
    \ you must specify a type for this binding, like `i32`\n   |\n21 |     let mut\
    \ i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0689`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    match n.is_power_of(x) {\n\
    \        Some(i) => i.is_integer(),\n        None => false,\n    }\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_power_of` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpo5s36ul2.rs:12:13\n   |\n12 |     match n.is_power_of(x)\
    \ {\n   |             ^^^^^^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x < 0 || n < 0 {\n  \
    \      return false;\n    }\n    if x == 0 {\n        return n == 0;\n    }\n\
    \    let log = (x as f64).log(n as f64);\n    log.floor() == log\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9dta1bo9.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x < 0 || n <= 0 {\n \
    \       return false;\n    }\n    for i in 0..=x / n {\n        if i.pow(n as\
    \ u32) == x {\n            return true;\n        }\n    }\n    false\n}\n\nfn\
    \ main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/num/mod.rs:248:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x < 0 || n <= 0 {\n \
    \       return false;\n    }\n    if x == 1 {\n        return true;\n    }\n \
    \   let mut tmp = n;\n    while tmp < x {\n        tmp *= n;\n    }\n    tmp ==\
    \ x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let exponent = (x as f64).log(n\
    \ as f64);\n    exponent.floor() == exponent.ceil()\n}\n\nfn main() {\n    let\
    \ candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpyvsm4arj.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        return\
    \ true;\n    }\n    let r = (x as f64).log(n as f64);\n    r == r.trunc()\n}\n\
    \nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut result = n;\n  \
    \  let mut count = 1;\n    while result <= x {\n        if result == x {\n   \
    \         return true;\n        }\n        count += 1;\n        result = n.pow(count);\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n  \
    \  assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpx9y181hg.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut product = 1;\n \
    \   let mut count = 0;\n    while product < x {\n        product *= n;\n     \
    \   count += 1;\n    }\n    product == x\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        return\
    \ true;\n    }\n    let mut power = n;\n    while power < x {\n        power *=\
    \ n;\n    }\n    power == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        return\
    \ true;\n    }\n    if n == 1 {\n        return false;\n    }\n    let mut left\
    \ = 1;\n    let mut right = x;\n    while left <= right {\n        let mid = (left\
    \ + right) / 2;\n        let mid_power = mid.pow(n as u32);\n        if mid_power\
    \ == x {\n            return true;\n        } else if mid_power > x {\n      \
    \      right = mid - 1;\n        } else {\n            left = mid + 1;\n     \
    \   }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/num/mod.rs:248:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        return\
    \ true;\n    }\n    match (x, n) {\n        (x, n) if x % n == 0 => is_simple_power(x\
    \ / n, n),\n        (1, _) => true,\n        _ => false,\n    }\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 0 || n == 0 {\n\
    \        return false;\n    }\n    let mut y = n;\n    while y <= x {\n      \
    \  if y == x {\n            return true;\n        }\n        y *= n;\n    }\n\
    \    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpai8paate.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x <= 0 || n <= 0 {\n\
    \        return false;\n    }\n    let mut res = n;\n    while res < x {\n   \
    \     res *= n;\n    }\n    return res == x;\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpt9v9c9h3.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        return\
    \ true;\n    }\n    let mut i = 1;\n    while i <= x {\n        if i == x {\n\
    \            return true;\n        }\n        i *= n;\n    }\n    false\n}\n\n\
    fn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        return\
    \ true;\n    }\n    if n == 1 {\n        return false;\n    }\n    let mut x =\
    \ x;\n    while x % n == 0 {\n        x /= n;\n    }\n    x == 1\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 && n == 1 {\n\
    \        return true;\n    }\n    if x == 0 || n == 0 {\n        return false;\n\
    \    }\n    let mut count = 0;\n    let mut x_c = x;\n    let mut n_c = n;\n \
    \   while x_c % n_c == 0 {\n        x_c /= n_c;\n        count += 1;\n    }\n\
    \    x_c == 1 && n_c.pow(count) == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (1..=x).any(|i| i.pow(n\
    \ as u32) == x)\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/num/mod.rs:248:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        return\
    \ true;\n    }\n    if n == 1 {\n        return false;\n    }\n    let mut ret\
    \ = 1;\n    for _ in 0..32 {\n        ret *= n;\n        if ret == x {\n     \
    \       return true;\n        }\n        if ret > x {\n            return false;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let res = (x as f64).log(n\
    \ as f64);\n    res == res.trunc()\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp60dyttu5.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (1..)\n        .map(|i|\
    \ n.pow(i))\n        .take_while(|&p| p <= x)\n        .last()\n        .map_or(false,\
    \ |last| last == x)\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        return\
    \ true;\n    }\n    let mut result = n;\n    while result < x {\n        result\
    \ *= n;\n    }\n    result == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (x as f64).log(n as f64).fract()\
    \ == 0.0\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0expl5fd.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (1..).find(|a| a * a * a\
    \ * a * a == x).is_some()\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to multiply with overflow', /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/ops/arith.rs:369:1\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut a = n;\n    while\
    \ a < x {\n        a *= n;\n    }\n    a == x\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpj_z1g2ea.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    // x/n=n**int\n    let mut\
    \ i = 1;\n    let mut a = n;\n    while a <= x {\n        if a == x {\n      \
    \      return true;\n        }\n        a *= n;\n        i += 1;\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp16bneu92.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 && n == 1 {\n\
    \        return true;\n    }\n    let sqrt = (x as f64).sqrt();\n    sqrt == sqrt.trunc()\
    \ && (sqrt as isize).pow(2) == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (1..).find(|&i| i.pow(n\
    \ as u32) == x).is_some()\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmpo4jdm0j6.rs:12:23\n   |\n12 |     (1..).find(|&i| i.pow(n as u32)\
    \ == x).is_some()\n   |                  -    ^^^\n   |                  |\n \
    \  |                  you must specify a type for this binding, like `i32`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0689`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut a = n;\n    let\
    \ mut r = 1;\n    while r < x {\n        r *= a;\n    }\n    r == x\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let m = (x as f64).log(n\
    \ as f64).floor() as isize;\n    n.pow(m) == x\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8i1c8lia.rs:13:11\n   |\n\
    13 |     n.pow(m) == x\n   |           ^ expected `u32`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `u32` and panic if the converted value doesn't\
    \ fit\n   |\n13 |     n.pow(m.try_into().unwrap()) == x\n   |            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (n..((x as f64).log(n as\
    \ f64).ceil() as isize + 1)).any(|i| x == n.pow(i))\n}\n\nfn main() {\n    let\
    \ candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx8pfpa6j.rs:12:76\n   |\n\
    12 |     (n..((x as f64).log(n as f64).ceil() as isize + 1)).any(|i| x == n.pow(i))\n\
    \   |                                                                        \
    \    ^ expected `u32`, found `isize`\n   |\nhelp: you can convert an `isize` to\
    \ a `u32` and panic if the converted value doesn't fit\n   |\n12 |     (n..((x\
    \ as f64).log(n as f64).ceil() as isize + 1)).any(|i| x == n.pow(i.try_into().unwrap()))\n\
    \   |                                                                        \
    \     ++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        return\
    \ true;\n    }\n    let mut m = n;\n    while m < x {\n        m *= n;\n    }\n\
    \    if m == x {\n        return true;\n    }\n    false\n}\n\nfn main() {\n \
    \   let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut p = n;\n    while\
    \ p < x {\n        p *= n;\n    }\n    p == x\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbto45i9y.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let result = x.pow(n.log(x).ceil()\
    \ as u32);\n    result == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0658]: use of unstable library feature 'int_log'\n  --> /tmp/tmpixdqd451.rs:12:26\n\
    \   |\n12 |     let result = x.pow(n.log(x).ceil() as u32);\n   |            \
    \              ^^^\n   |\n   = note: see issue #70887 <https://github.com/rust-lang/rust/issues/70887>\
    \ for more information\n\nerror[E0599]: no method named `ceil` found for type\
    \ `u32` in the current scope\n  --> /tmp/tmpixdqd451.rs:12:33\n   |\n12 |    \
    \ let result = x.pow(n.log(x).ceil() as u32);\n   |                          \
    \       ^^^^ help: there is an associated function with a similar name: `div_ceil`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0658.\nFor more information about an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 0 {\n        return\
    \ false;\n    }\n    let mut flag = true;\n    let mut p = n;\n    while p < x\
    \ {\n        p *= n;\n        if p == x {\n            return true;\n        }\n\
    \        if p > x {\n            flag = false;\n            break;\n        }\n\
    \    }\n    flag\n}\n\nfn main() {\n    let candidate = is_simple_power;\n   \
    \ assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16), false);\n\
    \    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9, 3), true);\n\
    \    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24, 2), false);\n\
    \    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12, 6), false);\n\
    \    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1, 12), true);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let root = (x as f64).sqrt()\
    \ as isize;\n    (n as f64).powi(root) == x as f64\n}\n\nfn main() {\n    let\
    \ candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkjetn036.rs:13:21\n   |\n\
    13 |     (n as f64).powi(root) == x as f64\n   |                     ^^^^ expected\
    \ `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an `i32` and\
    \ panic if the converted value doesn't fit\n   |\n13 |     (n as f64).powi(root.try_into().unwrap())\
    \ == x as f64\n   |                         ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmprz8bita9.rs:12:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    x.is_power_of(n)\n}\n\n\
    fn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_power_of` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmp4gmgk2hc.rs:12:7\n   |\n12 |     x.is_power_of(n)\n\
    \   |       ^^^^^^^^^^^ method not found in `isize`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    n.pow(x.trailing_zeros()\
    \ as u32) == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprn7t5k41.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 { return true;\
    \ }\n    let mut y = n;\n    while y < x {\n        y *= n;\n    }\n    y == x\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut res = x;\n    let\
    \ mut counter = 0;\n    while res % n == 0 {\n        res /= n;\n        counter\
    \ += 1;\n    }\n    if counter == 1 {\n        return true;\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpy3tv2l34.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    n.pow(((x as f64).log(n\
    \ as f64)).round() as u32) == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    match n.pow(1) {\n     \
    \   1 => x == 1,\n        _ => match n.pow(2) {\n            1 => x == 1,\n  \
    \          _ => match n.pow(3) {\n                1 => x == 1,\n             \
    \   _ => match n.pow(4) {\n                    1 => x == 1,\n                \
    \    _ => match n.pow(5) {\n                        1 => x == 1,\n           \
    \             _ => match n.pow(6) {\n                            1 => x == 1,\n\
    \                            _ => match n.pow(7) {\n                         \
    \       1 => x == 1,\n                                _ => match n.pow(8) {\n\
    \                                    1 => x == 1,\n                          \
    \          _ => match n.pow(9) {\n                                        1 =>\
    \ x == 1,\n                                        _ => match n.pow(10) {\n  \
    \                                          1 => x == 1,\n                    \
    \                        _ => false,\n                                       \
    \ },\n                                    },\n                               \
    \ },\n                            },\n                        },\n           \
    \         },\n                },\n            },\n        },\n    }\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpv7smqql3.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut result = n;\n  \
    \  while result <= x {\n        if result == x {\n            return true;\n \
    \       }\n        result *= n;\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkmn6_0k2.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    (n as f64).log(x as f64).fract()\
    \ == 0.0\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6sa4h84g.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 0 || n == 0 {\n\
    \        return false;\n    }\n    let mut i = 1;\n    while i < 10 {\n      \
    \  if n.pow(i) == x {\n            return true;\n        }\n        i += 1;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n  \
    \  assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbn92u_rt.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    match x.checked_pow(1/n)\
    \ {\n        Some(p) => p == n,\n        None => false\n    }\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmzbv960e.rs:12:25\n   |\n\
    12 |     match x.checked_pow(1/n) {\n   |                         ^^^ expected\
    \ `u32`, found `isize`\n   |\nhelp: you can convert an `isize` to a `u32` and\
    \ panic if the converted value doesn't fit\n   |\n12 |     match x.checked_pow((1/n).try_into().unwrap())\
    \ {\n   |                         +   +++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut y = n;\n    while\
    \ y <= x {\n        if y == x {\n            return true;\n        }\n       \
    \ y *= n;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpasxu6bth.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    x == 1 || (x as f64).log(n\
    \ as f64).fract() == 0.0\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        return\
    \ true;\n    }\n    let mut exponent = 2;\n    let mut x_pow_n = n * n;\n    while\
    \ x_pow_n <= x {\n        if x_pow_n == x {\n            return true;\n      \
    \  }\n        exponent += 1;\n        x_pow_n *= n;\n    }\n    false\n}\n\nfn\
    \ main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        return\
    \ true;\n    }\n    let mut num = n;\n    while num < x {\n        num *= n;\n\
    \    }\n    num == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut current = 1;\n \
    \   let mut count = 0;\n    while current <= x {\n        if current == x {\n\
    \            return true;\n        }\n        count += 1;\n        current *=\
    \ n;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut base = n;\n    while\
    \ base < x {\n        base *= n;\n    }\n    base == x\n}\n\nfn main() {\n   \
    \ let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpquw_had7.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut x = x;\n    let\
    \ mut count = 0;\n    while x % n == 0 {\n        x /= n;\n        count += 1;\n\
    \    }\n    count == 1 && x == 1\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp3nfbgdok.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x < 0 || n < 0 {\n  \
    \      return false;\n    }\n    let mut result = n;\n    while result < x {\n\
    \        result *= n;\n    }\n    result == x\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpisi0gvhw.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    n.pow(x.trailing_zeros()\
    \ as u32) == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkxivbaaw.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    x == n.pow(x.to_string().len()\
    \ as u32)\n}\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2i0_5flz.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 0 {\n        return\
    \ false;\n    }\n    (n as f64).log(x as f64).fract() == 0.0\n}\n\nfn main() {\n\
    \    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4qj_m37t.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        return\
    \ true;\n    }\n    if n == 1 {\n        return false;\n    }\n    let mut i =\
    \ 2;\n    let mut res = 1;\n    while res < x {\n        res *= n;\n        i\
    \ += 1;\n    }\n    if res == x {\n        return true;\n    }\n    false\n}\n\
    \nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut a = x;\n    while\
    \ a > 1 {\n        if a % n != 0 {\n            return false;\n        }\n   \
    \     a /= n;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 0 {\n        return\
    \ false;\n    }\n    let exp = (x as f64).log(n as f64).round() as isize;\n  \
    \  n.pow(exp) == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n \
    \   assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_swyzm8p.rs:16:11\n   |\n\
    16 |     n.pow(exp) == x\n   |           ^^^ expected `u32`, found `isize`\n \
    \  |\nhelp: you can convert an `isize` to a `u32` and panic if the converted value\
    \ doesn't fit\n   |\n16 |     n.pow(exp.try_into().unwrap()) == x\n   |      \
    \        ++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let mut i = 1;\n    while\
    \ i.pow(n as u32) < x {\n        i += 1;\n    }\n    i.pow(n as u32) == x\n}\n\
    \nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmpp911xv58.rs:13:13\n   |\n13 |     while i.pow(n as u32) < x {\n\
    \   |             ^^^\n   |\nhelp: you must specify a type for this binding, like\
    \ `i32`\n   |\n12 |     let mut i: i32 = 1;\n   |         ~~~~~~~~~~\n\nerror[E0689]:\
    \ can't call method `pow` on ambiguous numeric type `{integer}`\n  --> /tmp/tmpp911xv58.rs:16:7\n\
    \   |\n16 |     i.pow(n as u32) == x\n   |       ^^^\n   |\nhelp: you must specify\
    \ a type for this binding, like `i32`\n   |\n12 |     let mut i: i32 = 1;\n  \
    \ |         ~~~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0689`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    // answer is at most the\
    \ square root of x\n    let limit = (x as f64).sqrt() as isize;\n    // base to\
    \ be tested\n    let mut base = n;\n    // try to find a perfect square of the\
    \ base\n    while base <= limit {\n        // perfect square found\n        if\
    \ base * base == x {\n            return true;\n        }\n        // go to the\
    \ next even power\n        base *= n;\n    }\n    false\n}\n\nfn main() {\n  \
    \  let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwoa50gdp.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 0 || n == 0 {\n\
    \        return false;\n    }\n    for i in 1..=x {\n        if n.pow(i) == x\
    \ {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n\
    \    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppqfs2v88.rs:16:18\n   |\n\
    16 |         if n.pow(i) == x {\n   |                  ^ expected `u32`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `u32` and panic if the\
    \ converted value doesn't fit\n   |\n16 |         if n.pow(i.try_into().unwrap())\
    \ == x {\n   |                   ++++++++++++++++++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    let n_square = n.pow(2);\n\
    \    if n_square == x {\n        return true;\n    }\n    if n_square > x {\n\
    \        return false;\n    }\n    is_simple_power(x, n_square)\n}\n\nfn main()\
    \ {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n\
    \    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4, 2),\
    \ true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzj0fa4c6.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 0 {\n        return\
    \ true;\n    }\n    let mut x = x;\n    while x % n == 0 {\n        x /= n;\n\
    \    }\n    x == 1\n}\n\nfn main() {\n    let candidate = is_simple_power;\n \
    \   assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    n.pow((x as f64).log(n as\
    \ f64) as u32) == x\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 {\n        return\
    \ true;\n    }\n    for i in 1..x {\n        if n.pow(i) == x {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_simple_power;\n\
    \    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214, 16),\
    \ false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp27jpqvbw.rs:16:18\n   |\n\
    16 |         if n.pow(i) == x {\n   |                  ^ expected `u32`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `u32` and panic if the\
    \ converted value doesn't fit\n   |\n16 |         if n.pow(i.try_into().unwrap())\
    \ == x {\n   |                   ++++++++++++++++++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x <= 0 || n <= 0 {\n\
    \        return false;\n    }\n    let mut result = n;\n    while result < x {\n\
    \        result *= n;\n    }\n    result == x\n}\n\nfn main() {\n    let candidate\
    \ = is_simple_power;\n    assert_eq!(candidate(16, 2), true);\n    assert_eq!(candidate(143214,\
    \ 16), false);\n    assert_eq!(candidate(4, 2), true);\n    assert_eq!(candidate(9,\
    \ 3), true);\n    assert_eq!(candidate(16, 4), true);\n    assert_eq!(candidate(24,\
    \ 2), false);\n    assert_eq!(candidate(128, 4), false);\n    assert_eq!(candidate(12,\
    \ 6), false);\n    assert_eq!(candidate(1, 1), true);\n    assert_eq!(candidate(1,\
    \ 12), true);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpt2rcrwyr.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Your task is to write a function that returns true if a number x is\
    \ a simple\n/// power of n and false in other cases.\n/// x is a simple power\
    \ of n if n**int=x\n/// For example:\n/// is_simple_power(1, 4) => true\n/// is_simple_power(2,\
    \ 2) => true\n/// is_simple_power(8, 2) => true\n/// is_simple_power(3, 2) =>\
    \ false\n/// is_simple_power(3, 1) => false\n/// is_simple_power(5, 3) => false\n\
    fn is_simple_power(x: isize, n: isize) -> bool {\n    if x == 1 { return true;\
    \ }\n    let mut r = n;\n    while r < x {\n        r *= n;\n    }\n    r == x\n\
    }\n\nfn main() {\n    let candidate = is_simple_power;\n    assert_eq!(candidate(16,\
    \ 2), true);\n    assert_eq!(candidate(143214, 16), false);\n    assert_eq!(candidate(4,\
    \ 2), true);\n    assert_eq!(candidate(9, 3), true);\n    assert_eq!(candidate(16,\
    \ 4), true);\n    assert_eq!(candidate(24, 2), false);\n    assert_eq!(candidate(128,\
    \ 4), false);\n    assert_eq!(candidate(12, 6), false);\n    assert_eq!(candidate(1,\
    \ 1), true);\n    assert_eq!(candidate(1, 12), true);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
