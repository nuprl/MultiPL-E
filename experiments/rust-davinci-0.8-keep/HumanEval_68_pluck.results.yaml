name: HumanEval_68_pluck
language: rust
results:
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even = (0..10000).rev();\n    for i in arr.iter().enumerate() {\n\
    \        if i.1 % 2 == 0 {\n            even = i.0..i.0 + 1;\n            break;\n\
    \        }\n    }\n    if even.start > even.end {\n        return vec![];\n  \
    \  }\n    vec![arr[even.start], even.start as isize]\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg8dms5eh.rs:30:20\n   |\n\
    27 |     let mut even = (0..10000).rev();\n   |                    ----------------\
    \ expected due to this value\n...\n30 |             even = i.0..i.0 + 1;\n   |\
    \                    ^^^^^^^^^^^^ expected struct `Rev`, found struct `std::ops::Range`\n\
    \   |\n   = note: expected struct `Rev<std::ops::Range<{integer}>>`\n        \
    \      found struct `std::ops::Range<usize>`\n\nerror[E0609]: no field `start`\
    \ on type `Rev<std::ops::Range<{integer}>>`\n  --> /tmp/tmpg8dms5eh.rs:34:13\n\
    \   |\n34 |     if even.start > even.end {\n   |             ^^^^^ unknown field\n\
    \nerror[E0609]: no field `end` on type `Rev<std::ops::Range<{integer}>>`\n  -->\
    \ /tmp/tmpg8dms5eh.rs:34:26\n   |\n34 |     if even.start > even.end {\n   | \
    \                         ^^^ unknown field\n\nerror[E0609]: no field `start`\
    \ on type `Rev<std::ops::Range<{integer}>>`\n  --> /tmp/tmpg8dms5eh.rs:37:19\n\
    \   |\n37 |     vec![arr[even.start], even.start as isize]\n   |             \
    \      ^^^^^ unknown field\n\nerror[E0609]: no field `start` on type `Rev<std::ops::Range<{integer}>>`\n\
    \  --> /tmp/tmpg8dms5eh.rs:37:32\n   |\n37 |     vec![arr[even.start], even.start\
    \ as isize]\n   |                                ^^^^^ unknown field\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0609.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = std::isize::MAX;\n    let mut min_idx = 0;\n    for (i, x)\
    \ in arr.iter().enumerate() {\n        if x % 2 == 0 && x < &min {\n         \
    \   min = *x;\n            min_idx = i;\n        }\n    }\n    if min == std::isize::MAX\
    \ {\n        vec![]\n    } else {\n        vec![min, min_idx as isize]\n    }\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return Vec::new();\n    }\n    let mut min_even\
    \ = isize::max_value();\n    let mut index = 0;\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if n % 2 == 0 && n < &min_even {\n            min_even = *n;\n  \
    \          index = i;\n        }\n    }\n    if min_even == isize::max_value()\
    \ {\n        return Vec::new();\n    }\n    vec![min_even, index as isize]\n}\n\
    \nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2,\
    \ 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even = std::isize::MAX;\n    let mut idx = std::isize::MAX;\n   \
    \ for (i, v) in arr.iter().enumerate() {\n        if *v % 2 == 0 && *v < even\
    \ {\n            even = *v;\n            idx = i as isize;\n        }\n    }\n\
    \    if even == std::isize::MAX {\n        vec![]\n    } else {\n        vec![even,\
    \ idx]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest_value = 10001;\n    let mut smallest_value_index = 10001;\n\
    \    for (i, e) in arr.iter().enumerate() {\n        if *e % 2 == 0 && *e < smallest_value\
    \ {\n            smallest_value = *e;\n            smallest_value_index = i as\
    \ isize;\n        }\n    }\n    if smallest_value == 10001 {\n        return vec![];\n\
    \    }\n    vec![smallest_value, smallest_value_index]\n}\n\nfn main() {\n   \
    \ let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even = arr.iter().enumerate().filter(|&(_, &v)| v % 2 == 0);\n  \
    \  if let Some((i, &v)) = even.next() {\n        let mut min = (v, i);\n     \
    \   for (i, &v) in even {\n            if v < min.0 {\n                min = (v,\
    \ i);\n            }\n        }\n        vec![min.0, min.1 as isize]\n    } else\
    \ {\n        vec![]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n   \
    \ assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    use std::cmp::Ordering;\n    arr.iter()\n        .enumerate()\n        .filter(|(_,\
    \ node)| node.rem_euclid(2) == 0)\n        .min_by(|(_, node_a), (_, node_b)|\
    \ match node_a.cmp(node_b) {\n            Ordering::Equal => Ordering::Equal,\n\
    \            Ordering::Less => Ordering::Less,\n            Ordering::Greater\
    \ => Ordering::Greater,\n        })\n        .map(|(index, node)| vec![*node,\
    \ index as isize])\n        .unwrap_or_else(|| vec![])\n}\n\nfn main() {\n   \
    \ let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.len() == 0 {\n        return vec![];\n    }\n    let mut min = std::isize::MAX;\n\
    \    let mut index = 0;\n    for (i, v) in arr.iter().enumerate() {\n        if\
    \ v % 2 == 0 && v < &min {\n            min = *v;\n            index = i;\n  \
    \      }\n    }\n    if min == std::isize::MAX {\n        return vec![];\n   \
    \ }\n    vec![min, index as isize]\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.len() == 0 {\n        return vec![];\n    }\n    let index = arr.iter().enumerate().filter(|(_,\
    \ e)| e % 2 == 0).min_by_key(|(i, _)| *i).unwrap();\n    vec![*index.1, index.0\
    \ as isize]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmpvnd84ef0.rs:30:58\n\
    \   |\n30 |     let index = arr.iter().enumerate().filter(|(_, e)| e % 2 == 0).min_by_key(|(i,\
    \ _)| *i).unwrap();\n   |                                                    \
    \    - ^ - {integer}\n   |                                                   \
    \     |\n   |                                                        &&isize\n\
    \   |\nhelp: `%` can be used on `isize`, you can dereference `e`\n   |\n30 | \
    \    let index = arr.iter().enumerate().filter(|(_, e)| *e % 2 == 0).min_by_key(|(i,\
    \ _)| *i).unwrap();\n   |                                                    \
    \    +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest_value = None;\n    let mut smallest_value_index = None;\n\
    \    for (i, x) in arr.iter().enumerate() {\n        if x % 2 == 0 {\n       \
    \     if smallest_value.is_none() {\n                smallest_value = Some(*x);\n\
    \                smallest_value_index = Some(i);\n            } else if x < smallest_value.unwrap()\
    \ {\n                smallest_value = Some(*x);\n                smallest_value_index\
    \ = Some(i);\n            }\n        }\n    }\n    if smallest_value.is_none()\
    \ {\n        return vec![];\n    }\n    return vec![smallest_value.unwrap(), smallest_value_index.unwrap()\
    \ as isize];\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi316hgyf.rs:34:27\n   |\n\
    34 |             } else if x < smallest_value.unwrap() {\n   |               \
    \            ^^^^^^^^^^^^^^^^^^^^^^^\n   |                           |\n   | \
    \                          expected `&isize`, found `isize`\n   |            \
    \               help: consider borrowing here: `&smallest_value.unwrap()`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut r = Vec::<isize>::new();\n    let mut smallest = std::isize::MAX;\n\
    \    let mut index = 0;\n    for i in 0..arr.len() {\n        if arr[i] % 2 ==\
    \ 0 && arr[i] < smallest {\n            index = i;\n            smallest = arr[i];\n\
    \        }\n    }\n    if smallest < std::isize::MAX {\n        r.push(smallest);\n\
    \        r.push(index as isize);\n    }\n    r\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.len() == 0 {\n        return vec![];\n    }\n    let mut arr = arr;\n\
    \    arr.sort();\n    let mut min_even = isize::max_value();\n    let mut min_index\
    \ = isize::max_value();\n    for (i, &a) in arr.iter().enumerate() {\n       \
    \ if a % 2 == 0 && a < min_even {\n            min_even = a;\n            min_index\
    \ = i as isize;\n        }\n    }\n    if min_even == isize::max_value() {\n \
    \       return vec![];\n    }\n    vec![min_even, min_index]\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 0]`,\n right: `[2, 1]`', /tmp/tmpwpq17cjo.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = None;\n    let mut min_i = None;\n    for (i, x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 {\n            if min.is_none() || x < &min.unwrap()\
    \ {\n                min = Some(*x);\n                min_i = Some(i as isize);\n\
    \            }\n        }\n    }\n    match (min, min_i) {\n        (Some(m),\
    \ Some(i)) => vec![m, i],\n        _ => vec![],\n    }\n}\n\nfn main() {\n   \
    \ let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest_even_value = vec![];\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if n % 2 == 0 {\n            smallest_even_value.push(n);\n     \
    \       smallest_even_value.push(i as isize);\n            break;\n        }\n\
    \    }\n    for (i, n) in arr.iter().enumerate() {\n        if n % 2 == 0 && n\
    \ < smallest_even_value[0] {\n            smallest_even_value = vec![*n, i as\
    \ isize];\n        }\n    }\n    smallest_even_value\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7cg8qv0v.rs:31:38\n   |\n\
    31 |             smallest_even_value.push(i as isize);\n   |                 \
    \                     ^^^^^^^^^^\n   |                                      |\n\
    \   |                                      expected `&isize`, found `isize`\n\
    \   |                                      help: consider borrowing here: `&(i\
    \ as isize)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7cg8qv0v.rs:37:40\n\
    \   |\n37 |             smallest_even_value = vec![*n, i as isize];\n   |    \
    \                                    ^^\n   |                                \
    \        |\n   |                                        expected `&isize`, found\
    \ `isize`\n   |                                        help: consider borrowing\
    \ here: `&*n`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7cg8qv0v.rs:40:5\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \            ---------- expected `Vec<isize>` because of return type\n...\n40\
    \ |     smallest_even_value\n   |     ^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<&isize>`\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    unimplemented!();\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmphov142dq.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = isize::max_value();\n    let mut min_index = 0;\n    for\
    \ (index, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val <\
    \ min_even {\n            min_even = val;\n            min_index = index;\n  \
    \      }\n    }\n    if min_even != isize::max_value() {\n        vec![min_even,\
    \ min_index as isize]\n    } else {\n        vec![]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut copy = arr.clone();\n    copy.sort();\n    let mut candidate = None;\n\
    \    for x in copy {\n        if x % 2 == 0 {\n            candidate = Some(x);\n\
    \            break;\n        }\n    }\n    let index = match candidate {\n   \
    \     Some(c) => arr.iter().position(|&n| n == c),\n        None => None,\n  \
    \  };\n    index.map(|i| vec![arr[i], i as isize]).unwrap_or(vec![])\n}\n\nfn\
    \ main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even_value = isize::max_value();\n    let mut min_even_index\
    \ = usize::max_value();\n    for (i, v) in arr.iter().enumerate() {\n        if\
    \ v % 2 == 0 && v < &min_even_value {\n            min_even_value = *v;\n    \
    \        min_even_index = i;\n        }\n    }\n    if min_even_index != usize::max_value()\
    \ {\n        vec![min_even_value, min_even_index as isize]\n    } else {\n   \
    \     vec![]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = std::isize::MAX;\n    let mut min_index = 0;\n    for (i, v)\
    \ in arr.iter().enumerate() {\n        if *v % 2 == 0 && *v < min {\n        \
    \    min = *v;\n            min_index = i;\n        }\n    }\n    if min == std::isize::MAX\
    \ {\n        vec![]\n    } else {\n        vec![min, min_index as isize]\n   \
    \ }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = arr.iter().enumerate().filter(|(_, x)| *x % 2 == 0).collect::<Vec<_>>();\n\
    \    evens.sort_by_key(|(_, x)| x);\n    evens.get(0).map(|&(i, v)| vec![*v, i\
    \ as isize]).unwrap_or_else(|| vec![])\n}\n\nfn main() {\n    let candidate =\
    \ pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error: lifetime may not live long enough\n  --> /tmp/tmp_o1u69gs.rs:28:32\n\
    \   |\n28 |     evens.sort_by_key(|(_, x)| x);\n   |                        -------\
    \ ^ returning this value requires that `'1` must outlive `'2`\n   |          \
    \              |     |\n   |                        |     return type of closure\
    \ is &'2 &isize\n   |                        has type `&'1 (usize, &isize)`\n\n\
    error: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = isize::max_value();\n    let mut index = 0;\n    for (i, x)\
    \ in arr.iter().enumerate() {\n        if x % 2 == 0 && x < &min {\n         \
    \   min = *x;\n            index = i;\n        }\n    }\n    if min == isize::max_value()\
    \ {\n        return vec![];\n    }\n    vec![min, index as isize]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut r = Vec::new();\n    for (i, x) in arr.iter().enumerate() {\n   \
    \     if r.is_empty() {\n            if x % 2 == 0 {\n                r.push(*x);\n\
    \                r.push(i as isize);\n            }\n        } else {\n      \
    \      if x % 2 == 0 && x < &r[0] {\n                r[0] = *x;\n            \
    \    r[1] = i as isize;\n            }\n        }\n    }\n    r\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_indices = vec![];\n    let mut even_values = vec![];\n    for\
    \ (i, val) in arr.iter().enumerate() {\n        if val % 2 == 0 {\n          \
    \  even_indices.push(i);\n            even_values.push(*val);\n        }\n   \
    \ }\n    if even_values.is_empty() {\n        return vec![];\n    }\n    let even_min\
    \ = even_values.iter().min().unwrap();\n    let min_index = even_values.iter().position(|&x|\
    \ x == *even_min).unwrap();\n    vec![even_values[min_index], even_indices[min_index]\
    \ as isize]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = 10001;\n    let mut idx = -1;\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if n % 2 == 0 && n < &min {\n            min = *n;\n            idx\
    \ = i as isize;\n        }\n    }\n    if idx == -1 {\n        return vec![];\n\
    \    }\n    vec![min, idx]\n}\n\nfn main() {\n    let candidate = pluck;\n   \
    \ assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    let mut even = std::isize::MAX;\n\
    \    let mut index = std::isize::MAX;\n    for (i, v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 && v < &even {\n            even = *v;\n          \
    \  index = i as isize;\n        }\n    }\n    if even == std::isize::MAX {\n \
    \       return vec![];\n    }\n    vec![even, index]\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = arr.iter().enumerate().filter(|(_, &x)| x % 2 == 0).collect::<Vec<_>>();\n\
    \    if evens.is_empty() {\n        vec![]\n    } else {\n        evens.sort_by_key(|x|\
    \ x.1);\n        vec![*evens[0].1, evens[0].0 as isize]\n    }\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = arr.iter().enumerate().filter(|&(_, n)| n % 2 == 0).collect::<Vec<_>>();\n\
    \    evens.sort_by_key(|&(_, n)| n);\n    match evens.first() {\n        Some((i,\
    \ n)) => vec![*n, *i as isize],\n        None => vec![],\n    }\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuk5ktm5b.rs:30:30\n   |\n\
    30 |         Some((i, n)) => vec![*n, *i as isize],\n   |                    \
    \          ^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n30 |         Some((i, n)) => vec![**n, *i as isize],\n   |\
    \                              +\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_idx = std::isize::MAX;\n\
    \    for (idx, elem) in arr.iter().enumerate() {\n        if elem % 2 == 0 &&\
    \ elem < &min_even {\n            min_even = *elem;\n            min_idx = idx\
    \ as isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        return\
    \ vec![];\n    }\n    vec![min_even, min_idx]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest_even = isize::max_value();\n    let mut smallest_even_idx\
    \ = usize::max_value();\n    for (idx, value) in arr.iter().enumerate() {\n  \
    \      if *value % 2 == 0 && *value < smallest_even {\n            smallest_even\
    \ = *value;\n            smallest_even_idx = idx;\n        }\n    }\n    if smallest_even_idx\
    \ == usize::max_value() {\n        vec![]\n    } else {\n        vec![smallest_even,\
    \ smallest_even_idx as isize]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = vec![];\n    for (i, v) in arr.iter().enumerate() {\n   \
    \     if v % 2 == 0 {\n            evens.push((*v, i));\n        }\n    }\n  \
    \  evens.sort_by(|a, b| a.0.cmp(&b.0));\n    if evens.is_empty() {\n        vec![]\n\
    \    } else {\n        vec![evens[0].0, evens[0].1 as isize]\n    }\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    let mut min_even\
    \ = std::isize::MAX;\n    let mut min_index = 0;\n    for (index, value) in arr.iter().enumerate()\
    \ {\n        if value % 2 == 0 && value < &min_even {\n            min_even =\
    \ *value;\n            min_index = index;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        return vec![];\n    }\n    vec![min_even, min_index\
    \ as isize]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest = isize::max_value();\n    let mut index = 0;\n    for (i,\
    \ x) in arr.iter().enumerate() {\n        if x & 1 == 0 && x < &smallest {\n \
    \           smallest = *x;\n            index = i;\n        }\n    }\n    if smallest\
    \ == isize::max_value() { vec![] } else { vec![smallest, index as isize] }\n}\n\
    \nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2,\
    \ 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    use std::collections::VecDeque;\n    let mut queue = VecDeque::new();\n \
    \   queue.push_back((0, 0));\n    let mut result = isize::max_value();\n    let\
    \ mut index = 0;\n    while let Some((p, i)) = queue.pop_front() {\n        if\
    \ p >= arr.len() {\n            continue;\n        }\n        if arr[p] % 2 ==\
    \ 0 && arr[p] < result {\n            result = arr[p];\n            index = i;\n\
    \        }\n        queue.push_back((2 * p + 1, 2 * i + 1));\n        queue.push_back((2\
    \ * p + 2, 2 * i + 2));\n    }\n    if result == isize::max_value() {\n      \
    \  vec![]\n    } else {\n        vec![result, index]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    let mut min_even\
    \ = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n    for (idx,\
    \ &i) in arr.iter().enumerate() {\n        if i % 2 == 0 && i < min_even {\n \
    \           min_even = i;\n            min_even_idx = idx as isize;\n        }\n\
    \    }\n    if min_even_idx == std::isize::MAX {\n        return vec![];\n   \
    \ }\n    vec![min_even, min_even_idx]\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let result = arr.iter().enumerate().filter(|&(_, &num)| num % 2 == 0).min_by_key(|&(_,\
    \ &num)| num);\n    match result {\n        Some((index, value)) => vec![*value,\
    \ index as isize],\n        None => vec![],\n    }\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.iter()\n        .enumerate()\n        .filter(|(_, val)| val.is_even())\n\
    \        .min_by_key(|(idx, val)| (*val, *idx))\n        .map(|(idx, val)| vec![*val,\
    \ idx as isize])\n        .unwrap_or_else(|| vec![])\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_even` found for reference `&&isize` in\
    \ the current scope\n  --> /tmp/tmpuwdwgit4.rs:29:32\n   |\n29 |         .filter(|(_,\
    \ val)| val.is_even())\n   |                                ^^^^^^^ method not\
    \ found in `&&isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.len() < 1 {\n        return vec![];\n    }\n    let mut evens: Vec<isize>\
    \ = arr.iter().filter(|&&i| i % 2 == 0).cloned().collect();\n    evens.sort();\n\
    \    if evens.len() == 0 {\n        return vec![];\n    }\n    let v = evens[0];\n\
    \    let i = arr.iter().position(|&x| x == v).unwrap();\n    vec![v, i as isize]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.len() < 1 {\n        return vec![];\n    }\n    let mut even_idx =\
    \ Vec::new();\n    let mut even_val = std::isize::MAX;\n    for i in 0..arr.len()\
    \ {\n        if arr[i] % 2 == 0 {\n            if arr[i] < even_val {\n      \
    \          even_val = arr[i];\n                even_idx.clear();\n           \
    \     even_idx.push(i);\n            } else if arr[i] == even_val {\n        \
    \        even_idx.push(i);\n            }\n        }\n    }\n    if even_idx.len()\
    \ < 1 {\n        return vec![];\n    }\n    let mut min_idx = std::usize::MAX;\n\
    \    for i in 0..even_idx.len() {\n        if even_idx[i] < min_idx {\n      \
    \      min_idx = even_idx[i];\n        }\n    }\n    vec![even_val, min_idx as\
    \ isize]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // Since the input is not a full binary tree, we need to first convert it\
    \ to a full binary tree.\n    // The full binary tree of size N can have N/2 internal\
    \ nodes and N/2 leaf nodes.\n    // Thus, we need to extend the input with N/2\
    \ \"dummy\" internal nodes.\n    //\n    // The new binary tree is constructed\
    \ based on the following rules:\n    // * the full binary tree has N + N/2 nodes,\
    \ where N is the size of the original tree\n    // * the first N nodes are the\
    \ original tree\n    // * after the first N nodes, the rest of the tree is constructed\
    \ incrementally,\n    //   one node at a time.\n    // * each node after the first\
    \ N nodes has as left child the node at index 2*i,\n    //   where 2*i < N is\
    \ the current index of the node in the tree.\n    // * each node after the first\
    \ N nodes has as right child the node at index 2*i+1,\n    //   where 2*i+1 <\
    \ N is the current index of the node in the tree.\n    // * each node after the\
    \ first N nodes has value 0, except for the first one,\n    //   which has value\
    \ 1.\n    // * the last node in the tree, which must be a leaf node, has value\
    \ 0.\n    //\n    // Example:\n    //\n    // Given: [5, 0, 3, 0, 4, 2]\n    //\n\
    \    // This is the full binary tree:\n    //    [5, 0, 3, 0, 4, 2, 0, 0, 0, 0,\
    \ 0, 0, 0, 0, 0]\n    //      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14\n  \
    \  //\n    // The first N nodes are the original tree:\n    //    [5, 0, 3, 0,\
    \ 4, 2]\n    //      0  1  2  3  4  5\n    //\n    // The next N/2 nodes are constructed\
    \ incrementally, starting from the node at index N:\n    //\n    //        6 \
    \ // N = 6, node at 2*i = 2*6 = 12 < N\n    //       / \\\n   \n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0mm57bvc.rs:26:30\n   |\n\
    26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |    -----                \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // Make a list of all even numbers.\n    let mut even = Vec::new();\n   \
    \ let mut i = 0;\n    while i < arr.len() {\n        if arr[i] % 2 == 0 {\n  \
    \          even.push(arr[i]);\n        }\n        i += 1;\n    }\n    // Sort\
    \ the list.\n    even.sort();\n    if even.len() == 0 {\n        // No even numbers.\n\
    \        return vec![];\n    }\n    // Smallest even number.\n    let small =\
    \ even[0];\n    // Search for the index of that number in the original array.\n\
    \    let mut i = 0;\n    while i < arr.len() {\n        if arr[i] == small {\n\
    \            // The answer is a vec containing the smallest even number and its\
    \ index.\n            return vec![small, i as isize];\n        }\n        i +=\
    \ 1;\n    }\n    // Should never get here.\n    vec![]\n}\n\nfn main() {\n   \
    \ let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.len() == 0 {\n        return vec![];\n    }\n    let mut min = 10001;\n\
    \    let mut min_index = 10001;\n    for (i, v) in arr.iter().enumerate() {\n\
    \        if v % 2 == 0 && v < &min {\n            min = *v;\n            min_index\
    \ = i as isize;\n        }\n    }\n    if min == 10001 {\n        return vec![];\n\
    \    }\n    vec![min, min_index]\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = vec![];\n    for (i, v) in arr.iter().enumerate() {\n   \
    \     if v % 2 == 0 {\n            evens.push((v, i));\n        }\n    }\n   \
    \ evens.sort_by(|a, b| (a.0, a.1).cmp(&(b.0, b.1)));\n    if evens.is_empty()\
    \ {\n        vec![]\n    } else {\n        let mut ans = vec![evens[0].0];\n \
    \       ans.push(evens[0].1 as isize);\n        ans\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmav4mg04.rs:38:18\n   |\n\
    38 |         ans.push(evens[0].1 as isize);\n   |                  ^^^^^^^^^^^^^^^^^^^\n\
    \   |                  |\n   |                  expected `&isize`, found `isize`\n\
    \   |                  help: consider borrowing here: `&(evens[0].1 as isize)`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpmav4mg04.rs:39:9\n   |\n26 | fn\
    \ pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                              ----------\
    \ expected `Vec<isize>` because of return type\n...\n39 |         ans\n   |  \
    \       ^^^ expected `isize`, found `&isize`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n              found struct `Vec<&isize>`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.iter()\n        .enumerate()\n        .filter(|(_, &x)| x % 2 == 0)\n\
    \        .min_by_key(|(_, &x)| x)\n        .map(|(i, &x)| vec![x, i as isize])\n\
    \        .unwrap_or_else(|| vec![])\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = arr.iter().enumerate().filter(|(_, v)| v % 2 == 0).collect::<Vec<_>>();\n\
    \    if evens.is_empty() {\n        return vec![];\n    }\n    evens.sort_by_key(|(_,\
    \ v)| *v);\n    let (i, v) = evens[0];\n    vec![*v, i as isize]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmpu2h39nd0.rs:27:62\n\
    \   |\n27 |     let mut evens = arr.iter().enumerate().filter(|(_, v)| v % 2 ==\
    \ 0).collect::<Vec<_>>();\n   |                                              \
    \              - ^ - {integer}\n   |                                         \
    \                   |\n   |                                                  \
    \          &&isize\n   |\nhelp: `%` can be used on `isize`, you can dereference\
    \ `v`\n   |\n27 |     let mut evens = arr.iter().enumerate().filter(|(_, v)| *v\
    \ % 2 == 0).collect::<Vec<_>>();\n   |                                       \
    \                     +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    let mut vec: Vec<isize>\
    \ = vec![];\n    let mut min = isize::max_value();\n    for (index, item) in arr.iter().enumerate()\
    \ {\n        if item % 2 == 0 && *item < min {\n            vec.clear();\n   \
    \         vec.push(*item);\n            vec.push(index as isize);\n          \
    \  min = *item;\n        }\n    }\n    if vec.is_empty() {\n        vec![]\n \
    \   } else {\n        vec\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    let mut min_even\
    \ = isize::max_value();\n    let mut min_even_index = 0;\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if *n % 2 == 0 && *n < min_even {\n            min_even = *n;\n \
    \           min_even_index = i;\n        }\n    }\n    if min_even == isize::max_value()\
    \ {\n        return vec![];\n    }\n    vec![min_even, min_even_index as isize]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest_even = None;\n    let mut smallest_even_index = None;\n\
    \    for (index, item) in arr.iter().enumerate() {\n        if item % 2 == 0 {\n\
    \            if smallest_even.is_none() || *item < smallest_even.unwrap() {\n\
    \                smallest_even = Some(*item);\n                smallest_even_index\
    \ = Some(index);\n            }\n        }\n    }\n    if smallest_even.is_none()\
    \ {\n        vec![]\n    } else {\n        vec![smallest_even.unwrap(), smallest_even_index.unwrap()\
    \ as isize]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // check if there are any even values, then pick the smallest\n    let mut\
    \ smallest_even = 999999999999999;\n    let mut smallest_index = 999999999999999;\n\
    \    let mut found_even = false;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ % 2 == 0 {\n            if arr[i] < smallest_even {\n                smallest_even\
    \ = arr[i];\n                smallest_index = i as isize;\n            }\n   \
    \         found_even = true;\n        }\n    }\n    if found_even {\n        vec![smallest_even,\
    \ smallest_index]\n    } else {\n        vec![]\n    }\n}\n\nfn main() {\n   \
    \ let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut indices = vec![];\n    let mut evens = vec![];\n    for (i, x) in\
    \ arr.iter().enumerate() {\n        if x % 2 == 0 {\n            indices.push(i);\n\
    \            evens.push(*x);\n        }\n    }\n    if evens.is_empty() {\n  \
    \      return vec![];\n    }\n    let min = evens.iter().min().unwrap();\n   \
    \ let mut result = vec![];\n    for i in indices {\n        if arr[i] == *min\
    \ {\n            result.push(arr[i]);\n            result.push(i as isize);\n\
    \            break;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut idx = -1;\n    let mut smallest = arr.len() as isize;\n    for (i,\
    \ n) in arr.iter().enumerate() {\n        if *n % 2 == 0 && n < &smallest {\n\
    \            smallest = *n;\n            idx = i as isize;\n        }\n    }\n\
    \    if idx == -1 { vec![] } else { vec![smallest, idx] }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[6, 1]`', /tmp/tmplj4p6s2j.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut res = vec![];\n    let mut smallest_index = 0;\n    let mut smallest_value\
    \ = 0;\n    for (index, &value) in arr.iter().enumerate() {\n        if value\
    \ % 2 == 0 {\n            if res.is_empty() {\n                res.push(value);\n\
    \                res.push(index as isize);\n                smallest_index = index;\n\
    \                smallest_value = value;\n            } else {\n             \
    \   if value < smallest_value {\n                    res[0] = value;\n       \
    \             res[1] = index as isize;\n                    smallest_index = index;\n\
    \                    smallest_value = value;\n                } else if value\
    \ == smallest_value && index < smallest_index {\n                    res[0] =\
    \ value;\n                    res[1] = index as isize;\n                    smallest_index\
    \ = index;\n                    smallest_value = value;\n                }\n \
    \           }\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = None;\n    let mut idx = None;\n    for (i, &v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 {\n            match min {\n                None =>\
    \ {\n                    min = Some(v);\n                    idx = Some(i);\n\
    \                }\n                Some(m) => {\n                    if v < m\
    \ {\n                        min = Some(v);\n                        idx = Some(i);\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   match (min, idx) {\n        (Some(m), Some(i)) => vec![m, i as isize],\n \
    \       _ => vec![],\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n  \
    \  assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = 9999;\n    let mut index = 9999;\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if n.trailing_zeros() == 1 && n < &min {\n            min = *n;\n\
    \            index = i as isize;\n        }\n    }\n    if min == 9999 {\n   \
    \     vec![]\n    } else {\n        vec![min, index]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 5]`,\n right: `[0, 1]`', /tmp/tmp2vfwgr8o.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.iter()\n        .enumerate()\n        .filter(|(_, &n)| n % 2 == 0)\n\
    \        .min_by_key(|(_, &n)| n)\n        .map(|(i, &n)| vec![n, i as isize])\n\
    \        .unwrap_or_else(|| vec![])\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = std::isize::MAX;\n    let mut idx = -1;\n    for (i, x) in\
    \ arr.iter().enumerate() {\n        if x % 2 == 0 && x < &min {\n            min\
    \ = *x;\n            idx = i as isize;\n        }\n    }\n    if idx < 0 { vec![]\
    \ } else { vec![min, idx] }\n}\n\nfn main() {\n    let candidate = pluck;\n  \
    \  assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, value) in arr.iter().enumerate() {\n        if value % 2 == 0 &&\
    \ *value < min_even {\n            min_even = *value;\n            min_even_idx\
    \ = idx as isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n  \
    \      vec![]\n    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.iter()\n        .enumerate()\n        .filter(|(_, n)| n.is_even())\n\
    \        .min_by_key(|(_, n)| *n)\n        .map(|(i, n)| vec![*n, i as isize])\n\
    \        .unwrap_or_else(|| vec![])\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_even` found for reference `&&isize` in\
    \ the current scope\n  --> /tmp/tmpcnku_w_p.rs:29:28\n   |\n29 |         .filter(|(_,\
    \ n)| n.is_even())\n   |                            ^^^^^^^ method not found in\
    \ `&&isize`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut ret = vec![];\n    let mut min = isize::max_value();\n    let mut\
    \ min_idx = -1isize;\n    for (i, v) in arr.iter().enumerate() {\n        if v\
    \ & 1 == 0 && v < &min {\n            min = *v;\n            min_idx = i as isize;\n\
    \        }\n    }\n    if min != isize::max_value() {\n        ret.push(min);\n\
    \        ret.push(min_idx);\n    }\n    ret\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = arr.iter().enumerate().filter(|(_, &n)| n % 2 == 0).collect::<Vec<_>>();\n\
    \    evens.sort_by_key(|(_, &n)| n);\n    evens.first().map(|(i, &n)| vec![n,\
    \ *i as isize]).unwrap_or_default()\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut index = usize::max_value();\n    let\
    \ mut value = isize::max_value();\n    for (i, v) in arr.iter().enumerate() {\n\
    \        if v % 2 == 0 && v < &value {\n            index = i;\n            value\
    \ = *v;\n        }\n    }\n    if index != usize::max_value() {\n        result.push(value);\n\
    \        result.push(index as isize);\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.len() == 0 {\n        return vec![];\n    }\n    let even_it = arr.iter().filter(|&&x|\
    \ x % 2 == 0);\n    let mut min_val = <isize>::max_value();\n    let mut min_pos\
    \ = 0;\n    for (pos, val) in even_it.enumerate() {\n        if val < min_val\
    \ {\n            min_val = val;\n            min_pos = pos;\n        }\n    }\n\
    \    if min_val < <isize>::max_value() {\n        vec![min_val, min_pos as isize]\n\
    \    } else {\n        vec![]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzzkrxklx.rs:34:18\n   |\n\
    34 |         if val < min_val {\n   |                  ^^^^^^^\n   |         \
    \         |\n   |                  expected `&isize`, found `isize`\n   |    \
    \              help: consider borrowing here: `&min_val`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzzkrxklx.rs:35:23\n   |\n31 |     let mut min_val = <isize>::max_value();\n\
    \   |                       -------------------- expected due to this value\n\
    ...\n35 |             min_val = val;\n   |                       ^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    35 |             min_val = *val;\n   |                       +\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest = (std::isize::MAX, std::usize::MAX);\n    for (i, &n) in\
    \ arr.iter().enumerate() {\n        if n % 2 == 0 && n < smallest.0 {\n      \
    \      smallest = (n, i);\n        }\n    }\n    if smallest.0 == std::isize::MAX\
    \ {\n        vec![]\n    } else {\n        vec![smallest.0, smallest.1 as isize]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut small = std::isize::MAX;\n    let mut idx = std::isize::MAX;\n  \
    \  for (i, e) in arr.iter().enumerate() {\n        if e % 2 == 0 && e < &small\
    \ {\n            small = *e;\n            idx = i as isize;\n        }\n    }\n\
    \    if small == std::isize::MAX {\n        vec![]\n    } else {\n        vec![small,\
    \ idx]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let idx = arr.iter().enumerate().filter(|&(_, &x)| x % 2 == 0).min_by_key(|&(_,\
    \ x)| x).map(|(idx, _)| idx);\n    match idx {\n        Some(idx) => vec![arr[idx],\
    \ idx as isize],\n        None => vec![],\n    }\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = vec![];\n    for (i, &x) in arr.iter().enumerate() {\n  \
    \      if x % 2 == 0 {\n            evens.push((x, i));\n        }\n    }\n  \
    \  if evens.is_empty() {\n        vec![]\n    } else {\n        evens.sort_by_key(|x|\
    \ x.0);\n        vec![evens[0].0, evens[0].1 as isize]\n    }\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        vec![]\n    } else {\n        let mut even_candidate\
    \ = None;\n        let mut position = std::usize::MAX;\n        for (index, value)\
    \ in arr.iter().enumerate() {\n            if value % 2 == 0 {\n             \
    \   match even_candidate {\n                    None => {\n                  \
    \      even_candidate = Some(*value);\n                        position = index;\n\
    \                    }\n                    Some(candidate) => {\n           \
    \             if *value < candidate {\n                            even_candidate\
    \ = Some(*value);\n                            position = index;\n           \
    \             }\n                    }\n                }\n            }\n   \
    \     }\n        match even_candidate {\n            None => vec![],\n       \
    \     Some(candidate) => vec![candidate, position as isize],\n        }\n    }\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    let mut min = std::isize::MAX;\n\
    \    let mut res = vec![];\n    for (idx, val) in arr.iter().enumerate() {\n \
    \       if *val < min && *val % 2 == 0 {\n            min = *val;\n          \
    \  res = vec![min, idx as isize];\n        }\n    }\n    if min == std::isize::MAX\
    \ {\n        vec![]\n    } else {\n        res\n    }\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even = std::isize::MAX;\n    let mut index = std::isize::MAX;\n \
    \   for (i, n) in arr.iter().enumerate() {\n        if *n % 2 == 0 && *n < even\
    \ {\n            even = *n;\n            index = i as isize;\n        }\n    }\n\
    \    if even == std::isize::MAX {\n        vec![]\n    } else {\n        vec![even,\
    \ index]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = vec![];\n    for i in 0..arr.len() {\n        if arr[i] &\
    \ 1 == 0 {\n            evens.push((arr[i], i as isize));\n        }\n    }\n\
    \    evens.sort();\n    evens.first().map_or(vec![], |x| vec![x.0, x.1])\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    let mut min = std::isize::MAX;\n\
    \    let mut res = vec![];\n    for (i, v) in arr.iter().enumerate() {\n     \
    \   if v % 2 == 0 && v < &min {\n            min = *v;\n            res = vec![*v,\
    \ i as isize];\n        }\n    }\n    if min == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        res\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    unimplemented!();\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpfcj0k4z6.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut min_even = isize::max_value();\n  \
    \  let mut min_even_index = isize::max_value();\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 && x < min_even {\n            min_even = x;\n    \
    \        min_even_index = i as isize;\n        }\n    }\n    if min_even < isize::max_value()\
    \ {\n        result.push(min_even);\n        result.push(min_even_index);\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even = isize::max_value();\n    let mut index = 0;\n    for (i, v)\
    \ in arr.iter().enumerate() {\n        if v % 2 == 0 && v < &even {\n        \
    \    even = *v;\n            index = i;\n        }\n    }\n    if even == isize::max_value()\
    \ {\n        vec![]\n    } else {\n        vec![even, index as isize]\n    }\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    let mut indices =\
    \ arr.iter().enumerate().filter(|(_, x)| x.is_even()).collect::<Vec<_>>();\n \
    \   indices.sort_by_key(|(_, x)| *x);\n    indices.first().map(|(i, x)| vec![*x,\
    \ *i as isize]).unwrap_or(vec![])\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_even` found for reference `&&isize` in\
    \ the current scope\n  --> /tmp/tmps5bgftof.rs:30:64\n   |\n30 |     let mut indices\
    \ = arr.iter().enumerate().filter(|(_, x)| x.is_even()).collect::<Vec<_>>();\n\
    \   |                                                                ^^^^^^^ method\
    \ not found in `&&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps5bgftof.rs:32:43\n\
    \   |\n32 |     indices.first().map(|(i, x)| vec![*x, *i as isize]).unwrap_or(vec![])\n\
    \   |                                           ^^^^^^^^^^^ expected `&isize`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps5bgftof.rs:32:5\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \            ---------- expected `Vec<isize>` because of return type\n...\n32\
    \ |     indices.first().map(|(i, x)| vec![*x, *i as isize]).unwrap_or(vec![])\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<&isize>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    let mut min_index\
    \ = 0;\n    let mut min_value = std::isize::MAX;\n    for (i, &value) in arr.iter().enumerate()\
    \ {\n        if value % 2 == 0 && value < min_value {\n            min_index =\
    \ i;\n            min_value = value;\n        }\n    }\n    if min_value == std::isize::MAX\
    \ {\n        return vec![];\n    }\n    vec![min_value, min_index as isize]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.len() == 0 {\n        return vec![];\n    }\n    let mut smallest_even\
    \ = std::isize::MAX;\n    let mut smallest_even_index = std::usize::MAX;\n   \
    \ for (i, x) in arr.iter().enumerate() {\n        if *x != 0 && *x < smallest_even\
    \ && *x % 2 == 0 {\n            smallest_even = *x;\n            smallest_even_index\
    \ = i;\n        }\n    }\n    if smallest_even_index == std::usize::MAX {\n  \
    \      return vec![];\n    }\n    vec![smallest_even, smallest_even_index as isize]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 5]`,\n right: `[0, 1]`', /tmp/tmp3cizw9ac.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // \u65B9\u6CD51\n    // \u627E\u5230\u6700\u5C0F\u7684\u5076\u6570\uFF0C\
    \u7136\u540E\u8FD4\u56DE\u5B83\u7684\u7D22\u5F15\n    let mut ans = vec![];\n\
    \    let mut min = (std::i32::MAX, -1);\n    for (i, x) in arr.iter().enumerate()\
    \ {\n        if *x & 1 == 0 && *x < min.0 {\n            min = (*x as i32, i as\
    \ isize);\n        }\n    }\n    if min.1 == -1 {\n        return ans;\n    }\n\
    \    ans.push(min.0 as isize);\n    ans.push(min.1);\n    ans\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkqgks7b8.rs:32:32\n   |\n\
    32 |         if *x & 1 == 0 && *x < min.0 {\n   |                            \
    \    ^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert an `i32`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n32 |     \
    \    if *x & 1 == 0 && *x < min.0.try_into().unwrap() {\n   |                \
    \                     ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = isize::max_value();\n    let mut index = 0;\n    for (i,\
    \ v) in arr.iter().enumerate() {\n        if *v % 2 == 0 && *v < min_even {\n\
    \            min_even = *v;\n            index = i;\n        }\n    }\n    vec![min_even,\
    \ index as isize]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[9223372036854775807, 0]`,\n right: `[]`', /tmp/tmpknc73bu3.rs:42:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    let mut min_even\
    \ = None;\n    let mut min_even_index = None;\n    for (index, &value) in arr.iter().enumerate()\
    \ {\n        if value == 0 {\n            return vec![0, index as isize];\n  \
    \      }\n        if value % 2 == 0 {\n            if min_even.is_none() || value\
    \ < min_even.unwrap() {\n                min_even = Some(value);\n           \
    \     min_even_index = Some(index);\n            }\n        }\n    }\n    if let\
    \ Some(even) = min_even {\n        vec![even, min_even_index.unwrap() as isize]\n\
    \    } else {\n        vec![]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    for (i, item) in arr.iter().enumerate() {\n        if item % 2 == 0 {\n \
    \           return vec![*item, i as isize];\n        }\n    }\n    vec![]\n}\n\
    \nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2,\
    \ 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 0]`,\n right: `[2, 1]`', /tmp/tmp2iyxuqai.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // 1. find all even elements\n    // 2. find the smallest one\n    // 3.\
    \ return the smallest\n    let even_elems: Vec<isize> = arr.iter().filter(|n|\
    \ n % 2 == 0).cloned().collect();\n    let min_even = even_elems.iter().min().unwrap_or(&0);\n\
    \    let min_index = arr.iter().position(|&n| n == *min_even).unwrap_or(0);\n\
    \    vec![*min_even, min_index as isize]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmp_nnrspsw.rs:30:58\n\
    \   |\n30 |     let even_elems: Vec<isize> = arr.iter().filter(|n| n % 2 == 0).cloned().collect();\n\
    \   |                                                        - ^ - {integer}\n\
    \   |                                                        |\n   |         \
    \                                               &&isize\n   |\nhelp: `%` can be\
    \ used on `isize`, you can dereference `n`\n   |\n30 |     let even_elems: Vec<isize>\
    \ = arr.iter().filter(|n| *n % 2 == 0).cloned().collect();\n   |             \
    \                                           +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let min = arr.iter().filter(|&x| *x % 2 == 0).min();\n    match min {\n \
    \       Some(min) => {\n            let mut x = -1;\n            for (i, y) in\
    \ arr.iter().enumerate() {\n                if *y == *min {\n                \
    \    x = i as isize;\n                    break;\n                }\n        \
    \    }\n            vec![*min, x]\n        }\n        None => vec![],\n    }\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = isize::max_value();\n    let mut node = 0;\n    for (i, &n)\
    \ in arr.iter().enumerate() {\n        if n > 0 && n % 2 == 0 && n < min {\n \
    \           min = n;\n            node = i;\n        }\n    }\n    if min == isize::max_value()\
    \ {\n        vec![]\n    } else {\n        vec![min, node as isize]\n    }\n}\n\
    \nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2,\
    \ 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 5]`,\n right: `[0, 1]`', /tmp/tmp9o4_4qha.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest_even = std::isize::MAX;\n    let mut index = 0;\n    for\
    \ (i, &v) in arr.iter().enumerate() {\n        if v % 2 == 0 && v < smallest_even\
    \ {\n            smallest_even = v;\n            index = i;\n        }\n    }\n\
    \    if smallest_even == std::isize::MAX {\n        vec![]\n    } else {\n   \
    \     vec![smallest_even, index as isize]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = arr.iter().enumerate().filter(|(_, &v)| v % 2 == 0).collect::<Vec<_>>();\n\
    \    if evens.is_empty() {\n        return vec![];\n    }\n    evens.sort_by_key(|(_,\
    \ &v)| v);\n    let (i, &v) = evens[0];\n    vec![v, i as isize]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = isize::max_value();\n    let mut min_i = 0;\n    for (i, x)\
    \ in arr.iter().enumerate() {\n        if *x % 2 == 0 && *x < min {\n        \
    \    min = *x;\n            min_i = i;\n        }\n    }\n    if min == isize::max_value()\
    \ {\n        return vec![];\n    }\n    vec![min, min_i as isize]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even = std::isize::MAX;\n    let mut idx = std::isize::MAX;\n   \
    \ for (i, x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < &even {\n\
    \            even = *x;\n            idx = i as isize;\n        }\n    }\n   \
    \ if even == std::isize::MAX {\n        return vec![];\n    }\n    vec![even,\
    \ idx]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // Add your code here\n    let mut minimum = None;\n    let mut index = None;\n\
    \    for (i, v) in arr.iter().enumerate() {\n        if *v % 2 == 0 {\n      \
    \      if minimum.is_none() || *v < minimum.unwrap() {\n                minimum\
    \ = Some(*v);\n                index = Some(i as isize);\n            }\n    \
    \    }\n    }\n    match (minimum, index) {\n        (Some(x), Some(y)) => vec![x,\
    \ y],\n        _ => vec![],\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    let mut even = None;\n\
    \    let mut even_idx = None;\n    for (idx, &num) in arr.iter().enumerate() {\n\
    \        if num % 2 == 0 {\n            if even.is_none() || even.unwrap() > num\
    \ {\n                even = Some(num);\n                even_idx = Some(idx);\n\
    \            }\n        }\n    }\n    match (even, even_idx) {\n        (Some(even),\
    \ Some(even_idx)) => vec![even, even_idx as isize],\n        _ => vec![],\n  \
    \  }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.len() == 0 {\n        return vec![];\n    }\n    let mut min = isize::max_value();\n\
    \    let mut min_index = 0;\n    for (index, val) in arr.iter().enumerate() {\n\
    \        if *val % 2 == 0 && *val < min {\n            min = *val;\n         \
    \   min_index = index;\n        }\n    }\n    if min == isize::max_value() {\n\
    \        return vec![];\n    }\n    vec![min, min_index as isize]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest = isize::max_value();\n    let mut smallest_index = 0;\n\
    \    for (index, &num) in arr.iter().enumerate() {\n        if num % 2 == 0 &&\
    \ num < smallest {\n            smallest = num;\n            smallest_index =\
    \ index;\n        }\n    }\n    if smallest == isize::max_value() {\n        return\
    \ vec![];\n    }\n    vec![smallest, smallest_index as isize]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest = &ISIZE_MAX;\n    let mut index = 0;\n    for (i, e) in\
    \ arr.iter().enumerate() {\n        if *e % 2 == 0 && *e < *smallest {\n     \
    \       smallest = e;\n            index = i;\n        }\n    }\n    if *smallest\
    \ == ISIZE_MAX {\n        vec![]\n    } else {\n        vec![*smallest, index\
    \ as isize]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `ISIZE_MAX` in this scope\n  --> /tmp/tmpgkeb0a4t.rs:27:25\n\
    \   |\n27 |     let mut smallest = &ISIZE_MAX;\n   |                         ^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `ISIZE_MAX` in this\
    \ scope\n  --> /tmp/tmpgkeb0a4t.rs:35:21\n   |\n35 |     if *smallest == ISIZE_MAX\
    \ {\n   |                     ^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = isize::max_value();\n    let mut index = 0;\n    for (i, &x)\
    \ in arr.iter().enumerate() {\n        if x & 1 == 0 && x < min {\n          \
    \  min = x;\n            index = i;\n        }\n    }\n    if min == isize::max_value()\
    \ {\n        return vec![];\n    }\n    vec![min, index as isize]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.iter()\n        .enumerate()\n        .filter(|(_, &v)| v % 2 == 0)\n\
    \        .min_by_key(|&(_, v)| v)\n        .map(|(i, v)| vec![*v, i as isize])\n\
    \        .unwrap_or_else(|| vec![])\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest_even = isize::max_value();\n    let mut smallest_even_index\
    \ = usize::max_value();\n    for (i, x) in arr.iter().enumerate() {\n        if\
    \ x % 2 == 0 && x < &smallest_even {\n            smallest_even = *x;\n      \
    \      smallest_even_index = i;\n        }\n    }\n    if smallest_even_index\
    \ != usize::max_value() {\n        vec![smallest_even, smallest_even_index as\
    \ isize]\n    } else {\n        vec![]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    let mut evens = arr.iter().enumerate().filter(|(_,\
    \ x)| x % 2 == 0).collect::<Vec<_>>();\n    evens.sort_by_key(|(_, x)| *x);\n\
    \    evens.first().map(|(i, v)| vec![*v, *i as isize]).unwrap_or(vec![])\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmpppcyragr.rs:30:62\n\
    \   |\n30 |     let mut evens = arr.iter().enumerate().filter(|(_, x)| x % 2 ==\
    \ 0).collect::<Vec<_>>();\n   |                                              \
    \              - ^ - {integer}\n   |                                         \
    \                   |\n   |                                                  \
    \          &&isize\n   |\nhelp: `%` can be used on `isize`, you can dereference\
    \ `x`\n   |\n30 |     let mut evens = arr.iter().enumerate().filter(|(_, x)| *x\
    \ % 2 == 0).collect::<Vec<_>>();\n   |                                       \
    \                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpppcyragr.rs:32:41\n\
    \   |\n32 |     evens.first().map(|(i, v)| vec![*v, *i as isize]).unwrap_or(vec![])\n\
    \   |                                         ^^^^^^^^^^^ expected `&isize`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpppcyragr.rs:32:5\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \            ---------- expected `Vec<isize>` because of return type\n...\n32\
    \ |     evens.first().map(|(i, v)| vec![*v, *i as isize]).unwrap_or(vec![])\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<&isize>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = (isize::MAX, 0);\n    for (i, x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 && x < &min.0 {\n            min = (*x, i as isize);\n\
    \        }\n    }\n    if min.0 == isize::MAX {\n        vec![]\n    } else {\n\
    \        vec![min.0, min.1]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    let mut min = None;\n\
    \    let mut min_index = None;\n    for (i, &v) in arr.iter().enumerate() {\n\
    \        if v % 2 == 0 {\n            match min {\n                None => {\n\
    \                    min = Some(v);\n                    min_index = Some(i);\n\
    \                }\n                Some(m) => {\n                    if v < m\
    \ {\n                        min = Some(v);\n                        min_index\
    \ = Some(i);\n                    }\n                }\n            }\n      \
    \  }\n    }\n    match min_index {\n        None => vec![],\n        Some(i) =>\
    \ vec![arr[i], i as isize],\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut res = vec![0; 2];\n    let mut even = std::isize::MAX;\n    for (i,\
    \ &n) in arr.iter().enumerate() {\n        if n != 0 && n % 2 == 0 && n < even\
    \ {\n            even = n;\n            res[0] = n;\n            res[1] = i as\
    \ isize;\n        }\n    }\n    if even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        res\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 5]`,\n right: `[0, 1]`', /tmp/tmpskdfpsy3.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_nums = arr.iter().enumerate().filter(|(_, &x)| x % 2 == 0).collect::<Vec<_>>();\n\
    \    even_nums.sort_by_key(|(_, &x)| x);\n    if even_nums.is_empty() {\n    \
    \    vec![]\n    } else {\n        let (i, &num) = even_nums[0];\n        vec![num,\
    \ i as isize]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest_index = -1;\n    let mut smallest_even = std::isize::MAX;\n\
    \    for (index, &value) in arr.iter().enumerate() {\n        if value == 0 {\n\
    \            if smallest_index == -1 {\n                smallest_index = index;\n\
    \            }\n        } else if value < smallest_even && value % 2 == 0 {\n\
    \            smallest_even = value;\n            smallest_index = index;\n   \
    \     }\n    }\n    if smallest_index == -1 {\n        return vec![];\n    }\n\
    \    vec![smallest_even, smallest_index as isize]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpy43sp4t8.rs:27:30\n\
    \   |\n27 |     let mut smallest_index = -1;\n   |                           \
    \   ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the following\
    \ other types implement trait `Neg`:\n             &f32\n             &f64\n \
    \            &i128\n             &i16\n             &i32\n             &i64\n\
    \             &i8\n             &isize\n           and 8 others\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpy43sp4t8.rs:31:34\n\
    \   |\n31 |             if smallest_index == -1 {\n   |                      \
    \            ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help:\
    \ the following other types implement trait `Neg`:\n             &f32\n      \
    \       &f64\n             &i128\n             &i16\n             &i32\n     \
    \        &i64\n             &i8\n             &isize\n           and 8 others\n\
    \nerror[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpy43sp4t8.rs:39:26\n\
    \   |\n39 |     if smallest_index == -1 {\n   |                          ^^\n\
    \   |                          |\n   |                          cannot apply unary\
    \ operator `-`\n   |                          help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0600.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut index = std::isize::MAX;\n\
    \    for (i, v) in arr.iter().enumerate() {\n        if v % 2 == 0 && v < &min_even\
    \ {\n            min_even = *v;\n            index = i as isize;\n        }\n\
    \    }\n    if min_even == std::isize::MAX {\n        return vec![];\n    }\n\
    \    vec![min_even, index]\n}\n\nfn main() {\n    let candidate = pluck;\n   \
    \ assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut lowest_even = None;\n    let mut lowest_even_index = None;\n    for\
    \ (i, n) in arr.iter().enumerate() {\n        if n % 2 == 0 {\n            if\
    \ lowest_even.is_none() || n < &lowest_even.unwrap() {\n                lowest_even\
    \ = Some(*n);\n                lowest_even_index = Some(i as isize);\n       \
    \     }\n        }\n    }\n    match (lowest_even, lowest_even_index) {\n    \
    \    (Some(n), Some(i)) => vec![n, i],\n        _ => vec![],\n    }\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut temp: Vec<isize> = vec![];\n    let mut index: usize = 0;\n    for\
    \ (i, v) in arr.iter().enumerate() {\n        if *v > 0 && *v % 2 == 0 {\n   \
    \         if temp.is_empty() {\n                temp.push(*v);\n             \
    \   index = i;\n            } else if temp[0] > *v {\n                temp.pop();\n\
    \                temp.push(*v);\n                index = i;\n            }\n \
    \       }\n    }\n    if temp.is_empty() {\n        return vec![];\n    }\n  \
    \  temp.push(index as isize);\n    temp\n}\n\nfn main() {\n    let candidate =\
    \ pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 5]`,\n right: `[0, 1]`', /tmp/tmpc5rku7kt.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut res = Vec::new();\n    let mut smallest_idx = arr.len();\n    let\
    \ mut smallest_val = isize::max_value();\n    for (idx, v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 && v < &smallest_val {\n            smallest_idx =\
    \ idx;\n            smallest_val = *v;\n        }\n    }\n    if smallest_idx\
    \ != arr.len() {\n        res.push(smallest_val);\n        res.push(smallest_idx\
    \ as isize);\n    }\n    res\n}\n\nfn main() {\n    let candidate = pluck;\n \
    \   assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = 10000;\n    let mut index = 10000;\n    for (i, v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 && *v < min {\n            min = *v;\n            index\
    \ = i;\n        }\n    }\n    if min == 10000 {\n        vec![]\n    } else {\n\
    \        vec![min, index as isize]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        vec![]\n    } else {\n        let mut result\
    \ = (0, 0);\n        for i in 0..arr.len() {\n            if (arr[i] as usize)\
    \ % 2 == 0 {\n                result = (arr[i], i as isize);\n               \
    \ break;\n            }\n        }\n        for i in 0..arr.len() {\n        \
    \    if (arr[i] as usize) % 2 == 0 && arr[i] < result.0 {\n                result\
    \ = (arr[i], i as isize);\n            }\n        }\n        if result.0 != 0\
    \ {\n            vec![result.0, result.1]\n        } else {\n            vec![]\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[0, 1]`', /tmp/tmpq_h8k4wk.rs:55:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_value = isize::max_value();\n    let mut min_index = isize::max_value();\n\
    \    for (i, n) in arr.iter().enumerate() {\n        if *n % 2 == 0 && *n < min_value\
    \ {\n            min_value = *n;\n            min_index = i as isize;\n      \
    \  }\n    }\n    if min_value == isize::max_value() {\n        vec![]\n    } else\
    \ {\n        vec![min_value, min_index]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut ret = vec![];\n    if arr.len() == 0 {\n        return ret;\n   \
    \ }\n    let (mut v, mut idx) = (isize::max_value(), 0);\n    for (idx_, &x) in\
    \ arr.iter().enumerate() {\n        if x % 2 == 0 && x < v {\n            v =\
    \ x;\n            idx = idx_;\n        }\n    }\n    if v == isize::max_value()\
    \ {\n        return ret;\n    }\n    ret.push(v);\n    ret.push(idx as isize);\n\
    \    ret\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = std::usize::MAX;\n    let mut res = Vec::new();\n    let mut\
    \ i = 0;\n    for e in arr {\n        if e % 2 == 0 && e < min as isize {\n  \
    \          min = e as usize;\n            res = vec![e, i];\n        }\n     \
    \   i += 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate = pluck;\n  \
    \  assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[2, 1]`', /tmp/tmppvek_vwq.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    let mut smallest_even\
    \ = 10001;\n    let mut smallest_even_index = 10001;\n    for (index, value) in\
    \ arr.iter().enumerate() {\n        if value % 2 == 0 && *value < smallest_even\
    \ {\n            smallest_even = *value;\n            smallest_even_index = index\
    \ as isize;\n        }\n    }\n    if smallest_even == 10001 {\n        return\
    \ vec![];\n    }\n    vec![smallest_even, smallest_even_index]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_index = -1;\n    let mut min_even = 0;\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if min_index == -1 {\n            if n % 2 == 0 {\n             \
    \   min_index = i;\n                min_even = *n;\n            }\n        } else\
    \ {\n            if *n < min_even && n % 2 == 0 {\n                min_index =\
    \ i;\n                min_even = *n;\n            }\n        }\n    }\n    if\
    \ min_index >= 0 {\n        vec![min_even, min_index as isize]\n    } else {\n\
    \        vec![]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpa95ud7h_.rs:27:25\n\
    \   |\n27 |     let mut min_index = -1;\n   |                         ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n  --> /tmp/tmpa95ud7h_.rs:30:25\n   |\n30 | \
    \        if min_index == -1 {\n   |                         ^^ the trait `Neg`\
    \ is not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = vec![];\n    for (i, n) in arr.iter().enumerate() {\n   \
    \     if n % 2 == 0 {\n            evens.push((*n, i));\n        }\n    }\n  \
    \  if evens.is_empty() {\n        return vec![];\n    }\n    evens.sort_by(|a,\
    \ b| a.0.cmp(&b.0));\n    vec![evens[0].0, evens[0].1 as isize]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest = isize::max_value();\n    let mut smallest_index = isize::max_value();\n\
    \    for (i, num) in arr.iter().enumerate() {\n        if num % 2 == 0 && *num\
    \ < smallest {\n            smallest = *num;\n            smallest_index = i as\
    \ isize;\n        }\n    }\n    if smallest == isize::max_value() {\n        vec![]\n\
    \    } else {\n        vec![smallest, smallest_index]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    let mut min = isize::max_value();\n\
    \    let mut min_index = usize::max_value();\n    for (i, x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 && x < &min {\n            min = *x;\n            min_index\
    \ = i;\n        }\n    }\n    if min == isize::max_value() {\n        return vec![];\n\
    \    }\n    vec![min, min_index as isize]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_index = std::isize::MAX;\n\
    \    for (i, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min_even\
    \ {\n            min_even = x;\n            min_even_index = i as isize;\n   \
    \     }\n    }\n    if min_even == std::isize::MAX {\n        return vec![];\n\
    \    }\n    vec![min_even, min_even_index]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // the smallest even value and its index\n    let mut smallest_value = isize::max_value();\n\
    \    let mut smallest_index = usize::max_value();\n    // iterate all nodes\n\
    \    for (i, n) in arr.iter().enumerate() {\n        // if the node is even\n\
    \        if n % 2 == 0 {\n            // if the current node is smaller, update\n\
    \            if *n < smallest_value {\n                smallest_value = *n;\n\
    \                smallest_index = i;\n            }\n        }\n    }\n    //\
    \ if we have an even node, return the smallest one\n    if smallest_value != isize::max_value()\
    \ {\n        vec![smallest_value, smallest_index as isize]\n    } else {\n   \
    \     // otherwise return an empty array\n        vec![]\n    }\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut res = vec![std::isize::MAX, std::isize::MAX];\n    for (i, x) in\
    \ arr.iter().enumerate() {\n        if x % 2 == 0 && x < &res[0] {\n         \
    \   res = vec![*x, i as isize];\n        }\n    }\n    if res[0] == std::isize::MAX\
    \ {\n        vec![]\n    } else {\n        res\n    }\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.len() == 0 {\n        return vec![];\n    }\n    let mut min = 1_000_000_000;\n\
    \    let mut ret = 0;\n    let mut idx = 1_000_000_000;\n    for i in 0..arr.len()\
    \ {\n        if arr[i] < min && arr[i] % 2 == 0 {\n            min = arr[i];\n\
    \            ret = arr[i];\n            idx = i as isize;\n        }\n    }\n\
    \    if min == 1_000_000_000 {\n        return vec![];\n    }\n    vec![ret, idx]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even_value = isize::max_value();\n    let mut min_even_index\
    \ = isize::max_value();\n    for (i, &value) in arr.iter().enumerate() {\n   \
    \     if value % 2 == 0 && value < min_even_value {\n            min_even_value\
    \ = value;\n            min_even_index = i as isize;\n        }\n    }\n    if\
    \ min_even_value != isize::max_value() {\n        vec![min_even_value, min_even_index]\n\
    \    } else {\n        vec![]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    let mut index = 0;\n\
    \    let mut value = std::isize::MAX;\n    for (idx, v) in arr.iter().enumerate()\
    \ {\n        if *v % 2 == 0 && *v < value {\n            index = idx;\n      \
    \      value = *v;\n        }\n    }\n    if value == std::isize::MAX {\n    \
    \    return vec![];\n    }\n    vec![value, index as isize]\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest_index = isize::max_value();\n    let mut smallest_value\
    \ = isize::max_value();\n    for (i, e) in arr.iter().enumerate() {\n        if\
    \ *e % 2 == 0 && *e < smallest_value {\n            smallest_value = *e;\n   \
    \         smallest_index = i as isize;\n        }\n    }\n    if smallest_index\
    \ == isize::max_value() {\n        return vec![];\n    }\n    vec![smallest_value,\
    \ smallest_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    let mut evens = arr.iter().enumerate().filter(|(_,\
    \ x)| x % 2 == 0).collect::<Vec<_>>();\n    if evens.is_empty() {\n        return\
    \ vec![];\n    }\n    evens.sort_by_key(|(_, x)| *x);\n    evens.sort_by_key(|(i,\
    \ _)| *i);\n    vec![evens[0].1, (evens[0].0 as isize) + 1]\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmpadbu8eak.rs:30:62\n\
    \   |\n30 |     let mut evens = arr.iter().enumerate().filter(|(_, x)| x % 2 ==\
    \ 0).collect::<Vec<_>>();\n   |                                              \
    \              - ^ - {integer}\n   |                                         \
    \                   |\n   |                                                  \
    \          &&isize\n   |\nhelp: `%` can be used on `isize`, you can dereference\
    \ `x`\n   |\n30 |     let mut evens = arr.iter().enumerate().filter(|(_, x)| *x\
    \ % 2 == 0).collect::<Vec<_>>();\n   |                                       \
    \                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpadbu8eak.rs:36:10\n\
    \   |\n36 |     vec![evens[0].1, (evens[0].0 as isize) + 1]\n   |          ^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n36 |     vec![*evens[0].1, (evens[0].0 as isize) + 1]\n   |          +\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    let mut min_idx =\
    \ -1;\n    let mut min_even = 9999999;\n    for (idx, n) in arr.iter().enumerate()\
    \ {\n        if n % 2 == 0 && n < &min_even {\n            min_even = *n;\n  \
    \          min_idx = idx as isize;\n        }\n    }\n    if min_idx < 0 {\n \
    \       return vec![];\n    }\n    vec![min_even, min_idx]\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even = None;\n    let mut idx = 0;\n    for (i, x) in arr.iter().enumerate()\
    \ {\n        if *x % 2 == 0 {\n            if even.is_none() || even.unwrap()\
    \ > *x {\n                even = Some(*x);\n                idx = i;\n       \
    \     }\n        }\n    }\n    if let Some(x) = even {\n        vec![x, idx as\
    \ isize]\n    } else {\n        vec![]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.len() == 0 {\n        return vec![];\n    }\n    let mut even = None;\n\
    \    let mut idx = None;\n    for (i, a) in arr.iter().enumerate() {\n       \
    \ if a % 2 == 0 {\n            if even.is_none() || a < &even.unwrap() {\n   \
    \             even = Some(*a);\n                idx = Some(i as isize);\n    \
    \        }\n        }\n    }\n    if even.is_none() {\n        return vec![];\n\
    \    }\n    vec![even.unwrap(), idx.unwrap()]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    arr.iter()\n    \
    \    .filter(|x| x % 2 == 0)\n        .min()\n        .map(|min| {\n         \
    \   let idx = arr.iter().position(|x| x == min).unwrap();\n            vec![*min,\
    \ idx as isize]\n        })\n        .unwrap_or(vec![])\n}\n\nfn main() {\n  \
    \  let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmp1dp7t15t.rs:31:23\n\
    \   |\n31 |         .filter(|x| x % 2 == 0)\n   |                     - ^ - {integer}\n\
    \   |                     |\n   |                     &&isize\n   |\nhelp: `%`\
    \ can be used on `isize`, you can dereference `x`\n   |\n31 |         .filter(|x|\
    \ *x % 2 == 0)\n   |                     +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut min_even = std::isize::MAX;\n    let\
    \ mut min_even_index = std::isize::MAX;\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if n % 2 == 0 && n < &min_even {\n            min_even = *n;\n  \
    \          min_even_index = i as isize;\n        }\n    }\n    if min_even !=\
    \ std::isize::MAX {\n        result.push(min_even);\n        result.push(min_even_index);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = std::isize::MAX;\n    let mut min_idx = 0;\n    for (i, item)\
    \ in arr.iter().enumerate() {\n        if item % 2 == 0 && item < &min {\n   \
    \         min = *item;\n            min_idx = i;\n        }\n    }\n    if min\
    \ != std::isize::MAX {\n        vec![min, min_idx as isize]\n    } else {\n  \
    \      vec![]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    let min_even = {\n\
    \        let mut min_even = 2147483647;\n        for num in arr.iter() {\n   \
    \         if num % 2 == 0 && num < &min_even {\n                min_even = *num;\n\
    \            }\n        }\n        min_even\n    };\n    if min_even == 2147483647\
    \ {\n        return vec![];\n    }\n    for (i, num) in arr.iter().enumerate()\
    \ {\n        if num == &min_even {\n            return vec![min_even, i as isize];\n\
    \        }\n    }\n    return vec![];\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    let smallest_even\
    \ = arr.iter().enumerate().filter(|(_, &n)| n % 2 == 0).min_by_key(|(_, &n)| n).unwrap();\n\
    \    vec![smallest_even.1, smallest_even.0 as isize]\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0lsiq9lb.rs:31:10\n   |\n\
    31 |     vec![smallest_even.1, smallest_even.0 as isize]\n   |          ^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n31 |     vec![*smallest_even.1, smallest_even.0 as isize]\n   |       \
    \   +\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = isize::max_value();\n    let mut min_index = isize::max_value();\n\
    \    for (i, v) in arr.iter().enumerate() {\n        if (v % 2 == 0) && (v < &min)\
    \ {\n            min = *v;\n            min_index = i as isize;\n        }\n \
    \   }\n    if min == isize::max_value() {\n        vec![]\n    } else {\n    \
    \    vec![min, min_index]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = isize::max_value();\n    let mut idx = -1;\n    for (i, x)\
    \ in arr.iter().enumerate() {\n        if x % 2 == 0 && x < &min {\n         \
    \   min = *x;\n            idx = i as isize;\n        }\n    }\n    if idx ==\
    \ -1 {\n        vec![]\n    } else {\n        vec![min, idx]\n    }\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    let mut ret = (arr[0],\
    \ 0);\n    for (i, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && (ret.0\
    \ % 2 != 0 || x < ret.0) {\n            ret = (x, i);\n        }\n    }\n    if\
    \ ret.0 % 2 == 0 {\n        vec![ret.0, ret.1 as isize]\n    } else {\n      \
    \  vec![]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = isize::max_value();\n    let mut min_even_idx = isize::max_value();\n\
    \    for (idx, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min_even\
    \ {\n            min_even = x;\n            min_even_idx = idx as isize;\n   \
    \     }\n    }\n    if min_even_idx == isize::max_value() {\n        vec![]\n\
    \    } else {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = vec![];\n    for (i, n) in arr.iter().enumerate() {\n   \
    \     if n % 2 == 0 {\n            evens.push((n, i));\n        }\n    }\n   \
    \ evens.sort_by(|a, b| a.0.cmp(b.0));\n    if let Some((smallest, i)) = evens.first()\
    \ {\n        vec![*smallest, *i as isize]\n    } else {\n        vec![]\n    }\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzyyjma1x.rs:35:14\n   |\n\
    35 |         vec![*smallest, *i as isize]\n   |              ^^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    35 |         vec![**smallest, *i as isize]\n   |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    unimplemented!()\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpuhcay_lv.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest_even_value: Option<isize> = None;\n    let mut smallest_even_index:\
    \ Option<usize> = None;\n    for (index, value) in arr.iter().enumerate() {\n\
    \        if value % 2 == 0 {\n            match smallest_even_value {\n      \
    \          None => {\n                    smallest_even_value = Some(*value);\n\
    \                    smallest_even_index = Some(index);\n                },\n\
    \                Some(x) => {\n                    if *value < x {\n         \
    \               smallest_even_value = Some(*value);\n                        smallest_even_index\
    \ = Some(index);\n                    }\n                }\n            }\n  \
    \      }\n    }\n    match (smallest_even_value, smallest_even_index) {\n    \
    \    (Some(value), Some(index)) => vec![value, index as isize],\n        _ =>\
    \ vec![],\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < &min_even\
    \ {\n            min_even = *x;\n            min_even_idx = idx as isize;\n  \
    \      }\n    }\n    if min_even == std::isize::MAX {\n        vec![]\n    } else\
    \ {\n        vec![min_even, min_even_idx]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    let mut smallest_even_value\
    \ = std::isize::MAX;\n    let mut smallest_even_index = std::isize::MAX;\n   \
    \ for (i, &v) in arr.iter().enumerate() {\n        if v == 0 {\n            if\
    \ i < smallest_even_index {\n                smallest_even_value = 0;\n      \
    \          smallest_even_index = i as isize;\n            }\n        } else if\
    \ v % 2 == 0 && v < smallest_even_value {\n            smallest_even_value = v;\n\
    \            smallest_even_index = i as isize;\n        }\n    }\n    if smallest_even_value\
    \ == std::isize::MAX {\n        vec![]\n    } else {\n        vec![smallest_even_value,\
    \ smallest_even_index]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprt428vbp.rs:34:20\n   |\n\
    34 |             if i < smallest_even_index {\n   |                    ^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n34 |           \
    \  if i < smallest_even_index.try_into().unwrap() {\n   |                    \
    \                   ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = isize::max_value();\n    let mut min_index = isize::max_value();\n\
    \    for (i, value) in arr.iter().enumerate() {\n        if value % 2 == 0 &&\
    \ *value < min {\n            min = *value;\n            min_index = i as isize;\n\
    \        }\n    }\n    if min_index == isize::max_value() {\n        return vec![];\n\
    \    }\n    vec![min, min_index]\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    let mut min_value\
    \ = 10001;\n    let mut index = -1;\n    for (i, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_value {\n            min_value = *val;\n\
    \            index = i as isize;\n        }\n    }\n    if index == -1 {\n   \
    \     return vec![];\n    }\n    vec![min_value, index]\n}\n\nfn main() {\n  \
    \  let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut ret = vec![];\n    let mut smallest_even = std::isize::MAX;\n   \
    \ let mut smallest_even_index = std::isize::MAX;\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if n % 2 == 0 && n < &smallest_even {\n            smallest_even\
    \ = *n;\n            smallest_even_index = i as isize;\n        }\n    }\n   \
    \ if smallest_even_index != std::isize::MAX {\n        ret.push(smallest_even);\n\
    \        ret.push(smallest_even_index);\n    }\n    ret\n}\n\nfn main() {\n  \
    \  let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = isize::max_value();\n    let mut result = vec![];\n    for\
    \ (i, v) in arr.iter().enumerate() {\n        if min.checked_rem_euclid(2).unwrap()\
    \ != 0 {\n            if v.checked_rem_euclid(2).unwrap() == 0 {\n           \
    \     min = *v;\n                result = vec![min, i as isize];\n           \
    \ }\n        } else if v < &min {\n            min = *v;\n            result =\
    \ vec![min, i as isize];\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 3]`,\n right: `[6, 1]`', /tmp/tmphmsm4p2m.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = isize::max_value();\n    let mut min_i = 0;\n    for (i, n)\
    \ in arr.iter().enumerate() {\n        if *n % 2 == 0 && *n < min {\n        \
    \    min = *n;\n            min_i = i;\n        }\n    }\n    if min == isize::max_value()\
    \ {\n        vec![]\n    } else {\n        vec![min, min_i as isize]\n    }\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = None;\n    let mut min_even_pos = std::usize::MAX;\n \
    \   for (i, n) in arr.iter().enumerate() {\n        if n % 2 == 0 {\n        \
    \    if let Some(m) = min_even {\n                if n < m {\n               \
    \     min_even = Some(*n);\n                    min_even_pos = i;\n          \
    \      }\n            } else {\n                min_even = Some(*n);\n       \
    \         min_even_pos = i;\n            }\n        }\n    }\n    if let Some(m)\
    \ = min_even {\n        vec![m, min_even_pos as isize]\n    } else {\n       \
    \ vec![]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgq34nsv7.rs:33:37\n   |\n\
    33 |                     min_even = Some(*n);\n   |                          \
    \           ^^\n   |                                     |\n   |             \
    \                        expected `&isize`, found `isize`\n   |              \
    \                       help: consider borrowing here: `&*n`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgq34nsv7.rs:37:33\n   |\n37 |              \
    \   min_even = Some(*n);\n   |                                 ^^\n   |      \
    \                           |\n   |                                 expected `&isize`,\
    \ found `isize`\n   |                                 help: consider borrowing\
    \ here: `&*n`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgq34nsv7.rs:43:14\n\
    \   |\n43 |         vec![m, min_even_pos as isize]\n   |              ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    43 |         vec![*m, min_even_pos as isize]\n   |              +\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // Branch\n    // We are looking for the lowest even number.\n    // We will\
    \ track the highest odd number\n    // and the even number that is next-lowest\
    \ to it.\n    // If there are no even numbers, return empty.\n    let mut highest_odd\
    \ = -1;\n    let mut lowest_even = -1;\n    let mut lowest_even_index = -1;\n\
    \    for (index, item) in arr.iter().enumerate() {\n        if *item % 2 == 0\
    \ {\n            if lowest_even == -1 || item < &lowest_even {\n             \
    \   lowest_even = *item;\n                lowest_even_index = index as isize;\n\
    \            }\n        } else {\n            if item > &highest_odd {\n     \
    \           highest_odd = *item;\n            }\n        }\n    }\n    // If there\
    \ are no even numbers, return empty.\n    if lowest_even == -1 {\n        return\
    \ vec![];\n    }\n    // If the next-lowest even number is lower than the highest\
    \ odd number, return it.\n    if lowest_even < highest_odd {\n        return vec![lowest_even,\
    \ lowest_even_index];\n    }\n    // Otherwise, return the even number with the\
    \ lowest index.\n    let mut lowest_even_index = -1;\n    for (index, item) in\
    \ arr.iter().enumerate() {\n        if *item % 2 == 0 {\n            if lowest_even_index\
    \ == -1 || item < &lowest_even {\n                lowest_even = *item;\n     \
    \           lowest_even_index = index as isize;\n            }\n        }\n  \
    \  }\n    vec![lowest_even, lowest_even_index]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut lowest_even = isize::max_value();\n    let mut lowest_even_idx =\
    \ usize::max_value();\n    for (idx, val) in arr.iter().enumerate() {\n      \
    \  if *val % 2 == 0 && *val < lowest_even {\n            lowest_even = *val;\n\
    \            lowest_even_idx = idx;\n        }\n    }\n    if lowest_even_idx\
    \ != usize::max_value() {\n        vec![lowest_even, lowest_even_idx as isize]\n\
    \    } else {\n        vec![]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.len() == 0 {\n        return vec![];\n    }\n    let mut min_even\
    \ = isize::max_value();\n    let mut min_idx = -1;\n    for (idx, value) in arr.iter().enumerate()\
    \ {\n        if *value % 2 == 0 && *value < min_even {\n            min_even =\
    \ *value;\n            min_idx = idx as isize;\n        }\n    }\n    if min_idx\
    \ == -1 {\n        return vec![];\n    }\n    vec![min_even, min_idx]\n}\n\nfn\
    \ main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = arr.iter().enumerate().filter(|(_, x)| x % 2 == 0).collect::<Vec<_>>();\n\
    \    evens.sort_by_key(|(_, x)| *x);\n    evens.first().map(|(i, x)| vec![*x,\
    \ *i as isize]).unwrap_or_default()\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmp45e43_95.rs:27:62\n\
    \   |\n27 |     let mut evens = arr.iter().enumerate().filter(|(_, x)| x % 2 ==\
    \ 0).collect::<Vec<_>>();\n   |                                              \
    \              - ^ - {integer}\n   |                                         \
    \                   |\n   |                                                  \
    \          &&isize\n   |\nhelp: `%` can be used on `isize`, you can dereference\
    \ `x`\n   |\n27 |     let mut evens = arr.iter().enumerate().filter(|(_, x)| *x\
    \ % 2 == 0).collect::<Vec<_>>();\n   |                                       \
    \                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp45e43_95.rs:29:41\n\
    \   |\n29 |     evens.first().map(|(i, x)| vec![*x, *i as isize]).unwrap_or_default()\n\
    \   |                                         ^^^^^^^^^^^ expected `&isize`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp45e43_95.rs:29:5\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \            ---------- expected `Vec<isize>` because of return type\n...\n29\
    \ |     evens.first().map(|(i, x)| vec![*x, *i as isize]).unwrap_or_default()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<&isize>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    let (mut min_value,\
    \ mut min_index) = (arr[0], 0);\n    for (i, val) in arr.iter().enumerate() {\n\
    \        if *val % 2 == 0 && *val < min_value {\n            min_value = *val;\n\
    \            min_index = i;\n        }\n    }\n    if min_value % 2 == 0 {\n \
    \       vec![min_value, min_index as isize]\n    } else {\n        vec![]\n  \
    \  }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[2, 1]`', /tmp/tmp45jzu_sh.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even = None;\n    let mut idx = 0;\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 {\n            if even.is_none() || x < even.unwrap()\
    \ {\n                even = Some(x);\n                idx = i;\n            }\n\
    \        }\n    }\n    match even {\n        Some(x) => vec![x, idx as isize],\n\
    \        None => vec![],\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut index = 0;\n    let mut evens = vec![];\n    for (i, &v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 {\n            evens.push(v);\n            index =\
    \ i;\n        }\n    }\n    evens.sort();\n    if evens.is_empty() {\n       \
    \ vec![]\n    } else {\n        vec![evens[0], index as isize]\n    }\n}\n\nfn\
    \ main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 5]`,\n right: `[0, 1]`', /tmp/tmpxicacay8.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut r = arr.iter().enumerate().filter(|(_, &x)| x % 2 == 0).collect::<Vec<_>>();\n\
    \    r.sort_by_key(|&(_, x)| x);\n    r.first().map(|&(i, x)| vec![x, i as isize]).unwrap_or_else(||\
    \ vec![])\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcfj0ghpp.rs:29:37\n   |\n\
    29 |     r.first().map(|&(i, x)| vec![x, i as isize]).unwrap_or_else(|| vec![])\n\
    \   |                                     ^^^^^^^^^^ expected `&isize`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcfj0ghpp.rs:29:5\n\
    \   |\n26 | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                  \
    \            ---------- expected `Vec<isize>` because of return type\n...\n29\
    \ |     r.first().map(|&(i, x)| vec![x, i as isize]).unwrap_or_else(|| vec![])\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<&isize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    let mut smallest_even_value\
    \ = None;\n    let mut smallest_even_value_index = None;\n    for (i, v) in arr.iter().enumerate()\
    \ {\n        if *v % 2 == 0 {\n            if smallest_even_value.is_none() {\n\
    \                smallest_even_value = Some(*v);\n                smallest_even_value_index\
    \ = Some(i);\n            } else if *v < smallest_even_value.unwrap() {\n    \
    \            smallest_even_value = Some(*v);\n                smallest_even_value_index\
    \ = Some(i);\n            }\n        }\n    }\n    match (smallest_even_value,\
    \ smallest_even_value_index) {\n        (Some(sev), Some(sevi)) => vec![sev, sevi\
    \ as isize],\n        _ => vec![],\n    }\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let (mut min, mut index) = (1 << 32, 0);\n    for (i, val) in arr.iter().enumerate()\
    \ {\n        if *val & 1 == 0 && *val < min {\n            min = *val;\n     \
    \       index = i;\n        }\n    }\n    if min != 1 << 32 {\n        vec![min,\
    \ index as isize]\n    } else {\n        vec![]\n    }\n}\n\nfn main() {\n   \
    \ let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let evens: Vec<_> = arr.iter().enumerate().filter(|(i, &v)| v % 2 == 0).collect();\n\
    \    if evens.is_empty() {\n        return vec![];\n    }\n    let (idx, &value)\
    \ = evens.iter().min_by_key(|&(_, &v)| v).unwrap();\n    vec![value, idx as isize]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0606]: casting `&usize` as `isize` is invalid\n  --> /tmp/tmpj2wahqw5.rs:32:17\n\
    \   |\n32 |     vec![value, idx as isize]\n   |                 ---^^^^^^^^^\n\
    \   |                 |\n   |                 cannot cast `&usize` as `isize`\n\
    \   |                 help: dereference the expression: `*idx`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0606`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    let mut min_even\
    \ = None;\n    let mut min_even_index = None;\n    for (i, e) in arr.iter().enumerate()\
    \ {\n        if e % 2 == 0 {\n            if min_even.is_none() || e < min_even.unwrap()\
    \ {\n                min_even = Some(*e);\n                min_even_index = Some(i);\n\
    \            }\n        }\n    }\n    if min_even.is_none() {\n        return\
    \ vec![];\n    }\n    return vec![min_even.unwrap(), min_even_index.unwrap() as\
    \ isize];\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwr3bkhe3.rs:35:33\n   |\n\
    35 |                 min_even = Some(*e);\n   |                              \
    \   ^^\n   |                                 |\n   |                         \
    \        expected `&isize`, found `isize`\n   |                              \
    \   help: consider borrowing here: `&*e`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpwr3bkhe3.rs:43:17\n   |\n43 |     return vec![min_even.unwrap(),\
    \ min_even_index.unwrap() as isize];\n   |                 ^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    43 |     return vec![*min_even.unwrap(), min_even_index.unwrap() as isize];\n\
    \   |                 +\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = (None, std::isize::MAX);\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 && x < min_even.1 {\n            min_even = (Some(i),\
    \ x);\n        }\n    }\n    min_even.0.map(|i| vec![min_even.1, i as isize]).unwrap_or_default()\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even = None;\n    let mut index = std::usize::MAX;\n    for (idx,\
    \ val) in arr.iter().enumerate() {\n        if *val % 2 == 0 {\n            match\
    \ even {\n                None => {\n                    even = Some(*val);\n\
    \                    index = idx;\n                }\n                Some(n)\
    \ => {\n                    if *val < n {\n                        even = Some(*val);\n\
    \                        index = idx;\n                    }\n               \
    \ }\n            }\n        }\n    }\n    match even {\n        None => vec![],\n\
    \        Some(n) => vec![n, index as isize],\n    }\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_positions = Vec::new();\n    let mut smallest_even_value = isize::max_value();\n\
    \    for (i, &v) in arr.iter().enumerate() {\n        if v & 1 == 0 {\n      \
    \      if v < smallest_even_value {\n                even_positions.clear();\n\
    \                smallest_even_value = v;\n            }\n            if v ==\
    \ smallest_even_value {\n                even_positions.push(i);\n           \
    \ }\n        }\n    }\n    if even_positions.is_empty() {\n        return vec![];\n\
    \    }\n    vec![smallest_even_value, even_positions[0] as isize]\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = None;\n    let mut min_index = None;\n    for (index, item)\
    \ in arr.iter().enumerate() {\n        if item % 2 == 0 {\n            if min.is_none()\
    \ || item < &min.unwrap() {\n                min = Some(*item);\n            \
    \    min_index = Some(index);\n            }\n        }\n    }\n    match (min,\
    \ min_index) {\n        (Some(min), Some(min_index)) => vec![min, min_index as\
    \ isize],\n        _ => vec![],\n    }\n}\n\nfn main() {\n    let candidate =\
    \ pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // special case\n    if arr.is_empty() {\n        return vec![];\n    }\n\
    \    // create a map for all even values in the array\n    let mut even_map: HashMap<isize,\
    \ usize> = HashMap::new();\n    for (index, val) in arr.iter().enumerate() {\n\
    \        if val % 2 == 0 {\n            even_map.insert(*val, index);\n      \
    \  }\n    }\n    // if no even values were found, then return an empty array\n\
    \    if even_map.is_empty() {\n        return vec![];\n    }\n    // get the smallest\
    \ even value\n    let min_even_value = *even_map.keys().min().unwrap();\n    //\
    \ get the smallest index for this value\n    let index = even_map.get(&min_even_value).unwrap();\n\
    \    vec![min_even_value, *index as isize]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmpwg1o0lty.rs:32:23\n\
    \   |\n32 |     let mut even_map: HashMap<isize, usize> = HashMap::new();\n  \
    \ |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpwg1o0lty.rs:32:47\n\
    \   |\n32 |     let mut even_map: HashMap<isize, usize> = HashMap::new();\n  \
    \ |                                               ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0412, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even_pos = std::usize::MAX;\n    let mut min_even = std::isize::MAX;\n\
    \    for (pos, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            even_pos = pos;\n   \
    \     }\n    }\n    if even_pos == std::usize::MAX {\n        vec![]\n    } else\
    \ {\n        vec![min_even, even_pos as isize]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_val = std::isize::MAX;\n    let mut min_index = 0;\n    for (i,\
    \ n) in arr.iter().enumerate() {\n        if n % 2 == 0 && n < &min_val {\n  \
    \          min_val = *n;\n            min_index = i;\n        }\n    }\n    if\
    \ min_val == std::isize::MAX {\n        return vec![];\n    }\n    vec![min_val,\
    \ min_index as isize]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even = std::isize::MAX;\n    let mut even_index = 0;\n    for (i,\
    \ x) in arr.iter().enumerate() {\n        if *x % 2 == 0 && *x < even {\n    \
    \        even = *x;\n            even_index = i;\n        }\n    }\n    if even\
    \ == std::isize::MAX {\n        vec![]\n    } else {\n        vec![even, even_index\
    \ as isize]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_val = isize::max_value();\n    let mut result = vec![];\n   \
    \ for (i, &v) in arr.iter().enumerate() {\n        if v % 2 == 0 && v < min_val\
    \ {\n            min_val = v;\n            result = vec![v, i as isize];\n   \
    \     }\n    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n   \
    \ assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = arr.iter().enumerate().filter(|&(_, &x)| x % 2 == 0).collect::<Vec<_>>();\n\
    \    evens.sort_by_key(|&(_, x)| x);\n    if evens.is_empty() {\n        return\
    \ vec![];\n    }\n    evens[0].clone().into()\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Vec<isize>: From<(usize, &isize)>` is not\
    \ satisfied\n  --> /tmp/tmp4yvn9app.rs:32:22\n   |\n32 |     evens[0].clone().into()\n\
    \   |                      ^^^^ the trait `From<(usize, &isize)>` is not implemented\
    \ for `Vec<isize>`\n   |\n   = help: the following other types implement trait\
    \ `From<T>`:\n             <Vec<T, A> as From<Box<[T], A>>>\n             <Vec<T,\
    \ A> as From<VecDeque<T, A>>>\n             <Vec<T> as From<&[T]>>\n         \
    \    <Vec<T> as From<&mut [T]>>\n             <Vec<T> as From<BinaryHeap<T>>>\n\
    \             <Vec<T> as From<Cow<'a, [T]>>>\n             <Vec<T> as From<[T;\
    \ N]>>\n             <Vec<u8> as From<&str>>\n           and 2 others\n   = note:\
    \ required because of the requirements on the impl of `Into<Vec<isize>>` for `(usize,\
    \ &isize)`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut ans = vec![];\n    let mut arr_len = arr.len();\n    if arr_len ==\
    \ 0 {\n        return ans;\n    }\n    let mut min_even = arr[0];\n    let mut\
    \ min_even_idx = 0;\n    for (i, v) in arr.iter().enumerate() {\n        if *v\
    \ % 2 == 0 {\n            if *v < min_even {\n                min_even = *v;\n\
    \                min_even_idx = i;\n            }\n        }\n    }\n    if min_even\
    \ % 2 == 0 {\n        ans.push(min_even);\n        ans.push(min_even_idx as isize);\n\
    \    }\n    ans\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[2, 1]`', /tmp/tmppfo6p1q3.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = arr.iter().enumerate().filter(|(_, x)| x % 2 == 0).collect::<Vec<_>>();\n\
    \    evens.sort_by_key(|(_, x)| x);\n    if evens.is_empty() {\n        return\
    \ vec![];\n    }\n    let mut min = evens[0].1;\n    for (_, e) in evens {\n \
    \       if e < min {\n            min = e;\n        }\n    }\n    let index =\
    \ evens.iter().filter(|(_, x)| x == &min).map(|(i, _)| i).min().unwrap();\n  \
    \  vec![*min, *index as isize]\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmp2iza_uqn.rs:27:62\n\
    \   |\n27 |     let mut evens = arr.iter().enumerate().filter(|(_, x)| x % 2 ==\
    \ 0).collect::<Vec<_>>();\n   |                                              \
    \              - ^ - {integer}\n   |                                         \
    \                   |\n   |                                                  \
    \          &&isize\n   |\nhelp: `%` can be used on `isize`, you can dereference\
    \ `x`\n   |\n27 |     let mut evens = arr.iter().enumerate().filter(|(_, x)| *x\
    \ % 2 == 0).collect::<Vec<_>>();\n   |                                       \
    \                     +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = std::isize::MAX;\n    let mut min_index = std::isize::MAX;\n\
    \    for (index, item) in arr.iter().enumerate() {\n        if item % 2 == 0 &&\
    \ item < &min {\n            min = *item;\n            min_index = index as isize;\n\
    \        }\n    }\n    if min == std::isize::MAX {\n        return vec![];\n \
    \   }\n    vec![min, min_index]\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest = std::isize::MAX;\n    let mut idx = std::isize::MAX;\n\
    \    for (index, element) in arr.iter().enumerate() {\n        if *element % 2\
    \ == 0 && element < &smallest {\n            smallest = *element;\n          \
    \  idx = index as isize;\n        }\n    }\n    if smallest == std::isize::MAX\
    \ {\n        vec![]\n    } else {\n        vec![smallest, idx]\n    }\n}\n\nfn\
    \ main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    unimplemented!();\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpm9spimiy.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even = Vec::new();\n    let mut odd = Vec::new();\n    for (index,\
    \ i) in arr.iter().enumerate() {\n        if i % 2 == 0 {\n            even.push((index,\
    \ i));\n        } else {\n            odd.push((index, i));\n        }\n    }\n\
    \    if even.is_empty() {\n        Vec::new()\n    } else {\n        even.sort_by(|a,\
    \ b| a.1.cmp(b.1));\n        vec![*even[0].1, even[0].0 as isize]\n    }\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted = arr.clone();\n    sorted.sort();\n    for i in 0..sorted.len()\
    \ {\n        if sorted[i] % 2 == 0 {\n            return vec![sorted[i], arr.iter().position(|&x|\
    \ x == sorted[i]).unwrap() as isize + 1];\n        }\n    }\n    vec![]\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 2]`,\n right: `[2, 1]`', /tmp/tmpkuh3psnz.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut evens = arr.iter().enumerate().filter(|(_, x)| x % 2 == 0).collect::<Vec<_>>();\n\
    \    evens.sort_by_key(|(i, x)| (*x, *i));\n    match evens.get(0) {\n       \
    \ Some((i, x)) => vec![*x, *i as isize],\n        None => vec![],\n    }\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmp_k4z7oe1.rs:27:62\n\
    \   |\n27 |     let mut evens = arr.iter().enumerate().filter(|(_, x)| x % 2 ==\
    \ 0).collect::<Vec<_>>();\n   |                                              \
    \              - ^ - {integer}\n   |                                         \
    \                   |\n   |                                                  \
    \          &&isize\n   |\nhelp: `%` can be used on `isize`, you can dereference\
    \ `x`\n   |\n27 |     let mut evens = arr.iter().enumerate().filter(|(_, x)| *x\
    \ % 2 == 0).collect::<Vec<_>>();\n   |                                       \
    \                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_k4z7oe1.rs:30:30\n\
    \   |\n30 |         Some((i, x)) => vec![*x, *i as isize],\n   |             \
    \                 ^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n30 |         Some((i, x)) => vec![**x, *i as isize],\n   |\
    \                              +\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    arr.iter()\n        .enumerate()\n        .filter(|&(_, &e)| e % 2 == 0)\n\
    \        .min_by_key(|&(_, e)| e)\n        .map(|(i, &e)| vec![e, i as isize])\n\
    \        .unwrap_or_else(|| vec![])\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    let mut min_even\
    \ = isize::max_value();\n    let mut min_even_idx = usize::max_value();\n    for\
    \ (idx, val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val < &min_even\
    \ {\n            min_even = *val;\n            min_even_idx = idx;\n        }\n\
    \    }\n    if min_even == isize::max_value() {\n        return vec![];\n    }\n\
    \    vec![min_even, min_even_idx as isize]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let evens: Vec<isize> = arr.iter().filter(|n| n % 2 == 0).cloned().collect();\n\
    \    let min = evens.iter().cloned().min();\n    match min {\n        Some(x)\
    \ => {\n            match arr.iter().position(|&n| n == x) {\n               \
    \ Some(y) => vec![x, y as isize],\n                None => vec![],\n         \
    \   }\n        }\n        None => vec![],\n    }\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmp8t4z6pe3.rs:27:53\n\
    \   |\n27 |     let evens: Vec<isize> = arr.iter().filter(|n| n % 2 == 0).cloned().collect();\n\
    \   |                                                   - ^ - {integer}\n   |\
    \                                                   |\n   |                  \
    \                                 &&isize\n   |\nhelp: `%` can be used on `isize`,\
    \ you can dereference `n`\n   |\n27 |     let evens: Vec<isize> = arr.iter().filter(|n|\
    \ *n % 2 == 0).cloned().collect();\n   |                                     \
    \              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest_even_value = std::isize::MAX;\n    let mut smallest_even_index\
    \ = std::isize::MAX;\n    for (i, value) in arr.iter().enumerate() {\n       \
    \ if value % 2 == 0 && value < &smallest_even_value {\n            smallest_even_value\
    \ = *value;\n            smallest_even_index = i as isize;\n        }\n    }\n\
    \    if smallest_even_value == std::isize::MAX {\n        return vec![];\n   \
    \ }\n    vec![smallest_even_value, smallest_even_index]\n}\n\nfn main() {\n  \
    \  let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut v: Vec<isize> = arr.into_iter().filter(|i| i % 2 == 0).collect();\n\
    \    v.sort();\n    if let Some(smallest) = v.iter().next() {\n        let idx\
    \ = arr.iter().position(|&i| i == *smallest).unwrap();\n        vec![*smallest,\
    \ idx as isize]\n    } else {\n        vec![]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `arr`\n   --> /tmp/tmpf4rjd9fr.rs:30:19\n\
    \    |\n26  | fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    |          --- move\
    \ occurs because `arr` has type `Vec<isize>`, which does not implement the `Copy`\
    \ trait\n27  |     let mut v: Vec<isize> = arr.into_iter().filter(|i| i % 2 ==\
    \ 0).collect();\n    |                                 ----------- `arr` moved\
    \ due to this method call\n...\n30  |         let idx = arr.iter().position(|&i|\
    \ i == *smallest).unwrap();\n    |                   ^^^^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `arr`\n    = note: borrow occurs due to deref coercion to\
    \ `[isize]`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // Sort by value and index\n    let mut arr: Vec<_> = arr.into_iter().enumerate().collect();\n\
    \    arr.sort_by(|a, b| match a.1.cmp(&b.1) {\n        Ordering::Equal => a.0.cmp(&b.0),\n\
    \        Ordering::Less => Ordering::Less,\n        Ordering::Greater => Ordering::Greater,\n\
    \    });\n    // Linear search for evens\n    for (index, &value) in arr.iter().enumerate()\
    \ {\n        if value % 2 == 0 {\n            return vec![value, index as isize];\n\
    \        }\n    }\n    Vec::new()\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmp8f6yhqaj.rs:30:9\n   |\n30 |         Ordering::Equal => a.0.cmp(&b.0),\n\
    \   |         ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmp8f6yhqaj.rs:31:9\n\
    \   |\n31 |         Ordering::Less => Ordering::Less,\n   |         ^^^^^^^^ use\
    \ of undeclared type `Ordering`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Ordering`\n  --> /tmp/tmp8f6yhqaj.rs:31:27\n   |\n31 |         Ordering::Less\
    \ => Ordering::Less,\n   |                           ^^^^^^^^ use of undeclared\
    \ type `Ordering`\n\nerror[E0433]: failed to resolve: use of undeclared type `Ordering`\n\
    \  --> /tmp/tmp8f6yhqaj.rs:32:9\n   |\n32 |         Ordering::Greater => Ordering::Greater,\n\
    \   |         ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Ordering`\n  --> /tmp/tmp8f6yhqaj.rs:32:30\n\
    \   |\n32 |         Ordering::Greater => Ordering::Greater,\n   |            \
    \                  ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0369]:\
    \ cannot mod `(usize, isize)` by `{integer}`\n  --> /tmp/tmp8f6yhqaj.rs:36:18\n\
    \   |\n36 |         if value % 2 == 0 {\n   |            ----- ^ - {integer}\n\
    \   |            |\n   |            (usize, isize)\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8f6yhqaj.rs:37:25\n   |\n37 |             return vec![value,\
    \ index as isize];\n   |                         ^^^^^ expected `isize`, found\
    \ tuple\n   |\n   = note: expected type `isize`\n             found tuple `(usize,\
    \ isize)`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369, E0433.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = isize::max_value();\n    let mut index = -1;\n    for\
    \ (i, &a) in arr.iter().enumerate() {\n        if a % 2 == 0 && a < min_even {\n\
    \            min_even = a;\n            index = i as isize;\n        }\n    }\n\
    \    if index == -1 {\n        return vec![];\n    }\n    vec![min_even, index]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    let mut arr = arr;\n\
    \    arr.sort();\n    for (index, x) in arr.iter().enumerate() {\n        if x\
    \ % 2 == 0 {\n            return vec![*x, index as isize];\n        }\n    }\n\
    \    vec![]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 0]`,\n right: `[2, 1]`', /tmp/tmpujjiiyhk.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let evens: Vec<isize> = arr.into_iter().filter(|x| x % 2 == 0).collect();\n\
    \    if evens.is_empty() {\n        vec![]\n    } else {\n        let mut min\
    \ = evens[0];\n        let mut min_index = 0;\n        for (index, val) in evens.iter().enumerate()\
    \ {\n            if *val < min {\n                min = *val;\n              \
    \  min_index = index;\n            }\n        }\n        vec![min, min_index as\
    \ isize]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 0]`,\n right: `[2, 1]`', /tmp/tmp1c_xeyv9.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even_idx == std::isize::MAX {\n       \
    \ return vec![];\n    }\n    vec![min_even, min_even_idx]\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // 1. Find the first even number.\n    // 2. Find the smallest number.\n\
    \    // 3. Find the least index for that number.\n    // None of these needs to\
    \ be sorted.\n    if arr.len() == 0 {\n        return vec![];\n    }\n    let\
    \ mut found_even = false;\n    let mut best_index = 0;\n    let mut best_value\
    \ = arr[0];\n    for i in 0..arr.len() {\n        if arr[i] % 2 == 0 {\n     \
    \       found_even = true;\n            if arr[i] < best_value {\n           \
    \     best_value = arr[i];\n                best_index = i;\n            }\n \
    \       }\n    }\n    if found_even {\n        vec![best_value, best_index as\
    \ isize]\n    } else {\n        vec![]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 0]`,\n right: `[2, 1]`', /tmp/tmp277e460j.rs:56:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // Sort the input array.\n    let mut arr = arr;\n    arr.sort();\n    arr.dedup();\n\
    \    // Iterate over the sorted array.\n    let mut ret = Vec::new();\n    for\
    \ i in 0..arr.len() {\n        // If the current array element is even, check\
    \ whether it's the\n        // smallest even element so far.\n        if arr[i]\
    \ % 2 == 0 {\n            if ret.is_empty() || arr[i] < ret[0] {\n           \
    \     ret = vec![arr[i], i as isize];\n            }\n        }\n    }\n    ret\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 0]`,\n right: `[2, 1]`', /tmp/tmp74r527p_.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    unimplemented!();\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpccxcelz2.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // Your code here!\n    let mut smallest = isize::max_value();\n    let mut\
    \ index = 0;\n    for (i, e) in arr.iter().enumerate() {\n        if e % 2 ==\
    \ 0 && e < &smallest {\n            smallest = *e;\n            index = i;\n \
    \       }\n    }\n    if smallest != isize::max_value() {\n        vec![smallest,\
    \ index as isize]\n    } else {\n        vec![]\n    }\n}\n\nfn main() {\n   \
    \ let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    // Find the first element with an even value in the array.\n    let smallest_value\
    \ = arr.iter().find(|&&x| x % 2 == 0);\n    // Return the index of the element,\
    \ if any.\n    smallest_value.map(|x| vec![*x, arr.iter().position(|&y| y == *x).unwrap()\
    \ as isize])\n        // Otherwise return an empty vector.\n        .unwrap_or(vec![])\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[4, 0]`,\n right: `[2, 1]`', /tmp/tmp63gml353.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = 1_000_000_000;\n    let mut res = vec![];\n    for (i, v) in\
    \ arr.iter().enumerate() {\n        if *v == 0 {\n            res = vec![0, i\
    \ as isize];\n            break;\n        }\n        if *v % 2 == 0 && *v < min\
    \ {\n            min = *v;\n            res = vec![min, i as isize];\n       \
    \ }\n    }\n    res\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_even = isize::max_value();\n    let mut result = vec![];\n  \
    \  for (i, n) in arr.iter().enumerate() {\n        if *n % 2 == 0 && n < &min_even\
    \ {\n            min_even = *n;\n            result = vec![min_even, i as isize];\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut result = vec![];\n    let mut min_even = None;\n    let mut pos =\
    \ None;\n    for (index, i) in arr.iter().enumerate() {\n        if i % 2 == 0\
    \ {\n            if min_even.is_none() || i < min_even.unwrap() {\n          \
    \      min_even = Some(*i);\n                pos = Some(index);\n            }\n\
    \        }\n    }\n    if min_even.is_some() {\n        result.push(min_even.unwrap());\n\
    \        result.push(pos.unwrap() as isize);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgpo3l12r.rs:33:33\n   |\n\
    33 |                 min_even = Some(*i);\n   |                              \
    \   ^^\n   |                                 |\n   |                         \
    \        expected `&isize`, found `isize`\n   |                              \
    \   help: consider borrowing here: `&*i`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpgpo3l12r.rs:40:21\n   |\n40 |         result.push(pos.unwrap() as\
    \ isize);\n   |                     ^^^^^^^^^^^^^^^^^^^^^\n   |              \
    \       |\n   |                     expected `&isize`, found `isize`\n   |   \
    \                  help: consider borrowing here: `&(pos.unwrap() as isize)`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgpo3l12r.rs:42:5\n   |\n26 | fn\
    \ pluck(arr: Vec<isize>) -> Vec<isize> {\n   |                              ----------\
    \ expected `Vec<isize>` because of return type\n...\n42 |     result\n   |   \
    \  ^^^^^^ expected `isize`, found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<&isize>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.len() == 0 {\n        return vec![];\n    }\n    let mut min_even\
    \ = 1_000_000_000;\n    let mut min_even_idx = 0;\n    for i in 0..arr.len() {\n\
    \        if arr[i] % 2 == 0 && arr[i] < min_even {\n            min_even = arr[i];\n\
    \            min_even_idx = i;\n        }\n    }\n    if min_even != 1_000_000_000\
    \ {\n        vec![min_even, min_even_idx as isize]\n    } else {\n        vec![]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut smallest = std::isize::MAX;\n    let mut smallest_index = std::isize::MAX;\n\
    \    for (i, x) in arr.iter().enumerate() {\n        if x % 2 == 0 && *x < smallest\
    \ {\n            smallest = *x;\n            smallest_index = i as isize;\n  \
    \      }\n    }\n    if smallest == std::isize::MAX {\n        vec![]\n    } else\
    \ {\n        vec![smallest, smallest_index]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min = 10_000_000;\n    let mut idx = 0;\n    for (i, x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 && x < &min {\n            min = *x;\n            idx\
    \ = i;\n        }\n    }\n    if min == 10_000_000 {\n        vec![]\n    } else\
    \ {\n        vec![min, idx as isize]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut min_index = arr.len();\n    let mut min_value = std::isize::MAX;\n\
    \    for (i, v) in arr.iter().enumerate() {\n        if v % 2 == 0 && v < &min_value\
    \ {\n            min_index = i;\n            min_value = *v;\n        }\n    }\n\
    \    if min_index == arr.len() {\n        return vec![];\n    }\n    vec![min_value,\
    \ min_index as isize]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    let mut even = std::isize::MAX;\n    let mut index = std::isize::MAX;\n \
    \   for (i, e) in arr.iter().enumerate() {\n        if e % 2 == 0 && e < &even\
    \ {\n            even = *e;\n            index = i as isize;\n        }\n    }\n\
    \    if even == std::isize::MAX {\n        vec![]\n    } else {\n        vec![even,\
    \ index]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a list, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given array is empty, return\
    \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
    /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
    \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
    \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
    \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
    \ <= 10000\n/// * 0 <= node.value\nfn pluck(arr: Vec<isize>) -> Vec<isize> {\n\
    \    if arr.is_empty() {\n        return vec![];\n    }\n    let mut min_val =\
    \ 10001;\n    let mut min_index = 0;\n    for (index, value) in arr.iter().enumerate()\
    \ {\n        if *value < min_val && *value % 2 == 0 {\n            min_val = *value;\n\
    \            min_index = index;\n        }\n    }\n    if min_val == 10001 {\n\
    \        return vec![];\n    }\n    vec![min_val, min_index as isize]\n}\n\nfn\
    \ main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
