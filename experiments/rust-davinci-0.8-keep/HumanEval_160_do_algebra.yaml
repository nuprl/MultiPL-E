name: HumanEval_160_do_algebra
language: rust
prompt: "/// Given two lists operator, and operand. The first list has basic algebra\
  \ operations, and \n/// the second list is a list of integers. Use the two given\
  \ lists to build the algebric \n/// expression and return the evaluation of this\
  \ expression.\n/// The basic algebra operations:\n/// Addition ( + ) \n/// Subtraction\
  \ ( - ) \n/// Multiplication ( * ) \n/// Floor division ( // ) \n/// Exponentiation\
  \ ( ** ) \n/// Example:\n/// operator['+', '*', '-']\n/// array = [2, 3, 4, 5]\n\
  /// result = 2 + 3 * 4 - 5\n/// => result = 9\n/// Note:\n/// The length of operator\
  \ list is equal to the length of operand list minus one.\n/// Operand is a list\
  \ of of non-negative integers.\n/// Operator list has at least one operator, and\
  \ operand list has at least two operands.\nfn do_algebra(operator: Vec<String>,\
  \ operand: Vec<isize>) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = do_algebra;\n    assert_eq!(candidate(vec![String::from(\"\
  **\"), String::from(\"*\"), String::from(\"+\")], vec![2, 3, 4, 5]), 37);\n    assert_eq!(candidate(vec![String::from(\"\
  +\"), String::from(\"*\"), String::from(\"-\")], vec![2, 3, 4, 5]), 9);\n    assert_eq!(candidate(vec![String::from(\"\
  //\"), String::from(\"*\")], vec![7, 3, 4]), 8);\n}\n"
completions: ["  let mut result = operand[0];\n  for i in 0..operator.len() {\n  \
    \  match operator[i].as_str() {\n      \"+\" => result += operand[i + 1],\n  \
    \    \"-\" => result -= operand[i + 1],\n      \"*\" => result *= operand[i +\
    \ 1],\n      \"//\" => result /= operand[i + 1],\n      \"**\" => result = result.pow(operand[i\
    \ + 1] as u32),\n      _ => result = result,\n    }\n  }\n  result", "    let\
    \ mut opd = operand.clone();\n    let mut result = opd.remove(0);\n    for (op,\
    \ x) in operator.iter().zip(opd) {\n        match op.as_str() {\n            \"\
    +\" => result += x,\n            \"-\" => result -= x,\n            \"*\" => result\
    \ *= x,\n            \"//\" => result /= x,\n            \"**\" => result = result.pow(*x\
    \ as u32),\n            _ => return 0,\n        }\n    }\n    result", "    let\
    \ mut operand_iter = operand.iter();\n    let first_operand = operand_iter.next().unwrap();\n\
    \    operator.iter().fold(*first_operand, |acc, x| {\n        let y = operand_iter.next().unwrap();\n\
    \        match x.as_str() {\n            \"+\" => acc + y,\n            \"-\"\
    \ => acc - y,\n            \"*\" => acc * y,\n            \"//\" => acc / y,\n\
    \            \"**\" => acc.pow(*y as u32),\n            _ => 0,\n        }\n \
    \   })", "    let mut res = 0;\n    let mut i = 0;\n    for op in operator {\n\
    \        match op.as_str() {\n            \"+\" => {\n                res += operand[i];\n\
    \                i += 1;\n            }\n            \"-\" => {\n            \
    \    res -= operand[i];\n                i += 1;\n            }\n            \"\
    *\" => {\n                res *= operand[i];\n                i += 1;\n      \
    \      }\n            \"//\" => {\n                res /= operand[i];\n      \
    \          i += 1;\n            }\n            \"**\" => {\n                res\
    \ = res.pow(operand[i] as u32);\n                i += 1;\n            }\n    \
    \        _ => {}\n        }\n    }\n    res", "    operand.iter().skip(1).zip(operator.iter()).fold(operand[0],\n\
    \        |acc, (x, op)| match op.as_str() {\n            \"+\" => acc + x,\n \
    \           \"-\" => acc - x,\n            \"*\" => acc * x,\n            \"//\"\
    \ => acc / x,\n            \"**\" => acc.pow(*x as u32),\n            _ => panic!(\"\
    Unknown operator {}\", op),\n        })", "    // TODO\n    0", "    let mut output\
    \ = operand[0];\n    for i in 0..operator.len() {\n        let op_one = output;\n\
    \        let op_two = operand[i + 1];\n        output = match operator[i].as_str()\
    \ {\n            \"+\" => op_one + op_two,\n            \"-\" => op_one - op_two,\n\
    \            \"*\" => op_one * op_two,\n            \"//\" => op_one / op_two,\n\
    \            \"**\" => op_one.pow(op_two as u32),\n            _ => 0,\n     \
    \   };\n    }\n    output", "    let mut i = 0;\n    let mut result = operand[i];\n\
    \    i += 1;\n    for j in 0..operator.len() {\n        match operator[j].as_str()\
    \ {\n            \"+\" => result += operand[i],\n            \"-\" => result -=\
    \ operand[i],\n            \"*\" => result *= operand[i],\n            \"//\"\
    \ => result /= operand[i],\n            \"**\" => result = result.pow(operand[i]\
    \ as u32),\n            _ => {},\n        }\n        i += 1;\n    }\n    result",
  "    let mut stack: Vec<isize> = vec![];\n    let mut op_iter = operator.iter();\n\
    \    for num in operand {\n        stack.push(num);\n        if let Some(op) =\
    \ op_iter.next() {\n            let back = stack.pop().unwrap();\n           \
    \ let front = stack.pop().unwrap();\n            stack.push(match op.as_str()\
    \ {\n                \"+\" => front + back,\n                \"-\" => front -\
    \ back,\n                \"*\" => front * back,\n                \"//\" => front\
    \ / back,\n                \"**\" => front.pow(back as u32),\n               \
    \ _ => unreachable!()\n            });\n        }\n    }\n    stack.pop().unwrap()",
  "    let mut result = operand[0];\n    for i in 0..operator.len() {\n        let\
    \ oper = &operator[i];\n        let val = operand[i + 1];\n        match oper.as_str()\
    \ {\n            \"+\" => result += val,\n            \"-\" => result -= val,\n\
    \            \"*\" => result *= val,\n            \"//\" => result /= val,\n \
    \           \"**\" => result = result.pow(val as u32),\n            _ => panic!(\"\
    {} is not a valid operator\", oper),\n        }\n    }\n    result", "    let\
    \ op_iter = operator.iter();\n    let mut operation_stack: Vec<isize> = Vec::new();\n\
    \    let mut operand_stack: Vec<isize> = Vec::new();\n    for op in op_iter {\n\
    \        operation_stack.push(match op.as_ref() {\n            \"+\" => 1,\n \
    \           \"-\" => 2,\n            \"*\" => 3,\n            \"/\" => 4,\n  \
    \          \"^\" => 5,\n            _ => panic!(\"invalid operator {}\", op),\n\
    \        });\n    }\n    operation_stack.reverse();\n    for num in operand {\n\
    \        operand_stack.push(num);\n    }\n    let mut result = 0;\n    let mut\
    \ op_iter = operation_stack.iter();\n    loop {\n        match op_iter.next()\
    \ {\n            Some(op) => {\n                let a = operand_stack.pop().unwrap();\n\
    \                let b = operand_stack.pop().unwrap();\n                match\
    \ op {\n                    1 => result = a + b,\n                    2 => result\
    \ = a - b,\n                    3 => result = a * b,\n                    4 =>\
    \ result = a / b,\n                    5 => result = a.pow(b as u32),\n      \
    \              _ => panic!(\"invalid operator\"),\n                }\n       \
    \         operand_stack.push(result);\n            }\n            None => break,\n\
    \        }\n    }\n    result", "    let mut result = operand[0];\n    for i in\
    \ 0..operator.len() {\n        let num = operand[i + 1];\n        if operator[i]\
    \ == \"+\" {\n            result += num;\n        } else if operator[i] == \"\
    -\" {\n            result -= num;\n        } else if operator[i] == \"*\" {\n\
    \            result *= num;\n        } else if operator[i] == \"//\" {\n     \
    \       result /= num;\n        } else if operator[i] == \"**\" {\n          \
    \  result = result.pow(num as u32);\n        }\n    }\n    result", "    let mut\
    \ x = operand[0];\n    for i in 0..operator.len() {\n        let op = &operator[i];\n\
    \        let y = operand[i + 1];\n        match op.as_str() {\n            \"\
    +\" => x += y,\n            \"-\" => x -= y,\n            \"*\" => x *= y,\n \
    \           \"//\" => x /= y,\n            \"**\" => x = x.pow(y as u32),\n  \
    \          _ => panic!(\"Invalid operator {}\", op),\n        }\n    }\n    x",
  '    unimplemented!();', "    let mut stack: Vec<isize> = vec![];\n    let mut operand_iter\
    \ = operand.iter();\n    for op in operator {\n        match op.as_str() {\n \
    \           \"+\" => {\n                let o1 = operand_iter.next().unwrap();\n\
    \                let o2 = operand_iter.next().unwrap();\n                stack.push(*o1\
    \ + *o2);\n            }\n            \"-\" => {\n                let o1 = operand_iter.next().unwrap();\n\
    \                let o2 = operand_iter.next().unwrap();\n                stack.push(*o1\
    \ - *o2);\n            }\n            \"*\" => {\n                let o1 = operand_iter.next().unwrap();\n\
    \                let o2 = operand_iter.next().unwrap();\n                stack.push(*o1\
    \ * *o2);\n            }\n            \"//\" => {\n                let o1 = operand_iter.next().unwrap();\n\
    \                let o2 = operand_iter.next().unwrap();\n                stack.push(*o1\
    \ / *o2);\n            }\n            \"**\" => {\n                let o1 = operand_iter.next().unwrap();\n\
    \                let o2 = operand_iter.next().unwrap();\n                stack.push(o1.pow(*o2\
    \ as u32));\n            }\n            _ => {}\n        }\n    }\n    match stack.pop()\
    \ {\n        Some(i) => i,\n        None => 0,\n    }", "    operand.iter().fold(0,\
    \ |prev, curr| {\n        let curr_op = operator.pop().unwrap();\n        match\
    \ curr_op.as_str() {\n            \"+\" => prev + curr,\n            \"-\" =>\
    \ prev - curr,\n            \"*\" => prev * curr,\n            \"/\" => prev /\
    \ curr,\n            \"^\" => prev.pow(*curr as u32),\n            _ => 0,\n \
    \       }\n    })", "    let mut result = operand[0];\n    for i in 0..operand.len()\
    \ - 1 {\n        match operator[i].as_str() {\n            \"+\" => result +=\
    \ operand[i + 1],\n            \"-\" => result -= operand[i + 1],\n          \
    \  \"*\" => result *= operand[i + 1],\n            \"//\" => result /= operand[i\
    \ + 1],\n            \"**\" => result = result.pow(operand[i + 1] as u32),\n \
    \           _ => panic!(\"Unexpected operator\"),\n        }\n    }\n    result",
  "    let mut result = operand[0];\n    for (i, s) in operator.iter().enumerate()\
    \ {\n        let op2 = operand[i + 1];\n        match s.as_str() {\n         \
    \   \"+\" => result += op2,\n            \"-\" => result -= op2,\n           \
    \ \"*\" => result *= op2,\n            \"//\" => result /= op2,\n            \"\
    **\" => result = result.pow(op2 as u32),\n            _ => {}\n        }\n   \
    \ }\n    result", "    // This function is not yet implemented!\n    unimplemented!();",
  '    unimplemented!()', "    // your code here\n    0", "    let mut result = operand[0];\n\
    \    for i in 0..operator.len() {\n        match operator[i].as_str() {\n    \
    \        \"+\" => result += operand[i + 1],\n            \"-\" => result -= operand[i\
    \ + 1],\n            \"*\" => result *= operand[i + 1],\n            \"//\" =>\
    \ result /= operand[i + 1],\n            \"**\" => result = result.pow(operand[i\
    \ + 1] as u32),\n            _ => (),\n        }\n    }\n    result", "    let\
    \ mut res = operand[0];\n    for (i, o) in operator.iter().enumerate() {\n   \
    \     match o.as_str() {\n            \"+\" => res += operand[i + 1],\n      \
    \      \"-\" => res -= operand[i + 1],\n            \"*\" => res *= operand[i\
    \ + 1],\n            \"//\" => res /= operand[i + 1],\n            \"**\" => res\
    \ = res.pow(operand[i + 1] as u32),\n            _ => panic!(\"Invalid operator!\"\
    ),\n        }\n    }\n    res", "    let mut operand = operand;\n    let mut op_index\
    \ = 0;\n    let mut result = operand.remove(0);\n    while operand.len() > 0 {\n\
    \        let op = &operator[op_index];\n        let value = operand.remove(0);\n\
    \        match op.as_str() {\n            \"+\" => result += value,\n        \
    \    \"-\" => result -= value,\n            \"*\" => result *= value,\n      \
    \      \"//\" => result /= value,\n            \"**\" => result = result.pow(value\
    \ as u32),\n            _ => (),\n        }\n        op_index += 1;\n    }\n \
    \   result", "    let mut result = operand[0];\n    for i in 0..operator.len()\
    \ {\n        match operator[i].as_str() {\n            \"+\" => result += operand[i\
    \ + 1],\n            \"-\" => result -= operand[i + 1],\n            \"*\" =>\
    \ result *= operand[i + 1],\n            \"//\" => result /= operand[i + 1],\n\
    \            \"**\" => result = result.pow(operand[i + 1] as u32),\n         \
    \   _ => println!(\"unexpected\"),\n        }\n    }\n    result", "    let operator_iter\
    \ = operator.iter();\n    let operand_iter = operand.iter();\n    let mut res\
    \ = 0;\n    let mut operand_sum = 0;\n    let mut operand_multi = 0;\n    let\
    \ mut operand_minus = 0;\n    let mut operand_div = 0;\n    let mut operand_exp\
    \ = 0;\n    let mut res_div = 0;\n    let mut res_exp = 0;\n    let mut res_multi\
    \ = 0;\n    let mut sum_res = 0;\n    let mut minus_res = 0;\n    let mut multi_res\
    \ = 0;\n    let mut div_res = 0;\n    let mut exp_res = 0;\n    let mut res_minus\
    \ = 0;\n    let mut res_sum = 0;\n    let mut res_minus = 0;\n    let mut res_multi\
    \ = 0;\n    let mut res_exp = 0;\n    let mut res_div = 0;\n    let mut op_sum\
    \ = 0;\n    let mut op_minus = 0;\n    let mut op_multi = 0;\n    let mut op_div\
    \ = 0;\n    let mut op_exp = 0;\n    let mut sum_num = 0;\n    let mut minus_num\
    \ = 0;\n    let mut multi_num = 0;\n    let mut div_num = 0;\n    let mut exp_num\
    \ = 0;\n    for op in operator_iter {\n        if op == \"+\" {\n            for\
    \ num in operand_iter {\n                op_sum += 1;\n                operand_sum\
    \ += num;\n            }\n            sum_num = op_sum - 1;\n            sum_res\
    \ = operand_sum - operand[sum_num];\n        }\n        if op == \"-\" {\n   \
    \         for num in operand_iter {\n                op_minus += 1;\n        \
    \        operand_minus += num;\n            }\n            minus_num = op_minus\
    \ - 1;\n            minus_res = operand_minus - operand[minus_num];\n        }\n\
    \        if op == \"*\" {\n            for num in operand_iter {\n           \
    \     op_multi += 1;\n                operand_multi +=", "    let mut value: Vec<isize>\
    \ = vec![];\n    let mut op: Vec<String> = vec![];\n    let mut prec: Vec<usize>\
    \ = vec![];\n    for s in operator {\n        match s.as_str() {\n           \
    \ \"+\" => {\n                op.push(s);\n                prec.push(0);\n   \
    \         }\n            \"-\" => {\n                op.push(s);\n           \
    \     prec.push(0);\n            }\n            \"*\" => {\n                op.push(s);\n\
    \                prec.push(1);\n            }\n            \"/\" => {\n      \
    \          op.push(s);\n                prec.push(1);\n            }\n       \
    \     \"^\" => {\n                op.push(s);\n                prec.push(2);\n\
    \            }\n            _ => (),\n        }\n    }\n    let mut i = 0;\n \
    \   while i < operand.len() {\n        value.push(operand[i]);\n        if op.len()\
    \ == 0 {\n            break;\n        }\n        if prec[0] < 2 {\n          \
    \  value.push(op.remove(0));\n            prec.remove(0);\n        } else {\n\
    \            while prec[0] == 2 {\n                value.push(op.remove(0));\n\
    \                prec.remove(0);\n                value.push(operand[i + 1]);\n\
    \                i += 1;\n            }\n            if op.len() == 0 {\n    \
    \            break;\n            }\n            value.push(op.remove(0));\n  \
    \          prec.remove(0);\n        }\n        i += 1;\n    }\n    while op.len()\
    \ > 0 {\n        value.push(op.remove(0));\n        prec.remove(0);\n        value.push(operand[i]);\n\
    \        i += 1;\n    }\n    return eval(value);", "    // Write your code here\n\
    \    operand.iter().zip(operator.iter()).fold(0, |acc, (x, y)| {\n        acc\
    \ + match y.as_str() {\n            \"+\" => *x,\n            \"-\" => -*x,\n\
    \            \"*\" => 2 * *x,\n            \"//\" => *x / 2,\n            \"**\"\
    \ => x.pow(2),\n            _ => 0,\n        }\n    })", '    // ...', "    let\
    \ mut res = operand[0];\n    for i in 0..operator.len() {\n        let op: &str\
    \ = &operator[i];\n        let op1 = &operand[i + 1];\n        res = match op\
    \ {\n            \"+\" => res + op1,\n            \"-\" => res - op1,\n      \
    \      \"*\" => res * op1,\n            \"//\" => res / op1,\n            \"**\"\
    \ => res.pow(*op1 as u32),\n            _ => unreachable!(),\n        };\n   \
    \ }\n    res", "    let mut res = operand[0];\n    for i in 0..operator.len()\
    \ {\n        match operator[i].as_str() {\n            \"+\" => res += operand[i\
    \ + 1],\n            \"-\" => res -= operand[i + 1],\n            \"*\" => res\
    \ *= operand[i + 1],\n            \"//\" => res /= operand[i + 1],\n         \
    \   \"**\" => res = res.pow(operand[i + 1] as u32),\n            _ => panic!(\"\
    Unknown operator\"),\n        }\n    }\n    res", "    let mut result = operand[0];\n\
    \    for i in 0..operator.len() {\n        match operator[i].as_str() {\n    \
    \        \"+\" => result += operand[i + 1],\n            \"-\" => result -= operand[i\
    \ + 1],\n            \"*\" => result *= operand[i + 1],\n            \"//\" =>\
    \ result /= operand[i + 1],\n            \"**\" => result = result.pow(operand[i\
    \ + 1] as u32),\n            _ => {}\n        }\n    }\n    result", '    0',
  "    let mut result = operand[0];\n    for i in 0..operator.len() {\n        let\
    \ num = operand[i + 1];\n        match operator[i].as_str() {\n            \"\
    +\" => result += num,\n            \"-\" => result -= num,\n            \"*\"\
    \ => result *= num,\n            \"//\" => result /= num,\n            \"**\"\
    \ => result = result.pow(num as u32),\n            _ => unreachable!(),\n    \
    \    }\n    }\n    result", "    if operator.len() + 1 != operand.len() {\n  \
    \      return 0;\n    }\n    let mut stack: Vec<isize> = Vec::new();\n    let\
    \ mut op_idx = 0;\n    for item in operand {\n        stack.push(item);\n    \
    \    if op_idx < operator.len() {\n            let val1 = stack.pop().unwrap();\n\
    \            let val2 = stack.pop().unwrap();\n            stack.push(match operator[op_idx].as_str()\
    \ {\n                \"+\" => val2 + val1,\n                \"-\" => val2 - val1,\n\
    \                \"*\" => val2 * val1,\n                \"//\" => val2 / val1,\n\
    \                \"**\" => val2.pow(val1 as u32),\n                _ => 0,\n \
    \           });\n            op_idx += 1;\n        }\n    }\n    stack.pop().unwrap()",
  "    let mut r = operand[0];\n    for i in 0..operator.len() {\n        match operator[i].as_str()\
    \ {\n            \"+\" => r += operand[i + 1],\n            \"-\" => r -= operand[i\
    \ + 1],\n            \"*\" => r *= operand[i + 1],\n            \"//\" => r /=\
    \ operand[i + 1],\n            \"**\" => r = r.pow(operand[i + 1] as u32),\n \
    \           _ => {}\n        }\n    }\n    r", "    let mut curr = operand[0];\n\
    \    for (i, op) in operator.iter().enumerate() {\n        let v = operand[i +\
    \ 1];\n        match op.as_str() {\n            \"+\" => curr += v,\n        \
    \    \"-\" => curr -= v,\n            \"*\" => curr *= v,\n            \"//\"\
    \ => curr /= v,\n            \"**\" => curr = curr.pow(v as u32),\n          \
    \  _ => unreachable!(),\n        }\n    }\n    curr", "    let mut result = operand[0];\n\
    \    for (i, o) in operator.iter().enumerate() {\n        match o.as_str() {\n\
    \            \"+\" => result += operand[i + 1],\n            \"-\" => result -=\
    \ operand[i + 1],\n            \"*\" => result *= operand[i + 1],\n          \
    \  \"//\" => result /= operand[i + 1],\n            \"**\" => result = result.pow(operand[i\
    \ + 1] as u32),\n            _ => return 0,\n        }\n    }\n    result", '    return
    0;', "    let mut stack: Vec<isize> = Vec::new();\n    for op in operator {\n\
    \        let right = operand.pop().unwrap();\n        let left = operand.pop().unwrap();\n\
    \        match op.as_str() {\n            \"+\" => {\n                stack.push(left\
    \ + right);\n            }\n            \"-\" => {\n                stack.push(left\
    \ - right);\n            }\n            \"*\" => {\n                stack.push(left\
    \ * right);\n            }\n            \"/\" => {\n                stack.push(left\
    \ / right);\n            }\n            \"^\" => {\n                stack.push(left.pow(right\
    \ as u32));\n            }\n            _ => {\n                stack.push(0);\n\
    \            }\n        }\n    }\n    stack.pop().unwrap()", "    operand.iter().zip(operator.iter()).fold((operand[0],\
    \ 1), |(acc, _), (o, c)| {\n        (match c.as_str() {\n            \"+\" =>\
    \ acc + o,\n            \"-\" => acc - o,\n            \"*\" => acc * o,\n   \
    \         \"/\" => acc / o,\n            \"^\" => acc.pow(*o as u32),\n      \
    \      _ => panic!(\"Unsupported operator\")\n        }, 1)\n    }).0", "    let\
    \ mut stack: Vec<isize> = Vec::new();\n    let mut opr = operator.iter();\n  \
    \  let mut opn = operand.iter();\n    while let Some(op) = opr.next() {\n    \
    \    let num = opn.next().unwrap();\n        match op.as_str() {\n           \
    \ \"+\" => stack.push(*num),\n            \"-\" => stack.push(-*num),\n      \
    \      \"*\" => {\n                let mut oper = opn.next().unwrap();\n     \
    \           stack.push(stack.pop().unwrap() * oper);\n            }\n        \
    \    \"/\" => {\n                let mut oper = opn.next().unwrap();\n       \
    \         stack.push(stack.pop().unwrap() / oper);\n            }\n          \
    \  \"**\" => {\n                let mut oper = opn.next().unwrap();\n        \
    \        stack.push(stack.pop().unwrap().pow(*oper as u32));\n            }\n\
    \            _ => panic!(\"Unrecoganized operator!\"),\n        }\n    }\n   \
    \ stack.iter().sum()", "    let mut result = operand[0];\n    for i in 0..operator.len()\
    \ {\n        let op = &operator[i];\n        let opd = operand[i + 1];\n     \
    \   match op.as_str() {\n            \"+\" => result += opd,\n            \"-\"\
    \ => result -= opd,\n            \"*\" => result *= opd,\n            \"//\" =>\
    \ result /= opd,\n            \"**\" => result = result.pow(opd as u32),\n   \
    \         _ => panic!(\"Unknown operator\"),\n        }\n    }\n    result", " \
    \   let mut r = operand[0];\n    for i in 0..operator.len() {\n        match operator[i].as_str()\
    \ {\n            \"+\" => r += operand[i + 1],\n            \"-\" => r -= operand[i\
    \ + 1],\n            \"*\" => r *= operand[i + 1],\n            \"//\" => r /=\
    \ operand[i + 1],\n            \"**\" => r = r.pow(operand[i + 1] as u32),\n \
    \           _ => (),\n        }\n    }\n    r", "    let mut result = operand[0];\n\
    \    for i in 0..operator.len() {\n        if operator[i] == \"+\" {\n       \
    \     result += operand[i + 1];\n        } else if operator[i] == \"-\" {\n  \
    \          result -= operand[i + 1];\n        } else if operator[i] == \"*\" {\n\
    \            result *= operand[i + 1];\n        } else if operator[i] == \"//\"\
    \ {\n            result /= operand[i + 1];\n        } else if operator[i] == \"\
    **\" {\n            result = result.pow(operand[i + 1] as u32);\n        }\n \
    \   }\n    result", "    let mut op_it = operator.iter();\n    let mut op1 = *op_it.next().unwrap();\n\
    \    let mut op2 = *op_it.next().unwrap();\n    let mut a1 = operand[0];\n   \
    \ let mut a2 = operand[1];\n    let mut a3 = operand[2];\n    let mut a4 = operand[3];\n\
    \    let mut a5 = operand[4];\n    let mut a6 = operand[5];\n    let mut a7 =\
    \ operand[6];\n    let mut a8 = operand[7];\n    let mut a9 = operand[8];\n  \
    \  let mut a10 = operand[9];\n    let mut a11 = operand[10];\n    let mut a12\
    \ = operand[11];\n    let mut a13 = operand[12];\n    let mut a14 = operand[13];\n\
    \    let mut a15 = operand[14];\n    let mut a16 = operand[15];\n    let mut a17\
    \ = operand[16];\n    let mut a18 = operand[17];\n    let mut a19 = operand[18];\n\
    \    let mut a20 = operand[19];\n    let mut a21 = operand[20];\n    let mut a22\
    \ = operand[21];\n    let mut a23 = operand[22];\n    let mut a24 = operand[23];\n\
    \    let mut a25 = operand[24];\n    let mut a26 = operand[25];\n    let mut a27\
    \ = operand[26];\n    let mut a28 = operand[27];\n    let mut a29 = operand[28];\n\
    \    let mut a30 = operand[29];\n    let mut a31 = operand[30];\n    let mut a32\
    \ = operand[31];\n    let mut a33 = operand[32];\n    let mut a34 = operand[33];\n\
    \    let mut a35 = operand[34];\n    let mut a36 = operand[35];\n    let mut a37\
    \ = operand[36];\n    let mut a38 = operand[37];\n    let mut a39 = operand[",
  "    let mut result = operand[0];\n    for (index, op) in operator.iter().enumerate()\
    \ {\n        let op_next = operand[index + 1];\n        match op.as_str() {\n\
    \            \"+\" => result += op_next,\n            \"-\" => result -= op_next,\n\
    \            \"*\" => result *= op_next,\n            \"//\" => result /= op_next,\n\
    \            \"**\" => result = result.pow(op_next as u32),\n            _ =>\
    \ println!(\"Unknown operator\"),\n        }\n    }\n    result", "    let mut\
    \ stack: Vec<isize> = Vec::new();\n    stack.push(operand[0]);\n    for (i, o)\
    \ in operator.iter().enumerate() {\n        let op: isize = operand[i + 1];\n\
    \        match o.as_str() {\n            \"+\" => stack.push(op),\n          \
    \  \"-\" => stack.push(-op),\n            \"*\" => stack.push(stack.pop().unwrap()\
    \ * op),\n            \"//\" => stack.push(stack.pop().unwrap() / op),\n     \
    \       \"**\" => stack.push(stack.pop().unwrap().pow(op as u32)),\n         \
    \   _ => panic!(\"Invalid operation\"),\n        }\n    }\n    return stack.iter().sum();",
  "    let mut stack: Vec<isize> = vec![];\n    for (op, a) in operator.iter().zip(operand.iter())\
    \ {\n        match op.as_str() {\n            \"+\" => stack.push(*a),\n     \
    \       \"-\" => stack.push(-a),\n            \"*\" => {\n                let\
    \ a = *a;\n                stack.push(stack.pop().unwrap() * a);\n           \
    \ }\n            \"//\" => {\n                let a = *a;\n                stack.push(stack.pop().unwrap()\
    \ / a);\n            }\n            \"**\" => {\n                let a = *a;\n\
    \                stack.push(stack.pop().unwrap().pow(a as u32));\n           \
    \ }\n            _ => unreachable!(),\n        }\n    }\n    stack.iter().sum()",
  "    let mut res = operand[0];\n    for (i, op) in operator.iter().enumerate() {\n\
    \        match op.as_str() {\n            \"+\" => res += operand[i + 1],\n  \
    \          \"-\" => res -= operand[i + 1],\n            \"*\" => res *= operand[i\
    \ + 1],\n            \"//\" => res /= operand[i + 1],\n            \"**\" => res\
    \ = res.pow(operand[i + 1] as u32),\n            _ => (),\n        }\n    }\n\
    \    res", "    let mut operand_iter = operand.iter();\n    let mut res = *operand_iter.next().unwrap();\n\
    \    for op in operator {\n        let num = *operand_iter.next().unwrap();\n\
    \        res = match op.as_str() {\n            \"+\" => res + num,\n        \
    \    \"-\" => res - num,\n            \"*\" => res * num,\n            \"//\"\
    \ => res / num,\n            \"**\" => res.pow(num as u32),\n            _ =>\
    \ panic!(\"I don't know how to calculate {}\", op),\n        };\n    }\n    res",
  "    let mut operation = operator.into_iter();\n    let mut operand = operand.into_iter();\n\
    \    let first = operand.next().unwrap();\n    let mut result = operand.fold(first,\
    \ |acc, x| match operation.next().unwrap().as_ref() {\n        \"+\" => acc +\
    \ x,\n        \"-\" => acc - x,\n        \"*\" => acc * x,\n        \"//\" =>\
    \ acc / x,\n        \"**\" => acc.pow(x as u32),\n        _ => panic!(\"unknown\
    \ operator\"),\n    });\n    for op in operation {\n        let n = operand.next().unwrap();\n\
    \        result = match op.as_ref() {\n            \"+\" => result + n,\n    \
    \        \"-\" => result - n,\n            \"*\" => result * n,\n            \"\
    //\" => result / n,\n            \"**\" => result.pow(n as u32),\n           \
    \ _ => panic!(\"unknown operator\"),\n        };\n    }\n    result", "  (0..operator.len()).fold(operand[0],\
    \ |acc, i| {\n    match operator[i].as_str() {\n      \"+\" => acc + operand[i\
    \ + 1],\n      \"-\" => acc - operand[i + 1],\n      \"*\" => acc * operand[i\
    \ + 1],\n      \"//\" => acc / operand[i + 1],\n      \"**\" => acc.pow(operand[i\
    \ + 1] as u32),\n      _ => 0,\n    }\n  })", '    unimplemented!();', "    let\
    \ mut result = operand[0];\n    for i in 0..operator.len() {\n        let next\
    \ = operand[i + 1];\n        match operator[i].as_str() {\n            \"+\" =>\
    \ result += next,\n            \"-\" => result -= next,\n            \"*\" =>\
    \ result *= next,\n            \"//\" => result /= next,\n            \"**\" =>\
    \ result = result.pow(next as u32),\n            _ => panic!(\"Unknown operator:\
    \ {}\", operator[i]),\n        }\n    }\n    result", "    let exp = operator.iter().zip(operand.iter()).fold(\n\
    \        (operand[0], \"\".to_string()),\n        |(acc, exp), (op, num)| (match\
    \ op.as_str() {\n            \"+\" => acc + num,\n            \"-\" => acc - num,\n\
    \            \"*\" => acc * num,\n            \"//\" => acc / num,\n         \
    \   \"**\" => acc.pow(*num as u32),\n            _ => acc,\n        }, exp + op),\n\
    \    );\n    exp.0", "    let mut answer = operand[0];\n    for (i, op) in operator.iter().enumerate()\
    \ {\n        if op == \"+\" {\n            answer += operand[i + 1];\n       \
    \ } else if op == \"-\" {\n            answer -= operand[i + 1];\n        } else\
    \ if op == \"*\" {\n            answer *= operand[i + 1];\n        } else if op\
    \ == \"//\" {\n            answer /= operand[i + 1];\n        } else if op ==\
    \ \"**\" {\n            answer = answer.pow(operand[i + 1] as u32);\n        }\n\
    \    }\n    answer", "    let mut r = operand[0];\n    for i in 0..operator.len()\
    \ {\n        match operator[i].as_str() {\n            \"+\" => r += operand[i\
    \ + 1],\n            \"-\" => r -= operand[i + 1],\n            \"*\" => r *=\
    \ operand[i + 1],\n            \"//\" => r /= operand[i + 1],\n            \"\
    **\" => r = r.pow(operand[i + 1] as u32),\n            _ => return 0,\n      \
    \  }\n    }\n    r", "    let mut res = operand[0];\n    for (i, o) in operator.iter().enumerate()\
    \ {\n        res = match o.as_str() {\n            \"+\" => res + operand[i +\
    \ 1],\n            \"-\" => res - operand[i + 1],\n            \"*\" => res *\
    \ operand[i + 1],\n            \"//\" => res / operand[i + 1],\n            \"\
    **\" => res.pow(operand[i + 1] as u32),\n            _ => 0,\n        }\n    }\n\
    \    res", "  // Create the string expression\n  let mut expression = format!(\"\
    {}\", operand[0]);\n  for i in 0..operator.len() {\n    expression = format!(\"\
    {} {} {}\", expression, operator[i], operand[i + 1]);\n  }\n  //println!(\"expression:\
    \ {}\", expression);\n  // Evaluate the expression\n  let mut ans = String::new();\n\
    \  unsafe {\n    let c_expression = CString::new(expression).unwrap();\n    libc::printf(c_expression.as_ptr());\n\
    \    std::io::stdin().read_line(&mut ans).unwrap();\n  }\n  ans.trim().parse::<isize>().unwrap()",
  "    let mut f = operand[0];\n    for i in 1..operand.len() {\n        match operator[i\
    \ - 1].as_str() {\n            \"+\" => f += operand[i],\n            \"-\" =>\
    \ f -= operand[i],\n            \"*\" => f *= operand[i],\n            \"//\"\
    \ => f /= operand[i],\n            \"**\" => f = f.pow(operand[i] as u32),\n \
    \           _ => panic!(\"Invalid operator: {}\", operator[i - 1]),\n        }\n\
    \    }\n    f", "    let mut stack: Vec<isize> = vec![];\n    let mut ops: Vec<String>\
    \ = vec![];\n    let mut opr: Vec<isize> = vec![];\n    opr.push(operand[0]);\n\
    \    for i in 1..operand.len() {\n        let mut opr2 = operand[i];\n       \
    \ while ops.len() > 0 && (is_larger(ops[ops.len() - 1].as_str(), operator[i -\
    \ 1].as_str()) || ops[ops.len() - 1] == operator[i - 1]) {\n            opr2 =\
    \ apply(ops.pop().unwrap().as_str(), opr.pop().unwrap(), opr2);\n        }\n \
    \       ops.push(operator[i - 1].clone());\n        opr.push(opr2);\n    }\n \
    \   while ops.len() > 0 {\n        opr[opr.len() - 2] = apply(ops.pop().unwrap().as_str(),\
    \ opr[opr.len() - 2], opr[opr.len() - 1]);\n        opr.pop();\n    }\n    return\
    \ opr[0];", "    let mut result = operand[0];\n    for (i, val) in operand.iter().enumerate().skip(1)\
    \ {\n        match operator[i - 1].as_str() {\n            \"+\" => result +=\
    \ val,\n            \"-\" => result -= val,\n            \"*\" => result *= val,\n\
    \            \"/\" => result /= val,\n            \"**\" => result = result.pow(*val\
    \ as u32),\n            _ => panic!(\"Should not happen\"),\n        }\n    }\n\
    \    result", "    // TODO - fill this out\n    0", "  // this is the easy way,\
    \ but not the requested one\n  // operand.iter().zip(operator.iter()).fold(0,\
    \ |acc, (op1,op2)| acc + op1*op2)\n\n  let mut stack = Vec::new();\n  let mut\
    \ i = 0;\n  for op in operator {\n    let res = match op.as_str() {\n      \"\
    +\" => operand[i] + operand[i+1],\n      \"-\" => operand[i] - operand[i+1],\n\
    \      \"*\" => operand[i] * operand[i+1],\n      \"//\" => operand[i] / operand[i+1],\n\
    \      \"**\" => operand[i].pow(operand[i+1] as u32),\n      _ => panic!(\"Unknown\
    \ operator\")\n    };\n    stack.push(res);\n    i += 1;\n  }\n  stack.iter().sum()",
  "    let op: Vec<char> = operator.iter().map(|x| x.chars().nth(0).unwrap()).collect();\n\
    \    let mut result = operand[0];\n    for i in 0..op.len() {\n        match op[i]\
    \ {\n            '+' => result += operand[i + 1],\n            '-' => result -=\
    \ operand[i + 1],\n            '*' => result *= operand[i + 1],\n            '/'\
    \ => result /= operand[i + 1],\n            '^' => result = result.pow(operand[i\
    \ + 1] as u32),\n            _ => println!(\"wrong char\"),\n        }\n    }\n\
    \    result", "    let mut result = operand[0];\n    for (i, next) in operand.iter().skip(1).enumerate()\
    \ {\n        let op = &operator[i];\n        if op == \"+\" {\n            result\
    \ += next;\n        } else if op == \"-\" {\n            result -= next;\n   \
    \     } else if op == \"*\" {\n            result *= next;\n        } else if\
    \ op == \"//\" {\n            result /= next;\n        } else if op == \"**\"\
    \ {\n            result = result.pow(*next as u32);\n        }\n    }\n    result",
  "    if operand.len() == 0 {\n        return 0;\n    }\n\n    let mut result = operand[0];\n\
    \    for i in 0..operand.len() - 1 {\n        match operator[i].as_str() {\n \
    \           \"+\" => result += operand[i + 1],\n            \"-\" => result -=\
    \ operand[i + 1],\n            \"*\" => result *= operand[i + 1],\n          \
    \  \"/\" => result /= operand[i + 1],\n            \"^\" => result = result.pow(operand[i\
    \ + 1] as u32),\n            _ => {}\n        }\n    }\n    result", "    let\
    \ mut result = operand[0];\n    for i in 0..operator.len() {\n        let op =\
    \ &operator[i];\n        let a = operand[i];\n        let b = operand[i + 1];\n\
    \        result = match op.as_str() {\n            \"+\" => a + b,\n         \
    \   \"-\" => a - b,\n            \"*\" => a * b,\n            \"//\" => a / b,\n\
    \            \"**\" => a.pow(b as u32),\n            _ => panic!(\"Invalid operator\"\
    ),\n        };\n    }\n    result", "  operator.iter().zip(operand.iter().zip(operand.iter().skip(1)))\n\
    \    .fold(operand[0], |acc, (op, (lhs, rhs))| match op.as_str() {\n      \"+\"\
    \ => acc + lhs,\n      \"-\" => acc - lhs,\n      \"*\" => acc * lhs,\n      \"\
    //\" => acc / lhs,\n      \"**\" => acc.pow(*lhs as u32),\n      _ => unreachable!(),\n\
    \    })", '    unimplemented!();', "    assert!(operator.len() == operand.len()\
    \ - 1);\n    assert!(operator.len() > 0);\n    assert!(operand.len() > 1);\n \
    \   let mut total = operand[0];\n    for i in 0..operator.len() {\n        match\
    \ operator[i].as_str() {\n            \"+\" => total += operand[i + 1],\n    \
    \        \"-\" => total -= operand[i + 1],\n            \"*\" => total *= operand[i\
    \ + 1],\n            \"//\" => total /= operand[i + 1],\n            \"**\" =>\
    \ total = total.pow(operand[i + 1] as u32),\n            _ => (),\n        }\n\
    \    }\n    total", "    let mut result = operand[0];\n    for i in 0..operator.len()\
    \ {\n        let v = &operator[i];\n        let a = &operand[i];\n        let\
    \ b = &operand[i + 1];\n        match v.as_str() {\n            \"+\" => result\
    \ += a + b,\n            \"-\" => result += a - b,\n            \"*\" => result\
    \ += a * b,\n            \"//\" => result += a / b,\n            \"**\" => result\
    \ += a.pow(*b as u32),\n            _ => result = 0,\n        }\n    }\n    result",
  "  let mut result = operand[0];\n  for i in 0..operator.len() {\n    match operator[i].as_str()\
    \ {\n      \"+\" => result += operand[i + 1],\n      \"-\" => result -= operand[i\
    \ + 1],\n      \"*\" => result *= operand[i + 1],\n      \"//\" => result /= operand[i\
    \ + 1],\n      \"**\" => result = result.pow(operand[i + 1] as u32),\n      _\
    \ => panic!(\"Undefined operator {}\", operator[i]),\n    }\n  }\n  result", " \
    \   let mut operand = operand;\n    let mut res = operand.remove(0);\n    for\
    \ (i, op) in operator.iter().enumerate() {\n        let b = operand.remove(0);\n\
    \        match op.as_str() {\n            \"+\" => res += b,\n            \"-\"\
    \ => res -= b,\n            \"*\" => res *= b,\n            \"//\" => res /= b,\n\
    \            \"**\" => res = res.pow(b as u32),\n            _ => panic!(\"bad\
    \ operator\"),\n        }\n    }\n    res", "    let mut input = operand;\n  \
    \  for x in operator {\n        let num1 = input.pop().unwrap();\n        let\
    \ num2 = input.pop().unwrap();\n        let result = match x.as_str() {\n    \
    \        \"+\" => num1 + num2,\n            \"-\" => num1 - num2,\n          \
    \  \"*\" => num1 * num2,\n            \"//\" => num1 / num2,\n            \"**\"\
    \ => num1.pow(num2 as u32),\n            _ => 0,\n        };\n        input.push(result);\n\
    \    }\n    input.pop().unwrap()", "    // let mut stack: Vec<isize> = vec![];\n\
    \    // for idx in 0..operator.len() {\n    //     stack.push(operand[idx]);\n\
    \    //     let res = match operator[idx].as_str() {\n    //         \"+\" =>\
    \ stack.pop().unwrap() + stack.pop().unwrap(),\n    //         \"-\" => -stack.pop().unwrap()\
    \ + stack.pop().unwrap(),\n    //         \"*\" => stack.pop().unwrap() * stack.pop().unwrap(),\n\
    \    //         \"//\" => (stack.pop().unwrap() / stack.pop().unwrap()).floor(),\n\
    \    //         \"**\" => stack.pop().unwrap().powf(stack.pop().unwrap()),\n \
    \   //         _ => panic!(\"Unknown operator\"),\n    //     };\n    //     stack.push(res);\n\
    \    // }\n    // stack.pop().unwrap()\n    let mut stack: Vec<isize> = vec![];\n\
    \    for idx in 0..operator.len() {\n        stack.push(operand[idx]);\n     \
    \   let res = match operator[idx].as_str() {\n            \"+\" => stack.pop().unwrap()\
    \ + stack.pop().unwrap(),\n            \"-\" => -stack.pop().unwrap() + stack.pop().unwrap(),\n\
    \            \"*\" => stack.pop().unwrap() * stack.pop().unwrap(),\n         \
    \   \"//\" => stack.pop().unwrap() / stack.pop().unwrap(),\n            \"**\"\
    \ => stack.pop().unwrap().powf(stack.pop().unwrap()),\n            _ => panic!(\"\
    Unknown operator\"),\n        };\n        stack.push(res);\n    }\n    stack.pop().unwrap()",
  "    // TODO: Your algebraic expression here\n    unimplemented!();", "    if operator.len()\
    \ == 0 || operand.len() == 0 {\n        return 0;\n    }\n    let mut result =\
    \ operand[0];\n    for i in 0..operator.len() {\n        let op = &operator[i];\n\
    \        let num = operand[i + 1];\n        if op == \"+\" {\n            result\
    \ += num;\n        } else if op == \"-\" {\n            result -= num;\n     \
    \   } else if op == \"*\" {\n            result *= num;\n        } else if op\
    \ == \"//\" {\n            result /= num;\n        } else if op == \"**\" {\n\
    \            result = result.pow(num as u32);\n        }\n    }\n    result",
  "    operator.iter().rev().fold(\n        operand.pop().unwrap(),\n        |acc,\
    \ op| {\n            let b = operand.pop().unwrap();\n            match op.as_str()\
    \ {\n                \"+\" => b + acc,\n                \"-\" => b - acc,\n  \
    \              \"*\" => b * acc,\n                \"/\" => b / acc,\n        \
    \        \"^\" => b.pow(acc as u32),\n                _ => panic!(\"Unknown operation\"\
    ),\n            }\n        },\n    )", "    let mut result = operand[0];\n   \
    \ for (i, x) in operator.iter().enumerate() {\n        let n = operand[i + 1];\n\
    \        if x == \"+\" {\n            result += n;\n        } else if x == \"\
    -\" {\n            result -= n;\n        } else if x == \"*\" {\n            result\
    \ *= n;\n        } else if x == \"//\" {\n            result /= n;\n        }\
    \ else if x == \"**\" {\n            result = result.pow(n as u32);\n        }\n\
    \    }\n    result", "    let mut result = operand[0];\n    for (i, oper) in operator.iter().enumerate()\
    \ {\n        if oper == \"+\" {\n            result += operand[i + 1];\n     \
    \   } else if oper == \"-\" {\n            result -= operand[i + 1];\n       \
    \ } else if oper == \"*\" {\n            result *= operand[i + 1];\n        }\
    \ else if oper == \"//\" {\n            result /= operand[i + 1];\n        } else\
    \ if oper == \"**\" {\n            result = result.pow(operand[i + 1] as u32);\n\
    \        }\n    }\n    result", "    operand.windows(2).zip(operator.iter())\n\
    \        .fold(operand[0], |acc, (&x, &op)| match op.as_str() {\n            \"\
    +\" => acc + x,\n            \"-\" => acc - x,\n            \"*\" => acc * x,\n\
    \            \"//\" => acc / x,\n            \"**\" => acc.pow(x as u32),\n  \
    \          _ => panic!(\"unexpected operator!\"),\n        })", "    let result\
    \ = if let Some(x) = operand.get(0) {\n        *x\n    } else {\n        panic!(\"\
    operand is not allowed to be empty\")\n    };\n    let mut iter = operator.iter().zip(operand.iter().skip(1));\n\
    \    while let Some((op, x)) = iter.next() {\n        match op.as_str() {\n  \
    \          \"+\" => result += x,\n            \"-\" => result -= x,\n        \
    \    \"*\" => result *= x,\n            \"//\" => result /= x,\n            \"\
    **\" => result = result.pow(*x as u32),\n            _ => panic!(\"unknown operator\"\
    ),\n        }\n    }\n    result", "    // if operator is [] or operand is []\
    \ return 0\n    // if operator is [..] and operand is [_] return operand[0]\n\
    \    // if operator is [..] and operand is [_, _] return operand[0] op operand[1]\n\
    \    // else recursive call, op(0) is the first operation, op(1) the second, then\
    \ merge the result\n    // with the second operand, then recurse\n    if operator.is_empty()\
    \ || operand.is_empty() {\n        return 0;\n    }\n    let mut op = operator.clone();\n\
    \    let mut opr = operand.clone();\n    if op.len() == 1 && opr.len() == 2 {\n\
    \        return do_algebra_one_operator(op.remove(0), opr.remove(0), opr.remove(0));\n\
    \    }\n    let opr_0 = opr.remove(0);\n    let opr_1 = opr.remove(0);\n    let\
    \ r = do_algebra_one_operator(op.remove(0), opr_0, opr_1);\n    opr.insert(0,\
    \ r);\n    do_algebra(op, opr)", "    // your code here\n    0", "    let mut\
    \ expr = operand[0].to_string();\n    for i in 0..operand.len() - 1 {\n      \
    \  expr.push_str(&operator[i]);\n        expr.push_str(&operand[i + 1].to_string());\n\
    \    }\n    return eval_expr(&expr);", "    let mut result = operand[0];\n   \
    \ for (i, op) in operator.iter().enumerate() {\n        let operand_result = match\
    \ op.as_str() {\n            \"+\" => result + operand[i + 1],\n            \"\
    -\" => result - operand[i + 1],\n            \"*\" => result * operand[i + 1],\n\
    \            \"//\" => result / operand[i + 1],\n            \"**\" => result.pow(operand[i\
    \ + 1] as u32),\n            _ => panic!(\"Invalid operator\"),\n        };\n\
    \        result = operand_result;\n    }\n    result", "    // iterate over both\
    \ vectors of operators and operands, make them match\n    // and add up operands\
    \ as we go.\n    // if an operator is not defined, we return -1\n    // if there\
    \ are less operands than operators, we return -1\n    let mut result = -1;\n \
    \   if operand.len() < 2 {\n        return result;\n    }\n    if operator.len()\
    \ != operand.len() - 1 {\n        return result;\n    }\n    result = operand[0];\n\
    \    for i in 0..operator.len() {\n        if operator[i] == \"+\" {\n       \
    \     result += operand[i + 1];\n        } else if operator[i] == \"-\" {\n  \
    \          result -= operand[i + 1];\n        } else if operator[i] == \"*\" {\n\
    \            result *= operand[i + 1];\n        } else if operator[i] == \"//\"\
    \ {\n            result /= operand[i + 1];\n        } else if operator[i] == \"\
    **\" {\n            result = result.pow(operand[i + 1] as u32);\n        } else\
    \ {\n            return -1;\n        }\n    }\n    result", "    let mut operand\
    \ = operand;\n    let mut pos = 0;\n    while pos < operator.len() {\n       \
    \ let op = &operator[pos];\n        let pos = pos + 1;\n        let num1 = operand[pos];\n\
    \        let num2 = operand[pos + 1];\n        let ret = if op == \"-\" {\n  \
    \          num1 - num2\n        } else if op == \"+\" {\n            num1 + num2\n\
    \        } else if op == \"*\" {\n            num1 * num2\n        } else if op\
    \ == \"//\" {\n            num1 / num2\n        } else if op == \"**\" {\n   \
    \         num1.pow(num2 as u32)\n        } else {\n            panic!(\"unexpected\
    \ operator\");\n        };\n        operand.remove(pos);\n        operand.remove(pos);\n\
    \        operand.insert(pos, ret);\n    }\n    operand[0]", "    let mut operand\
    \ = operand;\n    let mut last = operand.pop().unwrap();\n    let mut r = last;\n\
    \    while !operand.is_empty() {\n        let a = operand.pop().unwrap();\n  \
    \      let o = operator.pop().unwrap();\n        r = match o.as_str() {\n    \
    \        \"+\" => a + last,\n            \"-\" => a - last,\n            \"*\"\
    \ => a * last,\n            \"//\" => a / last,\n            \"**\" => a.pow(last\
    \ as u32),\n            _ => panic!(\"unknown operator: {}\", o),\n        };\n\
    \        last = r;\n    }\n    r", "    let mut result = operand[0];\n    for\
    \ i in 0..operator.len() {\n        match operator[i].as_str() {\n           \
    \ \"+\" => result += operand[i + 1],\n            \"-\" => result -= operand[i\
    \ + 1],\n            \"*\" => result *= operand[i + 1],\n            \"//\" =>\
    \ result /= operand[i + 1],\n            \"**\" => result = result.pow(operand[i\
    \ + 1] as u32),\n            _ => panic!(\"unknown operator\"),\n        }\n \
    \   }\n    result", "    if operator.len() != operand.len() - 1 {\n        panic!(\"\
    unexpected\");\n    }\n    let mut result = operand[0];\n    for i in 0..operator.len()\
    \ {\n        match operator[i].as_str() {\n            \"+\" => result += operand[i\
    \ + 1],\n            \"-\" => result -= operand[i + 1],\n            \"*\" =>\
    \ result *= operand[i + 1],\n            \"//\" => result /= operand[i + 1],\n\
    \            \"**\" => result = result.pow(operand[i + 1] as u32),\n         \
    \   _ => panic!(\"unknown operator: {}\", operator[i]),\n        }\n    }\n  \
    \  result", "    let mut result = operand[0];\n    for i in 0..operator.len()\
    \ {\n        let op = &operator[i];\n        let p1 = operand[i];\n        let\
    \ p2 = operand[i + 1];\n        result = match op.as_str() {\n            \"+\"\
    \ => p1 + p2,\n            \"-\" => p1 - p2,\n            \"*\" => p1 * p2,\n\
    \            \"//\" => p1 / p2,\n            \"**\" => p1.pow(p2 as u32),\n  \
    \          _ => p1 + p2,\n        };\n    }\n    result", "    let mut iter_op\
    \ = operator.iter();\n    let mut iter_opd = operand.iter();\n    let mut ans\
    \ = *iter_opd.next().unwrap();\n    for opd in iter_opd {\n        match iter_op.next().unwrap().as_str()\
    \ {\n            \"+\" => ans += opd,\n            \"-\" => ans -= opd,\n    \
    \        \"*\" => ans *= opd,\n            \"//\" => ans /= opd,\n           \
    \ \"**\" => ans = ans.pow(*opd as u32),\n            _ => return -1,\n       \
    \ }\n    }\n    ans", "    // Write your code here\n    let mut new_operator =\
    \ operator.clone();\n    let mut new_operand = operand.clone();\n    let mut i\
    \ = 0;\n    while i < new_operator.len() {\n        if new_operator[i] == \"**\"\
    \ {\n            new_operand[i] = new_operand[i].pow(new_operand[i + 1] as u32);\n\
    \            new_operand.remove(i + 1);\n            new_operator.remove(i);\n\
    \        } else {\n            i += 1;\n        }\n    }\n    new_operand[0] =\
    \ match new_operator[0].as_str() {\n        \"+\" => new_operand[0] + new_operand[1],\n\
    \        \"-\" => new_operand[0] - new_operand[1],\n        \"*\" => new_operand[0]\
    \ * new_operand[1],\n        \"//\" => new_operand[0] / new_operand[1],\n    \
    \    _ => new_operand[0],\n    };\n    new_operand.remove(1);\n    new_operator.remove(0);\n\
    \    while new_operator.len() > 0 {\n        new_operand[0] = match new_operator[0].as_str()\
    \ {\n            \"+\" => new_operand[0] + new_operand[1],\n            \"-\"\
    \ => new_operand[0] - new_operand[1],\n            \"*\" => new_operand[0] * new_operand[1],\n\
    \            \"//\" => new_operand[0] / new_operand[1],\n            _ => new_operand[0],\n\
    \        };\n        new_operand.remove(1);\n        new_operator.remove(0);\n\
    \    }\n    new_operand[0]", "    let mut stack: Vec<isize> = Vec::new();\n  \
    \  for (i, op) in operator.iter().enumerate() {\n        if op == \"+\" {\n  \
    \          stack.push(operand[i]);\n        } else if op == \"-\" {\n        \
    \    stack.push(-operand[i]);\n        } else if op == \"*\" {\n            stack.push(stack.pop().unwrap()\
    \ * operand[i]);\n        } else if op == \"//\" {\n            stack.push(stack.pop().unwrap()\
    \ / operand[i]);\n        } else if op == \"**\" {\n            stack.push(stack.pop().unwrap().pow(operand[i]\
    \ as u32));\n        }\n    }\n    stack.iter().sum()", "    let mut result =\
    \ operand[0];\n    for (index, op) in operator.iter().enumerate() {\n        let\
    \ num2 = operand[index + 1];\n        match op.as_str() {\n            \"+\" =>\
    \ result += num2,\n            \"-\" => result -= num2,\n            \"*\" =>\
    \ result *= num2,\n            \"//\" => result /= num2,\n            \"**\" =>\
    \ result = result.pow(num2 as u32),\n            _ => result = 0,\n        }\n\
    \    }\n    result", "    let mut stack: Vec<isize> = Vec::new();\n    let mut\
    \ operator_iter = operator.iter();\n    let mut operand_iter = operand.iter();\n\
    \    let first_operand = operand_iter.next().unwrap();\n    stack.push(*first_operand);\n\
    \    for (op, num) in operator_iter.zip(operand_iter) {\n        match op.as_str()\
    \ {\n            \"+\" => stack.push(*num),\n            \"-\" => stack.push(-*num),\n\
    \            \"*\" => stack.push(stack.pop().unwrap() * *num),\n            \"\
    //\" => stack.push(stack.pop().unwrap() / *num),\n            \"**\" => stack.push(stack.pop().unwrap().pow(*num\
    \ as u32)),\n            _ => (),\n        }\n    }\n    stack.iter().sum()",
  "    let mut result = operand[0];\n    for i in 0..operator.len() {\n        match\
    \ operator[i].as_str() {\n            \"+\" => result += operand[i + 1],\n   \
    \         \"-\" => result -= operand[i + 1],\n            \"*\" => result *= operand[i\
    \ + 1],\n            \"//\" => result /= operand[i + 1],\n            \"**\" =>\
    \ result = result.pow(operand[i + 1] as u32),\n            _ => panic!(\"Invalid\
    \ operator\"),\n        }\n    }\n    result", "    let mut val: isize = operand[0];\n\
    \    for (i, op) in operator.iter().enumerate() {\n        match op.as_str() {\n\
    \            \"+\" => val += operand[i + 1],\n            \"-\" => val -= operand[i\
    \ + 1],\n            \"*\" => val *= operand[i + 1],\n            \"//\" => val\
    \ /= operand[i + 1],\n            \"**\" => val = val.pow(operand[i + 1] as u32),\n\
    \            _ => (),\n        }\n    }\n    val", "    let mut result = operand[0];\n\
    \    for i in 0..operator.len() {\n        if operator[i] == \"+\" {\n       \
    \     result += operand[i + 1];\n        } else if operator[i] == \"-\" {\n  \
    \          result -= operand[i + 1];\n        } else if operator[i] == \"*\" {\n\
    \            result *= operand[i + 1];\n        } else if operator[i] == \"//\"\
    \ {\n            result /= operand[i + 1];\n        } else if operator[i] == \"\
    **\" {\n            result = result.pow(operand[i + 1] as u32);\n        }\n \
    \   }\n    result", "    let mut expr = operand[0].to_string();\n    for i in\
    \ 0..operator.len() {\n        expr += &format!(\" {} {};\", operator[i], operand[i\
    \ + 1]);\n    }\n    eval(&expr)", "    if operator.len() == 0 || operand.len()\
    \ == 0 {\n        return 0;\n    }\n    let mut result = operand[0];\n    for\
    \ i in 0..operator.len() {\n        match operator[i].as_str() {\n           \
    \ \"+\" => result += operand[i + 1],\n            \"-\" => result -= operand[i\
    \ + 1],\n            \"*\" => result *= operand[i + 1],\n            \"//\" =>\
    \ result /= operand[i + 1],\n            \"**\" => result = result.pow(operand[i\
    \ + 1] as u32),\n            _ => unreachable!(),\n        }\n    }\n    result",
  "    let mut op = operator;\n    let mut num = operand;\n    while op.len() > 0\
    \ {\n        let p = op.iter().position(|x| *x == \"**\").unwrap_or(op.len());\n\
    \        if p < op.len() {\n            num[p] = num[p].pow(num[p + 1] as u32);\n\
    \            num.remove(p + 1);\n            op.remove(p);\n        }\n      \
    \  let p = op.iter().position(|x| *x == \"//\").unwrap_or(op.len());\n       \
    \ if p < op.len() {\n            num[p] = num[p] / num[p + 1];\n            num.remove(p\
    \ + 1);\n            op.remove(p);\n        }\n        let p = op.iter().position(|x|\
    \ *x == \"*\").unwrap_or(op.len());\n        if p < op.len() {\n            num[p]\
    \ = num[p] * num[p + 1];\n            num.remove(p + 1);\n            op.remove(p);\n\
    \        }\n        let p = op.iter().position(|x| *x == \"-\").unwrap_or(op.len());\n\
    \        if p < op.len() {\n            num[p] = num[p] - num[p + 1];\n      \
    \      num.remove(p + 1);\n            op.remove(p);\n        }\n        let p\
    \ = op.iter().position(|x| *x == \"+\").unwrap_or(op.len());\n        if p < op.len()\
    \ {\n            num[p] = num[p] + num[p + 1];\n            num.remove(p + 1);\n\
    \            op.remove(p);\n        }\n    }\n    num[0]", "    let mut operators\
    \ = operator.iter().peekable();\n    let mut operands = operand.iter().peekable();\n\
    \    let mut result = operands.next().unwrap().clone();\n    while let Some(op)\
    \ = operators.next() {\n        match op.as_str() {\n            \"+\" => result\
    \ += operands.next().unwrap(),\n            \"-\" => result -= operands.next().unwrap(),\n\
    \            \"*\" => result *= operands.next().unwrap(),\n            \"//\"\
    \ => result /= operands.next().unwrap(),\n            \"**\" => result = result.pow(operands.next().unwrap()\
    \ as u32),\n            _ => (),\n        }\n    }\n    result", "    let mut\
    \ result = operand[0];\n    for (i, op) in operator.iter().enumerate() {\n   \
    \     let op = match op.as_str() {\n            \"+\" => &Add,\n            \"\
    -\" => &Sub,\n            \"*\" => &Mul,\n            \"//\" => &Div,\n      \
    \      \"**\" => &Exp,\n            _ => panic!(\"Unrecognized operator: {}\"\
    , op),\n        };\n        result = op.eval(result, operand[i + 1]);\n    }\n\
    \    result", "    let mut result = operand[0];\n    for (op, num) in operator.iter().zip(operand.iter().skip(1))\
    \ {\n        result = match op.as_str() {\n            \"+\" => result + num,\n\
    \            \"-\" => result - num,\n            \"*\" => result * num,\n    \
    \        \"//\" => result / num,\n            \"**\" => result.pow(*num as u32),\n\
    \            _ => panic!(\"Unsupported operator.\"),\n        }\n    }\n    result",
  "    let mut temp = operand[0];\n    for i in 0..operator.len() {\n        match\
    \ operator[i].as_str() {\n            \"+\" => temp += operand[i + 1],\n     \
    \       \"-\" => temp -= operand[i + 1],\n            \"*\" => temp *= operand[i\
    \ + 1],\n            \"//\" => temp /= operand[i + 1],\n            \"**\" =>\
    \ temp = temp.pow(operand[i + 1] as u32),\n            _ => (),\n        }\n \
    \   }\n    temp", "  let mut operator_iter = operator.iter();\n  let mut operand_iter\
    \ = operand.iter();\n  let mut result = *operand_iter.next().unwrap();\n  for\
    \ operand in operand_iter {\n    match operator_iter.next().unwrap().as_str()\
    \ {\n      \"+\" => result += operand,\n      \"-\" => result -= operand,\n  \
    \    \"*\" => result *= operand,\n      \"//\" => result /= operand,\n      \"\
    **\" => result = result.pow(*operand as u32),\n      _ => panic!(\"Invalid operator:\
    \ {}\", operator_iter.next().unwrap()),\n    }\n  }\n  result", "    // Write\
    \ your code here\n    0", "    operand.iter().zip(operator.iter())\n        .fold((operand[0],\
    \ 0), |(acc, _), (o, op)| {\n            match op.as_str() {\n               \
    \ \"+\" => (acc + o, acc + o),\n                \"-\" => (acc - o, acc - o),\n\
    \                \"*\" => (acc * o, acc * o),\n                \"//\" => (acc\
    \ / o, acc / o),\n                \"**\" => (acc.pow(*o as u32), acc.pow(*o as\
    \ u32)),\n                _ => (acc, 0)\n            }\n        }).0", "    if\
    \ operator.len() == 0 || operand.len() < 2 {\n        panic!(\"invalid input!\"\
    );\n    }\n    let mut op: Vec<fn(isize, isize) -> isize> = vec![];\n    let mut\
    \ opr: Vec<isize> = vec![];\n    for o in operator {\n        match o.as_str()\
    \ {\n            \"+\" => op.push(|a, b| a + b),\n            \"-\" => op.push(|a,\
    \ b| a - b),\n            \"*\" => op.push(|a, b| a * b),\n            \"/\" =>\
    \ op.push(|a, b| a / b),\n            \"^\" => op.push(|a, b| a.pow(b as u32)),\n\
    \            _ => panic!(\"invalid operator!\"),\n        }\n    }\n    for i\
    \ in 0..operand.len() {\n        if i == 0 {\n            opr.push(operand[i]);\n\
    \        } else {\n            let val = op[i - 1](opr[i - 1], operand[i]);\n\
    \            opr.push(val);\n        }\n    }\n    opr[opr.len() - 1]", "  //TODO\
    \ do_algebra\n  if operator.len() == operand.len() - 1 {\n    if operator.len()\
    \ == 0 || operand.len() == 0 {\n      0\n    } else {\n      let mut result =\
    \ operand[0];\n      for i in 0..operator.len() {\n        let op = &operator[i];\n\
    \        let num = operand[i + 1];\n        match op.as_ref() {\n          \"\
    +\" => result += num,\n          \"-\" => result -= num,\n          \"*\" => result\
    \ *= num,\n          \"//\" => result /= num,\n          \"**\" => result = result.pow(num\
    \ as u32),\n          _ => result = 0,\n        }\n      }\n      result\n   \
    \ }\n  } else {\n    0\n  }", "    let mut i = 0;\n    let mut result = operand[i];\n\
    \    for op in operator {\n        i += 1;\n        match op.as_str() {\n    \
    \        \"+\" => result += operand[i],\n            \"-\" => result -= operand[i],\n\
    \            \"*\" => result *= operand[i],\n            \"//\" => result /= operand[i],\n\
    \            \"**\" => result = result.pow(operand[i] as u32),\n            _\
    \ => (),\n        }\n    }\n    result", "    let mut res = operand[0];\n    for\
    \ i in 0..operator.len() {\n        match operator[i].as_str() {\n           \
    \ \"+\" => res += operand[i + 1],\n            \"-\" => res -= operand[i + 1],\n\
    \            \"*\" => res *= operand[i + 1],\n            \"//\" => res /= operand[i\
    \ + 1],\n            \"**\" => res = res.pow(operand[i + 1] as u32),\n       \
    \     _ => panic!(\"Invalid operator\"),\n        }\n    }\n    res", "    let\
    \ mut left = operand[0];\n    let mut operator_iter = operator.iter();\n    let\
    \ mut operand_iter = operand.iter().skip(1);\n    while let Some(right) = operand_iter.next()\
    \ {\n        let op = operator_iter.next().unwrap();\n        match op.as_str()\
    \ {\n            \"+\" => left += right,\n            \"-\" => left -= right,\n\
    \            \"*\" => left *= right,\n            \"//\" => left /= right,\n \
    \           \"**\" => left = left.pow(*right as u32),\n            _ => panic!(\"\
    Unexpected operator\"),\n        }\n    }\n    left", "    let mut result = 0;\n\
    \    let mut op: Option<&str> = None;\n    for (i, n) in operand.iter().enumerate()\
    \ {\n        if i == 0 {\n            result = *n;\n        } else {\n       \
    \     match op {\n                Some(\"+\") => result += n,\n              \
    \  Some(\"-\") => result -= n,\n                Some(\"*\") => result *= n,\n\
    \                Some(\"//\") => result /= n,\n                Some(\"**\") =>\
    \ result = result.pow(*n as u32),\n                None => (),\n             \
    \   _ => continue,\n            }\n            op = operator.get(i - 1).map(|s|\
    \ s.as_str());\n        }\n    }\n    result", '  return 0;', "    let mut stack:\
    \ Vec<isize> = Vec::new();\n    let mut operand_ptr = operand.iter();\n    let\
    \ mut answer = operand_ptr.next().unwrap();\n    while let Some(op) = operand_ptr.next()\
    \ {\n        match operator.pop() {\n            Some(ref op_str) => {\n     \
    \           match op_str.as_str() {\n                    \"+\" => {\n        \
    \                *answer += *op;\n                    }\n                    \"\
    -\" => {\n                        *answer -= *op;\n                    }\n   \
    \                 \"*\" => {\n                        *answer *= *op;\n      \
    \              }\n                    \"/\" => {\n                        *answer\
    \ /= *op;\n                    }\n                    \"**\" => {\n          \
    \              *answer = answer.pow(*op as u32);\n                    }\n    \
    \                _ => panic!(\"Should not be here\"),\n                }\n   \
    \         }\n            None => {\n                panic!(\"Should not be here\"\
    );\n            }\n        }\n    }\n    return *answer;", "    let result = operand.iter().zip(operator.iter()).fold(operand[0],\
    \ |acc, (e, s)| {\n        match s.as_str() {\n            \"+\" => acc + e,\n\
    \            \"-\" => acc - e,\n            \"*\" => acc * e,\n            \"\
    //\" => acc / e,\n            \"**\" => acc.pow(*e as u32),\n            _ =>\
    \ 0,\n        }\n    });\n    result", "    let mut res = operand[0];\n    for\
    \ i in 0..operator.len() {\n        match operator[i].as_str() {\n           \
    \ \"+\" => res += operand[i + 1],\n            \"-\" => res -= operand[i + 1],\n\
    \            \"*\" => res *= operand[i + 1],\n            \"//\" => res /= operand[i\
    \ + 1],\n            \"**\" => res = res.pow(operand[i + 1] as u32),\n       \
    \     _ => unreachable!(),\n        }\n    }\n    res", "    let mut op: Vec<Box<Fn(isize,\
    \ isize) -> isize>> = vec![];\n    for o in operator {\n        match o.as_str()\
    \ {\n            \"+\" => op.push(Box::new(|a, b| a + b)),\n            \"-\"\
    \ => op.push(Box::new(|a, b| a - b)),\n            \"*\" => op.push(Box::new(|a,\
    \ b| a * b)),\n            \"//\" => op.push(Box::new(|a, b| a / b)),\n      \
    \      \"**\" => op.push(Box::new(|a, b| a.pow(b as u32))),\n            _ =>\
    \ return 0,\n        }\n    }\n    op.iter().rev().fold(operand.pop().unwrap(),\
    \ |a, f| f(a, operand.pop().unwrap()))", "    let mut it = operand.iter();\n \
    \   let mut res = *it.next().unwrap();\n    for op in operator {\n        let\
    \ op2 = *it.next().unwrap();\n        res = match op.as_str() {\n            \"\
    +\" => res + op2,\n            \"-\" => res - op2,\n            \"*\" => res *\
    \ op2,\n            \"//\" => res / op2,\n            \"**\" => res.pow(op2 as\
    \ u32),\n            _ => panic!(\"Invalid operator {}\", op),\n        };\n \
    \   }\n    res", "    let mut total = operand[0];\n    for i in 0..operator.len()\
    \ {\n        if operator[i] == \"+\" {\n            total += operand[i + 1];\n\
    \        } else if operator[i] == \"-\" {\n            total -= operand[i + 1];\n\
    \        } else if operator[i] == \"*\" {\n            total *= operand[i + 1];\n\
    \        } else if operator[i] == \"//\" {\n            total /= operand[i + 1];\n\
    \        } else if operator[i] == \"**\" {\n            total = total.pow(operand[i\
    \ + 1] as u32);\n        }\n    }\n    total", "    let mut ans = operand[0];\n\
    \    for i in 0..operator.len() {\n        let op = operator[i].as_str();\n  \
    \      let op_l = operand[i];\n        let op_r = operand[i + 1];\n        if\
    \ op == \"+\" {\n            ans += op_r;\n        } else if op == \"-\" {\n \
    \           ans -= op_r;\n        } else if op == \"*\" {\n            ans *=\
    \ op_r;\n        } else if op == \"//\" {\n            ans /= op_r;\n        }\
    \ else if op == \"**\" {\n            ans = ans.pow(op_r as u32);\n        }\n\
    \    }\n    ans", "    let mut stack: Vec<isize> = Vec::new();\n    for i in 0..operator.len()\
    \ {\n        let operand1 = stack.pop().unwrap();\n        let operand2 = operand[i\
    \ + 1];\n        match operator[i].as_str() {\n            \"+\" => stack.push(operand1\
    \ + operand2),\n            \"-\" => stack.push(operand1 - operand2),\n      \
    \      \"*\" => stack.push(operand1 * operand2),\n            \"//\" => stack.push(operand1\
    \ / operand2),\n            \"**\" => stack.push(operand1.pow(operand2 as u32)),\n\
    \            _ => {}\n        }\n    }\n    stack.pop().unwrap()", "    // Write\
    \ your code here\n    let mut stack: Vec<isize> = Vec::new();\n    let mut i =\
    \ 0;\n    while i < operand.len() {\n        stack.push(operand[i]);\n       \
    \ i += 1;\n    }\n    i = 0;\n    while i < operator.len() {\n        match operator[i].as_str()\
    \ {\n            \"+\" => {\n                let y = stack.pop().unwrap();\n \
    \               let x = stack.pop().unwrap();\n                stack.push(x +\
    \ y);\n            }\n            \"-\" => {\n                let y = stack.pop().unwrap();\n\
    \                let x = stack.pop().unwrap();\n                stack.push(x -\
    \ y);\n            }\n            \"*\" => {\n                let y = stack.pop().unwrap();\n\
    \                let x = stack.pop().unwrap();\n                stack.push(x *\
    \ y);\n            }\n            \"/\" => {\n                let y = stack.pop().unwrap();\n\
    \                let x = stack.pop().unwrap();\n                stack.push(x /\
    \ y);\n            }\n            \"^\" => {\n                let y = stack.pop().unwrap();\n\
    \                let x = stack.pop().unwrap();\n                stack.push(x.pow(y\
    \ as u32));\n            }\n            _ => {\n                println!(\"Operator\
    \ {} not supported!\", operator[i]);\n            }\n        }\n        i += 1;\n\
    \    }\n    stack.pop().unwrap()", "    if operator.len() == 0 || operand.len()\
    \ == 0 {\n        return 0;\n    }\n    let mut result = operand[0];\n    for\
    \ i in 0..operator.len() {\n        match operator[i].as_str() {\n           \
    \ \"+\" => result += operand[i + 1],\n            \"-\" => result -= operand[i\
    \ + 1],\n            \"*\" => result *= operand[i + 1],\n            \"//\" =>\
    \ result /= operand[i + 1],\n            \"**\" => result = result.pow(operand[i\
    \ + 1] as u32),\n            _ => println!(\"Invalid Operator\"),\n        }\n\
    \    }\n    result", "    let mut result = operand[0];\n    for (i, op) in operator.iter().enumerate()\
    \ {\n        let num = operand[i + 1];\n        match op.as_str() {\n        \
    \    \"+\" => result += num,\n            \"-\" => result -= num,\n          \
    \  \"*\" => result *= num,\n            \"//\" => result /= num,\n           \
    \ \"**\" => result = result.pow(num as u32),\n            _ => {}\n        }\n\
    \    }\n    result", "    let mut operand = operand;\n    for i in 0..operator.len()\
    \ {\n        let op = &operator[i];\n        match op.as_str() {\n           \
    \ \"+\" => operand[i+1] = operand[i] + operand[i+1],\n            \"-\" => operand[i+1]\
    \ = operand[i] - operand[i+1],\n            \"*\" => operand[i+1] = operand[i]\
    \ * operand[i+1],\n            \"//\" => operand[i+1] = operand[i] / operand[i+1],\n\
    \            \"**\" => operand[i+1] = operand[i].pow(operand[i+1] as u32),\n \
    \           _ => unreachable!(),\n        }\n    }\n    operand[operand.len()-1]",
  "    let mut result = 0;\n    let mut num = operand[0];\n    for i in 0..operand.len()\
    \ - 1 {\n        match operator[i].as_str() {\n            \"+\" => num += operand[i\
    \ + 1],\n            \"-\" => num -= operand[i + 1],\n            \"*\" => num\
    \ *= operand[i + 1],\n            \"//\" => num /= operand[i + 1],\n         \
    \   \"**\" => num = num.pow(operand[i + 1] as u32),\n            _ => return result,\n\
    \        }\n    }\n    result = num;\n    result", "    let mut result = operand[0];\n\
    \    for i in 0..operator.len() {\n        match operator[i].as_str() {\n    \
    \        \"+\" => result += operand[i + 1],\n            \"-\" => result -= operand[i\
    \ + 1],\n            \"*\" => result *= operand[i + 1],\n            \"//\" =>\
    \ result /= operand[i + 1],\n            \"**\" => result = result.pow(operand[i\
    \ + 1] as u32),\n            _ => result = operand[i + 1],\n        }\n    }\n\
    \    result", "    let mut result = operand[0];\n    for (i, v) in operator.iter().enumerate()\
    \ {\n        match v.as_str() {\n            \"+\" => result += operand[i + 1],\n\
    \            \"-\" => result -= operand[i + 1],\n            \"*\" => result *=\
    \ operand[i + 1],\n            \"//\" => result /= operand[i + 1],\n         \
    \   \"**\" => result = result.pow(operand[i + 1] as u32),\n            _ => unreachable!(),\n\
    \        }\n    }\n    result", "    let op: Vec<fn(isize, isize) -> isize> =\
    \ vec![\n        |a, b| a + b,\n        |a, b| a - b,\n        |a, b| a * b,\n\
    \        |a, b| a / b,\n        |a, b| a.pow(b as u32),\n    ];\n    let mut stack:\
    \ Vec<isize> = Vec::new();\n    for i in 0..operator.len() {\n        let op1\
    \ = operand[i];\n        let op2 = operand[i + 1];\n        let index = match\
    \ operator[i].as_str() {\n            \"+\" => 0,\n            \"-\" => 1,\n \
    \           \"*\" => 2,\n            \"/\" => 3,\n            \"**\" => 4,\n \
    \           _ => panic!(\"unknown operator {}\", operator[i]),\n        };\n \
    \       stack.push(op[index](op1, op2));\n    }\n    let mut result = stack[0];\n\
    \    for i in 1..stack.len() {\n        result = stack[i];\n    }\n    result",
  "    operand.iter().zip(operator.iter()).fold(operand[0], |acc, (op2, op)| {\n \
    \       match op.as_str() {\n            \"+\" => acc + op2,\n            \"-\"\
    \ => acc - op2,\n            \"*\" => acc * op2,\n            \"/\" => acc / op2,\n\
    \            \"^\" => acc.pow(*op2 as u32),\n            _ => panic!(\"Unknown\
    \ operator {}\", op),\n        }\n    })", "    let mut ops = operator.iter().cloned().map(|s|\
    \ {\n        match s.as_str() {\n            \"+\" => Operator::Add,\n       \
    \     \"-\" => Operator::Sub,\n            \"*\" => Operator::Mul,\n         \
    \   \"/\" => Operator::Div,\n            \"**\" => Operator::Pow,\n          \
    \  _ => panic!(\"Unexpected operator\"),\n        }\n    });\n    let mut res\
    \ = operand[0];\n    for op in operand.iter().skip(1) {\n        let operator\
    \ = ops.next().unwrap();\n        res = eval(res, operator, *op);\n    }\n   \
    \ res", "    let mut stack: Vec<isize> = Vec::new();\n    stack.push(operand[0]);\n\
    \    let mut i = 0;\n    while i < operator.len() {\n        match operator[i].as_str()\
    \ {\n            \"+\" => stack.push(operand[i + 1]),\n            \"-\" => stack.push(-operand[i\
    \ + 1]),\n            \"*\" => {\n                let val = stack.pop().unwrap();\n\
    \                stack.push(val * operand[i + 1]);\n            }\n          \
    \  \"//\" => {\n                let val = stack.pop().unwrap();\n            \
    \    stack.push(val / operand[i + 1]);\n            }\n            \"**\" => {\n\
    \                let val = stack.pop().unwrap();\n                stack.push(val.pow(operand[i\
    \ + 1] as u32));\n            }\n            _ => {}\n        }\n        i +=\
    \ 1;\n    }\n    stack.iter().sum()", "    let mut result = operand[0];\n    for\
    \ i in 0..operand.len() - 1 {\n        match operator[i].as_str() {\n        \
    \    \"+\" => result += operand[i + 1],\n            \"-\" => result -= operand[i\
    \ + 1],\n            \"*\" => result *= operand[i + 1],\n            \"//\" =>\
    \ result /= operand[i + 1],\n            \"**\" => result = result.pow(operand[i\
    \ + 1] as u32),\n            _ => (),\n        }\n    }\n    result", "    let\
    \ mut answer = operand[0];\n    for i in 0..operator.len() {\n        match operator[i].as_str()\
    \ {\n            \"+\" => answer += operand[i + 1],\n            \"-\" => answer\
    \ -= operand[i + 1],\n            \"*\" => answer *= operand[i + 1],\n       \
    \     \"//\" => answer /= operand[i + 1],\n            \"**\" => answer = answer.pow(operand[i\
    \ + 1] as u32),\n            _ => panic!(\"Operator unknown\"),\n        }\n \
    \   }\n    answer", "    let mut result = operand[0];\n    for (i, op) in operator.iter().enumerate()\
    \ {\n        match op.as_str() {\n            \"+\" => result += operand[i + 1],\n\
    \            \"-\" => result -= operand[i + 1],\n            \"*\" => result *=\
    \ operand[i + 1],\n            \"//\" => result /= operand[i + 1],\n         \
    \   \"**\" => result = result.pow(operand[i + 1] as u32),\n            _ => panic!(\"\
    unknown operator: {}\", op),\n        }\n    }\n    result", "    operator.iter().fold(operand[0],\
    \ |acc, x| {\n        match x.as_str() {\n            \"+\" => acc + operand[x.len()],\n\
    \            \"-\" => acc - operand[x.len()],\n            \"*\" => acc * operand[x.len()],\n\
    \            \"//\" => acc / operand[x.len()],\n            \"**\" => acc.pow(operand[x.len()]\
    \ as u32),\n            _ => 0,\n        }\n    })", "    let mut result = operand[0];\n\
    \    for index in 1..operand.len() {\n        match operator[index - 1].as_str()\
    \ {\n            \"+\" => result += operand[index],\n            \"-\" => result\
    \ -= operand[index],\n            \"*\" => result *= operand[index],\n       \
    \     \"//\" => result /= operand[index],\n            \"**\" => result = result.pow(operand[index]\
    \ as u32),\n            _ => panic!(\"unsupported operator\"),\n        }\n  \
    \  }\n    result", "    let mut exp = operand[0].to_string();\n    for i in 0..operator.len()\
    \ {\n        exp.push_str(&format!(\" {} {}\", operator[i], operand[i + 1]));\n\
    \    }\n    do_eval(exp)", "    assert!(operator.len() == operand.len() - 1);\n\
    \    assert!(operator.len() >= 1);\n    assert!(operand.len() >= 2);\n    match\
    \ operator.len() {\n        1 => operand[0] + operand[1],\n        2 => operand[0]\
    \ + operand[1] + operand[2],\n        3 => operand[0] + operand[1] + operand[2]\
    \ + operand[3],\n        4 => operand[0] + operand[1] + operand[2] + operand[3]\
    \ + operand[4],\n        5 => operand[0] + operand[1] + operand[2] + operand[3]\
    \ + operand[4] + operand[5],\n        6 => operand[0] + operand[1] + operand[2]\
    \ + operand[3] + operand[4] + operand[5] + operand[6],\n        7 => operand[0]\
    \ + operand[1] + operand[2] + operand[3] + operand[4] + operand[5] + operand[6]\
    \ + operand[7],\n        8 => operand[0] + operand[1] + operand[2] + operand[3]\
    \ + operand[4] + operand[5] + operand[6] + operand[7] + operand[8],\n        9\
    \ => operand[0] + operand[1] + operand[2] + operand[3] + operand[4] + operand[5]\
    \ + operand[6] + operand[7] + operand[8] + operand[9],\n        10 => operand[0]\
    \ + operand[1] + operand[2] + operand[3] + operand[4] + operand[5] + operand[6]\
    \ + operand[7] + operand[8] + operand[9] + operand[10],\n        11 => operand[0]\
    \ + operand[1] + operand[2] + operand[3] + operand[4] + operand[5] + oper", " \
    \   let mut result = operand[0];\n    for (i, op) in operator.iter().enumerate()\
    \ {\n        let left = operand[i];\n        let right = operand[i + 1];\n   \
    \     match op.as_str() {\n            \"+\" => result = left + right,\n     \
    \       \"-\" => result = left - right,\n            \"*\" => result = left *\
    \ right,\n            \"//\" => result = left / right,\n            \"**\" =>\
    \ result = left.pow(right as u32),\n            _ => unreachable!(),\n       \
    \ }\n    }\n    result", "    let mut result = operand[0];\n    for (x, y) in\
    \ operator.iter().zip(operand.iter().skip(1)) {\n        match x.as_str() {\n\
    \            \"+\" => result += y,\n            \"-\" => result -= y,\n      \
    \      \"*\" => result *= y,\n            \"/\" => result /= y,\n            \"\
    ^\" => result = result.pow(*y as u32),\n            _ => (),\n        }\n    }\n\
    \    result", "    let mut result = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    while i < operand.len() {\n        if i == 0 {\n            result = operand[i];\n\
    \        } else {\n            match operator[j].as_str() {\n                \"\
    +\" => result += operand[i],\n                \"-\" => result -= operand[i],\n\
    \                \"*\" => result *= operand[i],\n                \"//\" => result\
    \ /= operand[i],\n                \"**\" => result = result.pow(operand[i] as\
    \ u32),\n                _ => {}\n            }\n            j += 1;\n       \
    \ }\n        i += 1;\n    }\n    result", "    let mut operand = operand;\n  \
    \  for (operator, operand) in operator.iter().zip(operand.iter_mut()) {\n    \
    \    match operator.as_str() {\n            \"+\" => *operand += *operand + *operand,\n\
    \            \"-\" => *operand -= *operand + *operand,\n            \"*\" => *operand\
    \ *= *operand + *operand,\n            \"//\" => *operand /= *operand + *operand,\n\
    \            \"**\" => *operand = *operand.pow(*operand as u32),\n           \
    \ _ => return -1,\n        }\n    }\n    operand[0]", "    let mut result = 0;\n\
    \    let mut temp_operand = operand.clone();\n    for operator in operator {\n\
    \        match operator.as_str() {\n            \"+\" => result += temp_operand.remove(0),\n\
    \            \"-\" => result -= temp_operand.remove(0),\n            \"*\" =>\
    \ result *= temp_operand.remove(0),\n            \"//\" => result /= temp_operand.remove(0),\n\
    \            \"**\" => result = result.pow(temp_operand.remove(0) as u32),\n \
    \           _ => panic!(\"Unknown operator {}\", operator),\n        }\n    }\n\
    \    result += temp_operand.remove(0);\n    result", "    // write code here\n\
    \    let mut stack: Vec<isize> = Vec::new();\n    for (i, s) in operator.iter().enumerate()\
    \ {\n        match s.as_str() {\n            \"+\" => {\n                let j\
    \ = operand[i];\n                let k = operand[i + 1];\n                stack.push(j\
    \ + k);\n            }\n            \"-\" => {\n                let j = operand[i];\n\
    \                let k = operand[i + 1];\n                stack.push(j - k);\n\
    \            }\n            \"*\" => {\n                let j = operand[i];\n\
    \                let k = operand[i + 1];\n                stack.push(j * k);\n\
    \            }\n            \"//\" => {\n                let j = operand[i];\n\
    \                let k = operand[i + 1];\n                stack.push(j / k);\n\
    \            }\n            \"**\" => {\n                let j = operand[i];\n\
    \                let k = operand[i + 1];\n                stack.push(j.pow(k as\
    \ u32));\n            }\n            _ => (),\n        }\n    }\n    stack.pop().unwrap()",
  "    let mut result = operand[0];\n    for i in 0..operator.len() {\n        let\
    \ operation = &operator[i];\n        let tmp = &operand[i + 1];\n        match\
    \ operation.as_str() {\n            \"+\" => result += tmp,\n            \"-\"\
    \ => result -= tmp,\n            \"*\" => result *= tmp,\n            \"//\" =>\
    \ result /= tmp,\n            \"**\" => result = result.pow(*tmp as u32),\n  \
    \          _ => panic!(\"invalid operation\"),\n        }\n    }\n    result",
  "    let mut result = operand[0];\n    for i in 0..operator.len() {\n        if\
    \ operator[i] == \"+\" {\n            result += operand[i + 1];\n        } else\
    \ if operator[i] == \"-\" {\n            result -= operand[i + 1];\n        }\
    \ else if operator[i] == \"*\" {\n            result *= operand[i + 1];\n    \
    \    } else if operator[i] == \"//\" {\n            result /= operand[i + 1];\n\
    \        } else if operator[i] == \"**\" {\n            result = result.pow(operand[i\
    \ + 1] as u32);\n        }\n    }\n    result", "    if operand.len() < 2 {\n\
    \        panic!(\"Operand list must have at least two operands.\");\n    }\n \
    \   if operator.len() != operand.len() - 1 {\n        panic!(\"Length of operator\
    \ list must be equal to the length of operand list minus one.\");\n    }\n   \
    \ let mut expression = String::new();\n    for (op, opd) in operator.iter().zip(operand.iter())\
    \ {\n        expression.push_str(&format!(\"{} {} \", op, opd));\n    }\n    let\
    \ mut tokens = expression.split_whitespace();\n    let mut next_token = || tokens.next().unwrap();\n\
    \    let mut num_stack = vec![];\n    while let Some(token) = next_token() {\n\
    \        if let Ok(opnd) = token.parse::<isize>() {\n            num_stack.push(opnd);\n\
    \        } else {\n            let b = num_stack.pop().unwrap();\n           \
    \ let a = num_stack.pop().unwrap();\n            match token {\n             \
    \   \"+\" => num_stack.push(a + b),\n                \"-\" => num_stack.push(a\
    \ - b),\n                \"*\" => num_stack.push(a * b),\n                \"//\"\
    \ => num_stack.push(a / b),\n                \"**\" => num_stack.push(a.pow(b\
    \ as u32)),\n                _ => unreachable!()\n            }\n        }\n \
    \   }\n    num_stack.pop().unwrap()", "    let mut output: isize = operand[0];\n\
    \    for (i, op) in operator.iter().enumerate() {\n        let tmp = operand[i\
    \ + 1];\n        match op.as_str() {\n            \"+\" => output += tmp,\n  \
    \          \"-\" => output -= tmp,\n            \"*\" => output *= tmp,\n    \
    \        \"//\" => output /= tmp,\n            \"**\" => output = output.pow(tmp\
    \ as u32),\n            _ => {}\n        }\n    }\n    output", "    let mut result\
    \ = operand[0];\n    for i in 0..operator.len() {\n        match operator[i].as_str()\
    \ {\n            \"+\" => result += operand[i + 1],\n            \"-\" => result\
    \ -= operand[i + 1],\n            \"*\" => result *= operand[i + 1],\n       \
    \     \"//\" => result /= operand[i + 1],\n            \"**\" => result = result.pow(operand[i\
    \ + 1] as u32),\n            _ => {}\n        }\n    }\n    result", "    let\
    \ mut res = operand[0];\n    for i in 0..operator.len() {\n        let op: String\
    \ = operator[i].chars().collect();\n        match op.as_str() {\n            \"\
    +\" => res += operand[i + 1],\n            \"-\" => res -= operand[i + 1],\n \
    \           \"*\" => res *= operand[i + 1],\n            \"//\" => res /= operand[i\
    \ + 1],\n            \"**\" => res = res.pow(operand[i + 1] as u32),\n       \
    \     _ => {}\n        }\n    }\n    res", "    let mut stack: Vec<isize> = vec![];\n\
    \    for i in 0..operator.len() {\n        let oper = match operator[i].as_str()\
    \ {\n            \"+\" => &Operator::Add,\n            \"-\" => &Operator::Sub,\n\
    \            \"*\" => &Operator::Mul,\n            \"/\" => &Operator::Div,\n\
    \            \"^\" => &Operator::Pow,\n            _ => panic!(\"Invalid operator\"\
    ),\n        };\n        match oper {\n            Operator::Add => {\n       \
    \         let opr = operand[i + 1];\n                let opr1 = operand[i];\n\
    \                stack.push(opr + opr1);\n            }\n            Operator::Sub\
    \ => {\n                let opr = operand[i + 1];\n                let opr1 =\
    \ operand[i];\n                stack.push(opr - opr1);\n            }\n      \
    \      Operator::Mul => {\n                let opr = operand[i + 1];\n       \
    \         let opr1 = operand[i];\n                stack.push(opr * opr1);\n  \
    \          }\n            Operator::Div => {\n                let opr = operand[i\
    \ + 1];\n                let opr1 = operand[i];\n                stack.push(opr\
    \ / opr1);\n            }\n            Operator::Pow => {\n                let\
    \ opr = operand[i + 1];\n                let opr1 = operand[i];\n            \
    \    stack.push(opr.pow(opr1 as u32));\n            }\n        }\n    }\n    stack.pop().unwrap()",
  "    let mut result = operand[0];\n    for i in 0..operator.len() {\n        let\
    \ op = &operator[i];\n        if op == \"+\" {\n            result += operand[i\
    \ + 1];\n        } else if op == \"-\" {\n            result -= operand[i + 1];\n\
    \        } else if op == \"*\" {\n            result *= operand[i + 1];\n    \
    \    } else if op == \"//\" {\n            result /= operand[i + 1];\n       \
    \ } else if op == \"**\" {\n            result = result.pow(operand[i + 1] as\
    \ u32);\n        }\n    }\n    result", "    let mut result = operand[0];\n  \
    \  for i in 0..operator.len() {\n        let n = operand[i + 1];\n        match\
    \ operator[i].as_str() {\n            \"+\" => result += n,\n            \"-\"\
    \ => result -= n,\n            \"*\" => result *= n,\n            \"//\" => result\
    \ /= n,\n            \"**\" => result = result.pow(n as u32),\n            _ =>\
    \ {}\n        }\n    }\n    result", "    let mut result = operand[0];\n    for\
    \ (i, oper) in operator.iter().enumerate() {\n        match oper.as_str() {\n\
    \            \"+\" => result += operand[i + 1],\n            \"-\" => result -=\
    \ operand[i + 1],\n            \"*\" => result *= operand[i + 1],\n          \
    \  \"//\" => result /= operand[i + 1],\n            \"**\" => result = result.pow(operand[i\
    \ + 1] as u32),\n            _ => panic!(\"Illegal operator\"),\n        }\n \
    \   }\n    result", "    let mut stack: Vec<isize> = Vec::new();\n    stack.push(operand[0]);\n\
    \    for i in 1..operand.len() {\n        match operator[i - 1].as_str() {\n \
    \           \"+\" => stack.push(stack.pop().unwrap() + operand[i]),\n        \
    \    \"-\" => stack.push(stack.pop().unwrap() - operand[i]),\n            \"*\"\
    \ => stack.push(stack.pop().unwrap() * operand[i]),\n            \"//\" => stack.push(stack.pop().unwrap()\
    \ / operand[i]),\n            \"**\" => stack.push(stack.pop().unwrap().pow(operand[i]\
    \ as u32)),\n            _ => {\n                return 0;\n            }\n  \
    \      }\n    }\n    return stack.pop().unwrap();", "    let mut result = operand[0];\n\
    \    for (i, op) in operator.iter().enumerate() {\n        let a = operand[i];\n\
    \        let b = operand[i + 1];\n        match op.as_str() {\n            \"\
    +\" => result += b,\n            \"-\" => result -= b,\n            \"*\" => result\
    \ *= b,\n            \"//\" => result /= b,\n            \"**\" => result = result.pow(b\
    \ as u32),\n            _ => (),\n        }\n    }\n    result", "    let mut\
    \ stack: Vec<isize> = Vec::new();\n    for (i, op) in operator.iter().enumerate()\
    \ {\n        let left = operand[i];\n        let right = operand[i + 1];\n   \
    \     match op.as_str() {\n            \"+\" => stack.push(left + right),\n  \
    \          \"-\" => stack.push(left - right),\n            \"*\" => stack.push(left\
    \ * right),\n            \"//\" => stack.push(left / right),\n            \"**\"\
    \ => stack.push(left.pow(right as u32)),\n            _ => panic!(\"Undefined\
    \ operator.\"),\n        }\n    }\n    let mut result = 0;\n    while !stack.is_empty()\
    \ {\n        result += stack.pop().unwrap();\n    }\n    result", '    unimplemented!()',
  "    let mut stack: Vec<isize> = Vec::new();\n    let mut operator_iter = operator.iter();\n\
    \    let mut operand_iter = operand.iter();\n    let op = operand_iter.next().unwrap();\n\
    \    stack.push(*op);\n    while let Some(opt) = operator_iter.next() {\n    \
    \    let op = operand_iter.next().unwrap();\n        if opt == \"+\" {\n     \
    \       stack.push(*op);\n        } else if opt == \"-\" {\n            stack.push(-*op);\n\
    \        } else if opt == \"*\" {\n            let v = stack.pop().unwrap();\n\
    \            stack.push(v * *op);\n        } else if opt == \"//\" {\n       \
    \     let v = stack.pop().unwrap();\n            stack.push(v / *op);\n      \
    \  } else if opt == \"**\" {\n            let v = stack.pop().unwrap();\n    \
    \        stack.push(v.pow(*op as u32));\n        }\n    }\n    return stack.iter().sum();",
  "    let exp = get_exp(operator, operand);\n    exp.iter().fold(0, |total, o| total\
    \ + o)", "    let operator: Vec<fn(isize, isize) -> isize> = operator.iter().map(|o|\
    \ match o.as_str() {\n        \"+\" => std::ops::Add::add,\n        \"-\" => std::ops::Sub::sub,\n\
    \        \"*\" => std::ops::Mul::mul,\n        \"//\" => std::ops::Div::div,\n\
    \        \"**\" => std::ops::Pow::pow,\n        _ => unreachable!()\n    }).collect();\n\
    \    (0..operator.len()).fold(operand[0], |acc, i| operator[i](acc, operand[i\
    \ + 1]))", "    let mut result = operand[0];\n    for (i, e) in operator.iter().enumerate()\
    \ {\n        let op2 = operand[i + 1];\n        match e.as_str() {\n         \
    \   \"+\" => result += op2,\n            \"-\" => result -= op2,\n           \
    \ \"*\" => result *= op2,\n            \"//\" => result /= op2,\n            \"\
    **\" => result = result.pow(op2 as u32),\n            _ => result = 0,\n     \
    \   }\n    }\n    result", "    let mut op = operand.clone();\n    for i in 0..operator.len()\
    \ {\n        let tmp = op[i] + if operator[i] == \"+\" { op[i + 1] }\n       \
    \ else if operator[i] == \"-\" { -op[i + 1] }\n        else if operator[i] ==\
    \ \"*\" { op[i] * op[i + 1] }\n        else if operator[i] == \"//\" { op[i] /\
    \ op[i + 1] }\n        else { op[i].pow(op[i + 1] as u32) };\n        op[i + 1]\
    \ = tmp;\n    }\n    op[op.len() - 1]", "    let mut res = operand[0];\n    for\
    \ (i, op) in operator.iter().enumerate() {\n        let rhs = operand[i + 1];\n\
    \        match op.as_str() {\n            \"+\" => res += rhs,\n            \"\
    -\" => res -= rhs,\n            \"*\" => res *= rhs,\n            \"//\" => res\
    \ /= rhs,\n            \"**\" => res = res.pow(rhs as u32),\n            _ =>\
    \ panic!(\"unknown operator: {}\", op),\n        }\n    }\n    res", "    let\
    \ mut result = operand[0];\n    for i in 0..operator.len() {\n        match operator[i].as_str()\
    \ {\n            \"+\" => result += operand[i + 1],\n            \"-\" => result\
    \ -= operand[i + 1],\n            \"*\" => result *= operand[i + 1],\n       \
    \     \"//\" => result /= operand[i + 1],\n            \"**\" => result = result.pow(operand[i\
    \ + 1] as u32),\n            _ => panic!(\"Unknown operator\"),\n        }\n \
    \   }\n    result", "    let mut result = operand[0];\n    for i in 0..operator.len()\
    \ {\n        match operator[i].as_str() {\n            \"+\" => result += operand[i\
    \ + 1],\n            \"-\" => result -= operand[i + 1],\n            \"*\" =>\
    \ result *= operand[i + 1],\n            \"//\" => result /= operand[i + 1],\n\
    \            \"**\" => result = result.pow(operand[i + 1] as u32),\n         \
    \   _ => panic!(\"Unexpected operator: {}\", operator[i]),\n        }\n    }\n\
    \    result", "    let op_list = operator\n        .iter()\n        .map(|op|\
    \ match op.as_str() {\n            \"+\" => Op::Add,\n            \"-\" => Op::Sub,\n\
    \            \"*\" => Op::Mul,\n            \"/\" => Op::Div,\n            \"\
    **\" => Op::Pow,\n            _ => panic!(\"not a valid operator\"),\n       \
    \ })\n        .collect::<Vec<Op>>();\n    let mut n = operand[0];\n    for (i,\
    \ op) in op_list.iter().enumerate() {\n        let k = operand[i + 1];\n     \
    \   n = match op {\n            Op::Add => n + k,\n            Op::Sub => n -\
    \ k,\n            Op::Mul => n * k,\n            Op::Div => n / k,\n         \
    \   Op::Pow => n.pow(*k as u32),\n        };\n    }\n    n", "    let mut result\
    \ = operand[0];\n    for i in 0..operator.len() {\n        let temp = match operator[i].as_ref()\
    \ {\n            \"+\" => result + operand[i + 1],\n            \"-\" => result\
    \ - operand[i + 1],\n            \"*\" => result * operand[i + 1],\n         \
    \   \"//\" => result / operand[i + 1],\n            \"**\" => result.pow(operand[i\
    \ + 1] as u32),\n            _ => result,\n        };\n        result = temp;\n\
    \    }\n    result", "    let mut result = operand[0];\n    for i in 0..operator.len()\
    \ {\n        match operator[i].as_str() {\n            \"+\" => result += operand[i\
    \ + 1],\n            \"-\" => result -= operand[i + 1],\n            \"*\" =>\
    \ result *= operand[i + 1],\n            \"//\" => result /= operand[i + 1],\n\
    \            \"**\" => result = result.pow(operand[i + 1] as u32),\n         \
    \   _ => {}\n        }\n    }\n    result", "    // TODO\n    0", '    unimplemented!();',
  "    let mut operand = operand;\n    let mut algebra = String::new();\n    while\
    \ let Some(op) = operator.pop() {\n        match op.as_str() {\n            \"\
    +\" => {\n                algebra.push_str(&format!(\"+{}\", operand.pop().unwrap()));\n\
    \            }\n            \"-\" => {\n                algebra.push_str(&format!(\"\
    -{}\", operand.pop().unwrap()));\n            }\n            \"*\" => {\n    \
    \            algebra.push_str(&format!(\"*{}\", operand.pop().unwrap()));\n  \
    \          }\n            \"//\" => {\n                algebra.push_str(&format!(\"\
    //{}\", operand.pop().unwrap()));\n            }\n            \"**\" => {\n  \
    \              algebra.push_str(&format!(\"**{}\", operand.pop().unwrap()));\n\
    \            }\n            _ => panic!(\"Unknown operator\"),\n        }\n  \
    \  }\n    let mut result = format!(\"{}{}\", operand.pop().unwrap(), algebra);\n\
    \    result.replace(\"**\", \"**(\").replace(\"//\", \"//(\").replace(\"*\", \"\
    )*(\").replace(\"+\", \")+(\").replace(\"-\", \")-(\");\n    let result = format!(\"\
    {})\", result);\n    result.parse::<isize>().unwrap()", "    let mut result =\
    \ operand[0];\n    for i in 0..operator.len() {\n        match operator[i].as_str()\
    \ {\n            \"+\" => result += operand[i + 1],\n            \"-\" => result\
    \ -= operand[i + 1],\n            \"*\" => result *= operand[i + 1],\n       \
    \     \"//\" => result /= operand[i + 1],\n            \"**\" => result = result.pow(operand[i\
    \ + 1] as u32),\n            _ => result = 0,\n        }\n    }\n    result",
  "    let operators = {\n        operator\n            .iter()\n            .map(|operand|\
    \ match operand.as_str() {\n                \"+\" => Operator::Add,\n        \
    \        \"-\" => Operator::Sub,\n                \"*\" => Operator::Mul,\n  \
    \              \"/\" => Operator::Div,\n                \"**\" => Operator::Exp,\n\
    \                _ => panic!(\"Operator not found\"),\n            })\n      \
    \      .collect::<Vec<Operator>>()\n    };\n\n    let mut stack = vec![];\n  \
    \  let mut i = 0;\n    let mut j = 0;\n    let operand_len = operand.len();\n\
    \    let operator_len = operators.len();\n\n    while j < operand_len {\n    \
    \    let operand = operand[j];\n        if i < operator_len {\n            let\
    \ operator = operators[i];\n            match operator {\n                Operator::Add\
    \ => {\n                    stack.push(operand);\n                }\n        \
    \        Operator::Sub => {\n                    stack.push(-operand);\n     \
    \           }\n                Operator::Mul => {\n                    stack.push(stack.pop().unwrap()\
    \ * operand);\n                }\n                Operator::Div => {\n       \
    \             stack.push(stack.pop().unwrap() / operand);\n                }\n\
    \                Operator::Exp => {\n                    stack.push(stack.pop().unwrap().pow(operand\
    \ as u32));\n                }\n            }\n            i += 1;\n        }\
    \ else {\n            stack.push(operand);\n        }\n        j += 1;\n    }\n\
    \n    let mut result = 0;\n    for v in stack {\n        result += v;\n    }\n\
    \    result", "    let ops: Vec<fn(isize, isize) -> isize> = vec![add, sub, mul,\
    \ floor_div, exp];\n    let mut itr = operand.iter();\n    let mut result = *itr.next().unwrap();\n\
    \    for o in operator.iter() {\n        let n = *itr.next().unwrap();\n     \
    \   let f = match o.as_str() {\n            \"+\" => ops[0],\n            \"-\"\
    \ => ops[1],\n            \"*\" => ops[2],\n            \"//\" => ops[3],\n  \
    \          \"**\" => ops[4],\n            _ => panic!(\"Unexpected operator\"\
    ),\n        };\n        result = f(result, n);\n    }\n    result", "    let mut\
    \ array: Vec<isize> = operand;\n    let mut oper: Vec<String> = operator;\n  \
    \  let mut i = 0;\n    while i < oper.len() {\n        if oper[i] == \"**\" {\n\
    \            array[i] = array[i].pow(array[i + 1] as u32);\n            array.remove(i\
    \ + 1);\n            oper.remove(i);\n        } else {\n            i += 1;\n\
    \        }\n    }\n    i = 0;\n    while i < oper.len() {\n        if oper[i]\
    \ == \"//\" {\n            array[i] = array[i] / array[i + 1];\n            array.remove(i\
    \ + 1);\n            oper.remove(i);\n        } else {\n            i += 1;\n\
    \        }\n    }\n    i = 0;\n    while i < oper.len() {\n        if oper[i]\
    \ == \"*\" {\n            array[i] = array[i] * array[i + 1];\n            array.remove(i\
    \ + 1);\n            oper.remove(i);\n        } else {\n            i += 1;\n\
    \        }\n    }\n    i = 0;\n    while i < oper.len() {\n        if oper[i]\
    \ == \"+\" {\n            array[i] = array[i] + array[i + 1];\n            array.remove(i\
    \ + 1);\n            oper.remove(i);\n        } else if oper[i] == \"-\" {\n \
    \           array[i] = array[i] - array[i + 1];\n            array.remove(i +\
    \ 1);\n            oper.remove(i);\n        } else {\n            i += 1;\n  \
    \      }\n    }\n    array[0]", "    let mut result = operand[0];\n    for i in\
    \ 0..operator.len() {\n        if operator[i] == \"+\" {\n            result +=\
    \ operand[i + 1];\n        } else if operator[i] == \"-\" {\n            result\
    \ -= operand[i + 1];\n        } else if operator[i] == \"*\" {\n            result\
    \ *= operand[i + 1];\n        } else if operator[i] == \"//\" {\n            result\
    \ /= operand[i + 1];\n        } else if operator[i] == \"**\" {\n            result\
    \ = result.pow(operand[i + 1] as u32);\n        }\n    }\n    result", "    //\
    \ TODO: Implement this function\n    0", "    let mut result = operand[0];\n \
    \   for (i, c) in operator.iter().enumerate() {\n        match c.as_str() {\n\
    \            \"+\" => result += operand[i + 1],\n            \"-\" => result -=\
    \ operand[i + 1],\n            \"*\" => result *= operand[i + 1],\n          \
    \  \"//\" => result /= operand[i + 1],\n            \"**\" => result = result.pow(operand[i\
    \ + 1] as u32),\n            _ => panic!(\"Unknown operator {}\", c),\n      \
    \  }\n    }\n    result", "    let mut result = operand[0];\n    for i in 0..operator.len()\
    \ {\n        let op = operator[i].as_str();\n        let op1 = operand[i];\n \
    \       let op2 = operand[i + 1];\n        match op {\n            \"+\" => result\
    \ = result + op2,\n            \"-\" => result = result - op2,\n            \"\
    *\" => result = result * op2,\n            \"//\" => result = result / op2,\n\
    \            \"**\" => result = result.pow(op2 as u32),\n            _ => panic!(\"\
    Unknown operator: {}\", op),\n        }\n    }\n    result", "    let mut answer\
    \ = operand[0];\n    for i in 0..operator.len() {\n        if operator[i] == \"\
    +\" {\n            answer += operand[i + 1];\n        } else if operator[i] ==\
    \ \"-\" {\n            answer -= operand[i + 1];\n        } else if operator[i]\
    \ == \"*\" {\n            answer *= operand[i + 1];\n        } else if operator[i]\
    \ == \"//\" {\n            answer /= operand[i + 1];\n        } else if operator[i]\
    \ == \"**\" {\n            answer = answer.pow(operand[i + 1] as u32);\n     \
    \   }\n    }\n    answer", "    let mut result = operand[0];\n    for i in 0..operator.len()\
    \ {\n        match operator[i].as_str() {\n            \"+\" => result += operand[i\
    \ + 1],\n            \"-\" => result -= operand[i + 1],\n            \"*\" =>\
    \ result *= operand[i + 1],\n            \"//\" => result /= operand[i + 1],\n\
    \            \"**\" => result = result.pow(operand[i + 1] as u32),\n         \
    \   _ => unreachable!(),\n        }\n    }\n    result", "    let mut output =\
    \ operand[0];\n    for (i, item) in operator.iter().enumerate() {\n        let\
    \ b = operand[i + 1];\n        match item.as_str() {\n            \"+\" => output\
    \ += b,\n            \"-\" => output -= b,\n            \"*\" => output *= b,\n\
    \            \"//\" => output /= b,\n            \"**\" => output = output.pow(b\
    \ as u32),\n            _ => panic!(\"unknown operator: {}\", item),\n       \
    \ }\n    }\n    output", "    // Write your code here\n    let mut result = operand[0];\n\
    \    for i in 0..operator.len() {\n        match operator[i].as_str() {\n    \
    \        \"+\" => result += operand[i + 1],\n            \"-\" => result -= operand[i\
    \ + 1],\n            \"*\" => result *= operand[i + 1],\n            \"//\" =>\
    \ result /= operand[i + 1],\n            \"**\" => result = result.pow(operand[i\
    \ + 1] as u32),\n            _ => panic!(\"unknown operator\"),\n        }\n \
    \   }\n    result", "    let mut res = operand[0];\n    for i in 0..operator.len()\
    \ {\n        match operator[i].as_str() {\n            \"+\" => res += operand[i\
    \ + 1],\n            \"-\" => res -= operand[i + 1],\n            \"*\" => res\
    \ *= operand[i + 1],\n            \"//\" => res /= operand[i + 1],\n         \
    \   \"**\" => res = res.pow(operand[i + 1] as u32),\n            _ => println!(\"\
    Oops!\"),\n        }\n    }\n    res", "    let mut result = operand[0];\n   \
    \ for (i, op) in operator.iter().enumerate() {\n        match op.as_str() {\n\
    \            \"+\" => result += operand[i + 1],\n            \"-\" => result -=\
    \ operand[i + 1],\n            \"*\" => result *= operand[i + 1],\n          \
    \  \"//\" => result /= operand[i + 1],\n            \"**\" => result = result.pow(operand[i\
    \ + 1] as u32),\n            _ => {\n                println!(\"Invalid operator:\
    \ {}\", op);\n                break;\n            }\n        }\n    }\n    result",
  "    let mut result = operand[0];\n    for i in 0..operator.len() {\n        match\
    \ operator[i].as_str() {\n            \"+\" => result += operand[i + 1],\n   \
    \         \"-\" => result -= operand[i + 1],\n            \"*\" => result *= operand[i\
    \ + 1],\n            \"//\" => result /= operand[i + 1],\n            \"**\" =>\
    \ result = result.pow(operand[i + 1] as u32),\n            _ => panic!(\"invalid\
    \ operator\"),\n        }\n    }\n    result", "    let mut tmp = operand[0];\n\
    \    for (i, op) in operator.iter().enumerate() {\n        let n2 = operand[i\
    \ + 1];\n        match op.as_str() {\n            \"+\" => tmp += n2,\n      \
    \      \"-\" => tmp -= n2,\n            \"*\" => tmp *= n2,\n            \"//\"\
    \ => tmp /= n2,\n            \"**\" => tmp = tmp.pow(n2 as u32),\n           \
    \ _ => tmp += n2,\n        }\n    }\n    tmp", "    let mut result = operand[0];\n\
    \    for i in 0..operator.len() {\n        if operator[i] == \"+\" {\n       \
    \     result += operand[i + 1];\n        } else if operator[i] == \"-\" {\n  \
    \          result -= operand[i + 1];\n        } else if operator[i] == \"*\" {\n\
    \            result *= operand[i + 1];\n        } else if operator[i] == \"//\"\
    \ {\n            result /= operand[i + 1];\n        } else if operator[i] == \"\
    **\" {\n            result = result.pow(operand[i + 1] as u32);\n        }\n \
    \   }\n    result", "    use std::ops::*;\n    let mut expression = operand[0];\n\
    \    for (p, o) in operator.iter().zip(operand.iter().skip(1)) {\n        match\
    \ p.as_str() {\n            \"+\" => expression = expression + o,\n          \
    \  \"-\" => expression = expression - o,\n            \"*\" => expression = expression\
    \ * o,\n            \"/\" => expression = expression / o,\n            \"^\" =>\
    \ expression = expression.pow(*o as u32),\n            _ => (),\n        }\n \
    \   }\n    expression", "    // Write your code here\n    0", "    let mut op_stack:\
    \ Vec<isize> = vec![];\n    let mut op_stack_n: Vec<isize> = vec![];\n    for\
    \ (i, oper) in operator.iter().enumerate() {\n        match oper.as_str() {\n\
    \            \"+\" => {\n                op_stack.push(operand[i]);\n        \
    \        op_stack_n.push(operand[i + 1]);\n            }\n            \"-\" =>\
    \ {\n                op_stack.push(operand[i]);\n                op_stack_n.push(-operand[i\
    \ + 1]);\n            }\n            \"*\" => {\n                op_stack.push(op_stack.pop().unwrap()\
    \ * operand[i + 1]);\n                op_stack_n.push(operand[i + 1]);\n     \
    \       }\n            \"//\" => {\n                op_stack.push(op_stack.pop().unwrap()\
    \ / operand[i + 1]);\n                op_stack_n.push(operand[i + 1]);\n     \
    \       }\n            \"**\" => {\n                let prev = op_stack.pop().unwrap();\n\
    \                op_stack.push(prev.pow(operand[i + 1] as u32));\n           \
    \     op_stack_n.push(operand[i + 1]);\n            }\n            _ => println!(\"\
    Bad operator: {}\", oper),\n        }\n    }\n    let result = op_stack.iter().sum::<isize>();\n\
    \    println!(\"{:?}\", op_stack);\n    println!(\"{:?}\", op_stack_n);\n    result",
  "    let mut acc = operand[0];\n    for (idx, op) in operator.iter().enumerate()\
    \ {\n        match op.as_str() {\n            \"+\" => acc += operand[idx + 1],\n\
    \            \"-\" => acc -= operand[idx + 1],\n            \"*\" => acc *= operand[idx\
    \ + 1],\n            \"//\" => acc /= operand[idx + 1],\n            \"**\" =>\
    \ acc = acc.pow(operand[idx + 1] as u32),\n            _ => unreachable!()\n \
    \       }\n    }\n    acc"]
stop_tokens:
- "\n}"
