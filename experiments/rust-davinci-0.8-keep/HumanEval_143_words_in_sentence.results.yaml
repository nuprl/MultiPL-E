name: HumanEval_143_words_in_sentence
language: rust
results:
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut result = String::new();\n    let mut first = true;\n \
    \   for word in sentence.split(' ') {\n        if (2..=word.len()).all(|i| word.len()\
    \ % i != 0) {\n            if !first {\n                result.push(' ');\n  \
    \          }\n            result.push_str(word);\n            first = false;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"is\"`', /tmp/tmpih73yleg.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut result = String::new();\n    for word in sentence.split_whitespace()\
    \ {\n        if is_prime(word.len()) {\n            result.push_str(word);\n \
    \           result.push(' ');\n        }\n    }\n    if !result.is_empty() {\n\
    \        result.pop();\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpblo4krnk.rs:18:12\n\
    \   |\n18 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let words: Vec<_> = sentence.split(' ').collect();\n    let mut\
    \ res = String::new();\n    for w in words {\n        if w.len() > 1 && is_prime(w.len()\
    \ as u32) {\n            res.push_str(w);\n            res.push(' ');\n      \
    \  }\n    }\n    res.trim().to_string()\n}\n\nfn main() {\n    let candidate =\
    \ words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmphn_bqyo8.rs:19:27\n\
    \   |\n19 |         if w.len() > 1 && is_prime(w.len() as u32) {\n   |       \
    \                    ^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    const PRIMES: [u8; 28] = [\n        2, 3, 5, 7, 11, 13, 17, 19,\
    \ 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89,\n        97,\
    \ 101, 103, 107,\n    ];\n    sentence\n        .split_whitespace()\n        .filter(|word|\
    \ {\n            let mut iter = word.chars();\n            PRIMES.contains(&(iter.next().unwrap()\
    \ as u8 - 96))\n        })\n        .collect::<Vec<_>>()\n        .join(\" \"\
    )\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmplszo5kmu.rs:24:30\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split(' ')\n        .filter(|word| word.len().is_prime())\n\
    \        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_prime` found for type `usize` in the\
    \ current scope\n  --> /tmp/tmp87eywaft.rs:18:35\n   |\n18 |         .filter(|word|\
    \ word.len().is_prime())\n   |                                   ^^^^^^^^ method\
    \ not found in `usize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut result = String::new();\n    for word in sentence.split_whitespace()\
    \ {\n        if is_prime(word.len()) {\n            result.push_str(&word);\n\
    \            result.push(' ');\n        }\n    }\n    result.pop();\n    result\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp_u5en3ln.rs:18:12\n\
    \   |\n18 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut res = String::new();\n    for word in sentence.split_whitespace()\
    \ {\n        if word.len().is_prime() {\n            res.push_str(word);\n   \
    \         res.push(' ');\n        }\n    }\n    res.trim_end().to_string()\n}\n\
    \nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_prime` found for type `usize` in the\
    \ current scope\n  --> /tmp/tmpn13piozn.rs:18:23\n   |\n18 |         if word.len().is_prime()\
    \ {\n   |                       ^^^^^^^^ method not found in `usize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut primes = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut result\
    \ = String::new();\n    for word in sentence.split(' ') {\n        if primes.contains(&word.len())\
    \ {\n            result.push_str(word);\n            result.push(' ');\n     \
    \   }\n    }\n    if result.len() > 0 {\n        result.pop();\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let words: Vec<&str> = sentence.split_whitespace().collect();\n\
    \    let mut result = vec![];\n    for word in words {\n        if is_prime(word.len())\
    \ {\n            result.push(word);\n        }\n    }\n    result.join(\" \")\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpr79din1z.rs:19:12\n\
    \   |\n19 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split_whitespace()\n        .filter(|word|\
    \ {\n            word.chars()\n                .filter(|c| !c.is_alphabetic())\n\
    \                .collect::<String>()\n                .is_empty()\n        })\n\
    \        .filter(|word| is_prime(word.len() as i32))\n        .collect::<Vec<&str>>()\n\
    \        .join(\" \")\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpbr5a11pd.rs:24:24\n\
    \   |\n24 |         .filter(|word| is_prime(word.len() as i32))\n   |        \
    \                ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let words: Vec<_> = sentence.split_whitespace().collect();\n \
    \   let mut result = vec![];\n    for word in words {\n        if word.len().is_prime()\
    \ {\n            result.push(word);\n        }\n    }\n    result.join(\" \")\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_prime` found for type `usize` in the\
    \ current scope\n  --> /tmp/tmpuvkrhmst.rs:19:23\n   |\n19 |         if word.len().is_prime()\
    \ {\n   |                       ^^^^^^^^ method not found in `usize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let words: Vec<&str> = sentence.split(' ').collect();\n    let\
    \ res: Vec<&str> = words\n        .iter()\n        .filter(|&w| is_prime(w.len()\
    \ as u64))\n        .collect();\n    res.join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpeqsi5nkk.rs:19:22\n\
    \   |\n19 |         .filter(|&w| is_prime(w.len() as u64))\n   |             \
    \         ^^^^^^^^ not found in this scope\n\nerror[E0277]: a value of type `Vec<&str>`\
    \ cannot be built from an iterator over elements of type `&&str`\n    --> /tmp/tmpeqsi5nkk.rs:20:10\n\
    \     |\n20   |         .collect();\n     |          ^^^^^^^ value of type `Vec<&str>`\
    \ cannot be built from `std::iter::Iterator<Item=&&str>`\n     |\n     = help:\
    \ the trait `FromIterator<&&str>` is not implemented for `Vec<&str>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let words: Vec<&str> = sentence.split(' ').collect();\n    let\
    \ words: Vec<String> = words\n        .iter()\n        .filter(|w| is_prime(w.len()\
    \ as u64))\n        .map(|w| w.to_string())\n        .collect();\n    words.join(\"\
    \ \")\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp7eqznbf4.rs:19:21\n\
    \   |\n19 |         .filter(|w| is_prime(w.len() as u64))\n   |              \
    \       ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut res = String::new();\n    for s in sentence.split_whitespace()\
    \ {\n        if is_prime(s.len()) {\n            res.push_str(s);\n          \
    \  res.push(' ');\n        }\n    }\n    res.pop();\n    res\n}\n\nfn main() {\n\
    \    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmptuxmo98o.rs:18:12\n\
    \   |\n18 |         if is_prime(s.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split(' ')\n        .filter(|&word| is_prime(word.len()))\n\
    \        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp9v_eigtt.rs:18:25\n\
    \   |\n18 |         .filter(|&word| is_prime(word.len()))\n   |              \
    \           ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split_whitespace()\n        .filter(|word|\
    \ match word.len() {\n            0 => false,\n            2 => true,\n      \
    \      n if n > 2 => (2..n / 2 + 1).all(|i| n % i != 0),\n            _ => false,\n\
    \        })\n        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main()\
    \ {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let words: Vec<_> = sentence.split_whitespace().collect();\n \
    \   let mut result = Vec::new();\n    for word in words {\n        if is_prime(word.len())\
    \ {\n            result.push(word);\n        }\n    }\n    result.join(\" \")\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmptf2q98e9.rs:19:12\n\
    \   |\n19 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut res = String::new();\n    let mut first = true;\n    for\
    \ word in sentence.split(' ') {\n        if is_prime(word.len()) {\n         \
    \   if first {\n                first = false;\n            } else {\n       \
    \         res.push(' ');\n            }\n            res.push_str(word);\n   \
    \     }\n    }\n    res\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpv7llciv4.rs:19:12\n\
    \   |\n19 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let words: Vec<_> = sentence.split(' ').collect();\n    let result:\
    \ Vec<_> = words\n        .iter()\n        .filter(|word| is_prime(word.len()\
    \ as i32))\n        .cloned()\n        .collect();\n    result.join(\" \")\n}\n\
    \nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp_93poic0.rs:19:24\n\
    \   |\n19 |         .filter(|word| is_prime(word.len() as i32))\n   |        \
    \                ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut result = String::new();\n    for word in sentence.split_whitespace()\
    \ {\n        if is_prime(word.len()) {\n            result.push_str(word);\n \
    \           result.push(' ');\n        }\n    }\n    if !result.is_empty() {\n\
    \        result.pop();\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpp722e486.rs:18:12\n\
    \   |\n18 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let is_prime = |n: u32| {\n        let mut x = n;\n        while\
    \ x % 2 == 0 {\n            x /= 2;\n        }\n        (3..x / 2).all(|i| n %\
    \ i != 0)\n    };\n    sentence\n        .split(' ')\n        .filter(|word| is_prime(word.len()\
    \ as u32))\n        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main()\
    \ {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"This is a test\"`,\n right: `\"is\"`', /tmp/tmpgas81kr7.rs:32:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split_whitespace()\n        .filter(|word|\
    \ is_prime(word.len()))\n        .collect::<Vec<_>>()\n        .join(\" \")\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpgw_360z9.rs:18:24\n\
    \   |\n18 |         .filter(|word| is_prime(word.len()))\n   |               \
    \         ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut res = String::new();\n    for word in sentence.split('\
    \ ') {\n        if let Some(mut w) = word.chars().last() {\n            if w ==\
    \ '.' {\n                w = '\\0';\n            }\n            if is_prime(w\
    \ as u8 - b'a' as u8 + 1) {\n                res.push_str(word);\n           \
    \     res.push(' ');\n            }\n        }\n    }\n    if !res.is_empty()\
    \ {\n        res.pop();\n    }\n    res\n}\n\nfn main() {\n    let candidate =\
    \ words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpksw984mp.rs:22:16\n\
    \   |\n22 |             if is_prime(w as u8 - b'a' as u8 + 1) {\n   |        \
    \        ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut result = String::new();\n    for word in sentence.split_whitespace()\
    \ {\n        if is_prime(word.len()) {\n            result.push_str(word);\n \
    \           result.push(' ');\n        }\n    }\n    if result.ends_with(' ')\
    \ {\n        result.pop();\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp2xle8gil.rs:18:12\n\
    \   |\n18 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    fn is_prime(mut num: usize) -> bool {\n        if num < 2 {\n\
    \            return false;\n        }\n        for i in 2..(num / 2 + 1) {\n \
    \           if num % i == 0 {\n                return false;\n            }\n\
    \        }\n        true\n    }\n    sentence\n        .split_whitespace()\n \
    \       .filter(|s| is_prime(s.len()))\n        .collect::<Vec<_>>()\n       \
    \ .join(\" \")\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n   \
    \ assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split(' ')\n        .filter(|s| is_prime(s.len()))\n\
    \        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmppzalbo6u.rs:18:21\n\
    \   |\n18 |         .filter(|s| is_prime(s.len()))\n   |                     ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut result = Vec::new();\n    for word in sentence.split('\
    \ ') {\n        if word.len() > 1 && is_prime(word.len() as i32) {\n         \
    \   result.push(word);\n        }\n    }\n    result.join(\" \")\n}\n\nfn main()\
    \ {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp8087civu.rs:18:30\n\
    \   |\n18 |         if word.len() > 1 && is_prime(word.len() as i32) {\n   | \
    \                             ^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let words: Vec<&str> = sentence.split_whitespace().collect();\n\
    \    let mut result = Vec::new();\n    for word in words {\n        if is_prime(word.len()\
    \ as i32) {\n            result.push(word);\n        }\n    }\n    result.join(\"\
    \ \")\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpgrcyjru8.rs:19:12\n\
    \   |\n19 |         if is_prime(word.len() as i32) {\n   |            ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut res = Vec::new();\n    for word in sentence.split_whitespace()\
    \ {\n        if is_prime(word.len()) {\n            res.push(word);\n        }\n\
    \    }\n    res.join(\" \")\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpwxks3ik2.rs:18:12\n\
    \   |\n18 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut ret = String::new();\n    for s in sentence.split_whitespace()\
    \ {\n        if is_prime(s.len()) {\n            ret.push_str(&format!(\"{} \"\
    , s));\n        }\n    }\n    ret.trim().to_string()\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpbjhxsmex.rs:18:12\n\
    \   |\n18 |         if is_prime(s.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let words: Vec<&str> = sentence.split(' ').collect();\n    let\
    \ mut result = String::new();\n    for word in words {\n        if is_prime(word.len())\
    \ {\n            result.push_str(word);\n            result.push(' ');\n     \
    \   }\n    }\n    result.trim().to_string()\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmphcvmjbtv.rs:19:12\n\
    \   |\n19 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split_whitespace()\n        .filter(|w| is_prime(w.len()))\n\
    \        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp9qqyg67z.rs:18:21\n\
    \   |\n18 |         .filter(|w| is_prime(w.len()))\n   |                     ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let words: Vec<&str> = sentence.split(' ').collect();\n    let\
    \ mut res = Vec::new();\n    for w in words {\n        if w.len() % 2 == 1 {\n\
    \            res.push(w);\n        }\n    }\n    res.join(\" \")\n}\n\nfn main()\
    \ {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"is\"`', /tmp/tmpd1pk94ab.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut result = String::new();\n    for word in sentence.split_whitespace()\
    \ {\n        if is_prime(word.len()) {\n            result.push_str(word);\n \
    \           result.push(' ');\n        }\n    }\n    result.pop();\n    result\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp4eb10m53.rs:18:12\n\
    \   |\n18 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut primes = HashSet::new();\n    primes.insert(2);\n    primes.insert(3);\n\
    \    primes.insert(5);\n    primes.insert(7);\n    primes.insert(11);\n    primes.insert(13);\n\
    \    primes.insert(17);\n    primes.insert(19);\n    primes.insert(23);\n    primes.insert(29);\n\
    \    primes.insert(31);\n    primes.insert(37);\n    primes.insert(41);\n    primes.insert(43);\n\
    \    primes.insert(47);\n    primes.insert(53);\n    primes.insert(59);\n    primes.insert(61);\n\
    \    primes.insert(67);\n    primes.insert(71);\n    primes.insert(73);\n    primes.insert(79);\n\
    \    primes.insert(83);\n    primes.insert(89);\n    primes.insert(97);\n    primes.insert(101);\n\
    \    sentence\n        .split(' ')\n        .filter(|word| primes.contains(&word.len()))\n\
    \        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpkvnk3jd2.rs:16:22\n   |\n16 |     let mut primes = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut res = String::new();\n    for word in sentence.split_whitespace()\
    \ {\n        if is_prime(word.len()) {\n            res.push_str(word);\n    \
    \        res.push(' ');\n        }\n    }\n    if !res.is_empty() {\n        res.pop();\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n  \
    \  assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpuedcug0r.rs:18:12\n\
    \   |\n18 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut result = String::new();\n    for word in sentence.split_whitespace()\
    \ {\n        if is_prime(word.len()) {\n            result.push_str(word);\n \
    \           result.push(' ');\n        }\n    }\n    result.pop();\n    result\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpmv028cqv.rs:18:12\n\
    \   |\n18 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut result = String::from(\"\");\n    for word in sentence.split_whitespace()\
    \ {\n        if is_prime(word.len()) {\n            result.push_str(word);\n \
    \           result.push(' ');\n        }\n    }\n    if result.is_empty() {\n\
    \        result\n    } else {\n        result.pop();\n        result\n    }\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpm9jnvfoc.rs:18:12\n\
    \   |\n18 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut result = String::new();\n    for word in sentence.split_whitespace()\
    \ {\n        if word.len().is_prime() {\n            result.push_str(word);\n\
    \            result.push(' ');\n        }\n    }\n    result.trim_end().to_string()\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_prime` found for type `usize` in the\
    \ current scope\n  --> /tmp/tmp84whuiw0.rs:18:23\n   |\n18 |         if word.len().is_prime()\
    \ {\n   |                       ^^^^^^^^ method not found in `usize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split(' ')\n        .filter(|&word| word.len().is_prime())\n\
    \        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_prime` found for type `usize` in the\
    \ current scope\n  --> /tmp/tmpq0re5_52.rs:18:36\n   |\n18 |         .filter(|&word|\
    \ word.len().is_prime())\n   |                                    ^^^^^^^^ method\
    \ not found in `usize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split_whitespace()\n        .filter(|word|\
    \ is_prime(word.len()))\n        .collect::<Vec<_>>()\n        .join(\" \")\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp9ztap1uy.rs:18:24\n\
    \   |\n18 |         .filter(|word| is_prime(word.len()))\n   |               \
    \         ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut s = String::new();\n    for word in sentence.split_whitespace()\
    \ {\n        if word.len().is_prime() {\n            s.push_str(word);\n     \
    \       s.push(' ');\n        }\n    }\n    s.trim_end().to_string()\n}\n\nfn\
    \ main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_prime` found for type `usize` in the\
    \ current scope\n  --> /tmp/tmpxx7y2tqk.rs:18:23\n   |\n18 |         if word.len().is_prime()\
    \ {\n   |                       ^^^^^^^^ method not found in `usize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split_whitespace()\n        .filter(|w| w.len().is_prime())\n\
    \        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_prime` found for type `usize` in the\
    \ current scope\n  --> /tmp/tmpdw8q3wl5.rs:18:29\n   |\n18 |         .filter(|w|\
    \ w.len().is_prime())\n   |                             ^^^^^^^^ method not found\
    \ in `usize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut result = Vec::new();\n    for word in sentence.split('\
    \ ') {\n        if let Some(num) = word.len().checked_sub(1) {\n            if\
    \ is_prime(num) {\n                result.push(word);\n            }\n       \
    \ }\n    }\n    result.join(\" \")\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpdb268tn4.rs:19:16\n\
    \   |\n19 |             if is_prime(num) {\n   |                ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split_whitespace()\n        .filter(|word|\
    \ {\n            word.len() > 1 && word.chars().all(|c| c.is_alphabetic())\n \
    \       })\n        .filter(|word| {\n            let mut i = 2;\n           \
    \ while i * i <= word.len() {\n                if word.len() % i == 0 {\n    \
    \                return false;\n                }\n                i += 1;\n \
    \           }\n            true\n        })\n        .collect::<Vec<_>>()\n  \
    \      .join(\" \")\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let words: Vec<&str> = sentence.split(' ').collect();\n    let\
    \ mut res = String::new();\n    for word in words {\n        if is_prime(word.len())\
    \ {\n            res.push_str(word);\n            res.push(' ');\n        }\n\
    \    }\n    res.trim().to_string()\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp7ehmv7d3.rs:19:12\n\
    \   |\n19 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\
    \ 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101];\n    let mut result =\
    \ Vec::new();\n    let mut words = sentence.split(' ');\n    while let Some(word)\
    \ = words.next() {\n        if primes.contains(&word.len()) {\n            result.push(word);\n\
    \        }\n    }\n    result.join(\" \")\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut primes = HashSet::new();\n    for i in 2..sentence.len()\
    \ {\n        let mut j = 2;\n        let mut is_prime = true;\n        while j\
    \ * j <= i {\n            if i % j == 0 {\n                is_prime = false;\n\
    \                break;\n            }\n            j += 1;\n        }\n     \
    \   if is_prime {\n            primes.insert(i);\n        }\n    }\n    sentence\n\
    \        .split_whitespace()\n        .filter(|word| primes.contains(&word.len()))\n\
    \        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmphzgjteg9.rs:16:22\n   |\n16 |     let mut primes = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut result = String::new();\n    for word in sentence.split('\
    \ ') {\n        if word.len() > 1 && (2..word.len()).all(|divisor| word.len()\
    \ % divisor != 0) {\n            result.push_str(word);\n            result.push('\
    \ ');\n        }\n    }\n    result.trim().to_string()\n}\n\nfn main() {\n   \
    \ let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split_whitespace()\n        .filter(|word|\
    \ is_prime(word.len()))\n        .collect::<Vec<_>>()\n        .join(\" \")\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpju8ou8qd.rs:18:24\n\
    \   |\n18 |         .filter(|word| is_prime(word.len()))\n   |               \
    \         ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let words: Vec<&str> = sentence.split_whitespace().collect();\n\
    \    let mut ret = String::new();\n    for word in words {\n        if is_prime(word.len())\
    \ {\n            ret.push_str(word);\n            ret.push(' ');\n        }\n\
    \    }\n    ret.pop();\n    ret\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpukfgnlbs.rs:19:12\n\
    \   |\n19 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let sentence = sentence.split(' ').collect::<Vec<_>>();\n    let\
    \ mut result = Vec::new();\n    for word in sentence {\n        if word.len()\
    \ % 2 == 1 {\n            for i in 3..word.len() {\n                if word.len()\
    \ % i == 0 {\n                    break;\n                }\n                if\
    \ i == word.len() - 1 {\n                    result.push(word);\n            \
    \    }\n            }\n        }\n    }\n    result.join(\" \")\n}\n\nfn main()\
    \ {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"is\"`', /tmp/tmpum_ytxu1.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split_whitespace()\n        .filter(|word|\
    \ {\n            let length = word.len();\n            if length == 1 {\n    \
    \            return true;\n            }\n            let mut i = 2;\n       \
    \     while i * i <= length {\n                if length % i == 0 {\n        \
    \            return false;\n                }\n                i += 1;\n     \
    \       }\n            true\n        })\n        .collect::<Vec<_>>()\n      \
    \  .join(\" \")\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n  \
    \  assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"is a\"`,\n right: `\"is\"`', /tmp/tmpzl17rbt8.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let s = sentence.split_whitespace().collect::<Vec<_>>();\n   \
    \ let mut res = Vec::new();\n    for word in s {\n        if is_prime(word.len())\
    \ {\n            res.push(word);\n        }\n    }\n    res.join(\" \")\n}\n\n\
    fn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp4nsn9qhx.rs:19:12\n\
    \   |\n19 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut words = sentence.split_whitespace();\n    words.filter(|word|\
    \ {\n        if word.len() <= 1 {\n            return false;\n        }\n    \
    \    let mut i = 2;\n        while i * i <= word.len() {\n            if word.len()\
    \ % i == 0 {\n                return false;\n            }\n            i += 1;\n\
    \        }\n        true\n    })\n    .collect::<Vec<_>>()\n    .join(\" \")\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split(' ')\n        .filter(|word| {\n    \
    \        (word.len() > 1) &&\n            (word.len() == 2 || !(2..word.len()\
    \ / 2 + 1).any(|x| word.len() % x == 0))\n        })\n        .collect::<Vec<_>>()\n\
    \        .join(\" \")\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut result = String::new();\n    for word in sentence.split_whitespace()\
    \ {\n        if is_prime(word.len()) {\n            result.push_str(&word);\n\
    \            result.push(' ');\n        }\n    }\n    result.pop();\n    result\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpohfbbn0i.rs:18:12\n\
    \   |\n18 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut words = sentence.split_whitespace();\n    let first =\
    \ words.next().unwrap();\n    let mut primes = Vec::new();\n    let mut first_prime\
    \ = String::new();\n    let mut last_prime = String::new();\n    for (i, word)\
    \ in words.enumerate() {\n        if is_prime(word.len() as i32) {\n         \
    \   if i == 0 {\n                first_prime = word.to_string();\n           \
    \ } else {\n                last_prime = word.to_string();\n            }\n  \
    \          primes.push(word);\n        }\n    }\n    if primes.is_empty() {\n\
    \        return first.to_string();\n    }\n    let mut result = String::new();\n\
    \    result.push_str(&first_prime);\n    result.push(' ');\n    result.push_str(&last_prime);\n\
    \    result\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpbpk0uzo_.rs:22:12\n\
    \   |\n22 |         if is_prime(word.len() as i32) {\n   |            ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let words: Vec<&str> = sentence.split(' ').collect();\n    words.iter()\n\
    \        .filter(|&word| {\n            let len = word.len();\n            len\
    \ > 1 && (len == 2 || (2..(len as f64).sqrt() as usize + 1).all(|factor| len %\
    \ factor != 0))\n        })\n        .map(|&word| word.to_string())\n        .collect::<Vec<String>>()\n\
    \        .join(\" \")\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let sentence: Vec<&str> = sentence.split(' ').collect();\n   \
    \ let primes: Vec<usize> = (2..=sentence.iter().map(|s| s.len()).max().unwrap()).filter(|&n|\
    \ is_prime(n)).collect();\n    sentence.iter().filter(|s| primes.contains(&s.len())).cloned().collect::<Vec<&str>>().join(\"\
    \ \")\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp0_9df_w7.rs:17:96\n\
    \   |\n17 |     let primes: Vec<usize> = (2..=sentence.iter().map(|s| s.len()).max().unwrap()).filter(|&n|\
    \ is_prime(n)).collect();\n   |                                              \
    \                                                  ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut primes = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    sentence\n   \
    \     .split(' ')\n        .filter(|word| {\n            primes.binary_search(&word.len()).is_ok()\n\
    \        })\n        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main()\
    \ {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split(' ')\n        .filter(|word| {\n    \
    \        let len = word.len();\n            let len = if len == 1 { 2 } else {\
    \ len };\n            (2..len).all(|divisor| len % divisor != 0)\n        })\n\
    \        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"is a\"`,\n right: `\"is\"`', /tmp/tmp6xkvbw4i.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split(' ')\n        .filter(|w| is_prime(w.len()))\n\
    \        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp0fu3oz59.rs:18:21\n\
    \   |\n18 |         .filter(|w| is_prime(w.len()))\n   |                     ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut result = String::new();\n    let mut first = true;\n \
    \   for word in sentence.split(' ') {\n        if is_prime(word.len()) {\n   \
    \         if first {\n                first = false;\n            } else {\n \
    \               result.push(' ');\n            }\n            result.push_str(word);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpwj2rmgu0.rs:19:12\n\
    \   |\n19 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split_whitespace()\n        .filter(|word|\
    \ word.len().is_prime())\n        .collect::<Vec<_>>()\n        .join(\" \")\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_prime` found for type `usize` in the\
    \ current scope\n  --> /tmp/tmpsaocxxhn.rs:18:35\n   |\n18 |         .filter(|word|\
    \ word.len().is_prime())\n   |                                   ^^^^^^^^ method\
    \ not found in `usize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split(' ')\n        .filter(|s| is_prime(s.len()))\n\
    \        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpl4t9v2pk.rs:18:21\n\
    \   |\n18 |         .filter(|s| is_prime(s.len()))\n   |                     ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let words: Vec<&str> = sentence.split_whitespace().collect();\n\
    \    let mut word_vec: Vec<String> = Vec::new();\n    for word in words {\n  \
    \      if is_prime(word.len() as u64) {\n            word_vec.push(word.to_string());\n\
    \        }\n    }\n    word_vec.join(\" \")\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp9g80crfs.rs:19:12\n\
    \   |\n19 |         if is_prime(word.len() as u64) {\n   |            ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split(' ')\n        .filter(|w| is_prime(w.len()))\n\
    \        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpklkvm4sc.rs:18:21\n\
    \   |\n18 |         .filter(|w| is_prime(w.len()))\n   |                     ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut words = vec![];\n    for word in sentence.split(' ') {\n\
    \        if let Some(_) = is_prime(word.len()) {\n            words.push(word);\n\
    \        }\n    }\n    return words.join(\" \");\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpu56ex05g.rs:18:26\n\
    \   |\n18 |         if let Some(_) = is_prime(word.len()) {\n   |            \
    \              ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split(' ')\n        .filter(|s| is_prime(s.len()))\n\
    \        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmphpyqca0d.rs:18:21\n\
    \   |\n18 |         .filter(|s| is_prime(s.len()))\n   |                     ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split_whitespace()\n        .filter(|word|\
    \ is_prime(word.len()))\n        .collect::<Vec<_>>()\n        .join(\" \")\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp279bit_h.rs:18:24\n\
    \   |\n18 |         .filter(|word| is_prime(word.len()))\n   |               \
    \         ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut primes = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    primes.retain(|p|\
    \ sentence.len() >= *p);\n    sentence.split(' ').filter(|w| primes.contains(&w.len())).collect::<Vec<_>>().join(\"\
    \ \")\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut result = Vec::new();\n    for word in sentence.split_whitespace()\
    \ {\n        if is_prime(word.len()) {\n            result.push(word);\n     \
    \   }\n    }\n    result.join(\" \")\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp3njbmltx.rs:18:12\n\
    \   |\n18 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split_whitespace()\n        .filter(|word|\
    \ word.len().is_prime())\n        .collect::<Vec<_>>()\n        .join(\" \")\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_prime` found for type `usize` in the\
    \ current scope\n  --> /tmp/tmpabrim2qd.rs:18:35\n   |\n18 |         .filter(|word|\
    \ word.len().is_prime())\n   |                                   ^^^^^^^^ method\
    \ not found in `usize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut s: Vec<_> = sentence.split_whitespace().collect();\n \
    \   let mut i = 0;\n    while i < s.len() {\n        let mut v = 0;\n        for\
    \ c in s[i].chars() {\n            v += 1;\n        }\n        let mut p = true;\n\
    \        for j in 2..v / 2 + 1 {\n            if v % j == 0 {\n              \
    \  p = false;\n                break;\n            }\n        }\n        if !p\
    \ {\n            s.remove(i);\n        } else {\n            i += 1;\n       \
    \ }\n    }\n    s.join(\" \")\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"is a\"`,\n right: `\"is\"`', /tmp/tmp1oef7nqc.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut result = String::new();\n    for (i, word) in sentence.split_whitespace().enumerate()\
    \ {\n        if is_prime(word.len() as u64) {\n            if i > 0 {\n      \
    \          result.push(' ');\n            }\n            result.push_str(word);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpiv1tiauq.rs:18:12\n\
    \   |\n18 |         if is_prime(word.len() as u64) {\n   |            ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let words: Vec<&str> = sentence.split_whitespace().collect();\n\
    \    let mut prime_words = Vec::new();\n    for word in words {\n        if is_prime(word.len()\
    \ as i32) {\n            prime_words.push(word);\n        }\n    }\n    prime_words.join(\"\
    \ \")\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpn3e5d52j.rs:19:12\n\
    \   |\n19 |         if is_prime(word.len() as i32) {\n   |            ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split(' ')\n        .filter(|word| is_prime(word.len()))\n\
    \        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp4a7jg25u.rs:18:24\n\
    \   |\n18 |         .filter(|word| is_prime(word.len()))\n   |               \
    \         ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    const PRIMES: [u32; 25] = [\n        2, 3, 5, 7, 11, 13, 17, 19,\
    \ 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89,\n        97,\n\
    \    ];\n    sentence\n        .split_whitespace()\n        .filter(|word| PRIMES.contains(&(word.len()\
    \ as u32)))\n        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main()\
    \ {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split(' ')\n        .filter(|s| is_prime(s.len()))\n\
    \        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp1n2np9hg.rs:18:21\n\
    \   |\n18 |         .filter(|s| is_prime(s.len()))\n   |                     ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut words = Vec::new();\n    let mut s = String::new();\n\
    \    for c in sentence.chars() {\n        if c == ' ' {\n            words.push(s);\n\
    \            s = String::new();\n        } else {\n            s.push(c);\n  \
    \      }\n    }\n    words.push(s);\n    let mut primes = vec![];\n    for i in\
    \ 1..=words.len() {\n        if is_prime(i) {\n            primes.push(i);\n \
    \       }\n    }\n    let mut s = String::new();\n    for (i, w) in words.iter().enumerate()\
    \ {\n        if primes.contains(&(i + 1)) {\n            s.push_str(w);\n    \
    \        s.push(' ');\n        }\n    }\n    if !s.is_empty() {\n        s.pop();\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpszscowgw.rs:29:12\n\
    \   |\n29 |         if is_prime(i) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut primes = sieve(100);\n    primes.sort();\n    sentence\n\
    \        .split_whitespace()\n        .filter(|word| primes.binary_search(&word.len()).is_ok())\n\
    \        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sieve` in this scope\n  --> /tmp/tmpnrn26t5f.rs:16:22\n\
    \   |\n16 |     let mut primes = sieve(100);\n   |                      ^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let primes = vec![\n        2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89,\n        97, 101,\n\
    \    ];\n    let mut ret = vec![];\n    for word in sentence.split(' ') {\n  \
    \      if word.len() == 1 {\n            ret.push(word);\n        } else if primes.contains(&word.len())\
    \ {\n            ret.push(word);\n        }\n    }\n    ret.join(\" \")\n}\n\n\
    fn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"is a\"`,\n right: `\"is\"`', /tmp/tmpory4g5fh.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split(' ')\n        .filter(|w| is_prime(w.len()))\n\
    \        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpeapzkjlw.rs:18:21\n\
    \   |\n18 |         .filter(|w| is_prime(w.len()))\n   |                     ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split_whitespace()\n        .filter(|word|\
    \ PRIMES.contains(&word.len()))\n        .collect::<Vec<_>>()\n        .join(\"\
    \ \")\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `PRIMES` in this scope\n  --> /tmp/tmpr8ykywn4.rs:18:24\n\
    \   |\n18 |         .filter(|word| PRIMES.contains(&word.len()))\n   |       \
    \                 ^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut result = vec![];\n    let words = sentence.split(' ').collect::<Vec<_>>();\n\
    \    for word in words {\n        if word.len() > 1 && is_prime(word.len()) {\n\
    \            result.push(word);\n        }\n    }\n    result.join(\" \")\n}\n\
    \nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpfpvrrzjn.rs:19:30\n\
    \   |\n19 |         if word.len() > 1 && is_prime(word.len()) {\n   |        \
    \                      ^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split(' ')\n        .filter(|s| is_prime(s.len()))\n\
    \        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp4hw01nlc.rs:18:21\n\
    \   |\n18 |         .filter(|s| is_prime(s.len()))\n   |                     ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let words: Vec<&str> = sentence.split(' ').collect();\n    words.iter()\n\
    \        .filter(|&word| {\n            let n = word.len();\n            n ==\
    \ 2 || n == 3 || n == 5 || n == 7 || n == 11 || n == 13 || n == 17 || n == 19\n\
    \        })\n        .cloned()\n        .collect::<Vec<&str>>()\n        .join(\"\
    \ \")\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split_whitespace()\n        .filter(|w| is_prime(w.len()))\n\
    \        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpx3bglwfb.rs:18:21\n\
    \   |\n18 |         .filter(|w| is_prime(w.len()))\n   |                     ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split_whitespace()\n        .filter(|w| w.len().is_prime())\n\
    \        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_prime` found for type `usize` in the\
    \ current scope\n  --> /tmp/tmp_z_y0ai0.rs:18:29\n   |\n18 |         .filter(|w|\
    \ w.len().is_prime())\n   |                             ^^^^^^^^ method not found\
    \ in `usize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut res = vec![];\n    for word in sentence.split_whitespace()\
    \ {\n        if word.len().is_prime() {\n            res.push(word);\n       \
    \ }\n    }\n    res.join(\" \")\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_prime` found for type `usize` in the\
    \ current scope\n  --> /tmp/tmpal_azj0l.rs:18:23\n   |\n18 |         if word.len().is_prime()\
    \ {\n   |                       ^^^^^^^^ method not found in `usize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut words = vec![];\n    let mut word = String::new();\n \
    \   for c in sentence.chars() {\n        if c.is_whitespace() {\n            if\
    \ word.len() > 0 {\n                words.push(word);\n                word =\
    \ String::new();\n            }\n        } else {\n            word.push(c);\n\
    \        }\n    }\n    if word.len() > 0 {\n        words.push(word);\n    }\n\
    \    words.iter()\n        .filter(|w| is_prime(w.len()))\n        .collect::<Vec<_>>()\n\
    \        .join(\" \")\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpd0_6tl6g.rs:32:21\n\
    \   |\n32 |         .filter(|w| is_prime(w.len()))\n   |                     ^^^^^^^^\
    \ not found in this scope\n\nerror[E0599]: the method `join` exists for struct\
    \ `Vec<&String>`, but its trait bounds were not satisfied\n  --> /tmp/tmpd0_6tl6g.rs:34:10\n\
    \   |\n34 |         .join(\" \")\n   |          ^^^^ method cannot be called on\
    \ `Vec<&String>` due to unsatisfied trait bounds\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `[&String]: Join<_>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split_whitespace()\n        .filter(|word|\
    \ is_prime(word.len()))\n        .collect::<Vec<_>>()\n        .join(\" \")\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp0v4vhzk5.rs:18:24\n\
    \   |\n18 |         .filter(|word| is_prime(word.len()))\n   |               \
    \         ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split(' ')\n        .filter(|s| is_prime(s.len()))\n\
    \        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpexlpcm4i.rs:18:21\n\
    \   |\n18 |         .filter(|s| is_prime(s.len()))\n   |                     ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let words: Vec<&str> = sentence.split(' ').collect();\n    let\
    \ mut prime_length_words = vec![];\n    for w in words {\n        if is_prime(w.len()\
    \ as u64) {\n            prime_length_words.push(w);\n        }\n    }\n    prime_length_words.join(\"\
    \ \")\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp1lbu787l.rs:19:12\n\
    \   |\n19 |         if is_prime(w.len() as u64) {\n   |            ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut result = String::new();\n    for word in sentence.split('\
    \ ') {\n        if is_prime(word.len()) {\n            result.push_str(word);\n\
    \            result.push(' ');\n        }\n    }\n    result.pop();\n    result\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpulstn4zx.rs:18:12\n\
    \   |\n18 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut primes = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut res =\
    \ String::new();\n    let mut is_first = true;\n    for word in sentence.split('\
    \ ') {\n        if let Some(i) = primes.binary_search(&word.len()) {\n       \
    \     primes.remove(i);\n            if is_first {\n                is_first =\
    \ false;\n            } else {\n                res.push(' ');\n            }\n\
    \            res.push_str(word);\n        }\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfvxfu25f.rs:20:16\n   |\n\
    20 |         if let Some(i) = primes.binary_search(&word.len()) {\n   |      \
    \          ^^^^^^^   --------------------------------- this expression has type\
    \ `Result<usize, usize>`\n   |                |\n   |                expected\
    \ enum `Result`, found enum `Option`\n   |\n   = note: expected enum `Result<usize,\
    \ usize>`\n              found enum `Option<_>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut primes = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut res =\
    \ String::new();\n    for word in sentence.split(' ') {\n        let len = word.len();\n\
    \        if primes.contains(&len) {\n            res.push_str(word);\n       \
    \     res.push(' ');\n        }\n    }\n    res.trim().to_string()\n}\n\nfn main()\
    \ {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut res = String::new();\n    for word in sentence.split('\
    \ ') {\n        if is_prime(word.len()) {\n            res.push_str(word);\n \
    \           res.push(' ');\n        }\n    }\n    res.pop();\n    res\n}\n\nfn\
    \ main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpldon__q1.rs:18:12\n\
    \   |\n18 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split_whitespace()\n        .filter(|w| is_prime_number(w.len()))\n\
    \        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime_number` in this scope\n  -->\
    \ /tmp/tmp2ez_2t04.rs:18:21\n   |\n18 |         .filter(|w| is_prime_number(w.len()))\n\
    \   |                     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut words = Vec::new();\n    let mut chars = sentence.chars();\n\
    \    let mut word = String::new();\n    loop {\n        let c = chars.next();\n\
    \        if c.is_none() {\n            if is_prime(word.len()) {\n           \
    \     words.push(word);\n            }\n            break;\n        }\n      \
    \  let c = c.unwrap();\n        if c.is_whitespace() {\n            if is_prime(word.len())\
    \ {\n                words.push(word);\n            }\n            word = String::new();\n\
    \        } else {\n            word.push(c);\n        }\n    }\n    return words.join(\"\
    \ \");\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpxyi8542i.rs:22:16\n\
    \   |\n22 |             if is_prime(word.len()) {\n   |                ^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `is_prime` in\
    \ this scope\n  --> /tmp/tmpxyi8542i.rs:29:16\n   |\n29 |             if is_prime(word.len())\
    \ {\n   |                ^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut res = String::new();\n    let mut prime_table = vec![true;\
    \ 100];\n    prime_table[0] = false;\n    prime_table[1] = false;\n    for i in\
    \ 2..100 {\n        if prime_table[i] {\n            for j in (i * i..100).step_by(i)\
    \ {\n                prime_table[j] = false;\n            }\n        }\n    }\n\
    \    for word in sentence.split_whitespace() {\n        if prime_table[word.len()]\
    \ {\n            res.push_str(word);\n            res.push(' ');\n        }\n\
    \    }\n    res.pop();\n    res\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    if sentence.is_empty() {\n        return \"\".to_string();\n \
    \   }\n    let is_prime = |n: usize| {\n        if n < 2 {\n            return\
    \ false;\n        }\n        let mut divisor = 2;\n        while divisor * divisor\
    \ <= n {\n            if n % divisor == 0 {\n                return false;\n \
    \           }\n            divisor += 1;\n        }\n        true\n    };\n  \
    \  let mut result = vec![];\n    for word in sentence.split(' ') {\n        if\
    \ is_prime(word.len()) {\n            result.push(word);\n        }\n    }\n \
    \   result.join(\" \")\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let primes = vec![\n        2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89,\n        97, 101,\n\
    \    ];\n    let mut result = vec![];\n    for word in sentence.split(' ') {\n\
    \        if primes.contains(&word.len()) {\n            result.push(word);\n \
    \       }\n    }\n    result.join(\" \")\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split(' ')\n        .filter(|s| is_prime(s.len()))\n\
    \        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpuhhqkncn.rs:18:21\n\
    \   |\n18 |         .filter(|s| is_prime(s.len()))\n   |                     ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let result: Vec<String> = sentence\n        .split(' ')\n    \
    \    .filter(|word| is_prime(word.len()))\n        .map(|word| word.to_string())\n\
    \        .collect();\n    result.join(\" \")\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpv46iux1v.rs:18:24\n\
    \   |\n18 |         .filter(|word| is_prime(word.len()))\n   |               \
    \         ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split_whitespace()\n        .filter(|word|\
    \ is_prime(word.len()))\n        .collect::<Vec<_>>()\n        .join(\" \")\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpofuysyrn.rs:18:24\n\
    \   |\n18 |         .filter(|word| is_prime(word.len()))\n   |               \
    \         ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let primes = (1..=100).collect::<HashSet<_>>();\n    sentence\n\
    \        .split(' ')\n        .filter(|word| primes.contains(&word.len()))\n \
    \       .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpgp7ifgyy.rs:16:38\n\
    \   |\n16 |     let primes = (1..=100).collect::<HashSet<_>>();\n   |        \
    \                              ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut result = String::new();\n    for word in sentence.split_whitespace()\
    \ {\n        if is_prime(word.len()) {\n            result.push_str(word);\n \
    \           result.push(' ');\n        }\n    }\n    // trim_end() is used because\n\
    \    // if the last word is a prime then we'll have an extra space at the end\n\
    \    result.trim_end().to_string()\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmptvx5_hn5.rs:18:12\n\
    \   |\n18 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let primes = vec![\n        2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89,\n        97, 101,\n\
    \    ];\n    let mut words = vec![];\n    for word in sentence.split_whitespace()\
    \ {\n        if primes.contains(&word.len()) {\n            words.push(word);\n\
    \        }\n    }\n    words.join(\" \")\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split(' ')\n        .filter(|w| is_prime(w.len()))\n\
    \        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpy6s1zcvw.rs:18:21\n\
    \   |\n18 |         .filter(|w| is_prime(w.len()))\n   |                     ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split_whitespace()\n        .filter(|s| is_prime(s.len()))\n\
    \        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpq2gyi9fc.rs:18:21\n\
    \   |\n18 |         .filter(|s| is_prime(s.len()))\n   |                     ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split_whitespace()\n        .filter(|word|\
    \ is_prime(word.len()))\n        .join(\" \")\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp2847sy2d.rs:18:24\n\
    \   |\n18 |         .filter(|word| is_prime(word.len()))\n   |               \
    \         ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `join`\
    \ found for struct `Filter` in the current scope\n  --> /tmp/tmp2847sy2d.rs:19:10\n\
    \   |\n19 |         .join(\" \")\n   |          ^^^^ method not found in `Filter<SplitWhitespace<'_>,\
    \ [closure@/tmp/tmp2847sy2d.rs:18:17: 18:44]>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let words: Vec<&str> = sentence.split(' ').collect();\n    words.iter()\n\
    \        .filter(|&&w| is_prime(w.len()))\n        .join(\" \")\n}\n\nfn main()\
    \ {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp5o5xaks_.rs:18:23\n\
    \   |\n18 |         .filter(|&&w| is_prime(w.len()))\n   |                   \
    \    ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `join`\
    \ found for struct `Filter` in the current scope\n  --> /tmp/tmp5o5xaks_.rs:19:10\n\
    \   |\n19 |         .join(\" \")\n   |          ^^^^ method not found in `Filter<std::slice::Iter<'_,\
    \ &str>, [closure@/tmp/tmp5o5xaks_.rs:18:17: 18:40]>`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split_whitespace()\n        .filter(|s| is_prime(&s.len()))\n\
    \        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp7kbfqtho.rs:18:21\n\
    \   |\n18 |         .filter(|s| is_prime(&s.len()))\n   |                    \
    \ ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut result = String::new();\n    for word in sentence.split_whitespace()\
    \ {\n        if is_prime(word.len()) {\n            result.push_str(word);\n \
    \           result.push(' ');\n        }\n    }\n    result.pop();\n    result\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpcm91p14g.rs:18:12\n\
    \   |\n18 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut res = String::new();\n    for word in sentence.split_whitespace()\
    \ {\n        if is_prime(word.len()) {\n            res.push_str(word);\n    \
    \        res.push(' ');\n        }\n    }\n    res.pop();\n    res\n}\n\nfn main()\
    \ {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp9kd2qdfv.rs:18:12\n\
    \   |\n18 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let words: Vec<&str> = sentence.split_whitespace().collect();\n\
    \    let mut result = Vec::new();\n    for word in words {\n        if is_prime(word.len()\
    \ as u64) {\n            result.push(word);\n        }\n    }\n    result.join(\"\
    \ \")\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpz1e_1com.rs:19:12\n\
    \   |\n19 |         if is_prime(word.len() as u64) {\n   |            ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split_whitespace()\n        .filter(|s| is_prime(s.len()))\n\
    \        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpzt2w3qbv.rs:18:21\n\
    \   |\n18 |         .filter(|s| is_prime(s.len()))\n   |                     ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut result = String::new();\n    for word in sentence.split('\
    \ ') {\n        if is_prime(word.len()) {\n            result.push_str(word);\n\
    \            result.push(' ');\n        }\n    }\n    result.pop();\n    result\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp5d_3qn_1.rs:18:12\n\
    \   |\n18 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let words: Vec<_> = sentence.split(' ').collect();\n    let mut\
    \ result = Vec::new();\n    for word in words {\n        if is_prime(word.len())\
    \ {\n            result.push(word);\n        }\n    }\n    result.join(\" \")\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpre7de47s.rs:19:12\n\
    \   |\n19 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut result = String::new();\n    let words: Vec<&str> = sentence.split_whitespace().collect();\n\
    \    for word in words {\n        if (2..).take_while(|&n| n * n <= word.len()).all(|n|\
    \ word.len() % n != 0) {\n            result.push_str(word);\n            result.push('\
    \ ');\n        }\n    }\n    result.pop();\n    result\n}\n\nfn main() {\n   \
    \ let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"is a\"`,\n right: `\"is\"`', /tmp/tmpi39q99g2.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut res = vec![];\n    for word in sentence.split_whitespace()\
    \ {\n        if is_prime(word.len()) {\n            res.push(word);\n        }\n\
    \    }\n    res.join(\" \")\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp7nadhhi0.rs:18:12\n\
    \   |\n18 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split(' ')\n        .filter(|w| is_prime(w.len()))\n\
    \        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp2h8wu693.rs:18:21\n\
    \   |\n18 |         .filter(|w| is_prime(w.len()))\n   |                     ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split(' ')\n        .filter(|word| is_prime(word.len()))\n\
    \        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpk0mb5zb7.rs:18:24\n\
    \   |\n18 |         .filter(|word| is_prime(word.len()))\n   |               \
    \         ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut ans = String::new();\n    for word in sentence.split_whitespace()\
    \ {\n        if is_prime(word.len()) {\n            if !ans.is_empty() {\n   \
    \             ans.push(' ');\n            }\n            ans.push_str(word);\n\
    \        }\n    }\n    ans\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp223sjmue.rs:18:12\n\
    \   |\n18 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split_whitespace()\n        .filter(|word|\
    \ is_prime(word.len()))\n        .cloned()\n        .collect::<Vec<_>>()\n   \
    \     .join(\" \")\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpj6e73ytm.rs:18:24\n\
    \   |\n18 |         .filter(|word| is_prime(word.len()))\n   |               \
    \         ^^^^^^^^ not found in this scope\n\nerror[E0277]: the trait bound `str:\
    \ Clone` is not satisfied\n    --> /tmp/tmpj6e73ytm.rs:19:10\n     |\n19   | \
    \        .cloned()\n     |          ^^^^^^ the trait `Clone` is not implemented\
    \ for `str`\n     |\n     = help: the trait `Clone` is implemented for `String`\n\
    note: required by a bound in `cloned`\n\nerror[E0599]: the method `collect` exists\
    \ for struct `Cloned<Filter<SplitWhitespace<'_>, [closure@/tmp/tmpj6e73ytm.rs:18:17:\
    \ 18:44]>>`, but its trait bounds were not satisfied\n  --> /tmp/tmpj6e73ytm.rs:20:10\n\
    \   |\n20 |           .collect::<Vec<_>>()\n   |            ^^^^^^^ method cannot\
    \ be called on `Cloned<Filter<SplitWhitespace<'_>, [closure@/tmp/tmpj6e73ytm.rs:18:17:\
    \ 18:44]>>` due to unsatisfied trait bounds\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `Cloned<Filter<SplitWhitespace<'_>, [closure@/tmp/tmpj6e73ytm.rs:18:17:\
    \ 18:44]>>: Iterator`\n           which is required by `&mut Cloned<Filter<SplitWhitespace<'_>,\
    \ [closure@/tmp/tmpj6e73ytm.rs:18:17: 18:44]>>: Iterator`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0425,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split(' ')\n        .filter(|word| is_prime(word.len()))\n\
    \        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp9kwpa1sc.rs:18:24\n\
    \   |\n18 |         .filter(|word| is_prime(word.len()))\n   |               \
    \         ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split_whitespace()\n        .filter(|word|\
    \ is_prime(word.len()))\n        .collect::<Vec<_>>()\n        .join(\" \")\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpbqlvju7c.rs:18:24\n\
    \   |\n18 |         .filter(|word| is_prime(word.len()))\n   |               \
    \         ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split_whitespace()\n        .filter(|word|\
    \ is_prime_word(word))\n        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\
    \nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime_word` in this scope\n  -->\
    \ /tmp/tmp4l4ui98g.rs:18:24\n   |\n18 |         .filter(|word| is_prime_word(word))\n\
    \   |                        ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split_whitespace()\n        .filter(|s| s.len().is_prime())\n\
    \        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_prime` found for type `usize` in the\
    \ current scope\n  --> /tmp/tmppue77xtw.rs:18:29\n   |\n18 |         .filter(|s|\
    \ s.len().is_prime())\n   |                             ^^^^^^^^ method not found\
    \ in `usize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    fn is_prime(n: usize) -> bool {\n        if n <= 1 {\n       \
    \     return false;\n        }\n        let mut i = 2;\n        while i * i <=\
    \ n {\n            if n % i == 0 {\n                return false;\n          \
    \  }\n            i += 1;\n        }\n        true\n    }\n    sentence\n    \
    \    .split(' ')\n        .filter(|s| is_prime(s.len()))\n        .collect::<Vec<_>>()\n\
    \        .join(\" \")\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split_whitespace()\n        .filter(|word|\
    \ is_prime(word.len()))\n        .join(\" \")\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpupfoztim.rs:18:24\n\
    \   |\n18 |         .filter(|word| is_prime(word.len()))\n   |               \
    \         ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `join`\
    \ found for struct `Filter` in the current scope\n  --> /tmp/tmpupfoztim.rs:19:10\n\
    \   |\n19 |         .join(\" \")\n   |          ^^^^ method not found in `Filter<SplitWhitespace<'_>,\
    \ [closure@/tmp/tmpupfoztim.rs:18:17: 18:44]>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut res = String::new();\n    for word in sentence.split('\
    \ ') {\n        if is_prime(word.len()) {\n            res.push_str(&word);\n\
    \            res.push(' ');\n        }\n    }\n    res.pop();\n    res\n}\n\n\
    fn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpq22h3btg.rs:18:12\n\
    \   |\n18 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let primes = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101];\n    let words: Vec<&str>\
    \ = sentence.split(' ').collect();\n    let mut result = String::new();\n    for\
    \ word in words {\n        if primes.contains(&word.len()) {\n            result.push_str(word);\n\
    \            result.push(' ');\n        }\n    }\n    if result.ends_with(' ')\
    \ {\n        result.pop();\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut primes = vec![2];\n    for mut i in 3..=100 {\n      \
    \  let mut j = 0;\n        while primes[j] * primes[j] <= i {\n            if\
    \ i % primes[j] == 0 {\n                i += 2;\n                j = 0;\n    \
    \        } else {\n                j += 1;\n            }\n        }\n       \
    \ primes.push(i);\n    }\n    let sentence = sentence.as_str();\n    let mut words\
    \ = sentence.split_whitespace();\n    let mut result = String::new();\n    while\
    \ let Some(word) = words.next() {\n        if primes.contains(&word.len()) {\n\
    \            result.push_str(word);\n            result.push(' ');\n        }\n\
    \    }\n    result.pop();\n    result\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut result = String::new();\n    for word in sentence.split_whitespace()\
    \ {\n        if is_prime(word.len()) {\n            result.push_str(&word);\n\
    \            result.push(' ');\n        }\n    }\n    result.pop();\n    result\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpfw7qmcv5.rs:18:12\n\
    \   |\n18 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let sentence = sentence.split_whitespace().collect::<Vec<_>>();\n\
    \    if sentence.is_empty() {\n        return \"\".to_string();\n    }\n    let\
    \ primes = primes_up_to(100);\n    let mut result = String::new();\n    for word\
    \ in sentence {\n        if primes.contains(&word.len()) {\n            result.push_str(word);\n\
    \            result.push(' ');\n        }\n    }\n    result.pop();\n    result\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `primes_up_to` in this scope\n  -->\
    \ /tmp/tmpgsciopl0.rs:20:18\n   |\n20 |     let primes = primes_up_to(100);\n\
    \   |                  ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let primes = get_primes(5_000);\n    let words: Vec<_> = sentence.split_whitespace().collect();\n\
    \    let mut filtered = Vec::new();\n    for w in words {\n        if primes.contains(&w.len())\
    \ {\n            filtered.push(w);\n        }\n    }\n    filtered.join(\" \"\
    )\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `get_primes` in this scope\n  --> /tmp/tmp8bdxkly8.rs:16:18\n\
    \   |\n16 |     let primes = get_primes(5_000);\n   |                  ^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut result = String::new();\n    for word in sentence.split_whitespace()\
    \ {\n        if is_prime(word.len()) {\n            result.push_str(word);\n \
    \           result.push(' ');\n        }\n    }\n    result.pop();\n    result\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpm3u9rgpf.rs:18:12\n\
    \   |\n18 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let result: Vec<String> = sentence\n        .split_whitespace()\n\
    \        .filter(|word| is_prime(word.len()))\n        .map(|word| word.to_string())\n\
    \        .collect();\n    result.join(\" \")\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpuyk_f_id.rs:18:24\n\
    \   |\n18 |         .filter(|word| is_prime(word.len()))\n   |               \
    \         ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let words: Vec<&str> = sentence.split_whitespace().collect();\n\
    \    let res: Vec<&str> = words\n        .iter()\n        .filter(|w| is_prime(*w.len()\
    \ as u64))\n        .collect();\n    res.join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp5rzd2q4d.rs:19:21\n\
    \   |\n19 |         .filter(|w| is_prime(*w.len() as u64))\n   |             \
    \        ^^^^^^^^ not found in this scope\n\nerror[E0614]: type `usize` cannot\
    \ be dereferenced\n  --> /tmp/tmp5rzd2q4d.rs:19:30\n   |\n19 |         .filter(|w|\
    \ is_prime(*w.len() as u64))\n   |                              ^^^^^^^^\n\nerror[E0277]:\
    \ a value of type `Vec<&str>` cannot be built from an iterator over elements of\
    \ type `&&str`\n    --> /tmp/tmp5rzd2q4d.rs:20:10\n     |\n20   |         .collect();\n\
    \     |          ^^^^^^^ value of type `Vec<&str>` cannot be built from `std::iter::Iterator<Item=&&str>`\n\
    \     |\n     = help: the trait `FromIterator<&&str>` is not implemented for `Vec<&str>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0425, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split_whitespace()\n        .filter(|s| is_prime(s.len()))\n\
    \        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmporw3wp91.rs:18:21\n\
    \   |\n18 |         .filter(|s| is_prime(s.len()))\n   |                     ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut result = String::new();\n    for word in sentence.split_whitespace()\
    \ {\n        if is_prime(word.len()) {\n            result.push_str(word);\n \
    \           result.push(' ');\n        }\n    }\n    result.pop();\n    result\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp94mkhsdh.rs:18:12\n\
    \   |\n18 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split_whitespace()\n        .filter(|word|\
    \ is_prime(word.len()))\n        .collect::<Vec<_>>()\n        .join(\" \")\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpxy9oew4t.rs:18:24\n\
    \   |\n18 |         .filter(|word| is_prime(word.len()))\n   |               \
    \         ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split(' ')\n        .filter(|word| {\n    \
    \        let len = word.len();\n            len >= 2 && (2..(len / 2 + 1)).all(|x|\
    \ len % x != 0)\n        })\n        .collect::<Vec<_>>()\n        .join(\" \"\
    )\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut primes = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    sentence\n   \
    \     .split_whitespace()\n        .filter(|word| primes.binary_search(&word.len()).is_ok())\n\
    \        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split(' ')\n        .filter(|s| is_prime(s.len()))\n\
    \        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpecyy2j7c.rs:18:21\n\
    \   |\n18 |         .filter(|s| is_prime(s.len()))\n   |                     ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split_whitespace()\n        .filter(|s| is_prime(s.len()))\n\
    \        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpw6x6qld1.rs:18:21\n\
    \   |\n18 |         .filter(|s| is_prime(s.len()))\n   |                     ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut words = sentence.split_whitespace();\n    words.filter(|word|\
    \ word.len().is_prime()).collect::<Vec<_>>().join(\" \")\n}\n\nfn main() {\n \
    \   let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_prime` found for type `usize` in the\
    \ current scope\n  --> /tmp/tmpu5ab1lfv.rs:17:36\n   |\n17 |     words.filter(|word|\
    \ word.len().is_prime()).collect::<Vec<_>>().join(\" \")\n   |               \
    \                     ^^^^^^^^ method not found in `usize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split_whitespace()\n        .filter(|word|\
    \ is_prime(word.len()))\n        .collect::<Vec<_>>()\n        .join(\" \")\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpgb1nzpus.rs:18:24\n\
    \   |\n18 |         .filter(|word| is_prime(word.len()))\n   |               \
    \         ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split_whitespace()\n        .filter(|word|\
    \ is_prime(word.len()))\n        .collect::<Vec<_>>()\n        .join(\" \")\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmptp8j6ub6.rs:18:24\n\
    \   |\n18 |         .filter(|word| is_prime(word.len()))\n   |               \
    \         ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut res = Vec::new();\n    for s in sentence.split(' ') {\n\
    \        if is_prime(s.len()) {\n            res.push(s);\n        }\n    }\n\
    \    res.join(\" \")\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp0l0slvq6.rs:18:12\n\
    \   |\n18 |         if is_prime(s.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut primes = vec![2];\n    'outer: for n in 3.. {\n      \
    \  let mut is_prime = true;\n        for &p in &primes {\n            if n % p\
    \ == 0 {\n                is_prime = false;\n                break;\n        \
    \    }\n        }\n        if is_prime {\n            primes.push(n);\n      \
    \      if primes.len() == 26 {\n                break 'outer;\n            }\n\
    \        }\n    }\n    sentence\n        .split_whitespace()\n        .filter(|word|\
    \ primes.contains(&word.len()))\n        .collect::<Vec<_>>()\n        .join(\"\
    \ \")\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let words: Vec<&str> = sentence.split_whitespace().collect();\n\
    \    words.iter()\n        .filter(|word| is_prime(word.len() as u64))\n     \
    \   .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp9ge6jp_u.rs:18:24\n\
    \   |\n18 |         .filter(|word| is_prime(word.len() as u64))\n   |        \
    \                ^^^^^^^^ not found in this scope\n\nerror[E0599]: the method\
    \ `join` exists for struct `Vec<&&str>`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmp9ge6jp_u.rs:20:10\n   |\n20 |         .join(\" \")\n   |      \
    \    ^^^^ method cannot be called on `Vec<&&str>` due to unsatisfied trait bounds\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `[&&str]:\
    \ Join<_>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0425, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut res = String::new();\n    let mut first = true;\n    for\
    \ word in sentence.split(' ') {\n        if is_prime(word.len()) {\n         \
    \   if first {\n                first = false;\n            } else {\n       \
    \         res.push(' ');\n            }\n            res.push_str(word);\n   \
    \     }\n    }\n    res\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpzc3k52dd.rs:19:12\n\
    \   |\n19 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    if sentence.is_empty() {\n        return String::new();\n    }\n\
    \    let words: Vec<_> = sentence.split(' ').collect();\n    let mut result =\
    \ String::new();\n    for word in words {\n        if word.len() > 1 && is_prime(word.len())\
    \ {\n            result.push_str(word);\n            result.push(' ');\n     \
    \   }\n    }\n    if result.is_empty() {\n        return String::new();\n    }\n\
    \    result.pop();\n    result\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp2bth6loj.rs:22:30\n\
    \   |\n22 |         if word.len() > 1 && is_prime(word.len()) {\n   |        \
    \                      ^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\
    \ 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101];\n    let mut ans = Vec::new();\n\
    \    for word in sentence.split_whitespace() {\n        if primes.contains(&word.len())\
    \ {\n            ans.push(word);\n        }\n    }\n    ans.join(\" \")\n}\n\n\
    fn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut words = sentence.split_whitespace();\n    let mut result\
    \ = String::new();\n    while let Some(word) = words.next() {\n        if is_prime(word.len())\
    \ {\n            result.push_str(word);\n            result.push(' ');\n     \
    \   }\n    }\n    result.trim().to_string()\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpyjvwetp7.rs:19:12\n\
    \   |\n19 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut result = String::new();\n    let words: Vec<_> = sentence.split_whitespace().collect();\n\
    \    for word in words {\n        if is_prime(word.len()) {\n            result.push_str(word);\n\
    \            result.push(' ');\n        }\n    }\n    if !result.is_empty() {\n\
    \        result.pop();\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpyd2z1veo.rs:19:12\n\
    \   |\n19 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let primes = vec![\n        2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89,\n        97, 101,\n\
    \    ];\n    let mut result = String::new();\n    for word in sentence.split('\
    \ ') {\n        if word.is_empty() {\n            continue;\n        }\n     \
    \   if primes.contains(&word.len()) {\n            if !result.is_empty() {\n \
    \               result.push(' ');\n            }\n            result.push_str(word);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split_whitespace()\n        .filter(|word|\
    \ is_prime(word.len()))\n        .collect::<Vec<_>>()\n        .join(\" \")\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpiyaive66.rs:18:24\n\
    \   |\n18 |         .filter(|word| is_prime(word.len()))\n   |               \
    \         ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split_whitespace()\n        .filter(|word|\
    \ is_prime(word.len()))\n        .join(\" \")\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp1zyjj1ba.rs:18:24\n\
    \   |\n18 |         .filter(|word| is_prime(word.len()))\n   |               \
    \         ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `join`\
    \ found for struct `Filter` in the current scope\n  --> /tmp/tmp1zyjj1ba.rs:19:10\n\
    \   |\n19 |         .join(\" \")\n   |          ^^^^ method not found in `Filter<SplitWhitespace<'_>,\
    \ [closure@/tmp/tmp1zyjj1ba.rs:18:17: 18:44]>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let words: Vec<_> = sentence.split_whitespace().collect();\n \
    \   let len = words.len();\n    if len == 0 {\n        return String::new();\n\
    \    }\n    if len == 1 {\n        let l = words[0].len();\n        if prime_num(l)\
    \ {\n            return words[0].to_string();\n        }\n        return String::new();\n\
    \    }\n    let mut primes = Vec::new();\n    for word in words {\n        let\
    \ l = word.len();\n        if prime_num(l) {\n            primes.push(word);\n\
    \        }\n    }\n    if primes.is_empty() {\n        return String::new();\n\
    \    }\n    primes.join(\" \")\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `prime_num` in this scope\n  --> /tmp/tmpponp40eq.rs:23:12\n\
    \   |\n23 |         if prime_num(l) {\n   |            ^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find function `prime_num` in this scope\n\
    \  --> /tmp/tmpponp40eq.rs:31:12\n   |\n31 |         if prime_num(l) {\n   | \
    \           ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut ret = String::new();\n    for word in sentence.split_whitespace()\
    \ {\n        if is_prime(word.len()) {\n            ret.push_str(word);\n    \
    \        ret.push(' ');\n        }\n    }\n    ret.pop();\n    ret\n}\n\nfn main()\
    \ {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp9q69icti.rs:18:12\n\
    \   |\n18 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let words: Vec<&str> = sentence.split(' ').collect();\n    words.iter()\n\
    \        .filter(|word| {\n            let mut num = word.len();\n           \
    \ for i in 2..=(num / 2) {\n                if num % i == 0 {\n              \
    \      return false;\n                }\n            }\n            true\n   \
    \     })\n        .collect::<Vec<&str>>()\n        .join(\" \")\n}\n\nfn main()\
    \ {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<&str>` cannot be built from an iterator\
    \ over elements of type `&&str`\n    --> /tmp/tmpg9468itd.rs:27:10\n     |\n27\
    \   |         .collect::<Vec<&str>>()\n     |          ^^^^^^^ value of type `Vec<&str>`\
    \ cannot be built from `std::iter::Iterator<Item=&&str>`\n     |\n     = help:\
    \ the trait `FromIterator<&&str>` is not implemented for `Vec<&str>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut result = String::new();\n    let mut first = true;\n \
    \   for word in sentence.split(' ') {\n        if is_prime(word.len()) {\n   \
    \         if first {\n                first = false;\n            } else {\n \
    \               result.push(' ');\n            }\n            result.push_str(word);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpoy62w7oo.rs:19:12\n\
    \   |\n19 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let words: Vec<&str> = sentence.split_whitespace().collect();\n\
    \    let primes: HashSet<usize> = sieve_of_eratosthenes(100);\n    let mut result\
    \ = String::new();\n    for word in words {\n        if primes.contains(&word.len())\
    \ {\n            result.push_str(word);\n            result.push(' ');\n     \
    \   }\n    }\n    if result.is_empty() {\n        result\n    } else {\n     \
    \   result.pop();\n        result\n    }\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpf4wa779x.rs:17:17\n\
    \   |\n17 |     let primes: HashSet<usize> = sieve_of_eratosthenes(100);\n   |\
    \                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]:\
    \ cannot find function `sieve_of_eratosthenes` in this scope\n  --> /tmp/tmpf4wa779x.rs:17:34\n\
    \   |\n17 |     let primes: HashSet<usize> = sieve_of_eratosthenes(100);\n   |\
    \                                  ^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0412, E0425.\nFor more information about an error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split(' ')\n        .filter(|word| is_prime(word.len()))\n\
    \        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpty0j8_oi.rs:18:24\n\
    \   |\n18 |         .filter(|word| is_prime(word.len()))\n   |               \
    \         ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split_whitespace()\n        .filter(|s| is_prime(s.len()))\n\
    \        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpneke4wkm.rs:18:21\n\
    \   |\n18 |         .filter(|s| is_prime(s.len()))\n   |                     ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split_whitespace()\n        .filter(|w| is_prime(w.len()))\n\
    \        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpec_0d6hu.rs:18:21\n\
    \   |\n18 |         .filter(|w| is_prime(w.len()))\n   |                     ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split_whitespace()\n        .filter(|s| is_prime(s.len()))\n\
    \        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmplxedo97q.rs:18:21\n\
    \   |\n18 |         .filter(|s| is_prime(s.len()))\n   |                     ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split(' ')\n        .filter(|word| is_prime(word.len()))\n\
    \        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpyivyb42_.rs:18:24\n\
    \   |\n18 |         .filter(|word| is_prime(word.len()))\n   |               \
    \         ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split_whitespace()\n        .filter(|word|\
    \ is_prime(word.len()))\n        .collect::<Vec<_>>()\n        .join(\" \")\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpmzuxg01u.rs:18:24\n\
    \   |\n18 |         .filter(|word| is_prime(word.len()))\n   |               \
    \         ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut primes = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let sentence:\
    \ Vec<&str> = sentence.split(' ').collect();\n    let mut result = Vec::new();\n\
    \    for word in sentence {\n        let length = word.len();\n        if primes.contains(&length)\
    \ {\n            result.push(word);\n        }\n    }\n    result.join(\" \")\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let words: Vec<_> = sentence.split_whitespace().collect();\n \
    \   words.iter()\n        .filter(|word| word.len().is_prime())\n        .cloned()\n\
    \        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_prime` found for type `usize` in the\
    \ current scope\n  --> /tmp/tmpqxn3b5xc.rs:18:35\n   |\n18 |         .filter(|word|\
    \ word.len().is_prime())\n   |                                   ^^^^^^^^ method\
    \ not found in `usize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut words = sentence.split_whitespace();\n    let is_prime\
    \ = |n: &usize| (2..=n / 2).all(|d| n % d != 0);\n    words.filter(|word| is_prime(&word.len())).collect::<Vec<_>>().join(\"\
    \ \")\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"is a\"`,\n right: `\"is\"`', /tmp/tmp1h_28zee.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split_whitespace()\n        .filter(|w| w.chars().count().is_prime())\n\
    \        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_prime` found for type `usize` in the\
    \ current scope\n  --> /tmp/tmpkjn5db21.rs:18:39\n   |\n18 |         .filter(|w|\
    \ w.chars().count().is_prime())\n   |                                       ^^^^^^^^\
    \ method not found in `usize`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let words: Vec<_> = sentence.split(' ').collect();\n    let mut\
    \ res = String::new();\n    for word in words {\n        if is_prime(word.len())\
    \ {\n            res.push_str(word);\n            res.push(' ');\n        }\n\
    \    }\n    res.pop();\n    res\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp71sgd33c.rs:19:12\n\
    \   |\n19 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let primes = vec![\n        2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89,\n        97, 101,\n\
    \    ];\n    let mut result = vec![];\n    for word in sentence.split(' ') {\n\
    \        if primes.contains(&word.len()) {\n            result.push(word);\n \
    \       }\n    }\n    result.join(\" \")\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut r = String::new();\n    for w in sentence.split(' ') {\n\
    \        if is_prime(w.len()) {\n            r.push_str(w);\n            r.push('\
    \ ');\n        }\n    }\n    r.pop();\n    r\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpnakdvtqr.rs:18:12\n\
    \   |\n18 |         if is_prime(w.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut words = sentence.split(' ');\n    let mut result = String::new();\n\
    \    while let Some(word) = words.next() {\n        if is_prime(word.len()) {\n\
    \            result.push_str(word);\n            result.push(' ');\n        }\n\
    \    }\n    if result.is_empty() {\n        result\n    } else {\n        result.pop();\n\
    \        result\n    }\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp0itsgobz.rs:19:12\n\
    \   |\n19 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let primes = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101];\n    let mut words\
    \ = sentence.split_whitespace().collect::<Vec<_>>();\n    words.retain(|word|\
    \ primes.contains(&word.len()));\n    words.join(\" \")\n}\n\nfn main() {\n  \
    \  let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    fn is_prime(x: usize) -> bool {\n        if x <= 3 {\n       \
    \     return x > 1;\n        }\n        if x % 2 == 0 || x % 3 == 0 {\n      \
    \      return false;\n        }\n        for i in (5..=(x as f64).sqrt() as usize()).step_by(6)\
    \ {\n            if x % i == 0 || x % (i + 2) == 0 {\n                return false;\n\
    \            }\n        }\n        true\n    }\n    sentence\n        .split('\
    \ ')\n        .filter(|word| is_prime(word.len()))\n        .fold(String::new(),\
    \ |acc, word| {\n            if acc.is_empty() {\n                word.to_string()\n\
    \            } else {\n                format!(\"{} {}\", acc, word)\n       \
    \     }\n        })\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  stdout: ''
  stderr: "error[E0214]: parenthesized type parameters may only be used with a `Fn`\
    \ trait\n  --> /tmp/tmphohis9y_.rs:23:44\n   |\n23 |         for i in (5..=(x\
    \ as f64).sqrt() as usize()).step_by(6) {\n   |                              \
    \              ^^^^^^^ only `Fn` traits may use parentheses\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0214`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    // https://stackoverflow.com/questions/6392739/\n    // prime\
    \ number in range(2, end)\n    fn primes(end: u32) -> Vec<u32> {\n        let\
    \ mut ret = vec![2];\n        for i in 3..=end {\n            let mut is_prime\
    \ = true;\n            for p in &ret {\n                if i % p == 0 {\n    \
    \                is_prime = false;\n                    break;\n             \
    \   }\n            }\n            if is_prime {\n                ret.push(i);\n\
    \            }\n        }\n        ret\n    }\n    let primes = primes(100);\n\
    \    let mut ret = String::new();\n    for word in sentence.split(' ') {\n   \
    \     if primes.contains(&(word.len() as u32)) {\n            ret.push_str(word);\n\
    \            ret.push(' ');\n        }\n    }\n    ret.pop();\n    ret\n}\n\n\
    fn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let words: Vec<&str> = sentence.split(' ').collect();\n    let\
    \ primes: Vec<usize> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,\
    \ 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut result = String::new();\n\
    \    for word in words {\n        if primes.contains(&word.len()) {\n        \
    \    result.push_str(word);\n            result.push(' ');\n        }\n    }\n\
    \    if result.len() > 0 {\n        result.pop();\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut result = String::new();\n    for word in sentence.split('\
    \ ') {\n        if is_prime(word.len()) {\n            result.push_str(word);\n\
    \            result.push(' ');\n        }\n    }\n    if result.is_empty() {\n\
    \        result\n    } else {\n        result.pop();\n        result\n    }\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp_zfnr3vj.rs:18:12\n\
    \   |\n18 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut words = sentence.split(' ');\n    let mut result = String::new();\n\
    \    for word in words {\n        if is_prime(word.len()) {\n            result.push_str(word);\n\
    \            result.push(' ');\n        }\n    }\n    result.pop();\n    result\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp_0lc_hqk.rs:19:12\n\
    \   |\n19 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let words: Vec<&str> = sentence.split(' ').collect();\n    let\
    \ mut result = Vec::new();\n    for word in words {\n        if is_prime(word.len())\
    \ {\n            result.push(word);\n        }\n    }\n    result.join(\" \")\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpialupxq_.rs:19:12\n\
    \   |\n19 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let words: Vec<_> = sentence.split_whitespace().collect();\n \
    \   let mut result = String::new();\n    for &word in &words {\n        if is_prime(word.len())\
    \ {\n            result.push_str(word);\n            result.push(' ');\n     \
    \   }\n    }\n    result.pop();\n    result\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp1n8laxek.rs:19:12\n\
    \   |\n19 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let words: Vec<_> = sentence.split_whitespace().collect();\n \
    \   let mut res = vec![];\n    for word in words {\n        if is_prime(word.len())\
    \ {\n            res.push(word);\n        }\n    }\n    res.join(\" \")\n}\n\n\
    fn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpge69hopk.rs:19:12\n\
    \   |\n19 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut result = String::new();\n    let mut words = sentence.split_whitespace();\n\
    \    for word in words {\n        if is_prime(word.len()) {\n            result.push_str(&word);\n\
    \            result.push(' ');\n        }\n    }\n    if !result.is_empty() {\n\
    \        result.pop();\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp7zlnqdh2.rs:19:12\n\
    \   |\n19 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let words: Vec<&str> = sentence.split(' ').collect();\n    let\
    \ mut v = Vec::new();\n    for word in words {\n        if is_prime(word.len())\
    \ {\n            v.push(word);\n        }\n    }\n    v.join(\" \")\n}\n\nfn main()\
    \ {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmphtt7ayb5.rs:19:12\n\
    \   |\n19 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let sentence: Vec<_> = sentence.split_whitespace().collect();\n\
    \    sentence\n        .iter()\n        .filter(|w| is_prime(w.len() as u64))\n\
    \        .copied()\n        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\n\
    fn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpr6lgykn3.rs:19:21\n\
    \   |\n19 |         .filter(|w| is_prime(w.len() as u64))\n   |              \
    \       ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split_whitespace()\n        .filter(|word|\
    \ is_prime(word.len()))\n        .collect::<Vec<_>>()\n        .join(\" \")\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp9p5pqheg.rs:18:24\n\
    \   |\n18 |         .filter(|word| is_prime(word.len()))\n   |               \
    \         ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut primes = vec![2];\n    for i in 3..=15 {\n        let\
    \ is_prime = (2..i).all(|j| i % j != 0);\n        if is_prime {\n            primes.push(i);\n\
    \        }\n    }\n    sentence\n        .split_whitespace()\n        .filter(|word|\
    \ primes.contains(&word.len()))\n        .collect::<Vec<_>>()\n        .join(\"\
    \ \")\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split(' ')\n        .filter(|word| word.len().is_prime())\n\
    \        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_prime` found for type `usize` in the\
    \ current scope\n  --> /tmp/tmp7zk1qswh.rs:18:35\n   |\n18 |         .filter(|word|\
    \ word.len().is_prime())\n   |                                   ^^^^^^^^ method\
    \ not found in `usize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut result = String::new();\n    for word in sentence.split_whitespace()\
    \ {\n        if word.len().is_prime() {\n            result.push_str(word);\n\
    \            result.push(' ');\n        }\n    }\n    result.trim_end().to_string()\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_prime` found for type `usize` in the\
    \ current scope\n  --> /tmp/tmp_9jmn8x5.rs:18:23\n   |\n18 |         if word.len().is_prime()\
    \ {\n   |                       ^^^^^^^^ method not found in `usize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    let mut ans = Vec::new();\n    for word in sentence.split(' ')\
    \ {\n        if is_prime(word.len()) {\n            ans.push(word);\n        }\n\
    \    }\n    ans.join(\" \")\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpn36llx74.rs:18:12\n\
    \   |\n18 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// Input: sentence = \"This is a test\"\n\
    /// Output: \"is\"\n/// Example 2:\n/// Input: sentence = \"lets go for swimming\"\
    \n/// Output: \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence) <= 100\n\
    /// * sentence contains only letters\nfn words_in_sentence(sentence: String) ->\
    \ String {\n    sentence\n        .split_whitespace()\n        .filter(|word|\
    \ word.len().is_prime())\n        .collect::<Vec<_>>()\n        .join(\" \")\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_prime` found for type `usize` in the\
    \ current scope\n  --> /tmp/tmp31h6v5vm.rs:18:35\n   |\n18 |         .filter(|word|\
    \ word.len().is_prime())\n   |                                   ^^^^^^^^ method\
    \ not found in `usize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
