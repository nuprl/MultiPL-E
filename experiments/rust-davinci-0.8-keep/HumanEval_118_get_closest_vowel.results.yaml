name: HumanEval_118_get_closest_vowel
language: rust
results:
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let (vowels, consonants) = word.chars().partition(|&x|\
    \ \"aeiou\".contains(x));\n    let mut vec = vec![];\n    if consonants.len()\
    \ > 1 {\n        let mut prev = ' ';\n        for con in consonants {\n      \
    \      for vow in vowels.clone() {\n                if con < vow && prev < vow\
    \ {\n                    vec.push(vow);\n                }\n            }\n  \
    \          prev = con;\n        }\n    }\n    let mut smallest_distance = None;\n\
    \    let mut closest_vowel = ' ';\n    for &x in vec.iter() {\n        if smallest_distance.is_none()\
    \ {\n            smallest_distance = Some(x);\n            closest_vowel = x;\n\
    \        } else if (x as i32 - word.len() as i32).abs() < (smallest_distance.unwrap()\
    \ as i32 - word.len() as i32).abs() {\n            smallest_distance = Some(x);\n\
    \            closest_vowel = x;\n        }\n    }\n    if smallest_distance.is_some()\
    \ {\n        closest_vowel.to_string()\n    } else {\n        \"\".to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed for `(B, B)`\n  --> /tmp/tmpv2dmicfm.rs:14:8\n\
    \   |\n12 |     let (vowels, consonants) = word.chars().partition(|&x| \"aeiou\"\
    .contains(x));\n   |         -------------------- consider giving this pattern\
    \ the explicit type `(B, B)`, with the type parameters specified\n13 |     let\
    \ mut vec = vec![];\n14 |     if consonants.len() > 1 {\n   |        ^^^^^^^^^^\
    \ cannot infer type\n   |\n   = note: type must be known at this point\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\"\
    , \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\"\
    , \"v\", \"w\", \"x\", \"z\"];\n    let vowels = [\"a\", \"e\", \"i\", \"o\",\
    \ \"u\"];\n    let mut i = word.len() - 1;\n    let mut vowel = String::new();\n\
    \    let mut current_consonant = false;\n    let mut valid_vowel = false;\n  \
    \  while i > 0 {\n        let c = word.chars().nth(i).unwrap();\n        let c_str\
    \ = c.to_string();\n        if consonants.contains(&c_str.as_str()) {\n      \
    \      if current_consonant {\n                break;\n            }\n       \
    \     current_consonant = true;\n        } else if vowels.contains(&c_str.as_str())\
    \ {\n            if current_consonant {\n                valid_vowel = true;\n\
    \                vowel = c_str;\n                break;\n            }\n     \
    \   }\n        i -= 1;\n    }\n    if valid_vowel {\n        vowel\n    } else\
    \ {\n        String::new()\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmp4ocd2cdr.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowel = String::new();\n    let consonants\
    \ = vec![\"B\", \"C\", \"D\", \"F\", \"G\", \"H\", \"J\", \"K\", \"L\", \"M\"\
    , \"N\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"V\", \"W\", \"X\", \"Y\", \"Z\"\
    ];\n    let mut last_char = ' ';\n    for c in word.chars().rev() {\n        if\
    \ vowel.len() > 0 {\n            if consonants.contains(&c.to_uppercase().to_string().as_str())\
    \ {\n                break;\n            }\n        }\n        if [\"a\", \"e\"\
    , \"i\", \"o\", \"u\"].contains(&c.to_lowercase().to_string().as_str()) {\n  \
    \          if last_char != ' ' && last_char.is_lowercase() && ![\"a\", \"e\",\
    \ \"i\", \"o\", \"u\"].contains(&last_char.to_lowercase().to_string().as_str())\
    \ {\n                vowel.push(c);\n                break;\n            }\n \
    \           if last_char != ' ' && last_char.is_uppercase() && ![\"a\", \"e\"\
    , \"i\", \"o\", \"u\"].contains(&last_char.to_lowercase().to_string().as_str())\
    \ {\n                vowel.push(c);\n                break;\n            }\n \
    \       }\n        last_char = c;\n    }\n    return vowel;\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmp8gdkx22v.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut index = word.len();\n    for i in word.chars().rev()\
    \ {\n        index -= 1;\n        if i == 'e' || i == 'u' || i == 'i' || i ==\
    \ 'o' || i == 'a' {\n            if !index == 0 {\n                if word.chars().nth(index\
    \ - 1).unwrap() != 'e' && word.chars().nth(index - 1).unwrap() != 'u' && word.chars().nth(index\
    \ - 1).unwrap() != 'i' && word.chars().nth(index - 1).unwrap() != 'o' && word.chars().nth(index\
    \ - 1).unwrap() != 'a' {\n                    if index + 1 == word.len() {\n \
    \                       return String::from(i.to_string());\n                \
    \    } else {\n                        if word.chars().nth(index + 1).unwrap()\
    \ != 'e' && word.chars().nth(index + 1).unwrap() != 'u' && word.chars().nth(index\
    \ + 1).unwrap() != 'i' && word.chars().nth(index + 1).unwrap() != 'o' && word.chars().nth(index\
    \ + 1).unwrap() != 'a' {\n                            return String::from(i.to_string());\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n    }\n    return String::from(\"\");\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmptibkbj1f.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    // your code goes here\n    let vowels = vec![\"a\"\
    , \"e\", \"i\", \"o\", \"u\"];\n    let mut vowel_index = None;\n    for (index,\
    \ letter) in word.chars().rev().enumerate() {\n        if vowels.contains(&letter.to_string().as_str())\
    \ {\n            vowel_index = Some(index);\n            break;\n        }\n \
    \   }\n    let mut result = \"\".to_string();\n    if let Some(index) = vowel_index\
    \ {\n        let mut n = 0;\n        for (i, letter) in word.chars().rev().enumerate()\
    \ {\n            if n == 0 && vowels.contains(&letter.to_string().as_str()) {\n\
    \                n += 1;\n            } else if n == 1 && !vowels.contains(&letter.to_string().as_str())\
    \ {\n                n += 1;\n            } else if n == 2 && vowels.contains(&letter.to_string().as_str())\
    \ {\n                result = letter.to_string();\n                break;\n  \
    \          }\n            if i == index {\n                break;\n          \
    \  }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmp0mqoovk2.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    return if word.len() > 1 {\n        let mut last_vowel\
    \ = -1;\n        let mut last_consonant = -1;\n        for (i, c) in word.chars().enumerate().rev()\
    \ {\n            match is_vowel(c) {\n                true => {\n            \
    \        last_vowel = i;\n                    if last_consonant > 0 {\n      \
    \                  break;\n                    }\n                },\n       \
    \         false => {\n                    last_consonant = i;\n              \
    \      if last_vowel > 0 {\n                        break;\n                 \
    \   }\n                }\n            }\n        }\n        println!(\"{}\", last_vowel);\n\
    \        println!(\"{}\", last_consonant);\n        if last_vowel > last_consonant\
    \ {\n            word.chars().nth(last_vowel).unwrap().to_string()\n        }\
    \ else {\n            String::new()\n        }\n    } else {\n        String::new()\n\
    \    };\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpkhumzgfz.rs:16:19\n\
    \   |\n16 |             match is_vowel(c) {\n   |                   ^^^^^^^^ not\
    \ found in this scope\n\nerror[E0277]: the trait bound `Chars<'_>: ExactSizeIterator`\
    \ is not satisfied\n    --> /tmp/tmpkhumzgfz.rs:15:48\n     |\n15   |        \
    \ for (i, c) in word.chars().enumerate().rev() {\n     |                     \
    \                           ^^^ the trait `ExactSizeIterator` is not implemented\
    \ for `Chars<'_>`\n     |\n     = help: the following other types implement trait\
    \ `ExactSizeIterator`:\n               &mut I\n               Args\n         \
    \      ArgsOs\n               ArrayChunks<'_, T, N>\n               ArrayChunksMut<'_,\
    \ T, N>\n               ArrayWindows<'_, T, N>\n               Box<I, A>\n   \
    \            Chunks<'_, T>\n             and 109 others\n     = note: required\
    \ because of the requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    note: required by a bound in `rev`\n\nerror[E0277]: the trait bound `Chars<'_>:\
    \ ExactSizeIterator` is not satisfied\n  --> /tmp/tmpkhumzgfz.rs:15:23\n   |\n\
    15 |         for (i, c) in word.chars().enumerate().rev() {\n   |            \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator` is not\
    \ implemented for `Chars<'_>`\n   |\n   = help: the following other types implement\
    \ trait `ExactSizeIterator`:\n             &mut I\n             Args\n       \
    \      ArgsOs\n             ArrayChunks<'_, T, N>\n             ArrayChunksMut<'_,\
    \ T, N>\n             ArrayWindows<'_, T, N>\n             Box<I, A>\n       \
    \      Chunks<'_, T>\n           and 109 others\n   = note: required because of\
    \ the requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \   = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpkhumzgfz.rs:13:30\n\
    \   |\n13 |         "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().rev().skip_while(|c| is_consonant(*c)).skip(1).take_while(|c|\
    \ is_consonant(*c)).fold(\n        word.chars().rev().skip_while(|c| is_consonant(*c)).take_while(|c|\
    \ is_consonant(*c)).collect::<String>(), |mut acc, c| {\n            acc.push(c);\n\
    \            acc\n        }\n    )\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_consonant` in this scope\n  -->\
    \ /tmp/tmp8i7yu3uh.rs:12:39\n   |\n12 |     word.chars().rev().skip_while(|c|\
    \ is_consonant(*c)).skip(1).take_while(|c| is_consonant(*c)).fold(\n   |     \
    \                                  ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_consonant` in this scope\n  --> /tmp/tmp8i7yu3uh.rs:12:80\n\
    \   |\n12 |     word.chars().rev().skip_while(|c| is_consonant(*c)).skip(1).take_while(|c|\
    \ is_consonant(*c)).fold(\n   |                                              \
    \                                  ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_consonant` in this scope\n  --> /tmp/tmp8i7yu3uh.rs:13:43\n\
    \   |\n13 |         word.chars().rev().skip_while(|c| is_consonant(*c)).take_while(|c|\
    \ is_consonant(*c)).collect::<String>(), |mut acc, c| {\n   |                \
    \                           ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_consonant` in this scope\n  --> /tmp/tmp8i7yu3uh.rs:13:76\n\
    \   |\n13 |         word.chars().rev().skip_while(|c| is_consonant(*c)).take_while(|c|\
    \ is_consonant(*c)).collect::<String>(), |mut acc, c| {\n   |                \
    \                                                            ^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.rsplit(|c| c == 'a' || c == 'e' || c == 'i' ||\
    \ c == 'o' || c == 'u')\n        .nth(1)\n        .unwrap_or(\"\")\n        .chars()\n\
    \        .rev()\n        .nth(1)\n        .unwrap_or(' ')\n        .to_string()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\" \"`,\n right: `\"u\"`', /tmp/tmp73ag4c2a.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().rev().skip_while(|c| !c.is_vowel()).skip(1).find(|c|\
    \ c.is_vowel()).map(|c| c.to_string()).unwrap_or(\"\".to_string())\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmpej1cji1u.rs:12:42\n   |\n12 |     word.chars().rev().skip_while(|c|\
    \ !c.is_vowel()).skip(1).find(|c| c.is_vowel()).map(|c| c.to_string()).unwrap_or(\"\
    \".to_string())\n   |                                          ^^^^^^^^ method\
    \ not found in `&char`\n\nerror[E0599]: no method named `is_vowel` found for reference\
    \ `&char` in the current scope\n  --> /tmp/tmpej1cji1u.rs:12:73\n   |\n12 |  \
    \   word.chars().rev().skip_while(|c| !c.is_vowel()).skip(1).find(|c| c.is_vowel()).map(|c|\
    \ c.to_string()).unwrap_or(\"\".to_string())\n   |                           \
    \                                              ^^^^^^^^ method not found in `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let word = word.chars().rev().collect::<Vec<char>>();\n\
    \    for (i, c) in word.iter().enumerate() {\n        match c {\n            'a'\
    \ | 'e' | 'i' | 'o' | 'u' => {\n                if i + 1 >= word.len() {\n   \
    \                 return \"\".to_string();\n                }\n              \
    \  if !is_vowel(&word[i + 1]) {\n                    return c.to_string();\n \
    \               }\n            }\n            _ => {}\n        }\n    }\n    \"\
    \".to_string()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n   \
    \ assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"\
    most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n  \
    \  assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp3ycywkol.rs:19:21\n\
    \   |\n19 |                 if !is_vowel(&word[i + 1]) {\n   |               \
    \      ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut chars = word.chars().rev();\n    let mut found_consonant\
    \ = false;\n    let mut vowel_index = 0;\n    for (i, c) in chars.enumerate()\
    \ {\n        match c {\n            'a' | 'e' | 'i' | 'o' | 'u' => {\n       \
    \         if found_consonant {\n                    vowel_index = i;\n       \
    \             break;\n                }\n            },\n            _ => found_consonant\
    \ = true,\n        }\n    }\n    if vowel_index == 0 {\n        String::new()\n\
    \    } else {\n        String::from(chars.nth(vowel_index - 1).unwrap())\n   \
    \ }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `chars`\n   --> /tmp/tmp1x885v82.rs:29:22\n\
    \    |\n12  |     let mut chars = word.chars().rev();\n    |         ---------\
    \ move occurs because `chars` has type `Rev<Chars<'_>>`, which does not implement\
    \ the `Copy` trait\n...\n15  |     for (i, c) in chars.enumerate() {\n    |  \
    \                       ----------- `chars` moved due to this method call\n...\n\
    29  |         String::from(chars.nth(vowel_index - 1).unwrap())\n    |       \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n  \
    \  |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `chars`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel: String = \"\".to_string();\n\
    \    let mut consonant_count: u8 = 0;\n    let vowel_map: HashMap<char, char>\
    \ =\n        vec![('a', 'A'), ('e', 'E'), ('i', 'I'), ('o', 'O'), ('u', 'U')]\n\
    \            .into_iter()\n            .collect();\n    for (i, ch) in word.chars().rev().enumerate()\
    \ {\n        if consonant_count == 2 {\n            break;\n        }\n      \
    \  if vowel_map.contains_key(&ch) {\n            closest_vowel = ch.to_string();\n\
    \            break;\n        } else {\n            consonant_count += 1;\n   \
    \     }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmp3by_bf5q.rs:14:20\n\
    \   |\n14 |     let vowel_map: HashMap<char, char> =\n   |                   \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let word: Vec<char> = word.chars().collect();\n   \
    \ let vowels = \"aeiouAEIOU\";\n    for i in 0..word.len() {\n        if vowels.contains(word[i])\
    \ {\n            for j in (i + 1)..word.len() {\n                if vowels.contains(word[j])\
    \ {\n                    return String::from(\"\");\n                }\n     \
    \           if !vowels.contains(word[j]) {\n                    return word[j].to_string();\n\
    \                }\n            }\n        }\n    }\n    String::from(\"\")\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"g\"`,\n right: `\"u\"`', /tmp/tmpk1otbp_5.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut word = word.chars().rev().collect::<Vec<char>>();\n\
    \    if word.len() == 1 { return String::new(); }\n    let mut index = 0;\n  \
    \  while index < word.len() {\n        if word[index].is_vowel() {\n         \
    \   if index != 0 && word[index - 1].is_vowel() {\n                index += 1;\n\
    \                continue;\n            }\n            return word[index].to_string();\n\
    \        }\n        index += 1;\n    }\n    String::new()\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpghmk69ct.rs:16:24\n   |\n16 |         if word[index].is_vowel()\
    \ {\n   |                        ^^^^^^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `is_vowel` found for type `char` in the current scope\n  -->\
    \ /tmp/tmpghmk69ct.rs:17:46\n   |\n17 |             if index != 0 && word[index\
    \ - 1].is_vowel() {\n   |                                              ^^^^^^^^\
    \ method not found in `char`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut previous_char = None;\n    let mut closest_vowel:\
    \ Option<char> = None;\n    for (index, c) in word.chars().rev().enumerate() {\n\
    \        if index == 0 {\n            if is_vowel(c) {\n                return\
    \ c.to_string();\n            }\n        } else {\n            match previous_char\
    \ {\n                Some(prev) => {\n                    if is_vowel(prev) &&\
    \ !is_vowel(c) {\n                        closest_vowel = Some(prev);\n      \
    \                  break;\n                    }\n                },\n       \
    \         None => {}\n            }\n        }\n        previous_char = Some(c);\n\
    \    }\n    match closest_vowel {\n        Some(c) => c.to_string(),\n       \
    \ None => \"\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpijw9o5o9.rs:16:16\n\
    \   |\n16 |             if is_vowel(c) {\n   |                ^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `is_vowel` in this scope\n\
    \  --> /tmp/tmpijw9o5o9.rs:22:24\n   |\n22 |                     if is_vowel(prev)\
    \ && !is_vowel(c) {\n   |                        ^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpijw9o5o9.rs:22:43\n\
    \   |\n22 |                     if is_vowel(prev) && !is_vowel(c) {\n   |    \
    \                                       ^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j',\
    \ 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'z'];\n    let vowels\
    \ = ['a', 'e', 'i', 'o', 'u'];\n    let mut pos = 0;\n    let mut vowel_pos =\
    \ 0;\n    let mut vowel_finded = false;\n    let mut vowel_closest_dist = 0;\n\
    \    let mut chars = word.chars();\n    loop {\n        match chars.next() {\n\
    \            Some(c) => {\n                if consonants.contains(&c) {\n    \
    \                if vowel_finded {\n                        vowel_closest_dist\
    \ = pos - vowel_pos;\n                        vowel_finded = false;\n        \
    \            }\n                } else if vowels.contains(&c) {\n            \
    \        if !vowel_finded {\n                        vowel_pos = pos;\n      \
    \                  vowel_finded = true;\n                    } else if pos - vowel_pos\
    \ < vowel_closest_dist {\n                        vowel_closest_dist = pos - vowel_pos;\n\
    \                        vowel_pos = pos;\n                    }\n           \
    \     }\n                pos += 1;\n            },\n            None => break,\n\
    \        }\n    }\n    if vowel_finded {\n        return chars.clone().take(vowel_pos\
    \ + 1).collect();\n    }\n    return String::new();\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpaeblgztt.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    // This is not a very good algorithm, but it will do\
    \ for this exercise.\n    // You could make it less inefficient by replacing the\
    \ repeated string\n    // traversals with a single traversal that would determine\
    \ the nearest vowel\n    // in both directions and then return the nearest of\
    \ the two\n    let mut nearest_vowel_idx = None;\n    let mut nearest_vowel_dist\
    \ = 0;\n    let mut prev_vowel_idx = None;\n    let mut prev_vowel_dist = 0;\n\
    \    for (i, ch) in word.chars().enumerate() {\n        if ch == 'a' || ch ==\
    \ 'e' || ch == 'i' || ch == 'o' || ch == 'u' {\n            if prev_vowel_idx.is_none()\
    \ {\n                prev_vowel_idx = Some(i);\n                prev_vowel_dist\
    \ = i;\n            } else {\n                let dist = i - prev_vowel_idx.unwrap();\n\
    \                if prev_vowel_dist > dist {\n                    prev_vowel_dist\
    \ = dist;\n                    prev_vowel_idx = Some(i);\n                }\n\
    \            }\n        }\n    }\n    let len = word.len();\n    for (i, ch) in\
    \ word.chars().rev().enumerate() {\n        if ch == 'a' || ch == 'e' || ch ==\
    \ 'i' || ch == 'o' || ch == 'u' {\n            if nearest_vowel_idx.is_none()\
    \ {\n                nearest_vowel_idx = Some(len - i - 1);\n                nearest_vowel_dist\
    \ = i;\n            } else {\n                let dist = i - nearest_vowel_idx.unwrap();\n\
    \                if nearest_vowel_dist > dist {\n                    nearest_vowel_dist\
    \ = dist;\n                    nearest_vowel_idx = Some(len - i - 1);\n      \
    \          }\n            }\n        }\n    }\n    if prev_vowel_idx.is_none()\
    \ && nearest_vowel_idx.is_\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: expected `{`, found `}`\n  --> /tmp/tmp49whjkim.rs:50:1\n   |\n\
    49 |     if prev_vowel_idx.is_none() && nearest_vowel_idx.is_\n   |     -- this\
    \ `if` expression has a condition, but no block\n50 | }\n   | ^ expected `{`\n\
    \nerror: aborting due to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut index = 0;\n    for (i, c) in word.chars().rev().enumerate()\
    \ {\n        if \"aeiou\".contains(c) {\n            if i < word.len() - 1 &&\
    \ \"aeiou\".contains(word.chars().rev().nth(i + 1).unwrap()) {\n             \
    \   index = i + 1;\n            } else {\n                index = i;\n       \
    \     }\n            break;\n        }\n    }\n    word.chars().rev().nth(index).unwrap().to_string()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"e\"`,\n right: `\"\"`', /tmp/tmp9gn7nzp4.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    // TODO: Implemente\n    String::new()\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmp70lb6p6z.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    // unimplemented!(\"Find the closest vowel to the right\
    \ of {}\", word);\n    let mut vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    vowels.append(&mut\
    \ vec!['A', 'E', 'I', 'O', 'U']);\n    word.chars().rev().skip_while(|&c| !vowels.contains(&c)).skip(1).skip_while(|&c|\
    \ vowels.contains(&c)).next().map(|c| c.to_string()).unwrap_or(\"\".to_string())\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"g\"`,\n right: `\"u\"`', /tmp/tmp86m2bm_q.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = String::new();\n    let mut cons =\
    \ String::new();\n    let mut seperators = String::new();\n    let mut res = String::new();\n\
    \    for i in 0..word.len() {\n        if is_vowel(word.chars().nth(i).unwrap())\
    \ {\n            vowels.push(word.chars().nth(i).unwrap());\n        } else if\
    \ is_consonant(word.chars().nth(i).unwrap()) {\n            cons.push(word.chars().nth(i).unwrap());\n\
    \        } else {\n            seperators.push(word.chars().nth(i).unwrap());\n\
    \        }\n    }\n    for i in 0..cons.len() {\n        for j in 0..vowels.len()\
    \ {\n            if vowels.chars().nth(j).unwrap() < cons.chars().nth(i).unwrap()\
    \ {\n                if i == 0 {\n                    res.push(vowels.chars().nth(j).unwrap());\n\
    \                } else {\n                    if vowels.chars().nth(j).unwrap()\
    \ > cons.chars().nth(i - 1).unwrap() {\n                        res.push(vowels.chars().nth(j).unwrap());\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   if res.len() > 0 {\n        return res;\n    } else {\n        return String::from(\"\
    \");\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpqp451l6w.rs:17:12\n\
    \   |\n17 |         if is_vowel(word.chars().nth(i).unwrap()) {\n   |        \
    \    ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_consonant`\
    \ in this scope\n  --> /tmp/tmpqp451l6w.rs:19:19\n   |\n19 |         } else if\
    \ is_consonant(word.chars().nth(i).unwrap()) {\n   |                   ^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.split(\"\")\n        .rev()\n        .skip(1)\n\
    \        .zip(word.split(\"\").rev())\n        .find(|(left, right)| {\n     \
    \       let l = left.chars().nth(0).unwrap();\n            let r = right.chars().nth(0).unwrap();\n\
    \            is_vowel(l) && is_vowel(r)\n        })\n        .map(|(left, _)|\
    \ left.to_string())\n        .unwrap_or_else(|| \"\".to_string())\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpdydr2baw.rs:19:13\n\
    \   |\n19 |             is_vowel(l) && is_vowel(r)\n   |             ^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `is_vowel` in\
    \ this scope\n  --> /tmp/tmpdydr2baw.rs:19:28\n   |\n19 |             is_vowel(l)\
    \ && is_vowel(r)\n   |                            ^^^^^^^^ not found in this scope\n\
    \nerror[E0277]: the trait bound `StrSearcher<'_, '_>: DoubleEndedSearcher<'_>`\
    \ is not satisfied\n    --> /tmp/tmpdydr2baw.rs:13:10\n     |\n13   |        \
    \ .rev()\n     |          ^^^ the trait `DoubleEndedSearcher<'_>` is not implemented\
    \ for `StrSearcher<'_, '_>`\n     |\n     = help: the following other types implement\
    \ trait `DoubleEndedSearcher<'a>`:\n               CharPredicateSearcher<'a, F>\n\
    \               CharSearcher<'a>\n               CharSliceSearcher<'a, 'b>\n \
    \              pattern::MultiCharEqSearcher<'a, C>\n     = note: required because\
    \ of the requirements on the impl of `DoubleEndedIterator` for `std::str::Split<'_,\
    \ &str>`\nnote: required by a bound in `rev`\n\nerror[E0599]: the method `skip`\
    \ exists for struct `Rev<std::str::Split<'_, &str>>`, but its trait bounds were\
    \ not satisfied\n   --> /tmp/tmpdydr2baw.rs:14:10\n    |\n14  |           .skip(1)\n\
    \    |            ^^^^ method cannot be called on `Rev<std::str::Split<'_, &str>>`\
    \ due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds\
    \ were not satisfied:\n            `std::str::Split<'_, &str>: DoubleEndedIterator`\n\
    \            which is required by `Rev<std::str::Split<'_, &str>>: Iterator`\n\
    \            `Rev<std::str::Split<'_, &str>>: Iterator`\n            which is\
    \ required by `&mut Rev<std::str::Split<'_, &str>>: Iterator`\n\nerror[E0277]:\
    \ the trait bound `StrSearcher<'_, '_>: DoubleEndedSearcher<'_>` is not satisfied\n\
    \    --> /tmp/tmpdydr2baw.rs:15:29\n     |\n15   |         .zip(word.split(\"\"\
    ).rev())\n     |                             ^^^ the trait `DoubleEndedSearcher<'_>`\
    \ is not implemented for `StrSearcher<'_, '_>`\n     |\n     = help: the following\
    \ other t"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"AEIOU\";\n    let mut pos = 0;\n   \
    \ let mut ret = String::new();\n    let mut prev_char = ' ';\n    let mut prev_vowel\
    \ = ' ';\n    for i in (0..word.len()).rev() {\n        let ch = word.chars().nth(i).unwrap();\n\
    \        if vowels.contains(ch) {\n            prev_vowel = ch;\n            if\
    \ pos > 0 {\n                ret.push(prev_vowel);\n                break;\n \
    \           }\n        } else {\n            pos += 1;\n            if prev_vowel\
    \ != ' ' {\n                ret.push(prev_vowel);\n                break;\n  \
    \          }\n        }\n        prev_char = ch;\n    }\n    ret\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpibb6ax6t.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ prev_char = None;\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    for\
    \ character in word.chars().rev() {\n        if vowels.contains(&character) {\n\
    \            if prev_char.is_some() && prev_char.unwrap() != character {\n   \
    \             closest_vowel.push(character);\n                break;\n       \
    \     }\n        } else {\n            prev_char = Some(character);\n        }\n\
    \    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpbxcm09yn.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpllic877y.rs:12:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    for vowel in word.chars().rev() {\n        match vowel\
    \ {\n            'a' | 'e' | 'i' | 'o' | 'u' => {\n                return vowel.to_string();\n\
    \            }\n            _ => {}\n        }\n    }\n    \"\".to_string()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmp7gu4adwy.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"\
    ];\n    let mut vowel_indices = Vec::new();\n    let mut consonant_indices = Vec::new();\n\
    \    for (index, letter) in word.chars().enumerate() {\n        if vowels.contains(&letter.to_string().as_str())\
    \ {\n            vowel_indices.push(index);\n        } else {\n            consonant_indices.push(index);\n\
    \        }\n    }\n    let mut result = String::new();\n    for vowel_index in\
    \ vowel_indices {\n        for consonant_index in consonant_indices.iter().rev()\
    \ {\n            if vowel_index > *consonant_index {\n                result =\
    \ word.chars().nth(vowel_index).unwrap().to_string();\n                break;\n\
    \            }\n        }\n        if !result.is_empty() {\n            break;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpc7xuv3ea.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec![];\n    let mut consonants =\
    \ vec![];\n    for (i, c) in word.chars().enumerate() {\n        if \"aeiou\"\
    .contains(c) {\n            vowels.push(i);\n        } else {\n            consonants.push(i);\n\
    \        }\n    }\n    let v = vowels.iter().filter(|&&v| v > consonants.last().unwrap_or(&0)).min();\n\
    \    match v {\n        Some(v) => format!(\"{}\", word.chars().nth(*v).unwrap()),\n\
    \        None => String::new(),\n    }\n}\n\nfn main() {\n    let candidate =\
    \ get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaa1uax2c.rs:21:44\n   |\n\
    21 |     let v = vowels.iter().filter(|&&v| v > consonants.last().unwrap_or(&0)).min();\n\
    \   |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `&usize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n21 |     let v = vowels.iter().filter(|&&v| v > *consonants.last().unwrap_or(&0)).min();\n\
    \   |                                            +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    if word.len() < 3 {\n        return \"\".to_string();\n\
    \    }\n    let mut closest_vowel: Option<char> = None;\n    let mut flag = false;\n\
    \    for (i, c) in word.chars().rev().enumerate() {\n        if c == 'A' || c\
    \ == 'E' || c == 'I' || c == 'O' || c == 'U' {\n            closest_vowel = Some(c);\n\
    \            if flag {\n                break;\n            }\n        } else\
    \ {\n            flag = true;\n        }\n    }\n    closest_vowel.map(|v| v.to_string()).unwrap_or(\"\
    \".to_string())\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n  \
    \  assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n   \
    \ assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpczmcz71r.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"AEIOU\";\n    let mut chars = word.chars().rev().peekable();\n\
    \    let mut current = chars.next();\n    let mut prev = chars.peek();\n    while\
    \ current.is_some() {\n        if prev.is_some() &&\n            vowels.contains(current.unwrap())\
    \ &&\n            vowels.contains(prev.unwrap()) {\n            return String::new();\n\
    \        }\n        if vowels.contains(current.unwrap()) {\n            return\
    \ current.unwrap().to_string();\n        }\n        current = chars.next();\n\
    \        prev = chars.peek();\n    }\n    String::new()\n}\n\nfn main() {\n  \
    \  let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmpl6ruqfgv.rs:19:29\n\
    \     |\n19   |             vowels.contains(prev.unwrap()) {\n     |         \
    \           -------- ^^^^^^^^^^^^^ expected an `Fn<(char,)>` closure, found `char`\n\
    \     |                    |\n     |                    required by a bound introduced\
    \ by this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n     = note: required because of the requirements on the impl of\
    \ `FnOnce<(char,)>` for `&char`\n     = note: required because of the requirements\
    \ on the impl of `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl\
    \ str>::contains`\nhelp: consider dereferencing here\n     |\n19   |         \
    \    vowels.contains(*prev.unwrap()) {\n     |                             +\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.char_indices()\n        .rev()\n        .scan(None,\
    \ |state, (i, c)| {\n            match *state {\n                None => {\n \
    \                   if \"AEIOU\".contains(c) {\n                        *state\
    \ = Some(i);\n                    }\n                }\n                Some(a)\
    \ => {\n                    if \"AEIOU\".contains(c) {\n                     \
    \   *state = Some(i);\n                    } else if \"AEIOU\".contains(word.chars().nth(a\
    \ + 1).unwrap()) {\n                        *state = None;\n                 \
    \       return Some(Some(a));\n                    }\n                }\n    \
    \        }\n            None\n        })\n        .filter_map(|x| x)\n       \
    \ .nth(0)\n        .map(|x| word.chars().nth(x).unwrap().to_string())\n      \
    \  .unwrap_or(\"\".to_string())\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpelez_2xi.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    let consonants\
    \ = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's',\
    \ 't', 'v', 'w', 'x', 'y', 'z'];\n    let word_vec: Vec<char> = word.chars().collect();\n\
    \    let mut vowel_found: String = \"\".to_string();\n    let mut prev_consonant:\
    \ String = \"\".to_string();\n    let mut next_consonant: String = \"\".to_string();\n\
    \    for i in (0..word_vec.len()).rev() {\n        if consonants.contains(&word_vec[i])\
    \ {\n            prev_consonant = word_vec[i].to_string();\n            break;\n\
    \        }\n    }\n    for i in 0..word_vec.len() {\n        if consonants.contains(&word_vec[i])\
    \ {\n            next_consonant = word_vec[i].to_string();\n            break;\n\
    \        }\n    }\n    if prev_consonant == \"\" || next_consonant == \"\" {\n\
    \        return \"\".to_string();\n    }\n    let mut vowel_distance = word_vec.len();\n\
    \    for i in 0..word_vec.len() {\n        if vowels.contains(&word_vec[i]) {\n\
    \            let mut distance_vowel_prev_consonant = 0;\n            let mut distance_vowel_next_consonant\
    \ = 0;\n            for j in (0..i).rev() {\n                if consonants.contains(&word_vec[j])\
    \ {\n                    distance_vowel_prev_consonant = i - j;\n            \
    \        break;\n                }\n            }\n            for j in i..word_vec.len()\
    \ {\n                if consonants.contains(&word_vec[j]) {\n                \
    \    distance_vowel_next_consonant = j - i;\n                    break;\n    \
    \            }\n            }\n            if\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmps0tiju08.rs:68:3\n\
    \   |\n11 | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n34 |     for i in\
    \ 0..word_vec.len() {\n   |                                - unclosed delimiter\n\
    35 |         if vowels.contains(&word_vec[i]) {\n   |                        \
    \                  - this delimiter might not be properly closed...\n...\n51 |\
    \ }\n   | - ...as it matches this but it has different indentation\n...\n68 |\
    \ }\n   |   ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmps0tiju08.rs:51:1\n\
    \   |\n51 | }\n   | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmps0tiju08.rs:34:5\n   |\n11 |   fn get_closest_vowel(word: String)\
    \ -> String {\n   |                                         ------ expected `String`\
    \ because of return type\n...\n34 | /     for i in 0..word_vec.len() {\n35 | |\
    \         if vowels.contains(&word_vec[i]) {\n36 | |             let mut distance_vowel_prev_consonant\
    \ = 0;\n37 | |             let mut distance_vowel_next_consonant = 0;\n...  |\n\
    67 | |     assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    68 | | }\n   | |__^ expected struct `String`, found `()`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    if word.len() <= 2 {\n        return String::new();\n\
    \    }\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let is_vowel = |c:\
    \ char| vowels.contains(&c);\n    let mut front_consonant_found = false;\n   \
    \ let mut closest_vowel = ' ';\n    let mut closest_vowel_index = word.len();\n\
    \    for (i, c) in word.chars().rev().enumerate() {\n        if is_vowel(c) {\n\
    \            if !front_consonant_found {\n                closest_vowel = c;\n\
    \                closest_vowel_index = i;\n            } else {\n            \
    \    break;\n            }\n        } else {\n            front_consonant_found\
    \ = true;\n        }\n    }\n    if closest_vowel == ' ' {\n        String::new()\n\
    \    } else {\n        word.chars().skip(word.len() - closest_vowel_index - 1).take(1).collect()\n\
    \    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpbzsg6x08.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let word: Vec<char> = word.chars().collect();\n   \
    \ for i in 0..word.len() {\n        if (i+1) < word.len() && is_vowel(word[i+1])\
    \ && !is_vowel(word[i]) {\n            return word[i+1].to_string();\n       \
    \ }\n    }\n    \"\".to_string()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp_5t6gi3p.rs:14:34\n\
    \   |\n14 |         if (i+1) < word.len() && is_vowel(word[i+1]) && !is_vowel(word[i])\
    \ {\n   |                                  ^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp_5t6gi3p.rs:14:58\n\
    \   |\n14 |         if (i+1) < word.len() && is_vowel(word[i+1]) && !is_vowel(word[i])\
    \ {\n   |                                                          ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut res = \"\".to_string();\n    let mut prev =\
    \ '\\0';\n    let mut next = '\\0';\n    let mut chars = word.chars().rev();\n\
    \    for c in chars.by_ref() {\n        if is_vowel(c) {\n            res = c.to_string();\n\
    \            break;\n        }\n        next = c;\n    }\n    if !res.is_empty()\
    \ {\n        for c in chars {\n            if is_vowel(prev) && is_vowel(next)\
    \ {\n                break;\n            }\n            if is_vowel(prev) && !is_vowel(next)\
    \ {\n                res = prev.to_string();\n                break;\n       \
    \     }\n            prev = next;\n            next = c;\n        }\n    }\n \
    \   res\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpogqfijaw.rs:17:12\n\
    \   |\n17 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `is_vowel` in this scope\n  -->\
    \ /tmp/tmpogqfijaw.rs:25:16\n   |\n25 |             if is_vowel(prev) && is_vowel(next)\
    \ {\n   |                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `is_vowel` in this scope\n  --> /tmp/tmpogqfijaw.rs:25:34\n  \
    \ |\n25 |             if is_vowel(prev) && is_vowel(next) {\n   |            \
    \                      ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `is_vowel` in this scope\n  --> /tmp/tmpogqfijaw.rs:28:16\n  \
    \ |\n28 |             if is_vowel(prev) && !is_vowel(next) {\n   |           \
    \     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_vowel`\
    \ in this scope\n  --> /tmp/tmpogqfijaw.rs:28:35\n   |\n28 |             if is_vowel(prev)\
    \ && !is_vowel(next) {\n   |                                   ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 5 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n  let vowels = \"aeiouAEIOU\";\n  let chars: Vec<char>\
    \ = word.chars().collect();\n  for i in (0..chars.len()).rev() {\n    if vowels.contains(chars[i])\
    \ {\n      if i > 0 && !vowels.contains(chars[i - 1]) {\n        return chars[i].to_string();\n\
    \      }\n      if i < chars.len() - 1 && !vowels.contains(chars[i + 1]) {\n \
    \       return chars[i].to_string();\n      }\n    }\n  }\n  \"\".to_string()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmp8jproi33.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let chars: Vec<char> = word.chars().collect();\n\
    \    let mut count = 0;\n    let char_len = chars.len();\n    for c in chars.iter().rev()\
    \ {\n        count += 1;\n        if vowels.contains(&c.to_string().as_str())\
    \ {\n            if count > 2 && count < char_len - 1 {\n                result\
    \ = c.to_string();\n                break;\n            }\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmp3fqeytc8.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let word = word.chars().rev().collect::<Vec<char>>();\n\
    \    for i in 1..word.len() {\n        if !word[i].is_vowel() && word[i - 1].is_vowel()\
    \ {\n            return word[i - 1].to_string();\n        }\n    }\n    \"\".to_string()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp_1snf5_l.rs:14:21\n   |\n14 |         if !word[i].is_vowel()\
    \ && word[i - 1].is_vowel() {\n   |                     ^^^^^^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `is_vowel` found for type `char`\
    \ in the current scope\n  --> /tmp/tmp_1snf5_l.rs:14:47\n   |\n14 |         if\
    \ !word[i].is_vowel() && word[i - 1].is_vowel() {\n   |                      \
    \                         ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.rmatch(|c| \"AEIOUaeiou\".contains(c))\n     \
    \   .and_then(|(s, pos)| s.find(|c| \"AEIOUaeiou\".contains(c))\n            \
    \                  .map(|vowel_pos| (pos + vowel_pos, s.chars().nth(vowel_pos).unwrap())))\n\
    \        .map(|(_, c)| c.to_string())\n        .unwrap_or(\"\".to_string())\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `rmatch` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpzak02jm9.rs:12:10\n   |\n12 |     word.rmatch(|c|\
    \ \"AEIOUaeiou\".contains(c))\n   |          ^^^^^^ help: there is an associated\
    \ function with a similar name: `rmatches`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiou\";\n    for (i, &ch) in word.chars().rev().enumerate()\
    \ {\n        let ch_lower = ch.to_lowercase().next().unwrap();\n        if vowels.contains(ch_lower)\
    \ {\n            if i < word.len() - 1 {\n                let next_ch = word.chars().rev().nth(i\
    \ + 1).unwrap();\n                if !vowels.contains(next_ch.to_lowercase().next().unwrap())\
    \ {\n                    return ch.to_string();\n                }\n         \
    \   }\n        }\n    }\n    \"\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp0hpz299.rs:13:13\n   |\n\
    13 |     for (i, &ch) in word.chars().rev().enumerate() {\n   |             ^^^\
    \     ------------------------------ this expression has type `Option<(usize,\
    \ char)>`\n   |             |\n   |             expected `char`, found reference\n\
    \   |             help: you can probably remove the explicit borrow: `ch`\n  \
    \ |\n   = note:   expected type `char`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    if word.len() < 3 {\n        return String::new();\n\
    \    }\n    for (i, c) in word.char_indices().rev() {\n        if is_vowel(c)\
    \ {\n            let is_front_c_vowel = is_vowel(word.chars().nth(i - 1).unwrap());\n\
    \            let is_back_c_vowel = is_vowel(word.chars().nth(i + 1).unwrap());\n\
    \            if !is_front_c_vowel && !is_back_c_vowel {\n                return\
    \ c.to_string();\n            }\n        }\n    }\n    String::new()\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp4sbab61k.rs:16:12\n\
    \   |\n16 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `is_vowel` in this scope\n  -->\
    \ /tmp/tmp4sbab61k.rs:17:36\n   |\n17 |             let is_front_c_vowel = is_vowel(word.chars().nth(i\
    \ - 1).unwrap());\n   |                                    ^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `is_vowel` in this scope\n\
    \  --> /tmp/tmp4sbab61k.rs:18:35\n   |\n18 |             let is_back_c_vowel =\
    \ is_vowel(word.chars().nth(i + 1).unwrap());\n   |                          \
    \         ^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    // Write your code here\n    let vowels = [\"a\", \"\
    e\", \"i\", \"o\", \"u\"];\n    let word = word.chars().rev().collect::<String>();\n\
    \    for (i, ch) in word.chars().enumerate() {\n        if vowels.contains(&ch.to_string().as_str())\
    \ {\n            if i+1 < word.len() && !vowels.contains(&word.chars().nth(i+1).unwrap().to_string().as_str())\
    \ {\n                return word.chars().nth(i).unwrap().to_string();\n      \
    \      }\n        }\n    }\n    \"\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"i\"`,\n right: `\"\"`', /tmp/tmpod7sn7ai.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    let chars:\
    \ Vec<char> = word.chars().collect();\n    let mut min = (std::u32::MAX, std::u32::MAX);\n\
    \    for i in 0..chars.len() {\n        if !vowels.contains(&chars[i]) {\n   \
    \         continue;\n        }\n        for j in (i + 1)..chars.len() {\n    \
    \        if vowels.contains(&chars[j]) {\n                break;\n           \
    \ }\n            if min.0 == std::u32::MAX {\n                min = (i as u32,\
    \ j as u32);\n            } else if min.1 > j as u32 {\n                min =\
    \ (i as u32, j as u32);\n            }\n        }\n    }\n    if min.0 == std::u32::MAX\
    \ {\n        return String::from(\"\");\n    }\n    chars[min.0 as usize].to_string()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmp2o27ro3v.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiou\";\n    let (mut first_vowel,\
    \ mut found_first) = (String::new(), false);\n    let mut it = word.chars().rev().peekable();\n\
    \    while let Some(c) = it.next() {\n        if !found_first && vowels.contains(c)\
    \ {\n            first_vowel = c.to_string();\n            found_first = true;\n\
    \        } else if found_first && vowels.contains(c) {\n            return first_vowel;\n\
    \        } else if found_first && !vowels.contains(c) {\n            return String::new();\n\
    \        }\n    }\n    String::new()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpzq7qw20f.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpeq86rxzf.rs:12:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    // ...\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpno_puu_c.rs:11:39\n   |\n\
    11 | fn get_closest_vowel(word: String) -> String {\n   |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n   |    |\n  \
    \ |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ start_pos = 0;\n    for (i, c) in word.chars().enumerate() {\n        if c.is_vowel()\
    \ {\n            closest_vowel = c.to_string();\n            start_pos = i;\n\
    \            break;\n        }\n    }\n    for c in word.chars().skip(start_pos\
    \ + 1) {\n        if c.is_vowel() {\n            closest_vowel = c.to_string();\n\
    \        } else {\n            break;\n        }\n    }\n    if closest_vowel.is_empty()\
    \ {\n        closest_vowel\n    } else {\n        closest_vowel.to_lowercase()\n\
    \    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp0qpl0t48.rs:15:14\n   |\n15 |         if c.is_vowel() {\n\
    \   |              ^^^^^^^^ method not found in `char`\n\nerror[E0599]: no method\
    \ named `is_vowel` found for type `char` in the current scope\n  --> /tmp/tmp0qpl0t48.rs:22:14\n\
    \   |\n22 |         if c.is_vowel() {\n   |              ^^^^^^^^ method not found\
    \ in `char`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.split(|c: char| \"AEIOU\".contains(c))\n     \
    \   .fold(vec![], |mut acc, seq| {\n            let seq = seq.chars().rev().collect::<String>();\n\
    \            if seq.len() > 1 {\n                acc.push(seq);\n            }\n\
    \            acc\n        })\n        .into_iter()\n        .filter(|seq| {\n\
    \            !seq.chars().all(|c| c.is_lowercase()) &&\n            !seq.chars().all(|c|\
    \ c.is_uppercase())\n        })\n        .next()\n        .map(|seq| seq.chars().next().unwrap().to_string())\n\
    \        .unwrap_or(\"\".to_string())\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpm7414prg.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let word_lower\
    \ = word.to_lowercase();\n    let word_chars = word_lower.chars().collect::<Vec<char>>();\n\
    \    let mut vowel_index = vec![];\n    for i in 0..word_chars.len() {\n     \
    \   if is_vowel(word_chars[i]) {\n            vowel_index.push(i);\n        }\n\
    \    }\n    for i in 0..vowel_index.len() {\n        if i == 0 {\n           \
    \ if vowel_index[i] != 0 {\n                result = word[vowel_index[i]..(vowel_index[i]\
    \ + 1)].to_string();\n                break;\n            }\n        } else {\n\
    \            if vowel_index[i] - vowel_index[i - 1] != 1 {\n                result\
    \ = word[vowel_index[i - 1]..(vowel_index[i - 1] + 1)].to_string();\n        \
    \        break;\n            }\n        }\n    }\n    if result.is_empty() {\n\
    \        if vowel_index.len() == 0 {\n            result = \"\".to_string();\n\
    \        } else {\n            result = word[vowel_index[vowel_index.len() - 1]..(vowel_index[vowel_index.len()\
    \ - 1] + 1)].to_string();\n        }\n    }\n    result\n}\n\nfn main() {\n  \
    \  let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp2ano4r81.rs:17:12\n\
    \   |\n17 |         if is_vowel(word_chars[i]) {\n   |            ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut res = \"\".to_string();\n    let v = ['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut index = word.len() - 1;\n    for i in (0..word.len()).rev()\
    \ {\n        if v.contains(&word.chars().nth(i).unwrap()) {\n            res =\
    \ word.chars().nth(i).unwrap().to_string();\n            index = i;\n        }\
    \ else {\n            break;\n        }\n    }\n    if index > 0 && index < word.len()\
    \ - 1 {\n        res\n    } else {\n        \"\".to_string()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmp6icof1cj.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut last_cons = None;\n    let mut last_vowel =\
    \ None;\n    for (i, c) in word.chars().enumerate() {\n        match c {\n   \
    \         'a' | 'e' | 'i' | 'o' | 'u' => {\n                if let Some(last_cons)\
    \ = last_cons {\n                    if last_vowel.is_none() || last_vowel.unwrap()\
    \ < last_cons {\n                        last_vowel = Some(i);\n             \
    \       }\n                }\n            }\n            _ => {\n            \
    \    last_cons = Some(i);\n            }\n        }\n    }\n    if let Some(last_vowel)\
    \ = last_vowel {\n        word.chars().nth(last_vowel).unwrap().to_string()\n\
    \    } else {\n        \"\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"i\"`,\n right: `\"\"`', /tmp/tmppsb4pwcu.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().rev().skip_while(|&c| !is_vowel(c)).\n\
    \        skip_while(|&c| is_vowel(c)).take_while(|&c| !is_vowel(c)).\n       \
    \ take_while(|&c| is_vowel(c)).collect()\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpgndiw4ya.rs:12:41\n\
    \   |\n12 |     word.chars().rev().skip_while(|&c| !is_vowel(c)).\n   |      \
    \                                   ^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_vowel` in this scope\n  --> /tmp/tmpgndiw4ya.rs:13:25\n\
    \   |\n13 |         skip_while(|&c| is_vowel(c)).take_while(|&c| !is_vowel(c)).\n\
    \   |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_vowel` in this scope\n  --> /tmp/tmpgndiw4ya.rs:13:55\n\
    \   |\n13 |         skip_while(|&c| is_vowel(c)).take_while(|&c| !is_vowel(c)).\n\
    \   |                                                       ^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `is_vowel` in this scope\n\
    \  --> /tmp/tmpgndiw4ya.rs:14:25\n   |\n14 |         take_while(|&c| is_vowel(c)).collect()\n\
    \   |                         ^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in word.chars().rev()\
    \ {\n        if c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' {\n \
    \           result.push(c);\n            break;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpod541uzk.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().rev().skip_while(|c| \"AEIOUaeiou\".contains(*c)).skip(1).take_while(|c|\
    \ !\"AEIOUaeiou\".contains(*c)).rev().collect()\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `TakeWhile<Skip<SkipWhile<Rev<Chars<'_>>,\
    \ [closure@/tmp/tmpb0l8022z.rs:12:35: 12:64]>>, [closure@/tmp/tmpb0l8022z.rs:12:85:\
    \ 12:115]>: DoubleEndedIterator` is not satisfied\n    --> /tmp/tmpb0l8022z.rs:12:117\n\
    \     |\n12   |     word.chars().rev().skip_while(|c| \"AEIOUaeiou\".contains(*c)).skip(1).take_while(|c|\
    \ !\"AEIOUaeiou\".contains(*c)).rev().collect()\n     |                      \
    \                                                                            \
    \                   ^^^ the trait `DoubleEndedIterator` is not implemented for\
    \ `TakeWhile<Skip<SkipWhile<Rev<Chars<'_>>, [closure@/tmp/tmpb0l8022z.rs:12:35:\
    \ 12:64]>>, [closure@/tmp/tmpb0l8022z.rs:12:85: 12:115]>`\n     |\nnote: required\
    \ by a bound in `rev`\n\nerror[E0599]: the method `collect` exists for struct\
    \ `Rev<TakeWhile<Skip<SkipWhile<Rev<Chars<'_>>, [closure@/tmp/tmpb0l8022z.rs:12:35:\
    \ 12:64]>>, [closure@/tmp/tmpb0l8022z.rs:12:85: 12:115]>>`, but its trait bounds\
    \ were not satisfied\n  --> /tmp/tmpb0l8022z.rs:12:123\n   |\n12 |        word.chars().rev().skip_while(|c|\
    \ \"AEIOUaeiou\".contains(*c)).skip(1).take_while(|c| !\"AEIOUaeiou\".contains(*c)).rev().collect()\n\
    \   |                                                                        \
    \                                                      ^^^^^^^ method cannot be\
    \ called on `Rev<TakeWhile<Skip<SkipWhile<Rev<Chars<'_>>, [closure@/tmp/tmpb0l8022z.rs:12:35:\
    \ 12:64]>>, [closure@/tmp/tmpb0l8022z.rs:12:85: 12:115]>>` due to unsatisfied\
    \ trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `TakeWhile<Skip<SkipWhile<Rev<Chars<'_>>, [closure@/tmp/tmpb0l8022z.rs:12:35:\
    \ 12:64]>>, [closure@/tmp/tmpb0l8022z.rs:12:85: 12:115]>: DoubleEndedIterator`\n\
    \           which is required by `Rev<TakeWhile<Skip<SkipWhile<Rev<Chars<'_>>,\
    \ [closure@/tmp/tmpb0l8022z.rs:12:35: 12:64]>>, [closure@/tmp/tmpb0l8022z.rs:12:85:\
    \ 12:115]>>: Iterator`\n           `Rev<TakeWhile<Skip<SkipWhile<Rev<Chars<'_>>,\
    \ [closure@/tmp/tmpb0l8022z.rs:12:35: 12:64]>>, [closure@/tmp/tmpb0l8022z.rs:12:85:\
    \ 12:115]>>:"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut prev_letter = None;\n    let mut closest_vowel\
    \ = None;\n    for letter in word.chars().rev() {\n        if closest_vowel.is_some()\
    \ {\n            break;\n        }\n        if is_vowel(letter) {\n          \
    \  prev_letter = Some(letter);\n        } else if prev_letter.is_some() {\n  \
    \          closest_vowel = prev_letter;\n        }\n    }\n    closest_vowel.map(|letter|\
    \ letter.to_string()).unwrap_or(\"\".to_string())\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpk3igubtb.rs:18:12\n\
    \   |\n18 |         if is_vowel(letter) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"AEIOUaeiou\";\n    let mut result =\
    \ String::new();\n    let mut found = false;\n    let letters: Vec<char> = word.chars().collect();\n\
    \    for i in (0..letters.len()).rev() {\n        if vowels.contains(letters[i])\
    \ {\n            if i != 0 && i != letters.len() - 1 {\n                if !vowels.contains(letters[i\
    \ - 1]) && !vowels.contains(letters[i + 1]) {\n                    result.push(letters[i]);\n\
    \                    found = true;\n                    break;\n             \
    \   }\n            }\n        }\n    }\n    if !found {\n        result = String::from(\"\
    \");\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    let mut\
    \ first_consonant = None;\n    let mut last_consonant = None;\n    let mut closest_vowel\
    \ = None;\n    let mut vowel_distance = 0;\n    let mut vowel_index = 0;\n   \
    \ let mut consonant_index = 0;\n    for (i, c) in word.chars().enumerate() {\n\
    \        if vowels.contains(&c) {\n            vowel_index = i;\n            if\
    \ closest_vowel.is_none() {\n                closest_vowel = Some(c);\n      \
    \          vowel_distance = i;\n            } else if last_consonant.is_some()\
    \ && (vowel_index - consonant_index) < vowel_distance {\n                closest_vowel\
    \ = Some(c);\n                vowel_distance = i - consonant_index;\n        \
    \    }\n        } else {\n            consonant_index = i;\n            if closest_vowel.is_some()\
    \ {\n                last_consonant = Some(c);\n            } else {\n       \
    \         first_consonant = Some(c);\n            }\n        }\n    }\n    if\
    \ closest_vowel.is_some() && last_consonant.is_some() {\n        return closest_vowel.unwrap().to_string();\n\
    \    }\n    return \"\".to_string();\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmp3_c8yhh1.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let s = word.chars().rev().skip_while(|c| c.is_ascii_lowercase()\
    \ || c.is_ascii_uppercase()).collect::<String>();\n    let p = s.chars().skip_while(|c|\
    \ !(c.is_ascii_lowercase() || c.is_ascii_uppercase())).collect::<String>();\n\
    \    if p.is_empty() {\n        return \"\".to_string();\n    }\n    let v = p.chars().take_while(|c|\
    \ c.is_ascii_lowercase() || c.is_ascii_uppercase()).collect::<String>();\n   \
    \ if v.is_empty() {\n        return \"\".to_string();\n    }\n    let r = v.chars().rev().skip_while(|c|\
    \ !(c.is_ascii_lowercase() || c.is_ascii_uppercase())).collect::<String>();\n\
    \    if r.is_empty() {\n        return \"\".to_string();\n    }\n    let mut max_d\
    \ = 0.0;\n    let mut res = \"\".to_string();\n    for c in r.chars() {\n    \
    \    if !is_vowel(c) {\n            continue;\n        }\n        let d = res.chars().zip(c.to_string().chars()).map(|(x,\
    \ y)| if x == y { 0.0 } else { 1.0 }).sum::<f64>();\n        if max_d < d {\n\
    \            max_d = d;\n            res = c.to_string();\n        }\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp90ce5imh.rs:28:13\n\
    \   |\n28 |         if !is_vowel(c) {\n   |             ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp7iao3fbk.rs:12:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let word = word.chars().rev().collect::<Vec<char>>();\n\
    \    let mut result = String::new();\n    let mut counter = 0;\n    while counter\
    \ < word.len() {\n        if !word[counter].is_alphabetic() {\n            break;\n\
    \        }\n        if word[counter].is_vowel() {\n            result.push(word[counter]);\n\
    \            break;\n        }\n        counter += 1;\n    }\n    if result.is_empty()\
    \ {\n        return String::new();\n    }\n    result.chars().rev().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpbvq1c6y8.rs:19:26\n   |\n19 |         if word[counter].is_vowel()\
    \ {\n   |                          ^^^^^^^^ method not found in `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"AEIOUaeiou\";\n    let mut vowel_pos\
    \ = -1;\n    let mut current_pos = -1;\n    for ch in word.chars().rev() {\n \
    \       current_pos += 1;\n        if vowels.contains(ch) {\n            vowel_pos\
    \ = current_pos;\n        } else if vowel_pos != -1 {\n            return word[word.len()\
    \ - 1 - vowel_pos..word.len() - vowel_pos].to_string();\n        }\n    }\n  \
    \  String::new()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n \
    \   assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n  \
    \  assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmptvnpl_0m.rs:13:25\n\
    \   |\n13 |     let mut vowel_pos = -1;\n   |                         ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n  --> /tmp/tmptvnpl_0m.rs:14:27\n   |\n14 | \
    \    let mut current_pos = -1;\n   |                           ^^ the trait `Neg`\
    \ is not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0277]: the trait bound `usize:\
    \ Neg` is not satisfied\n  --> /tmp/tmptvnpl_0m.rs:19:32\n   |\n19 |         }\
    \ else if vowel_pos != -1 {\n   |                                ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    if word.is_empty() {\n        return \"\".to_string();\n\
    \    }\n    let mut result = \"\".to_string();\n    let len = word.len();\n  \
    \  let chars: Vec<char> = word.chars().collect();\n    let mut l_consonant = true;\n\
    \    let mut r_consonant = true;\n    let mut l_vowel = \"\".to_string();\n  \
    \  let mut r_vowel = \"\".to_string();\n    for (i, c) in chars.iter().enumerate()\
    \ {\n        let pos = len - i - 1;\n        if !is_vowel(*c) {\n            r_consonant\
    \ = true;\n            if l_consonant {\n                if !l_vowel.is_empty()\
    \ {\n                    if r_vowel.is_empty() {\n                        result\
    \ = l_vowel.clone();\n                    } else {\n                        if\
    \ pos - l_vowel.len() > r_vowel.len() {\n                            result =\
    \ r_vowel.clone();\n                        } else {\n                       \
    \     result = l_vowel.clone();\n                        }\n                 \
    \   }\n                    break;\n                }\n            }\n        }\
    \ else {\n            if r_consonant {\n                r_vowel = c.to_string();\n\
    \            }\n            r_consonant = false;\n        }\n        if !is_vowel(*c)\
    \ {\n            l_consonant = true;\n        } else {\n            if l_consonant\
    \ {\n                l_vowel = c.to_string();\n            }\n            l_consonant\
    \ = false;\n        }\n    }\n    if l_consonant && !l_vowel.is_empty() {\n  \
    \      result = l_vowel;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp3yyoad5i.rs:24:13\n\
    \   |\n24 |         if !is_vowel(*c) {\n   |             ^^^^^^^^ help: a local\
    \ variable with a similar name exists: `l_vowel`\n\nerror[E0425]: cannot find\
    \ function `is_vowel` in this scope\n  --> /tmp/tmp3yyoad5i.rs:46:13\n   |\n46\
    \ |         if !is_vowel(*c) {\n   |             ^^^^^^^^ help: a local variable\
    \ with a similar name exists: `l_vowel`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiouAEIOU\";\n    let mut a: Vec<char>\
    \ = word.chars().rev().collect();\n    let mut i = 0;\n    while i < a.len() -\
    \ 1 {\n        if vowels.contains(a[i + 1]) && vowels.contains(a[i]) {\n     \
    \       return String::new();\n        }\n        if vowels.contains(a[i]) &&\
    \ !vowels.contains(a[i + 1]) {\n            return String::from(vowels.chars().find(|&c|\
    \ c == a[i]).unwrap().to_string());\n        }\n        i += 1;\n    }\n    String::new()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"i\"`,\n right: `\"\"`', /tmp/tmpha_foq56.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    let chars:\
    \ Vec<char> = word.chars().collect();\n    let mut last_consonant_index = 0;\n\
    \    let mut result = String::new();\n    for (i, c) in chars.iter().enumerate().rev()\
    \ {\n        if vowels.contains(c) {\n            let consonant_index = last_consonant_index;\n\
    \            if consonant_index > 0 && i + 1 < chars.len() {\n               \
    \ let consonant_right = &chars[consonant_index];\n                let consonant_left\
    \ = &chars[i + 1];\n                if consonant_right.is_ascii_alphabetic() &&\
    \ consonant_left.is_ascii_alphabetic() {\n                    result.push(*c);\n\
    \                    break;\n                }\n            }\n        } else\
    \ {\n            last_consonant_index = i;\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpyfn6w5k5.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp6f4sq2x3.rs:12:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiouAEIOU\";\n    let mut index = 0;\n\
    \    for (i, c) in word.chars().rev().enumerate() {\n        if vowels.contains(c)\
    \ {\n            index = i;\n            break;\n        }\n    }\n    let mut\
    \ end = 0;\n    for (i, c) in word.chars().rev().enumerate() {\n        if !vowels.contains(c)\
    \ {\n            end = i;\n            break;\n        }\n    }\n    if index\
    \ == 0 || end == 0 {\n        return String::from(\"\");\n    }\n    if index\
    \ <= end {\n        return String::from(\"\");\n    }\n    let mut result = String::from(\"\
    \");\n    for (i, c) in word.chars().rev().enumerate() {\n        if vowels.contains(c)\
    \ {\n            result.push(c);\n            if i == end + 1 {\n            \
    \    break;\n            }\n        }\n    }\n    result.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmppynp46sn.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut start_index\
    \ = 0;\n    let mut end_index = 0;\n    let mut flag = false;\n    let mut counter\
    \ = 0;\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut find_vowel\
    \ = false;\n    for (i, c) in word.chars().enumerate() {\n        if !find_vowel\
    \ && (vowels.contains(&c) || counter == 2) {\n            find_vowel = true;\n\
    \            start_index = i;\n        }\n        if find_vowel && !vowels.contains(&c)\
    \ {\n            end_index = i;\n            counter += 1;\n        }\n      \
    \  if counter == 2 {\n            flag = true;\n            break;\n        }\n\
    \    }\n    for c in word.chars().skip(start_index).take(end_index - start_index)\
    \ {\n        if vowels.contains(&c) {\n            result.push(c);\n        }\n\
    \    }\n    if !flag {\n        result = String::new();\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ou\"`,\n right: `\"u\"`', /tmp/tmp_4vijoim.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ (last_index, last_char) = word.char_indices().last().unwrap();\n    let mut\
    \ char_indices = word.char_indices().skip(1);\n    if !vowels.contains(&last_char)\
    \ {\n        char_indices = char_indices.take(last_index - 1);\n    }\n    char_indices\n\
    \        .filter(|&(_, c)| vowels.contains(&c))\n        .fold((&\"\", &\"\"),\
    \ |(best_pos, best_vowel), pos| {\n            if pos.0 >= best_pos.0 {\n    \
    \            (pos, best_vowel)\n            } else {\n                (best_pos,\
    \ pos.1.to_string())\n            }\n        })\n        .1\n        .to_string()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp94mkl70q.rs:16:24\n   |\n\
    14 |     let mut char_indices = word.char_indices().skip(1);\n   |           \
    \                 --------------------------- expected due to this value\n15 |\
    \     if !vowels.contains(&last_char) {\n16 |         char_indices = char_indices.take(last_index\
    \ - 1);\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Skip`, found struct `std::iter::Take`\n   |\n   = note: expected struct\
    \ `Skip<CharIndices<'_>>`\n              found struct `std::iter::Take<Skip<CharIndices<'_>>>`\n\
    \nerror[E0609]: no field `0` on type `&&str`\n  --> /tmp/tmp94mkl70q.rs:21:34\n\
    \   |\n21 |             if pos.0 >= best_pos.0 {\n   |                       \
    \           ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp94mkl70q.rs:22:18\n\
    \   |\n22 |                 (pos, best_vowel)\n   |                  ^^^ expected\
    \ `&&str`, found tuple\n   |\n   = note: expected reference `&&str`\n        \
    \          found tuple `(usize, char)`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp94mkl70q.rs:24:28\n   |\n24 |                 (best_pos, pos.1.to_string())\n\
    \   |                            ^^^^^^^^^^^^^^^^^ expected `&&str`, found struct\
    \ `String`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0609.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiou\";\n    let letters: Vec<char>\
    \ = word.chars().collect();\n    let mut cons = 0;\n    let mut cur_vowel = String::new();\n\
    \    for i in (0..letters.len()).rev() {\n        if vowels.contains(letters[i])\
    \ {\n            if cons > 1 {\n                return cur_vowel;\n          \
    \  }\n            cur_vowel = letters[i].to_string();\n        } else {\n    \
    \        cons += 1;\n        }\n    }\n    \"\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmp39ynjedb.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiouAEIOU\";\n    let mut result =\
    \ String::new();\n    let mut word = word.chars().rev().collect::<Vec<char>>();\n\
    \    while word.len() > 0 {\n        let c = word.pop().unwrap();\n        if\
    \ vowels.contains(c) {\n            result.push(c);\n            break;\n    \
    \    }\n    }\n    while word.len() > 0 {\n        let c = word.pop().unwrap();\n\
    \        if vowels.contains(c) {\n            break;\n        }\n        result.push(c);\n\
    \    }\n    result.chars().rev().collect::<String>()\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"go\"`,\n right: `\"u\"`', /tmp/tmpv591yf8p.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let chars: Vec<char> = word.chars().collect();\n  \
    \  let mut closest_vowel = String::new();\n    for i in (0..chars.len()).rev()\
    \ {\n        if is_consonant(chars[i]) {\n            if i > 0 && is_vowel(chars[i\
    \ - 1]) {\n                closest_vowel.push(chars[i - 1]);\n               \
    \ break;\n            } else if i + 1 < chars.len() && is_vowel(chars[i + 1])\
    \ {\n                closest_vowel.push(chars[i + 1]);\n                break;\n\
    \            }\n        }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_consonant` in this scope\n  -->\
    \ /tmp/tmpuntbb7qu.rs:15:12\n   |\n15 |         if is_consonant(chars[i]) {\n\
    \   |            ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `is_vowel` in this scope\n  --> /tmp/tmpuntbb7qu.rs:16:25\n  \
    \ |\n16 |             if i > 0 && is_vowel(chars[i - 1]) {\n   |             \
    \            ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `is_vowel` in this scope\n  --> /tmp/tmpuntbb7qu.rs:19:46\n   |\n19 |      \
    \       } else if i + 1 < chars.len() && is_vowel(chars[i + 1]) {\n   |      \
    \                                        ^^^^^^^^ not found in this scope\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = \"\".to_string();\n    let mut closest_idx\
    \ = -1;\n    let mut closest_distance = -1;\n    let mut last_consonant_idx =\
    \ -1;\n    let mut consonant_count = 0;\n    let mut last_vowel_idx = -1;\n  \
    \  let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut has_vowel = false;\n\
    \    for (i, c) in word.char_indices() {\n        if vowels.contains(&c) {\n \
    \           last_vowel_idx = i;\n            has_vowel = true;\n        } else\
    \ {\n            consonant_count += 1;\n            if consonant_count > 1 {\n\
    \                let distance = last_vowel_idx - last_consonant_idx;\n       \
    \         if distance < closest_distance || closest_distance == -1 {\n       \
    \             closest_distance = distance;\n                    closest_idx =\
    \ last_vowel_idx;\n                }\n            }\n            last_consonant_idx\
    \ = i;\n        }\n    }\n    if closest_idx > -1 {\n        result = word.chars().nth(closest_idx).unwrap().to_string();\n\
    \    }\n    if !has_vowel {\n        result = \"\".to_string();\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpxp2451q5.rs:17:30\n\
    \   |\n17 |     let mut last_vowel_idx = -1;\n   |                           \
    \   ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the following\
    \ other types implement trait `Neg`:\n             &f32\n             &f64\n \
    \            &i128\n             &i16\n             &i32\n             &i64\n\
    \             &i8\n             &isize\n           and 8 others\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpxp2451q5.rs:15:34\n\
    \   |\n15 |     let mut last_consonant_idx = -1;\n   |                       \
    \           ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help:\
    \ the following other types implement trait `Neg`:\n             &f32\n      \
    \       &f64\n             &i128\n             &i16\n             &i32\n     \
    \        &i64\n             &i8\n             &isize\n           and 8 others\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpxp2451q5.rs:14:32\n\
    \   |\n14 |     let mut closest_distance = -1;\n   |                         \
    \       ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the\
    \ following other types implement trait `Neg`:\n             &f32\n          \
    \   &f64\n             &i128\n             &i16\n             &i32\n         \
    \    &i64\n             &i8\n             &isize\n           and 8 others\n\n\
    error[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpxp2451q5.rs:28:71\n\
    \   |\n28 |                 if distance < closest_distance || closest_distance\
    \ == -1 {\n   |                                                              \
    \         ^^\n   |                                                           \
    \            |\n   |                                                         \
    \              cannot apply unary operator `-`\n   |                         \
    \                                              help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror[E0277]: the trait bound `usize"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().enumerate().rev().find_map(|(i,c)| if\
    \ c.is_vowel() { Some(i) } else { None }).and_then(|i| word.chars().skip(i).find_map(|c|\
    \ if c.is_vowel() { Some(c.to_string()) } else { None })).unwrap_or(\"\".to_string())\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmpithgri5i.rs:12:30\n     |\n12   |     word.chars().enumerate().rev().find_map(|(i,c)|\
    \ if c.is_vowel() { Some(i) } else { None }).and_then(|i| word.chars().skip(i).find_map...\n\
    \     |                              ^^^ the trait `ExactSizeIterator` is not\
    \ implemented for `Chars<'_>`\n     |\n     = help: the following other types\
    \ implement trait `ExactSizeIterator`:\n               &mut I\n              \
    \ Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n        \
    \       ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n    \
    \           Box<I, A>\n               Chunks<'_, T>\n             and 109 others\n\
    \     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Enumerate<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0599]:\
    \ the method `find_map` exists for struct `Rev<Enumerate<Chars<'_>>>`, but its\
    \ trait bounds were not satisfied\n  --> /tmp/tmpithgri5i.rs:12:36\n   |\n12 |\
    \       word.chars().enumerate().rev().find_map(|(i,c)| if c.is_vowel() { Some(i)\
    \ } else { None }).and_then(|i| word.chars().skip(i).find_map...\n   |       \
    \                               ^^^^^^^^ method cannot be called on `Rev<Enumerate<Chars<'_>>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `Enumerate<Chars<'_>>: DoubleEndedIterator`\n\
    \           which is required by `Rev<Enumerate<Chars<'_>>>: Iterator`\n\nerror[E0599]:\
    \ no method named `is_vowel` found for type `char` in the current scope\n  -->\
    \ /tmp/tmpithgri5i.rs:12:148\n   |\n12 | ..._then(|i| word.chars().skip(i).find_map(|c|\
    \ if c.is_vowel() { Some(c.to_string()) } else { None })).unwrap_or(\"\".to_string())\n\
    \   |                                                     ^^^^^^^^ method not\
    \ found in `char`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut pos = 0;\n    let chars: Vec<char> = word.chars().collect();\n    if chars.len()\
    \ < 3 {\n        return \"\".to_string();\n    }\n    loop {\n        pos += 1;\n\
    \        if pos >= chars.len() - 1 {\n            break;\n        }\n        if\
    \ vowels.contains(&chars[pos]) {\n            if !vowels.contains(&chars[pos -\
    \ 1]) && !vowels.contains(&chars[pos + 1]) {\n                return chars[pos].to_string();\n\
    \            }\n        }\n    }\n    \"\".to_string()\n}\n\nfn main() {\n   \
    \ let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpid9139d5.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiou\";\n    let mut letter_count =\
    \ 0;\n    let mut cons_count = 0;\n    let mut current_vowel = \"\";\n    for\
    \ c in word.chars().rev() {\n        if vowels.contains(c) {\n            letter_count\
    \ += 1;\n            current_vowel = c.to_string();\n        } else {\n      \
    \      if letter_count > 0 {\n                cons_count += 1;\n            }\n\
    \            if cons_count == 2 {\n                return current_vowel;\n   \
    \         }\n        }\n    }\n    \"\".to_string()\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9fq_ik6o.rs:19:29\n   |\n\
    15 |     let mut current_vowel = \"\";\n   |                             -- expected\
    \ due to this value\n...\n19 |             current_vowel = c.to_string();\n  \
    \ |                             ^^^^^^^^^^^^^\n   |                          \
    \   |\n   |                             expected `&str`, found struct `String`\n\
    \   |                             help: consider borrowing here: `&c.to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9fq_ik6o.rs:25:24\n   |\n25 |\
    \                 return current_vowel;\n   |                        ^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \      |\n   |                        expected struct `String`, found `&str`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp72uyhive.rs:12:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    // Your code here!\n    let consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n    let vowels = \"aeiouAEIOU\";\n    let mut result = \"\".to_string();\n\
    \    let mut i = word.len() - 1;\n    let mut j = i;\n    let mut temp: Vec<&str>\
    \ = vec![];\n    for _ in 0..word.len() {\n        if consonants.contains(word.get(i..i+1).unwrap())\
    \ {\n            if i == 0 {\n                temp.push(\"\");\n             \
    \   break;\n            }\n            i -= 1;\n        } else {\n           \
    \ if i == 0 {\n                break;\n            }\n            while i >= 0\
    \ {\n                if vowels.contains(word.get(i..i+1).unwrap()) {\n       \
    \             temp.push(word.get(i..i+1).unwrap());\n                    i -=\
    \ 1;\n                } else {\n                    break;\n                }\n\
    \            }\n            i = j - 1;\n        }\n    }\n    if temp.len() !=\
    \ 0 {\n        result = temp[0].to_string();\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpawp6oq_5.rs:33:21\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ reverse_chars: Vec<char> = word.chars().rev().collect();\n    let mut closest_vowel\
    \ = ' ';\n    let mut prev_letter = ' ';\n    let mut next_letter = ' ';\n   \
    \ for i in 1..reverse_chars.len() - 1 {\n        next_letter = reverse_chars[i];\n\
    \        prev_letter = reverse_chars[i - 1];\n        for vowel in vowels.iter()\
    \ {\n            if next_letter == *vowel && prev_letter != *vowel {\n       \
    \         closest_vowel = *vowel;\n                break;\n            }\n   \
    \     }\n        if closest_vowel != ' ' {\n            break;\n        }\n  \
    \  }\n    if closest_vowel == ' ' {\n        return String::from(\"\");\n    }\n\
    \    return closest_vowel.to_string();\n}\n\nfn main() {\n    let candidate =\
    \ get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpj2nr7dk5.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    // TODO!\n    \"\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpv_yt6l9h.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut i = word.len() - 1;\n    let mut idx = 0;\n    let mut cons = true;\n  \
    \  let mut vowel = false;\n    while i > 0 {\n        if vowels.contains(&word.chars().nth(i).unwrap())\
    \ {\n            vowel = true;\n            if cons {\n                idx = i;\n\
    \                break;\n            }\n        } else {\n            cons = true;\n\
    \        }\n        i -= 1;\n    }\n    if vowel {\n        format!(\"{}\", word.chars().nth(idx).unwrap())\n\
    \    } else {\n        \"\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpewebvz4v.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    // for (var i = word.length - 1; i > 0; i--) {\n  \
    \  //     if (is_vowel(word[i]) && !is_vowel(word[i - 1])) {\n    //         return\
    \ word[i];\n    //     }\n    // }\n    // return \"\";\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpvddqngps.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let word = word.into_bytes();\n    let mut index =\
    \ 0;\n    for i in (0..word.len()).rev() {\n        if !is_vowel(word[i]) {\n\
    \            index = i + 1;\n            break;\n        }\n    }\n    if index\
    \ == 0 {\n        return String::new();\n    }\n    if index == word.len() {\n\
    \        return String::new();\n    }\n    let mut right_index = index;\n    for\
    \ i in index..word.len() {\n        if is_vowel(word[i]) {\n            right_index\
    \ = i;\n            break;\n        }\n    }\n    if right_index == index {\n\
    \        return String::new();\n    }\n    let mut left_index = index;\n    for\
    \ i in (0..index).rev() {\n        if is_vowel(word[i]) {\n            left_index\
    \ = i;\n            break;\n        }\n    }\n    if right_index - index > index\
    \ - left_index {\n        return String::from_utf8(vec![word[left_index]]).unwrap();\n\
    \    } else {\n        return String::from_utf8(vec![word[right_index]]).unwrap();\n\
    \    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp1i6gnp3e.rs:15:13\n\
    \   |\n15 |         if !is_vowel(word[i]) {\n   |             ^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `is_vowel` in this scope\n\
    \  --> /tmp/tmp1i6gnp3e.rs:28:12\n   |\n28 |         if is_vowel(word[i]) {\n\
    \   |            ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `is_vowel` in this scope\n  --> /tmp/tmp1i6gnp3e.rs:38:12\n   |\n38\
    \ |         if is_vowel(word[i]) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let consonants = \"bcdfghjklmnpqrstvwxyz\";\n    let\
    \ vowels = \"aeiou\";\n    let mut closest_vowel: char = ' ';\n    let mut dist\
    \ = word.len();\n    let mut found = false;\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if consonants.find(c) != None {\n            let sub_vowels = &word[i..];\n\
    \            for (j,v) in sub_vowels.chars().enumerate() {\n                if\
    \ vowels.find(v) != None {\n                    if j < dist {\n              \
    \          dist = j;\n                        closest_vowel = v;\n           \
    \             found = true;\n                    }\n                    break;\n\
    \                }\n            }\n        }\n    }\n    if found {\n        closest_vowel.to_string()\n\
    \    } else {\n        \"\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmprt89odue.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"AEIOU\";\n    let chars: Vec<char> =\
    \ word.chars().collect();\n    let n = chars.len();\n    for i in 0..n {\n   \
    \     if vowels.contains(chars[i]) {\n            if i+1 < n && vowels.contains(chars[i+1])\
    \ {\n                return chars[i+1].to_string();\n            }\n        }\n\
    \    }\n    return \"\".to_string();\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmp1mee5spd.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut last_consonant = None;\n    let mut first_vowel\
    \ = None;\n    for (i, c) in word.chars().enumerate() {\n        if c.is_alphabetic()\
    \ {\n            if !c.is_vowel() {\n                last_consonant = Some(i);\n\
    \            } else if last_consonant.is_some() {\n                first_vowel\
    \ = Some(i);\n                break;\n            }\n        }\n    }\n    if\
    \ last_consonant.is_none() || first_vowel.is_none() {\n        return String::new();\n\
    \    }\n    let mut vowel = None;\n    for (i, c) in word.chars().enumerate().rev()\
    \ {\n        if c.is_alphabetic() {\n            if c.is_vowel() {\n         \
    \       vowel = Some(i);\n            } else if vowel.is_some() {\n          \
    \      break;\n            }\n        }\n    }\n    let vowel = vowel.unwrap();\n\
    \    if vowel > last_consonant.unwrap() && vowel < first_vowel.unwrap() {\n  \
    \      return word.chars().nth(vowel).unwrap().to_string();\n    }\n    String::new()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpbpcr92g4.rs:16:19\n   |\n16 |             if !c.is_vowel()\
    \ {\n   |                   ^^^^^^^^ method not found in `char`\n\nerror[E0277]:\
    \ the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n    --> /tmp/tmpbpcr92g4.rs:28:44\n\
    \     |\n28   |     for (i, c) in word.chars().enumerate().rev() {\n     |   \
    \                                         ^^^ the trait `ExactSizeIterator` is\
    \ not implemented for `Chars<'_>`\n     |\n     = help: the following other types\
    \ implement trait `ExactSizeIterator`:\n               &mut I\n              \
    \ Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n        \
    \       ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n    \
    \           Box<I, A>\n               Chunks<'_, T>\n             and 109 others\n\
    \     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Enumerate<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0277]:\
    \ the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n  --> /tmp/tmpbpcr92g4.rs:28:19\n\
    \   |\n28 |     for (i, c) in word.chars().enumerate().rev() {\n   |         \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator` is not\
    \ implemented for `Chars<'_>`\n   |\n   = help: the following other types implement\
    \ trait `ExactSizeIterator`:\n             &mut I\n             Args\n       \
    \      ArgsOs\n             ArrayChunks<'_, T, N>\n             ArrayChunksMut<'_,\
    \ T, N>\n             ArrayWindows<'_, T, N>\n             Box<I, A>\n       \
    \      Chunks<'_, T>\n           and 109 others\n   = note: required because of\
    \ the requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \   = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\n\nerror[E0599]:\
    \ no method named `is_vowel` found for type `char` in the current scope\n  -->\
    \ /tmp/tmpbp"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    let mut\
    \ res = String::new();\n    let mut c0 = '\\0';\n    let mut c1 = '\\0';\n   \
    \ for c in word.chars().rev() {\n        if vowels.contains(&c) {\n          \
    \  if c0 != '\\0' && c1 != '\\0' {\n                break;\n            }\n  \
    \          res.push(c);\n        } else {\n            if c0 == '\\0' {\n    \
    \            c0 = c;\n            } else if c1 == '\\0' {\n                c1\
    \ = c;\n            }\n        }\n    }\n    res.chars().rev().collect()\n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmplmxwrmt1.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut char_vec: Vec<char> = word.chars().collect();\n\
    \    let mut vowel_index: i32 = -1;\n    let mut vowel_count: i32 = 0;\n    for\
    \ i in (0..char_vec.len()).rev() {\n        if is_vowel(char_vec[i]) {\n     \
    \       vowel_count += 1;\n            if vowel_count == 2 {\n               \
    \ vowel_index = i as i32;\n                break;\n            }\n        }\n\
    \    }\n    if vowel_index != -1 {\n        return char_vec[vowel_index as usize].to_string();\n\
    \    }\n    return \"\".to_string();\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp1eid7puz.rs:16:12\n\
    \   |\n16 |         if is_vowel(char_vec[i]) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp8eqcabdn.rs:12:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n\
    \    let mut first_letter = 0;\n    let mut second_letter = 0;\n    let mut first_is_vowel\
    \ = false;\n    let mut second_is_vowel = false;\n    let mut first_found = false;\n\
    \    let mut second_found = false;\n    let mut closest_vowel = String::new();\n\
    \    let char_vec: Vec<char> = word.chars().collect();\n    let length = char_vec.len();\n\
    \    let last_index = length - 1;\n    for i in (0..length).rev() {\n        if\
    \ first_found && second_found {\n            break;\n        } else if first_found\
    \ && second_is_vowel {\n            second_letter = i;\n            second_found\
    \ = true;\n        } else if first_is_vowel {\n            first_letter = i;\n\
    \            first_found = true;\n        } else if first_letter == last_index\
    \ {\n            break;\n        } else if vowels.contains(&char_vec[i].to_string().as_str())\
    \ {\n            first_is_vowel = true;\n        }\n    }\n    if first_letter\
    \ != 0 && second_letter != 0 {\n        if first_letter - second_letter <= 1 {\n\
    \            closest_vowel = char_vec[first_letter].to_string();\n        } else\
    \ {\n            closest_vowel = char_vec[second_letter].to_string();\n      \
    \  }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpd7uf68so.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = String::from(\"aeiouAEIOU\");\n    let\
    \ mut res = String::new();\n    let mut is_consonant = word.chars().last().unwrap().is_ascii_lowercase();\n\
    \    for c in word.chars().rev() {\n        let is_consonant_next = c.is_ascii_lowercase();\n\
    \        if vowels.contains(c) && is_consonant && is_consonant_next {\n      \
    \      res.push(c);\n            break;\n        }\n        is_consonant = is_consonant_next;\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n  \
    \  assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n   \
    \ assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmps1zbv0l3.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let word = word.chars().rev().collect::<Vec<char>>();\n\
    \    let map = vec!['a', 'e', 'i', 'o', 'u'];\n    for i in 0..word.len() - 1\
    \ {\n        if !map.contains(&word[i]) && map.contains(&word[i + 1]) {\n    \
    \        return word[i + 1].to_string();\n        }\n    }\n    String::new()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpbikvq7zw.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.split(|c: char| !is_vowel(c)).skip(1).nth(0).unwrap_or(\"\
    \").to_string()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n  \
    \  assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n   \
    \ assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmptee1fm0p.rs:12:27\n\
    \   |\n12 |     word.split(|c: char| !is_vowel(c)).skip(1).nth(0).unwrap_or(\"\
    \").to_string()\n   |                           ^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().rev().skip_while(|&c| !is_vowel(c)).skip(1).take_while(|&c|\
    \ !is_vowel(c)).collect()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp_mlq249a.rs:12:41\n\
    \   |\n12 |     word.chars().rev().skip_while(|&c| !is_vowel(c)).skip(1).take_while(|&c|\
    \ !is_vowel(c)).collect()\n   |                                         ^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `is_vowel` in\
    \ this scope\n  --> /tmp/tmp_mlq249a.rs:12:79\n   |\n12 |     word.chars().rev().skip_while(|&c|\
    \ !is_vowel(c)).skip(1).take_while(|&c| !is_vowel(c)).collect()\n   |        \
    \                                                                       ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"AEIOUaeiou\";\n    let mut res = \"\"\
    .to_string();\n    for (i, c) in word.chars().rev().enumerate() {\n        if\
    \ vowels.contains(c) {\n            if i < word.len() - 1 && i > 0 {\n       \
    \         if !vowels.contains(word.chars().rev().nth(i + 1).unwrap()) && !vowels.contains(word.chars().rev().nth(i\
    \ - 1).unwrap()) {\n                    res = c.to_string();\n               \
    \     break;\n                }\n            }\n        }\n    }\n    res\n}\n\
    \nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest = \"\";\n    let mut closest_index\
    \ = 0;\n    for (index, letter) in word.chars().enumerate().rev() {\n        if\
    \ !is_vowel(letter) {\n            if closest.is_empty() {\n                continue;\n\
    \            }\n            break;\n        }\n        closest = &word[index..index\
    \ + 1];\n        closest_index = index;\n    }\n    if closest_index == 0 {\n\
    \        return String::from(\"\");\n    }\n    for (index, letter) in word.chars().enumerate().rev()\
    \ {\n        if is_vowel(letter) {\n            continue;\n        }\n       \
    \ if index < closest_index {\n            return String::from(\"\");\n       \
    \ }\n        break;\n    }\n    String::from(closest)\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp3t0eb1z7.rs:15:13\n\
    \   |\n15 |         if !is_vowel(letter) {\n   |             ^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `is_vowel` in this scope\n\
    \  --> /tmp/tmp3t0eb1z7.rs:28:12\n   |\n28 |         if is_vowel(letter) {\n \
    \  |            ^^^^^^^^ not found in this scope\n\nerror[E0277]: the trait bound\
    \ `Chars<'_>: ExactSizeIterator` is not satisfied\n    --> /tmp/tmp3t0eb1z7.rs:14:53\n\
    \     |\n14   |     for (index, letter) in word.chars().enumerate().rev() {\n\
    \     |                                                     ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\n     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Enumerate<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0277]:\
    \ the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n  --> /tmp/tmp3t0eb1z7.rs:14:28\n\
    \   |\n14 |     for (index, letter) in word.chars().enumerate().rev() {\n   |\
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n   |\n   = help: the following other types\
    \ implement trait `ExactSizeIterator`:\n             &mut I\n             Args\n\
    \             ArgsOs\n             ArrayChunks<'_, T, N>\n             ArrayChunksMut<'_,\
    \ T, N>\n             ArrayWindows<'_, T, N>\n             Box<I, A>\n       \
    \      Chunks<'_, T>\n           and 109 others\n   = note: required because of\
    \ the requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \   = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n   = note: required becaus"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().rev().skip_while(|&c| !c.is_ascii_alphabetic()).skip(1).skip_while(|&c|\
    \ !c.is_ascii_alphabetic()).take_while(|&c| !c.is_ascii_alphabetic()).filter(|&c|\
    \ c.is_ascii_lowercase()).map(|c| c.to_ascii_uppercase()).next().unwrap_or('\\\
    0').to_string()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n  \
    \  assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n   \
    \ assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\0\"`,\n right: `\"u\"`', /tmp/tmp3c5hiav3.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    if word.len() < 3 {\n        return String::new();\n\
    \    }\n    let vowel_vec = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut vowel_index\
    \ = 0;\n    let mut consonant_counter = 0;\n    let mut vowel_counter = 0;\n \
    \   let mut return_string = String::new();\n    for ch in word.chars().rev() {\n\
    \        if vowel_vec.contains(&ch) {\n            vowel_counter += 1;\n     \
    \       vowel_index = vowel_counter;\n            if consonant_counter >= 2 {\n\
    \                return_string.push(ch);\n                break;\n           \
    \ }\n        } else {\n            consonant_counter += 1;\n        }\n    }\n\
    \    for _ in 0..vowel_index {\n        return_string.pop();\n    }\n    return_string\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmp7f30l14a.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut current_closest = String::new();\n    for c\
    \ in word.chars().rev() {\n        match c {\n            'a' | 'e' | 'i' | 'o'\
    \ | 'u' => {\n                if current_closest.is_empty() {\n              \
    \      current_closest.push(c);\n                } else {\n                  \
    \  return String::from(current_closest);\n                }\n            },\n\
    \            _ => {\n                if !current_closest.is_empty() {\n      \
    \              current_closest.clear();\n                }\n            }\n  \
    \      }\n    }\n    String::new()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpeumhm9ii.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = String::from(\"aeiouAEIOU\");\n    let mut vowel_index = 0;\n    let mut last_consonant_index\
    \ = 0;\n    let mut iter = word.chars().rev().enumerate();\n    let mut is_it_first_consonant\
    \ = true;\n    while let Some((i, c)) = iter.next() {\n        if vowels.contains(c)\
    \ {\n            vowel_index = i;\n            continue;\n        } else {\n \
    \           if is_it_first_consonant {\n                is_it_first_consonant\
    \ = false;\n                last_consonant_index = i;\n                continue;\n\
    \            } else {\n                break;\n            }\n        }\n    }\n\
    \    if is_it_first_consonant {\n        return result;\n    }\n    let distance_to_first_consonant\
    \ = last_consonant_index + 1;\n    let distance_to_second_consonant = vowel_index\
    \ + 1;\n    if distance_to_first_consonant >= distance_to_second_consonant {\n\
    \        result.push(word.chars().nth(word.len() - distance_to_second_consonant).unwrap());\n\
    \    } else {\n        result.push(word.chars().nth(word.len() - distance_to_first_consonant).unwrap());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"t\"`,\n right: `\"u\"`', /tmp/tmp4dbdalhy.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut res: usize = 0;\n    for (i, c) in word.chars().rev().enumerate() {\n  \
    \      if vowels.contains(&c) {\n            res = i;\n            break;\n  \
    \      }\n    }\n    word.chars().rev().skip(res + 1).take(1).collect()\n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"g\"`,\n right: `\"u\"`', /tmp/tmp94bgosl7.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp7p2_tem2.rs:12:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiouAEIOU\";\n    let mut ptr = word.len()\
    \ - 1;\n    let mut found = false;\n    let mut vowel = \"\";\n    while ptr >\
    \ 0 {\n        let ch = word.chars().nth(ptr);\n        match ch {\n         \
    \   Some(c) => {\n                if vowels.contains(c) {\n                  \
    \  found = true;\n                    vowel = c.to_string();\n               \
    \ } else if found {\n                    return vowel;\n                }\n  \
    \          },\n            None => return \"\".to_string()\n        }\n      \
    \  ptr -= 1;\n    }\n    return \"\".to_string();\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0om6cffa.rs:22:29\n   |\n\
    15 |     let mut vowel = \"\";\n   |                     -- expected due to this\
    \ value\n...\n22 |                     vowel = c.to_string();\n   |          \
    \                   ^^^^^^^^^^^^^\n   |                             |\n   |  \
    \                           expected `&str`, found struct `String`\n   |     \
    \                        help: consider borrowing here: `&c.to_string()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0om6cffa.rs:24:28\n   |\n24 |              \
    \       return vowel;\n   |                            ^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                            |\n   |\
    \                            expected struct `String`, found `&str`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().rev().skip_while(|&c| !c.is_alphabetic()).skip(1).take_while(|&c|\
    \ !c.is_alphabetic()).filter(|&c| \"aeiou\".contains(c)).next().map(|c| c.to_string()).unwrap_or(\"\
    \".to_string())\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n  \
    \  assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n   \
    \ assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpa6fx6x52.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = \"\";\n    let mut pos = 0;\n\
    \    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let word = word.to_lowercase();\n\
    \    let word = word.chars().collect::<Vec<char>>();\n    let word_size = word.len();\n\
    \    let mut prev_vowel = true;\n    while pos < word_size {\n        if vowels.contains(&word[pos])\
    \ {\n            if !prev_vowel {\n                break;\n            }\n   \
    \         pos += 1;\n            prev_vowel = true;\n        } else {\n      \
    \      prev_vowel = false;\n            pos += 1;\n        }\n    }\n    pos -=\
    \ 1;\n    if pos > 0 {\n        closest_vowel = word[pos].to_string().to_uppercase().as_str();\n\
    \    }\n    return closest_vowel.to_string();\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmpi4t3xc2c.rs:33:25\n\
    \   |\n33 |         closest_vowel = word[pos].to_string().to_uppercase().as_str();\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^         - temporary\
    \ value is freed at the end of this statement\n   |                         |\n\
    \   |                         creates a temporary which is freed while still in\
    \ use\n34 |     }\n35 |     return closest_vowel.to_string();\n   |          \
    \  ------------------------- borrow later used here\n   |\n   = note: consider\
    \ using a `let` binding to create a longer lived value\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0716`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n  unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp_ohw3_2x.rs:12:3\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    // TODO: implement\n    return \"\".to_string();\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmph81xu16a.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    word.chars().rev().skip(1).zip(word.chars()).find(|(a,\
    \ b)| {\n        a.is_alphabetic() && b.is_alphabetic() && !vowels.contains(&a.to_ascii_lowercase())\
    \ && vowels.contains(&b.to_ascii_lowercase())\n    }).map(|(a, _)| a.to_string()).unwrap_or(\"\
    \".to_string())\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n  \
    \  assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n   \
    \ assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpkij4k0dv.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().rev().skip_while(|&c| !c.is_ascii_alphabetic()).skip(1).skip_while(|&c|\
    \ !c.is_ascii_alphabetic()).skip(1).take_while(|&c| c.is_ascii_alphabetic()).skip_while(|&c|\
    \ !c.is_ascii_vowel()).take(1).collect()\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_ascii_vowel` found for type `char` in\
    \ the current scope\n  --> /tmp/tmp3nem7j64.rs:12:184\n   |\n12 | ...ic()).skip_while(|&c|\
    \ !c.is_ascii_vowel()).take(1).collect()\n   |                             ^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"AEIOU\";\n    let mut is_consonant =\
    \ true;\n    let mut last_vowel_index = None;\n    let mut last_consonant_index\
    \ = None;\n    let mut result = String::new();\n    for (i, c) in word.char_indices().rev()\
    \ {\n        if vowels.contains(c) {\n            is_consonant = false;\n    \
    \        last_vowel_index = Some(i);\n        } else if !is_consonant {\n    \
    \        last_consonant_index = Some(i);\n            break;\n        }\n    }\n\
    \    if let (Some(i), Some(j)) = (last_vowel_index, last_consonant_index) {\n\
    \        if i > j {\n            for ch in word.chars().skip(j + 1).take(i - j\
    \ - 1) {\n                result.push(ch);\n            }\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmp3jq1nk7h.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().rev().fold((\"\", ' '), |(acc, last),\
    \ c| {\n        if acc.is_empty() && !c.is_vowel() {\n            (acc, c)\n \
    \       } else if c.is_vowel() && !last.is_vowel() {\n            (c.to_string(),\
    \ c)\n        } else {\n            (acc, c)\n        }\n    }).0\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpmkeztr1b.rs:13:33\n   |\n13 |         if acc.is_empty()\
    \ && !c.is_vowel() {\n   |                                 ^^^^^^^^ method not\
    \ found in `char`\n\nerror[E0599]: no method named `is_vowel` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpmkeztr1b.rs:15:21\n   |\n15 |         }\
    \ else if c.is_vowel() && !last.is_vowel() {\n   |                     ^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `is_vowel` found\
    \ for type `char` in the current scope\n  --> /tmp/tmpmkeztr1b.rs:15:41\n   |\n\
    15 |         } else if c.is_vowel() && !last.is_vowel() {\n   |              \
    \                           ^^^^^^^^ method not found in `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmkeztr1b.rs:16:14\n   |\n16 |             (c.to_string(),\
    \ c)\n   |              ^^^^^^^^^^^^^\n   |              |\n   |             \
    \ expected `&str`, found struct `String`\n   |              help: consider borrowing\
    \ here: `&c.to_string()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmkeztr1b.rs:12:5\n\
    \   |\n11 |   fn get_closest_vowel(word: String) -> String {\n   |           \
    \                              ------ expected `String` because of return type\n\
    12 | /     word.chars().rev().fold((\"\", ' '), |(acc, last), c| {\n13 | |   \
    \      if acc.is_empty() && !c.is_vowel() {\n14 | |             (acc, c)\n15 |\
    \ |         } else if c.is_vowel() && !last.is_vowel() {\n...  |\n19 | |     \
    \    }\n20 | |     }).0\n   | |        ^- help: try using a conversion method:\
    \ `.to_string()`\n   | |________|\n   |          expected struct `String`, found\
    \ `&str`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let result: String = String::new();\n    let words:\
    \ Vec<char> = word.chars().collect();\n    let vowels: HashSet<char> = ['a', 'e',\
    \ 'i', 'o', 'u'].iter().cloned().collect();\n    let mut start: usize = 0;\n \
    \   for i in words.iter().rev() {\n        if vowels.contains(i) {\n         \
    \   start = words.len() - words.iter().rev().position(|&x| x == *i).unwrap() -\
    \ 1;\n            break;\n        }\n    }\n    if start == 0 {\n        return\
    \ result;\n    }\n    let mut closest_vowel: char = '0';\n    let mut distance:\
    \ usize = 0;\n    for i in (start..words.len()).rev() {\n        if vowels.contains(&words[i])\
    \ {\n            let temp: usize = words.len() - i - 1;\n            if closest_vowel\
    \ == '0' {\n                closest_vowel = words[i];\n                distance\
    \ = temp;\n            } else if temp < distance {\n                closest_vowel\
    \ = words[i];\n                distance = temp;\n            }\n        }\n  \
    \  }\n    closest_vowel.to_string()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp29ru140j.rs:14:17\n\
    \   |\n14 |     let vowels: HashSet<char> = ['a', 'e', 'i', 'o', 'u'].iter().cloned().collect();\n\
    \   |                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let is_vowel = |c: &char| c == &'a' || c == &'e' ||\
    \ c == &'i' || c == &'o' || c == &'u';\n    let mut vowels: Vec<char> = word.chars().filter(|c|\
    \ is_vowel(c)).collect();\n    let mut last_consonant = word.chars().rev().take_while(|c|\
    \ !is_vowel(c)).count();\n    if last_consonant == word.len() {\n        return\
    \ String::new();\n    }\n    last_consonant = word.len() - last_consonant;\n \
    \   while let Some(c) = vowels.pop() {\n        if c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u' {\n            return c.to_string();\n        }\n\
    \    }\n    String::new()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpr9sx9dbv.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    for (i, c) in word.chars().rev().enumerate() {\n  \
    \      if i > 1 && is_vowel(c) {\n            return c.to_string();\n        }\n\
    \    }\n    \"\".to_string()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpfxppa3de.rs:13:21\n\
    \   |\n13 |         if i > 1 && is_vowel(c) {\n   |                     ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiouAEIOU\";\n    let consonants =\
    \ \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    let mut prev_char = 0 as\
    \ char;\n    let mut prev_char_is_c = false;\n    let mut min_vowel_char = 0 as\
    \ char;\n    let mut min_vowel_dist = 0;\n    let mut found_vowel = false;\n \
    \   for ch in word.chars() {\n        if vowels.contains(ch) {\n            if\
    \ prev_char_is_c {\n                if !found_vowel {\n                    min_vowel_char\
    \ = ch;\n                    min_vowel_dist = 1;\n                    found_vowel\
    \ = true;\n                } else {\n                    min_vowel_dist += 1;\n\
    \                }\n            }\n        } else if consonants.contains(ch) {\n\
    \            prev_char_is_c = true;\n        }\n        prev_char = ch;\n    }\n\
    \    if found_vowel {\n        min_vowel_char.to_string()\n    } else {\n    \
    \    \"\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpqqb1l2_l.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp3ihr1wgk.rs:12:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.char_indices()\n        .rev()\n        .filter(|&(_,\
    \ letter)| !is_vowel(letter))\n        .skip(1)\n        .find_map(|(index, _)|\
    \ word.get(index + 1..index + 2))\n        .unwrap_or(\"\")\n        .to_string()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp9wxeab2_.rs:14:33\n\
    \   |\n14 |         .filter(|&(_, letter)| !is_vowel(letter))\n   |          \
    \                       ^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiou\";\n    let mut result = String::new();\n\
    \    let mut vowels_start = 0;\n    let mut vowels_end = 4;\n    let mut char_iter\
    \ = word.chars().rev();\n    let mut vowel_index;\n    while let Some(x) = char_iter.next()\
    \ {\n        if vowels.contains(x) {\n            if let Some(y) = char_iter.next()\
    \ {\n                if !vowels.contains(y) {\n                    vowel_index\
    \ = vowels.find(x).unwrap();\n                    if vowel_index <= vowels_start\
    \ {\n                        vowels_start = vowel_index;\n                   \
    \     result = x.to_string();\n                    }\n                    break;\n\
    \                }\n            }\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpegtjsm6w.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.char_indices()\n        .rev()\n        .find(|(_,\
    \ ch)| {\n            let (_, consonant1) = \n                word.char_indices()\n\
    \                    .rev()\n                    .find(|(_, ch)| !ch.is_vowel())\n\
    \                    .unwrap();\n            let (_, consonant2) = \n        \
    \        word.char_indices()\n                    .rev()\n                   \
    \ .find(|(_, ch)| ch != &consonant1 && !ch.is_vowel())\n                    .unwrap();\n\
    \            !ch.is_vowel() && ch != &consonant1 && ch != &consonant2\n      \
    \  })\n        .map(|(index, _)| {\n            word.char_indices()\n        \
    \        .skip(index + 1)\n                .find(|(_, ch)| ch.is_vowel())\n  \
    \              .map(|(_, ch)| ch.to_string())\n                .unwrap_or(\"\"\
    .to_string())\n        })\n        .unwrap_or(\"\".to_string())\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmp0zqp381r.rs:18:41\n   |\n18 |             \
    \        .find(|(_, ch)| !ch.is_vowel())\n   |                               \
    \          ^^^^^^^^ method not found in `&char`\n\nerror[E0599]: no method named\
    \ `is_vowel` found for reference `&char` in the current scope\n  --> /tmp/tmp0zqp381r.rs:23:62\n\
    \   |\n23 |                     .find(|(_, ch)| ch != &consonant1 && !ch.is_vowel())\n\
    \   |                                                              ^^^^^^^^ method\
    \ not found in `&char`\n\nerror[E0599]: no method named `is_vowel` found for reference\
    \ `&char` in the current scope\n  --> /tmp/tmp0zqp381r.rs:25:17\n   |\n25 |  \
    \           !ch.is_vowel() && ch != &consonant1 && ch != &consonant2\n   |   \
    \              ^^^^^^^^ method not found in `&char`\n\nerror[E0599]: no method\
    \ named `is_vowel` found for reference `&char` in the current scope\n  --> /tmp/tmp0zqp381r.rs:30:36\n\
    \   |\n30 |                 .find(|(_, ch)| ch.is_vowel())\n   |             \
    \                       ^^^^^^^^ method not found in `&char`\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut s = String::new();\n    for (i, c) in word.chars().rev().enumerate()\
    \ {\n        match c {\n            'a' | 'e' | 'i' | 'o' | 'u' => {\n       \
    \         if i > 0 && word.chars().rev().nth(i-1).unwrap().is_lowercase() {\n\
    \                    if i == word.len() - 1 {\n                        s = c.to_string();\n\
    \                    } else {\n                        if !word.chars().rev().nth(i+1).unwrap().is_lowercase()\
    \ {\n                            s = c.to_string();\n                        }\n\
    \                    }\n                }\n            },\n            _ => {},\n\
    \        }\n    }\n    return s;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmp5md39ii8.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut closest_distance = word.len();\n    let mut closest_vowel = '.';\n    let\
    \ bytes = word.into_bytes();\n    for (i, &byte) in bytes.iter().enumerate() {\n\
    \        if vowels.contains(&(byte as char)) {\n            if i > 0 && i < bytes.len()\
    \ - 1 {\n                if !vowels.contains(&(bytes[i - 1] as char))\n      \
    \              && !vowels.contains(&(bytes[i + 1] as char))\n                {\n\
    \                    if i < closest_distance {\n                        closest_distance\
    \ = i;\n                        closest_vowel = byte as char;\n              \
    \      }\n                }\n            }\n        }\n    }\n    if closest_vowel\
    \ == '.' {\n        String::new()\n    } else {\n        closest_vowel.to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmppg8yqr64.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    \"aeiou\".chars().find(|v| {\n        word.chars().rev().skip(1).take_while(|c|\
    \ !\"aeiou\".contains(*c)).any(|c| c == *v)\n    }).map(|v| v.to_string()).unwrap_or_else(||\
    \ \"\".to_string())\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmprdg2f122.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut word = word.into_bytes();\n    word.reverse();\n\
    \    word.into_iter()\n        .filter(|&x| is_vowel(x))\n        .nth(1)\n  \
    \      .map(|x| x as char)\n        .map(|x| x.to_string())\n        .unwrap_or(\"\
    \".to_string())\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n  \
    \  assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n   \
    \ assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp2ipoiuuh.rs:15:22\n\
    \   |\n15 |         .filter(|&x| is_vowel(x))\n   |                      ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut tmp: String = String::new();\n    let mut tmp2:\
    \ String = String::new();\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut found: bool = false;\n    let mut closest: String = String::new();\n   \
    \ let mut count: i32 = 0;\n    for char in word.chars() {\n        if !vowels.contains(&char)\
    \ {\n            tmp.push(char);\n        } else {\n            tmp2.push(char);\n\
    \        }\n    }\n    for (i, char) in tmp.chars().rev().enumerate() {\n    \
    \    if i == 0 {\n            if !vowels.contains(&char) {\n                return\
    \ String::from(\"\");\n            }\n        }\n        if !vowels.contains(&char)\
    \ {\n            for (j, char2) in tmp2.chars().rev().enumerate() {\n        \
    \        if j < count {\n                    continue;\n                }\n  \
    \              if i - 1 == j {\n                    closest.push(char2);\n   \
    \                 found = true;\n                    break;\n                }\n\
    \                count += 1;\n            }\n            if found {\n        \
    \        break;\n            }\n        }\n    }\n    closest\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk9g6gf37.rs:33:24\n   |\n\
    33 |                 if j < count {\n   |                        ^^^^^ expected\
    \ `usize`, found `i32`\n   |\nhelp: you can convert an `i32` to a `usize` and\
    \ panic if the converted value doesn't fit\n   |\n33 |                 if j <\
    \ count.try_into().unwrap() {\n   |                             ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    // get the word and split it\n    let chars: Vec<char>\
    \ = word.chars().collect();\n    let len = chars.len();\n    // run through the\
    \ word\n    for i in 0..len {\n        // check if the current char is a vowel\n\
    \        if is_vowel(chars[i]) {\n            // if it is a vowel, then check\
    \ if the last char was a vowel\n            if is_vowel(chars[i - 1]) {\n    \
    \            // check if the next char is a vowel\n                if is_vowel(chars[i\
    \ + 1]) {\n                    // if it is a vowel, then just continue\n     \
    \               continue;\n                } else {\n                    // if\
    \ it is not a vowel, then return the vowel\n                    return chars[i].to_string();\n\
    \                }\n            } else {\n                // if the last char\
    \ was not a vowel, then return the vowel\n                return chars[i].to_string();\n\
    \            }\n        }\n    }\n    \"\".to_string()\n}\n\nfn main() {\n   \
    \ let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpmxdtni41.rs:18:12\n\
    \   |\n18 |         if is_vowel(chars[i]) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `is_vowel` in this scope\n\
    \  --> /tmp/tmpmxdtni41.rs:20:16\n   |\n20 |             if is_vowel(chars[i -\
    \ 1]) {\n   |                ^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_vowel` in this scope\n  --> /tmp/tmpmxdtni41.rs:22:20\n\
    \   |\n22 |                 if is_vowel(chars[i + 1]) {\n   |                \
    \    ^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().fold((\"\", 0, false), |(res, pos, prev_vowel),\
    \ ch|\n        if \"aeiou\".contains(ch) {\n            if prev_vowel {\n    \
    \            (res, pos, true)\n            } else {\n                (\"\".to_string(),\
    \ pos, true)\n            }\n        } else {\n            if prev_vowel {\n \
    \               if res.len() == 0 || pos < res.len() {\n                    (ch.to_string(),\
    \ pos + 1, false)\n                } else {\n                    (res, pos + 1,\
    \ false)\n                }\n            } else {\n                (res, pos +\
    \ 1, false)\n            }\n        }\n    ).0\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2nk8md5f.rs:17:18\n   |\n\
    17 |                 (\"\".to_string(), pos, true)\n   |                  ^^^^^^^^^^^^^^\n\
    \   |                  |\n   |                  expected `&str`, found struct\
    \ `String`\n   |                  help: consider borrowing here: `&\"\".to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2nk8md5f.rs:22:22\n   |\n22 |\
    \                     (ch.to_string(), pos + 1, false)\n   |                 \
    \     ^^^^^^^^^^^^^^\n   |                      |\n   |                      expected\
    \ `&str`, found struct `String`\n   |                      help: consider borrowing\
    \ here: `&ch.to_string()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2nk8md5f.rs:12:5\n\
    \   |\n11 |   fn get_closest_vowel(word: String) -> String {\n   |           \
    \                              ------ expected `String` because of return type\n\
    12 | /     word.chars().fold((\"\", 0, false), |(res, pos, prev_vowel), ch|\n\
    13 | |         if \"aeiou\".contains(ch) {\n14 | |             if prev_vowel {\n\
    15 | |                 (res, pos, true)\n...  |\n29 | |         }\n30 | |    \
    \ ).0\n   | |       ^- help: try using a conversion method: `.to_string()`\n \
    \  | |_______|\n   |         expected struct `String`, found `&str`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let is_vowel = |c: char| \"aeiou\".contains(c);\n \
    \   let mut acc: Vec<char> = vec![];\n    for c in word.chars().rev() {\n    \
    \    if is_vowel(c) {\n            acc.push(c);\n        } else if !acc.is_empty()\
    \ {\n            break;\n        }\n    }\n    acc.iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ae\"`,\n right: `\"\"`', /tmp/tmpt_zhlhu7.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    const VOWELS: &'static str = \"AEIOU\";\n    let mut\
    \ start = word.len();\n    let mut end = 0;\n    let mut found = false;\n    for\
    \ (i, c) in word.chars().enumerate() {\n        if VOWELS.contains(c) {\n    \
    \        if found {\n                end = i;\n                break;\n      \
    \      }\n        } else {\n            if found {\n                start = i;\n\
    \                found = false;\n            }\n        }\n        if VOWELS.contains(c)\
    \ {\n            found = true;\n        }\n    }\n    if start < end {\n     \
    \   let mut closest_vowel = \"\".to_string();\n        let mut distance = end\
    \ - start;\n        for i in start..end {\n            if VOWELS.contains(word.chars().nth(i).unwrap())\
    \ {\n                if end - i < distance {\n                    distance = end\
    \ - i;\n                    closest_vowel = word.chars().nth(i).unwrap().to_string();\n\
    \                }\n            }\n        }\n        closest_vowel\n    } else\
    \ {\n        \"\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpfq2cqlv4.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut counter =\
    \ 0;\n    let mut prev_vowel = ' ';\n    let word = word.into_bytes();\n    for\
    \ (i, c) in word.iter().rev().enumerate() {\n        if !is_vowel(*c) {\n    \
    \        counter += 1;\n        } else {\n            prev_vowel = *c as char;\n\
    \        }\n        if counter == 2 {\n            break;\n        }\n       \
    \ if i == word.len() - 1 {\n            return String::new();\n        }\n   \
    \ }\n    if counter == 2 {\n        res.push(prev_vowel);\n    }\n    res\n}\n\
    \nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpab7kj3wv.rs:17:13\n\
    \   |\n17 |         if !is_vowel(*c) {\n   |             ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut idx = 0;\n    let mut cons = false;\n    let\
    \ mut vow = false;\n    let mut last_vow = -1;\n    let mut last_cons = -1;\n\
    \    let mut word = word.chars().collect::<Vec<char>>();\n    word.reverse();\n\
    \    while idx < word.len() - 1 {\n        if last_vow == -1 {\n            match\
    \ word[idx] {\n                'a' | 'e' | 'i' | 'o' | 'u' => {\n            \
    \        last_vow = idx;\n                    vow = true;\n                }\n\
    \                _ => (),\n            }\n        }\n        if vow && last_cons\
    \ == -1 {\n            match word[idx] {\n                'a' | 'e' | 'i' | 'o'\
    \ | 'u' => (),\n                _ => {\n                    last_cons = idx;\n\
    \                    cons = true;\n                }\n            }\n        }\n\
    \        if cons && !vow {\n            return String::new();\n        }\n   \
    \     idx += 1;\n    }\n    if last_vow == -1 || last_cons == -1 {\n        return\
    \ String::new();\n    }\n    word[last_vow].to_string()\n}\n\nfn main() {\n  \
    \  let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmph5nbzxju.rs:15:24\n\
    \   |\n15 |     let mut last_vow = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n  --> /tmp/tmph5nbzxju.rs:20:24\n   |\n20 | \
    \        if last_vow == -1 {\n   |                        ^^ the trait `Neg` is\
    \ not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0277]: the trait bound `usize:\
    \ Neg` is not satisfied\n  --> /tmp/tmph5nbzxju.rs:16:25\n   |\n16 |     let mut\
    \ last_cons = -1;\n   |                         ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0277]: the trait bound `usize: Neg` is not\
    \ satisfied\n  --> /tmp/tmph5nbzxju.rs:29:32\n   |\n29 |         if vow && last_cons\
    \ == -1 {\n   |                                ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0600]: cannot apply unary operator `-` to type\
    \ `usize`\n  --> /tmp/tmph5nbzxju.rs:43:20\n   |\n43 |     if last_vow == -1 ||\
    \ last_cons == -1 {\n   |                    ^^\n   |                    |\n \
    \  |                    cannot apply unary operator `-`\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    if word.is_empty() {\n        return \"\".to_string();\n\
    \    }\n    let mut closest_vowel = \"\".to_string();\n    let vowels = \"aeiouAEIOU\"\
    ;\n    let mut prev_char_is_vowel = false;\n    for c in word.chars().rev() {\n\
    \        if vowels.contains(c) {\n            if prev_char_is_vowel {\n      \
    \          break;\n            }\n            closest_vowel = c.to_string();\n\
    \        } else {\n            prev_char_is_vowel = vowels.contains(c);\n    \
    \    }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmphik9o6zf.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiouAEIOU\";\n    let mut pos = 0;\n\
    \    let mut prev = false;\n    for (i, ch) in word.chars().rev().enumerate()\
    \ {\n        if vowels.contains(ch) {\n            if prev {\n               \
    \ pos = i;\n                break;\n            }\n        } else {\n        \
    \    prev = true;\n        }\n    }\n    if pos == 0 {\n        return \"\".to_string();\n\
    \    }\n    word.chars().rev().skip(pos+1).next().unwrap().to_string()\n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"g\"`,\n right: `\"u\"`', /tmp/tmpr_x08u3y.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n  if word.is_empty() {\n    return \"\".to_string();\n\
    \  }\n  let mut vowel = \"\".to_string();\n  let mut prev = false;\n  let mut\
    \ next = false;\n  let vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n  let\
    \ mut ch_vec: Vec<char> = word.chars().collect();\n  ch_vec.reverse();\n  for\
    \ c in ch_vec {\n    if vowels.contains(&c.to_string().as_str()) {\n      vowel\
    \ = c.to_string();\n      break;\n    }\n    if prev {\n      next = !next;\n\
    \    }\n    prev = !prev;\n  }\n  if next {\n    vowel\n  } else {\n    \"\".to_string()\n\
    \  }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpgm8n0w25.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ chars: Vec<char> = word.chars().collect();\n    let mut closest_vowel = ' ';\n\
    \    let mut distance = 0;\n    let mut prev_is_vowel = false;\n    for (index,\
    \ c) in chars.iter().enumerate() {\n        if vowels.contains(c) {\n        \
    \    prev_is_vowel = true;\n            continue;\n        }\n        if prev_is_vowel\
    \ {\n            if closest_vowel == ' ' {\n                closest_vowel = *c;\n\
    \                distance = index;\n            } else if index < distance {\n\
    \                closest_vowel = *c;\n                distance = index;\n    \
    \        }\n            prev_is_vowel = false;\n        }\n    }\n    let mut\
    \ result = String::new();\n    if closest_vowel != ' ' {\n        result.push(closest_vowel);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"g\"`,\n right: `\"u\"`', /tmp/tmpgky34db4.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiouAEIOU\";\n    let mut index = 0;\n\
    \    let s = word.chars().rev().collect::<String>();\n    for (i, c) in s.chars().enumerate()\
    \ {\n        if vowels.contains(c) {\n            index = i;\n            break;\n\
    \        }\n    }\n    if index > 0 {\n        let mut v = s.chars().skip(index).take(1).collect::<String>();\n\
    \        v.make_ascii_uppercase();\n        v\n    } else {\n        \"\".to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"U\"`,\n right: `\"u\"`', /tmp/tmpgsdnvcvv.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    if word.len() < 2 {\n        return String::new();\n\
    \    }\n    let mut res = String::new();\n    let mut cond1 = false;\n    let\
    \ mut cond2 = false;\n    let mut prev_char = ' ';\n    let mut prev_prev_char\
    \ = ' ';\n    for c in word.chars().rev() {\n        if !cond1 && (c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            cond1 = true;\n\
    \            res.push(c);\n        } else if !cond2 && cond1 && (c != 'a' && c\
    \ != 'e' && c != 'i' && c != 'o' && c != 'u') {\n            cond2 = true;\n \
    \       } else if cond1 && cond2 && (c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u') {\n            res.push(c);\n            break;\n        }\n\
    \        prev_prev_char = prev_char;\n        prev_char = c;\n    }\n    if cond1\
    \ && cond2 {\n        res.chars().rev().collect()\n    } else {\n        String::new()\n\
    \    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ou\"`,\n right: `\"u\"`', /tmp/tmp6m06ol1u.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiou\";\n    let mut index = None;\n\
    \    for (i, c) in word.chars().rev().enumerate() {\n        if index.is_none()\
    \ && vowels.contains(c) {\n            index = Some(i);\n        } else if index.is_some()\
    \ && !vowels.contains(c) {\n            break;\n        }\n    }\n    if let Some(i)\
    \ = index {\n        let result = word.chars().rev().nth(i).unwrap();\n      \
    \  result.to_string()\n    } else {\n        \"\".to_string()\n    }\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpv_ccwrj7.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    if word.len() < 3 {\n        return \"\".to_string();\n\
    \    }\n    let mut idx = word.len() - 1;\n    while idx > 0 {\n        let candidate\
    \ = word.chars().nth(idx).unwrap();\n        if is_vowel(candidate) {\n      \
    \      return candidate.to_string();\n        }\n        idx -= 1;\n    }\n  \
    \  \"\".to_string()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp72tuf1ak.rs:18:12\n\
    \   |\n18 |         if is_vowel(candidate) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut iter = word.char_indices().rev();\n    let\
    \ mut vw = iter.next();\n    let mut cn = iter.next();\n    let mut vw_pos = word.len();\n\
    \    loop {\n        match vw {\n            Some((vw_pos_, _)) if !is_vowel(vw_.to_ascii_lowercase())\
    \ => {\n                vw = iter.next();\n            }\n            _ => {\n\
    \                break;\n            }\n        }\n    }\n    loop {\n       \
    \ match cn {\n            Some((cn_pos, _)) if is_vowel(cn_.to_ascii_lowercase())\
    \ => {\n                cn = iter.next();\n            }\n            _ => {\n\
    \                break;\n            }\n        }\n    }\n    match (vw, cn) {\n\
    \        (Some((vw_pos_, vw_)), Some((cn_pos, _))) if vw_pos_ > cn_pos => {\n\
    \            vw_.to_string()\n        }\n        _ => String::new(),\n    }\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpl47xccqq.rs:18:36\n\
    \   |\n18 |             Some((vw_pos_, _)) if !is_vowel(vw_.to_ascii_lowercase())\
    \ => {\n   |                                    ^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `vw_` in this scope\n  --> /tmp/tmpl47xccqq.rs:18:45\n\
    \   |\n18 |             Some((vw_pos_, _)) if !is_vowel(vw_.to_ascii_lowercase())\
    \ => {\n   |                                             ^^^ help: a local variable\
    \ with a similar name exists: `vw`\n\nerror[E0425]: cannot find function `is_vowel`\
    \ in this scope\n  --> /tmp/tmpl47xccqq.rs:28:34\n   |\n28 |             Some((cn_pos,\
    \ _)) if is_vowel(cn_.to_ascii_lowercase()) => {\n   |                       \
    \           ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `cn_` in this scope\n  --> /tmp/tmpl47xccqq.rs:28:43\n   |\n28 |           \
    \  Some((cn_pos, _)) if is_vowel(cn_.to_ascii_lowercase()) => {\n   |        \
    \                                   ^^^ help: a local variable with a similar\
    \ name exists: `cn`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut chars = word.chars().rev();\n    chars.next();\n\
    \    let mut word: String = chars.collect();\n    word = word.replace(\"a\", \"\
    \ \");\n    word = word.replace(\"e\", \" \");\n    word = word.replace(\"i\"\
    , \" \");\n    word = word.replace(\"o\", \" \");\n    word = word.replace(\"\
    u\", \" \");\n    word = word.replace(\"y\", \" \");\n    word = word.replace(\"\
    A\", \" \");\n    word = word.replace(\"E\", \" \");\n    word = word.replace(\"\
    I\", \" \");\n    word = word.replace(\"O\", \" \");\n    word = word.replace(\"\
    U\", \" \");\n    word = word.replace(\"Y\", \" \");\n    word = word.trim().to_string();\n\
    \    let mut chars = word.chars().rev();\n    chars.next();\n    let word: String\
    \ = chars.collect();\n    word\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\" r\"`,\n right: `\"u\"`', /tmp/tmpw8p7ue4a.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n  word.chars().rfold((\"\", 100), |(ch, distance), letter|\n\
    \    if \"aeiou\".contains(letter) {\n      if distance > 1 {\n        (ch, distance)\n\
    \      } else {\n        (letter.to_string(), distance - 1)\n      }\n    } else\
    \ {\n      if \"aeiou\".contains(ch.as_str()) {\n        (ch, distance)\n    \
    \  } else {\n        (\"\", distance + 1)\n      }\n    }\n  ).0\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8_leylmu.rs:17:10\n   |\n\
    17 |         (letter.to_string(), distance - 1)\n   |          ^^^^^^^^^^^^^^^^^^\n\
    \   |          |\n   |          expected `&str`, found struct `String`\n   | \
    \         help: consider borrowing here: `&letter.to_string()`\n\nerror[E0599]:\
    \ no method named `as_str` found for reference `&str` in the current scope\n \
    \ --> /tmp/tmp8_leylmu.rs:20:30\n   |\n20 |       if \"aeiou\".contains(ch.as_str())\
    \ {\n   |                             -^^^^^^-- help: remove this method call\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp8_leylmu.rs:12:3\n   |\n11 | \
    \  fn get_closest_vowel(word: String) -> String {\n   |                      \
    \                   ------ expected `String` because of return type\n12 | /  \
    \ word.chars().rfold((\"\", 100), |(ch, distance), letter|\n13 | |     if \"aeiou\"\
    .contains(letter) {\n14 | |       if distance > 1 {\n15 | |         (ch, distance)\n\
    ...  |\n25 | |     }\n26 | |   ).0\n   | |     ^- help: try using a conversion\
    \ method: `.to_string()`\n   | |_____|\n   |       expected struct `String`, found\
    \ `&str`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let chars: Vec<char> = word.chars().collect();\n  \
    \  let mut result = String::new();\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n\
    \    let mut vowel_count = 0;\n    let mut consonant_count = 0;\n    let mut current_count\
    \ = 0;\n    let mut index = 0;\n    for c in chars.iter().rev() {\n        if\
    \ vowels.contains(c) {\n            vowel_count += 1;\n            if current_count\
    \ > consonant_count {\n                consonant_count = current_count;\n    \
    \            current_count = 0;\n                result = String::from(*c);\n\
    \                index = chars.len() - vowel_count;\n            }\n        }\
    \ else {\n            current_count += 1;\n        }\n    }\n    if vowel_count\
    \ > 0 && (index == 0 || index == chars.len() - 1) {\n        String::new()\n \
    \   } else {\n        result\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpoqet9z1d.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiou\";\n    let mut closes_vowel =\
    \ \"\";\n    let mut dist = 0;\n    for (idx, ch) in word.char_indices().rev()\
    \ {\n        if idx > 0 && vowels.contains(ch) {\n            if word.chars().nth(idx\
    \ - 1).unwrap().is_ascii_alphabetic() && !vowels.contains(word.chars().nth(idx\
    \ - 1).unwrap()) {\n                if word.len() - idx - 1 < dist || dist ==\
    \ 0 {\n                    dist = word.len() - idx - 1;\n                    closes_vowel\
    \ = ch.to_string().as_str();\n                }\n            }\n        }\n  \
    \  }\n    closes_vowel.to_string()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmpf_u8y6bn.rs:20:36\n\
    \   |\n20 |                     closes_vowel = ch.to_string().as_str();\n   |\
    \                                    ^^^^^^^^^^^^^^         - temporary value\
    \ is freed at the end of this statement\n   |                                \
    \    |\n   |                                    creates a temporary which is freed\
    \ while still in use\n...\n25 |     closes_vowel.to_string()\n   |     ------------------------\
    \ borrow later used here\n   |\n   = note: consider using a `let` binding to create\
    \ a longer lived value\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0716`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut prev =\
    \ false;\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    for c in\
    \ word.chars().rev() {\n        if vowels.contains(&c.to_lowercase().to_string().as_str())\
    \ {\n            if prev {\n                result.push(c);\n                break;\n\
    \            }\n        } else {\n            prev = true;\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmp1td7tdm5.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().rev().skip_while(|c| is_consonant(*c)).skip(1).take_while(|c|\
    \ is_consonant(*c)).last().map(|v| v.to_string()).unwrap_or(\"\".to_string())\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_consonant` in this scope\n  -->\
    \ /tmp/tmp0eyyrg6f.rs:12:39\n   |\n12 |     word.chars().rev().skip_while(|c|\
    \ is_consonant(*c)).skip(1).take_while(|c| is_consonant(*c)).last().map(|v| v.to_string()).unwrap_or(...\n\
    \   |                                       ^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `is_consonant` in this scope\n  --> /tmp/tmp0eyyrg6f.rs:12:80\n\
    \   |\n12 |     word.chars().rev().skip_while(|c| is_consonant(*c)).skip(1).take_while(|c|\
    \ is_consonant(*c)).last().map(|v| v.to_string()).unwrap_or(...\n   |        \
    \                                                                        ^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().enumerate().fold((0, false, None), |(last_i,\
    \ last_is_consonant, mut ret), (i, c)| {\n        let is_consonant = vec!['b',\
    \ 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v',\
    \ 'w', 'x', 'z'].contains(&c);\n        let is_vowel = vec!['a', 'e', 'i', 'o',\
    \ 'u'].contains(&c);\n        if !is_consonant && last_is_consonant && i > 0 {\n\
    \            ret = Some(c);\n        }\n        (i, is_consonant, ret)\n    }).2.map(|c|\
    \ c.to_string()).unwrap_or(\"\".to_string())\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"y\"`,\n right: `\"\"`', /tmp/tmpnb23rqai.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n\
    \    let chars: Vec<char> = word.chars().collect();\n    let mut vowel = String::new();\n\
    \    for i in 0..chars.len() {\n        for v in vowels.iter() {\n           \
    \ if chars[i] == *v {\n                if i > 0 && i < chars.len() - 1 {\n   \
    \                 if !is_vowel(chars[i - 1]) && !is_vowel(chars[i + 1]) {\n  \
    \                      vowel = v.to_string();\n                        break;\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp8mhbp5os.rs:19:25\n\
    \   |\n19 |                     if !is_vowel(chars[i - 1]) && !is_vowel(chars[i\
    \ + 1]) {\n   |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_vowel` in this scope\n  --> /tmp/tmp8mhbp5os.rs:19:52\n\
    \   |\n19 |                     if !is_vowel(chars[i - 1]) && !is_vowel(chars[i\
    \ + 1]) {\n   |                                                    ^^^^^^^^ not\
    \ found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8mhbp5os.rs:17:28\n\
    \   |\n17 |             if chars[i] == *v {\n   |                            ^^\
    \ expected `char`, found `&str`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().rev().skip_while(|x| \"AEIOUaeiou\".find(*x).is_none()).skip(1).skip_while(|x|\
    \ \"AEIOUaeiou\".find(*x).is_some()).take(1).collect()\n}\n\nfn main() {\n   \
    \ let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"g\"`,\n right: `\"u\"`', /tmp/tmp9hn_pl5z.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n  for ch in word.chars().rev() {\n    match ch {\n    \
    \  'a' | 'e' | 'i' | 'o' | 'u' => return ch.to_string(),\n      'A' | 'E' | 'I'\
    \ | 'O' | 'U' => return ch.to_string(),\n      _ => continue,\n    }\n  }\n  return\
    \ \"\".to_string();\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpqpb15mp1.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowel_pos = 0;\n    let mut consonant_pos =\
    \ 0;\n    let mut distance = 0;\n    let mut min_distance = word.len();\n    let\
    \ letters: Vec<char> = word.chars().collect();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    vowels.extend(vec!['A', 'E', 'I', 'O', 'U']);\n  \
    \  for (i, l) in letters.iter().enumerate() {\n        if vowels.contains(l) {\n\
    \            vowel_pos = i;\n        } else {\n            consonant_pos = i;\n\
    \        }\n        if vowel_pos < consonant_pos {\n            vowel_pos = 0;\n\
    \            consonant_pos = 0;\n        } else {\n            distance = consonant_pos\
    \ - vowel_pos;\n            if distance < min_distance {\n                min_distance\
    \ = distance;\n            }\n        }\n    }\n    if min_distance == word.len()\
    \ {\n        return String::from(\"\");\n    }\n    let last_vowel_pos = word.len()\
    \ - min_distance;\n    return word.chars().skip(last_vowel_pos).take(1).collect();\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpw9g_zw3w.rs:29:24\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    if word.is_empty() {\n        return String::new();\n\
    \    }\n    let mut words = word.chars().rev().peekable();\n    let mut index\
    \ = 0;\n    let mut consonant = true;\n    let mut closest_vowel = String::new();\n\
    \    let mut closest_index = word.len();\n    let mut i = 0;\n    while let Some(c)\
    \ = words.next() {\n        match c {\n            'a' | 'e' | 'i' | 'o' | 'u'\
    \ => {\n                if !consonant {\n                    consonant = true;\n\
    \                    index = i;\n                    if index < closest_index\
    \ {\n                        closest_index = index;\n                        closest_vowel\
    \ = c.to_string();\n                    }\n                }\n            }\n\
    \            _ => {\n                if consonant {\n                    consonant\
    \ = false;\n                }\n            }\n        }\n        i += 1;\n   \
    \ }\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpoqwp9fns.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n  let mut vowels = Vec::new();\n  let mut i = word.len()\
    \ - 1;\n  loop {\n    let current = &word[i..i+1];\n    if i == 0 {\n      break;\n\
    \    }\n    if current == \"a\" || current == \"e\" || current == \"i\" || current\
    \ == \"o\" || current == \"u\" {\n      vowels.push(current);\n    }\n    i -=\
    \ 1;\n  }\n  for i in 0..vowels.len() {\n    let prev = &word[vowels[i].len()..vowels[i].len()+1];\n\
    \    if prev != \"a\" && prev != \"e\" && prev != \"i\" && prev != \"o\" && prev\
    \ != \"u\" {\n      return String::from(vowels[i]);\n    }\n  }\n  String::from(\"\
    \")\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpamuml5gn.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut dist: usize = word.len();\n    let mut match_vowel\
    \ = String::new();\n    word.chars().rev().fold(None, |last_ch, ch| {\n      \
    \  if \"aeiou\".contains(ch) {\n            if let Some(lc) = last_ch {\n    \
    \            if !\"aeiou\".contains(lc) {\n                    let match_dist\
    \ = word.len() - ch.len_utf8();\n                    if match_dist < dist {\n\
    \                        dist = match_dist;\n                        match_vowel\
    \ = ch.to_string();\n                    }\n                }\n            }\n\
    \        }\n        Some(ch)\n    });\n    match_vowel\n}\n\nfn main() {\n   \
    \ let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmp_616ovnu.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut consonants = false;\n    let vowels = ['a',\
    \ 'e', 'i', 'o', 'u'];\n    word.chars().rev().filter(|x| {\n        if vowels.contains(x)\
    \ {\n            consonants\n        } else {\n            consonants = true;\n\
    \            false\n        }\n    }).next().unwrap_or(' ').to_string()\n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpq75k4u67.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut right = 0;\n    for i in word.chars().rev()\
    \ {\n        if i == 'a' || i == 'e' || i == 'i' || i == 'o' || i == 'u' {\n \
    \           if right > 0 {\n                return i.to_string();\n          \
    \  }\n        } else {\n            right += 1;\n        }\n    }\n    String::new()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpp_nyfhpp.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut dist = (word.len(), ' ');\n    for i in 0..word.len()\
    \ {\n        let c = word.chars().nth(i).unwrap();\n        if c == 'a' || c ==\
    \ 'e' || c == 'i' || c == 'o' || c == 'u' {\n            let start = if i > 0\
    \ {\n                word.chars().nth(i - 1).unwrap()\n            } else {\n\
    \                c\n            };\n            let end = if i < word.len() -\
    \ 1 {\n                word.chars().nth(i + 1).unwrap()\n            } else {\n\
    \                c\n            };\n            if start.is_lowercase() && end.is_lowercase()\
    \ {\n                let n = word.len() - i - 1;\n                if n < dist.0\
    \ {\n                    dist = (n, c);\n                }\n            }\n  \
    \      }\n    }\n    if dist.0 == word.len() {\n        String::new()\n    } else\
    \ {\n        dist.1.to_string()\n    }\n}\n\nfn main() {\n    let candidate =\
    \ get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpgyj8qiqu.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = String::new();\n    let mut consonants\
    \ = String::new();\n    for c in word.chars() {\n        match c {\n         \
    \   'a' | 'e' | 'i' | 'o' | 'u' => vowels.push(c),\n            _ => consonants.push(c),\n\
    \        }\n    }\n    let mut str = String::new();\n    let mut idx = 0;\n  \
    \  let mut left = 0;\n    let mut right = 0;\n    let mut min = word.len();\n\
    \    for c in vowels.chars() {\n        right = consonants.rfind(c).unwrap_or(0);\n\
    \        left = vowels.rfind(c).unwrap_or(0);\n        if right > left && right\
    \ - left < min {\n            idx = left;\n            min = right - left;\n \
    \       }\n    }\n    for c in vowels.chars().skip(idx) {\n        str.push(c);\n\
    \    }\n    str\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n  \
    \  assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n   \
    \ assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ou\"`,\n right: `\"u\"`', /tmp/tmpuokncbcu.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    // TODO\n    \"\".to_string()\n}\n\nfn main() {\n \
    \   let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpu07aec7x.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiouAEIOU\";\n    let mut i = word.len()\
    \ - 1;\n    while i > 0 {\n        if word.chars().nth(i).unwrap().is_alphabetic()\
    \ && vowels.contains(word.chars().nth(i).unwrap()) {\n            if word.chars().nth(i\
    \ - 1).unwrap().is_alphabetic() && !vowels.contains(word.chars().nth(i - 1).unwrap())\
    \ {\n                return word.chars().nth(i).unwrap().to_string();\n      \
    \      }\n        }\n        i -= 1;\n    }\n    \"\".to_string()\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"i\"`,\n right: `\"\"`', /tmp/tmpqw8vkj8c.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiouAEIOU\";\n    let mut it1 = word.chars().rev();\n\
    \    let mut it2 = word.chars().rev();\n    let mut result = String::new();\n\
    \    while let Some(first) = it1.next() {\n        if vowels.contains(first) {\n\
    \            result.push(first);\n            break;\n        }\n        let second\
    \ = it2.next().unwrap();\n        if first != second && vowels.contains(second)\
    \ {\n            result.push(second);\n            break;\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpg8r1vx12.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let word = word.as_bytes();\n    let mut result = \"\
    \".to_string();\n    for (i, c) in word.iter().enumerate() {\n        if *c ==\
    \ b'a' || *c == b'e' || *c == b'i' || *c == b'o' || *c == b'u' {\n           \
    \ if i < word.len() - 1 && (\n                word[i + 1] != b'a' && word[i +\
    \ 1] != b'e' && word[i + 1] != b'i' && word[i + 1] != b'o' && word[i + 1] != b'u'\n\
    \            ) && (\n                i == 0 || word[i - 1] != b'a' && word[i -\
    \ 1] != b'e' && word[i - 1] != b'i' && word[i - 1] != b'o' && word[i - 1] != b'u'\n\
    \            ) {\n                result = unsafe { String::from_utf8_unchecked(vec![*c])\
    \ };\n                break;\n            }\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpg1p9xa1z.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    const VOWELS: [char; 5] = ['a', 'e', 'i', 'o', 'u'];\n\
    \    let word = word.chars().collect::<Vec<char>>();\n    let len = word.len();\n\
    \    for i in (0..len - 1).rev() {\n        if !VOWELS.contains(&word[i]) && VOWELS.contains(&word[i\
    \ + 1]) {\n            return word[i + 1].to_string();\n        }\n    }\n   \
    \ \"\".to_string()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"i\"`,\n right: `\"\"`', /tmp/tmpwu2u8ybe.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n  let vowels = String::from(\"AEIOUaeiou\");\n  let mut\
    \ s = String::new();\n  let mut i = word.len() - 1;\n  while i > 0 {\n    if vowels.contains(word.chars().nth(i).unwrap())\
    \ {\n      if !vowels.contains(word.chars().nth(i - 1).unwrap()) {\n        s.push(word.chars().nth(i).unwrap());\n\
    \        break;\n      }\n    }\n    i -= 1;\n  }\n  s\n}\n\nfn main() {\n   \
    \ let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"i\"`,\n right: `\"\"`', /tmp/tmp6k3as7ws.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let word = word.to_lowercase();\n    let mut found\
    \ = String::new();\n    for (i, c) in word.chars().enumerate() {\n        if i\
    \ > 0 && is_vowel(c) && !is_vowel(word.chars().nth(i - 1).unwrap()) {\n      \
    \      found = c.to_string();\n            break;\n        }\n    }\n    found\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp3kp_6z17.rs:15:21\n\
    \   |\n15 |         if i > 0 && is_vowel(c) && !is_vowel(word.chars().nth(i -\
    \ 1).unwrap()) {\n   |                     ^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp3kp_6z17.rs:15:37\n\
    \   |\n15 |         if i > 0 && is_vowel(c) && !is_vowel(word.chars().nth(i -\
    \ 1).unwrap()) {\n   |                                     ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let word = word.chars().rev().collect::<Vec<char>>();\n\
    \    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let consonants = vec!['b',\
    \ 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v',\
    \ 'w', 'x', 'y', 'z'];\n    let mut index = 0;\n    while index < word.len() -\
    \ 1 {\n        let mut flag = false;\n        if consonants.contains(&word[index])\
    \ {\n            if index + 1 < word.len() {\n                if vowels.contains(&word[index\
    \ + 1]) {\n                    flag = true;\n                }\n            }\n\
    \            if index + 2 < word.len() {\n                if consonants.contains(&word[index\
    \ + 2]) {\n                    flag = true;\n                }\n            }\n\
    \            if flag {\n                return word[index + 1].to_string();\n\
    \            }\n        }\n        index += 1;\n    }\n    \"\".to_string()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmp9cv_2_ug.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpdyq69lhi.rs:12:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    let mut\
    \ last_consonant_idx = 0;\n    let mut first_vowel_idx = -1;\n    for (i, c) in\
    \ word.chars().enumerate() {\n        if vowels.contains(&c) {\n            if\
    \ first_vowel_idx == -1 {\n                first_vowel_idx = i;\n            }\n\
    \        } else {\n            last_consonant_idx = i;\n        }\n    }\n   \
    \ if first_vowel_idx == -1 || last_consonant_idx == 0 {\n        return String::new();\n\
    \    }\n    let mut min_dist = i32::max_value();\n    let mut min_idx = -1;\n\
    \    for (i, c) in word.chars().enumerate() {\n        if vowels.contains(&c)\
    \ {\n            let dist = (i as i32) - (last_consonant_idx as i32);\n      \
    \      if dist < min_dist && dist > 0 {\n                min_dist = dist;\n  \
    \              min_idx = i;\n            }\n        }\n    }\n    if min_idx ==\
    \ -1 {\n        return String::new();\n    }\n    word.chars().nth(min_idx).unwrap().to_string()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpdsqr3nmo.rs:14:31\n\
    \   |\n14 |     let mut first_vowel_idx = -1;\n   |                          \
    \     ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the\
    \ following other types implement trait `Neg`:\n             &f32\n          \
    \   &f64\n             &i128\n             &i16\n             &i32\n         \
    \    &i64\n             &i8\n             &isize\n           and 8 others\n\n\
    error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpdsqr3nmo.rs:17:35\n\
    \   |\n17 |             if first_vowel_idx == -1 {\n   |                     \
    \              ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help:\
    \ the following other types implement trait `Neg`:\n             &f32\n      \
    \       &f64\n             &i128\n             &i16\n             &i32\n     \
    \        &i64\n             &i8\n             &isize\n           and 8 others\n\
    \nerror[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpdsqr3nmo.rs:24:27\n\
    \   |\n24 |     if first_vowel_idx == -1 || last_consonant_idx == 0 {\n   |  \
    \                         ^^\n   |                           |\n   |         \
    \                  cannot apply unary operator `-`\n   |                     \
    \      help: you may have meant the maximum value of `usize`: `usize::MAX`\n \
    \  |\n   = note: unsigned values cannot be negated\n\nerror[E0277]: the trait\
    \ bound `usize: Neg` is not satisfied\n  --> /tmp/tmpdsqr3nmo.rs:28:23\n   |\n\
    28 |     let mut min_idx = -1;\n   |                       ^^ the trait `Neg`\
    \ is not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0600]: cannot apply unary\
    \ operator `-` to type `usize`\n  --> /tmp/tmpdsqr3nmo.rs:38:19\n   |\n38 |  \
    \   if min_idx == -1 {\n   |                   ^^\n   |                   |\n\
    \   |                   cannot apply unary operator `-`\n   |     "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpn_p3927j.rs:12:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    \"\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmprcyw8218.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiouAEIOU\";\n    let mut letter_iter\
    \ = word.chars().rev();\n    let mut left = letter_iter.next();\n    let mut right\
    \ = letter_iter.next();\n    while let Some(right_letter) = right {\n        if\
    \ vowels.contains(right_letter) {\n            if let Some(left_letter) = left\
    \ {\n                if !vowels.contains(left_letter) {\n                    return\
    \ right_letter.to_string();\n                }\n            }\n        }\n   \
    \     left = right;\n        right = letter_iter.next();\n    }\n    \"\".to_string()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpqg7wa1_n.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowel_array: Vec<char> = Vec::new();\n    for\
    \ ch in word.chars() {\n        match ch {\n            'a' | 'e' | 'i' | 'o'\
    \ | 'u' => vowel_array.push(ch),\n            _ => (),\n        }\n    }\n   \
    \ if vowel_array.len() == 0 {\n        return String::from(\"\");\n    }\n   \
    \ if vowel_array.len() == 1 {\n        return vowel_array[0].to_string();\n  \
    \  }\n    let mut x = 1;\n    let mut max_len = vowel_array.len();\n    let mut\
    \ word_len = word.len();\n    loop {\n        if x >= max_len {\n            return\
    \ vowel_array[x - 1].to_string();\n        }\n        let (vowel_index, word_index)\
    \ =\n            (word_len - 1 - vowel_array.len() + x, word_len - 1 - x);\n \
    \       if word.chars().nth(word_index).unwrap().is_ascii_uppercase() {\n    \
    \        x += 1;\n            continue;\n        }\n        if word_index > 0\
    \ && word.chars().nth(word_index - 1).unwrap().is_ascii_uppercase() {\n      \
    \      return vowel_array[vowel_index].to_string();\n        }\n        if vowel_index\
    \ == max_len - 1 {\n            return vowel_array[vowel_index].to_string();\n\
    \        }\n        if word.chars().nth(word_index + 1).unwrap().is_ascii_uppercase()\
    \ {\n            return vowel_array[vowel_index].to_string();\n        }\n   \
    \     x += 1;\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmp7xsgmqpx.rs:55:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    let mut\
    \ result = String::new();\n    for (i, c) in word.chars().rev().enumerate() {\n\
    \        if vowels.contains(&c) {\n            if i > 0 && !vowels.contains(&word.chars().rev().skip(i).next().unwrap())\
    \ {\n                result.push(c);\n                break;\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpdm_dbqkj.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    \"\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpkjzre8qy.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"\
    ];\n    let mut last_consonant = -1;\n    let mut distance = 0;\n    let mut vowel\
    \ = \"\";\n    for (index, ch) in word.chars().enumerate().rev() {\n        if\
    \ vowels.contains(&ch.to_string().as_str()) {\n            if last_consonant ==\
    \ -1 {\n                break;\n            }\n            if distance == 0 ||\
    \ distance > index - last_consonant {\n                distance = index - last_consonant;\n\
    \                vowel = ch.to_string().as_str();\n            }\n        } else\
    \ {\n            last_consonant = index;\n        }\n    }\n    vowel.to_string()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmpibe0r55e.rs:16:49\n     |\n16   |     for (index, ch) in word.chars().enumerate().rev()\
    \ {\n     |                                                 ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\n     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Enumerate<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0277]:\
    \ the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n  --> /tmp/tmpibe0r55e.rs:16:24\n\
    \   |\n16 |     for (index, ch) in word.chars().enumerate().rev() {\n   |    \
    \                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n   |\n   = help: the following other types\
    \ implement trait `ExactSizeIterator`:\n             &mut I\n             Args\n\
    \             ArgsOs\n             ArrayChunks<'_, T, N>\n             ArrayChunksMut<'_,\
    \ T, N>\n             ArrayWindows<'_, T, N>\n             Box<I, A>\n       \
    \      Chunks<'_, T>\n           and 109 others\n   = note: required because of\
    \ the requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \   = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpibe0r55e.rs:13:30\n\
    \   |\n13 |     let mut last_consonant = -1;\n   |                           \
    \   ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the following\
    \ other types implement trait `Neg`:\n             "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiou\";\n    let mut idx: i32 = -1;\n\
    \    for (i, c) in word.char_indices().rev() {\n        if vowels.contains(c)\
    \ {\n            idx = i as i32;\n            break;\n        }\n    }\n    if\
    \ idx == -1 {\n        return \"\".to_string();\n    }\n    for _ in 0..idx {\n\
    \        if !vowels.contains(word.chars().nth(idx as usize).unwrap()) {\n    \
    \        return word.chars().nth(idx as usize).unwrap().to_string();\n       \
    \ }\n        idx -= 1;\n    }\n    \"\".to_string()\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"g\"`,\n right: `\"u\"`', /tmp/tmp1tclxvdw.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut res = String::new();\n    let chars: Vec<char>\
    \ = word.chars().collect();\n    for (i, c) in chars.iter().enumerate() {\n  \
    \      if i > 0 && i < chars.len() - 1 {\n            if !c.is_vowel() && chars[i-1].is_vowel()\
    \ && chars[i+1].is_vowel() {\n                res = c.to_string();\n         \
    \       break;\n            }\n        }\n    }\n    res\n}\n\nfn main() {\n \
    \   let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmpzul9yf3m.rs:16:19\n   |\n16 |             if\
    \ !c.is_vowel() && chars[i-1].is_vowel() && chars[i+1].is_vowel() {\n   |    \
    \               ^^^^^^^^ method not found in `&char`\n\nerror[E0599]: no method\
    \ named `is_vowel` found for type `char` in the current scope\n  --> /tmp/tmpzul9yf3m.rs:16:44\n\
    \   |\n16 |             if !c.is_vowel() && chars[i-1].is_vowel() && chars[i+1].is_vowel()\
    \ {\n   |                                            ^^^^^^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `is_vowel` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpzul9yf3m.rs:16:69\n   |\n16 |          \
    \   if !c.is_vowel() && chars[i-1].is_vowel() && chars[i+1].is_vowel() {\n   |\
    \                                                                     ^^^^^^^^\
    \ method not found in `char`\n\nerror: aborting due to 3 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"AEIOUaeiou\";\n    let consonants =\
    \ \"BCDFGHJKLMNPQRSTVWXYZbcdfghjklmnpqrstvwxyz\";\n    word.chars().rev().skip_while(|&c|\
    \ c == ' ')\n        .filter(|&c| consonants.contains(c))\n        .find_map(|_|\
    \ word.chars().skip_while(|&c| c == ' ')\n                      .find(|&c| vowels.contains(c)))\n\
    \        .map(|c| c.to_string())\n        .unwrap_or(\"\".to_string())\n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpv9ax1sx6.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.matches(regex!(r\"(?<=[^aeiou])([aeiou])(?![aeiou])\"\
    )).next().unwrap_or(\"\").to_string()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error: cannot find macro `regex` in this scope\n  --> /tmp/tmpdc53o6l6.rs:12:18\n\
    \   |\n12 |     word.matches(regex!(r\"(?<=[^aeiou])([aeiou])(?![aeiou])\")).next().unwrap_or(\"\
    \").to_string()\n   |                  ^^^^^\n\nerror: aborting due to previous\
    \ error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"AEIOU\";\n    let mut last_consonant\
    \ = None;\n    let mut last_vowel = None;\n    for c in word.chars().rev() {\n\
    \        if vowels.contains(c) {\n            last_vowel = Some(c);\n        }\
    \ else if last_vowel.is_some() {\n            if last_consonant.is_none() {\n\
    \                last_consonant = Some(c);\n            } else {\n           \
    \     break;\n            }\n        }\n    }\n    last_vowel.unwrap_or(' ').to_string()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\" \"`,\n right: `\"u\"`', /tmp/tmp0n5rdz9r.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n\
    \    let mut prev = ' ';\n    let mut prev_is_vowel = false;\n    let mut closest_vowel\
    \ = \"\";\n    for ch in word.chars().rev() {\n        if vowels.contains(&ch.to_string().as_str())\
    \ {\n            if prev.is_ascii_alphabetic() && prev.is_ascii_uppercase() !=\
    \ ch.is_ascii_uppercase() {\n                continue;\n            }\n      \
    \      if !prev_is_vowel {\n                closest_vowel = ch.to_string().as_str();\n\
    \                break;\n            }\n            prev_is_vowel = true;\n  \
    \      } else {\n            prev_is_vowel = false;\n        }\n        prev =\
    \ ch;\n    }\n    closest_vowel.to_string()\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmpqrloge41.rs:22:33\n\
    \   |\n22 |                 closest_vowel = ch.to_string().as_str();\n   |   \
    \                              ^^^^^^^^^^^^^^         - temporary value is freed\
    \ at the end of this statement\n   |                                 |\n   | \
    \                                creates a temporary which is freed while still\
    \ in use\n...\n31 |     closest_vowel.to_string()\n   |     -------------------------\
    \ borrow later used here\n   |\n   = note: consider using a `let` binding to create\
    \ a longer lived value\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0716`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    const VOWELS: &'static [char] = &['a', 'e', 'i', 'o',\
    \ 'u'];\n    let c = word.chars();\n    let last = c.last().unwrap();\n    let\
    \ first = c.next().unwrap();\n    if VOWELS.contains(&last) {\n        last.to_string()\n\
    \    } else if VOWELS.contains(&first) {\n        first.to_string()\n    } else\
    \ {\n        \"\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0596]: cannot borrow `c` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmp5k8t3vp7.rs:15:17\n   |\n13 |     let c = word.chars();\n   | \
    \        - help: consider changing this to be mutable: `mut c`\n14 |     let last\
    \ = c.last().unwrap();\n15 |     let first = c.next().unwrap();\n   |        \
    \         ^^^^^^^^ cannot borrow as mutable\n\nerror[E0382]: borrow of moved value:\
    \ `c`\n   --> /tmp/tmp5k8t3vp7.rs:15:17\n    |\n13  |     let c = word.chars();\n\
    \    |         - move occurs because `c` has type `Chars<'_>`, which does not\
    \ implement the `Copy` trait\n14  |     let last = c.last().unwrap();\n    | \
    \                 ------ `c` moved due to this method call\n15  |     let first\
    \ = c.next().unwrap();\n    |                 ^^^^^^^^ value borrowed here after\
    \ move\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `c`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0382, E0596.\nFor more information about an error, try `rustc\
    \ --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest = String::new();\n    let mut closest_dist\
    \ = word.len();\n    let mut prev_vowel = false;\n    for (index, ch) in word.chars().enumerate()\
    \ {\n        let is_vowel = ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' ||\
    \ ch == 'u';\n        if !prev_vowel && is_vowel {\n            closest_dist =\
    \ word.len() - index;\n            closest = ch.to_string();\n        }\n    \
    \    if prev_vowel && !is_vowel {\n            if index - closest_dist < closest_dist\
    \ {\n                closest_dist = index - closest_dist;\n            }\n   \
    \     }\n        prev_vowel = is_vowel;\n    }\n    if closest_dist == word.len()\
    \ {\n        String::new()\n    } else {\n        closest\n    }\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmps1obt_1t.rs:22:16\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut result = String::new();\n    let mut is_start_with_consonant = true;\n \
    \   let mut start_index = 0;\n    for (index, character) in word.chars().enumerate()\
    \ {\n        if vowels.contains(&character) {\n            is_start_with_consonant\
    \ = false;\n            if index + 1 < word.len() {\n                start_index\
    \ = index + 1;\n            }\n        }\n    }\n    if is_start_with_consonant\
    \ {\n        return result;\n    }\n    for character in word.chars().skip(start_index)\
    \ {\n        if !vowels.contains(&character) {\n            result = character.to_string();\n\
    \            break;\n        }\n    }\n    if result.is_empty() {\n        return\
    \ result;\n    }\n    for character in word.chars().rev() {\n        if vowels.contains(&character)\
    \ {\n            return character.to_string();\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpsvj4und8.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let word = word.as_bytes();\n    for (i, c) in word.iter().enumerate().rev()\
    \ {\n        if is_vowel(*c) {\n            return ((i + 1)..word.len())\n   \
    \             .filter(|&i| is_consonant(word[i]))\n                .take(1)\n\
    \                .map(|i| *c as char)\n                .collect();\n        }\n\
    \    }\n    String::new()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpy6i612zu.rs:14:12\n\
    \   |\n14 |         if is_vowel(*c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `is_consonant` in this scope\n \
    \ --> /tmp/tmpy6i612zu.rs:16:30\n   |\n16 |                 .filter(|&i| is_consonant(word[i]))\n\
    \   |                              ^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let cons = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n    let vowels = \"aeiouAEIOU\";\n    let mut prev_is_cons = false;\n    let\
    \ mut nearest_vowel = ' ';\n    let mut nearest_vowel_idx = word.len();\n    for\
    \ (i, ch) in word.chars().enumerate().rev() {\n        if prev_is_cons && vowels.contains(ch)\
    \ {\n            if nearest_vowel_idx > i {\n                nearest_vowel = ch;\n\
    \                nearest_vowel_idx = i;\n            }\n        }\n        prev_is_cons\
    \ = cons.contains(ch);\n    }\n    if nearest_vowel_idx < word.len() {\n     \
    \   nearest_vowel.to_string()\n    } else {\n        \"\".to_string()\n    }\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmpk9pyr3ch.rs:17:45\n     |\n17   |     for (i, ch) in word.chars().enumerate().rev()\
    \ {\n     |                                             ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\n     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Enumerate<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0277]:\
    \ the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n  --> /tmp/tmpk9pyr3ch.rs:17:20\n\
    \   |\n17 |     for (i, ch) in word.chars().enumerate().rev() {\n   |        \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator` is not\
    \ implemented for `Chars<'_>`\n   |\n   = help: the following other types implement\
    \ trait `ExactSizeIterator`:\n             &mut I\n             Args\n       \
    \      ArgsOs\n             ArrayChunks<'_, T, N>\n             ArrayChunksMut<'_,\
    \ T, N>\n             ArrayWindows<'_, T, N>\n             Box<I, A>\n       \
    \      Chunks<'_, T>\n           and 109 others\n   = note: required because of\
    \ the requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \   = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ word = word.chars().rev().collect::<Vec<char>>();\n    let mut closest_vowel\
    \ = \"\".to_string();\n    for (i, c) in word.iter().enumerate() {\n        if\
    \ vowels.contains(c) {\n            if i + 1 < word.len() && !vowels.contains(&word[i\
    \ + 1]) {\n                closest_vowel = c.to_string();\n                break;\n\
    \            }\n        }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"i\"`,\n right: `\"\"`', /tmp/tmpffvda0yq.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut prev_vowel\
    \ = '\\0';\n    let mut prev_consonant = '\\0';\n    for character in word.chars().rev()\
    \ {\n        if is_vowel(character) {\n            if prev_consonant != '\\0'\
    \ {\n                result = character.to_string();\n                break;\n\
    \            }\n            prev_vowel = character;\n        } else {\n      \
    \      if prev_vowel != '\\0' {\n                result = prev_vowel.to_string();\n\
    \                break;\n            }\n            prev_consonant = character;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpgv_ga8xk.rs:16:12\n\
    \   |\n16 |         if is_vowel(character) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    if word.len() < 3 {\n        return String::new();\n\
    \    }\n    let mut a = word.chars().rev().peekable();\n    let mut b = word.chars().rev().peekable();\n\
    \    b.next();\n    loop {\n        if a.peek().is_none() || b.peek().is_none()\
    \ {\n            return String::new();\n        }\n        let a_ch = a.next().unwrap();\n\
    \        let b_ch = b.next().unwrap();\n        if is_vowel(a_ch) && !is_vowel(b_ch)\
    \ {\n            return a_ch.to_string();\n        }\n    }\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp6np5rjfw.rs:24:12\n\
    \   |\n24 |         if is_vowel(a_ch) && !is_vowel(b_ch) {\n   |            ^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `is_vowel` in\
    \ this scope\n  --> /tmp/tmp6np5rjfw.rs:24:31\n   |\n24 |         if is_vowel(a_ch)\
    \ && !is_vowel(b_ch) {\n   |                               ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut index\
    \ = 0;\n    let chars: Vec<char> = word.chars().collect();\n    for (i, c) in\
    \ chars.iter().enumerate() {\n        if !is_vowel(c) {\n            if i > index\
    \ {\n                index = i;\n            }\n        } else {\n           \
    \ if index != 0 {\n                result = chars[index].to_string();\n      \
    \          break;\n            }\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp_exdydy4.rs:16:13\n\
    \   |\n16 |         if !is_vowel(c) {\n   |             ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let word: Vec<char> = word.chars().collect();\n   \
    \ let mut word_chars: Vec<char> = word.clone();\n    word_chars.reverse();\n \
    \   let mut vowel_pos: Vec<usize> = Vec::new();\n    for (i, x) in word_chars.iter().enumerate()\
    \ {\n        if *x == 'a' || *x == 'e' || *x == 'i' || *x == 'o' || *x == 'u'\
    \ || *x == 'A' || *x == 'E' || *x == 'I' || *x == 'O' || *x == 'U' {\n       \
    \     vowel_pos.push(i);\n        }\n    }\n    vowel_pos.reverse();\n    for\
    \ x in vowel_pos {\n        if x + 1 < word_chars.len() {\n            if word_chars[x\
    \ + 1] != 'a' && word_chars[x + 1] != 'e' && word_chars[x + 1] != 'i' && word_chars[x\
    \ + 1] != 'o' && word_chars[x + 1] != 'u' && word_chars[x + 1] != 'A' && word_chars[x\
    \ + 1] != 'E' && word_chars[x + 1] != 'I' && word_chars[x + 1] != 'O' && word_chars[x\
    \ + 1] != 'U' {\n                return word[word.len() - x - 1].to_string();\n\
    \            }\n        }\n    }\n    String::from(\"\")\n}\n\nfn main() {\n \
    \   let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmp58rcuiv1.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut index = 0;\n    for (i, ch) in word.char_indices().rev()\
    \ {\n        match ch {\n            'a' | 'e' | 'i' | 'o' | 'u' => {\n      \
    \          index = i;\n                break;\n            }\n            _ =>\
    \ {}\n        }\n    }\n    String::from(&word[index..=index])\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmp9xrqrocz.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiou\";\n    let mut dist = word.len();\n\
    \    let mut result = \"\";\n    for (i, c) in word.chars().enumerate().rev()\
    \ {\n        if vowels.contains(c) {\n            if i < dist {\n            \
    \    dist = i;\n                result = c.to_string().as_str();\n           \
    \ }\n        }\n    }\n    result.to_string()\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmpx_k48uqd.rs:15:44\n     |\n15   |     for (i, c) in word.chars().enumerate().rev()\
    \ {\n     |                                            ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\n     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Enumerate<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0277]:\
    \ the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n  --> /tmp/tmpx_k48uqd.rs:15:19\n\
    \   |\n15 |     for (i, c) in word.chars().enumerate().rev() {\n   |         \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator` is not\
    \ implemented for `Chars<'_>`\n   |\n   = help: the following other types implement\
    \ trait `ExactSizeIterator`:\n             &mut I\n             Args\n       \
    \      ArgsOs\n             ArrayChunks<'_, T, N>\n             ArrayChunksMut<'_,\
    \ T, N>\n             ArrayWindows<'_, T, N>\n             Box<I, A>\n       \
    \      Chunks<'_, T>\n           and 109 others\n   = note: required because of\
    \ the requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \   = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    const VOWELS: &str = \"aeiou\";\n    let mut previous_consonant\
    \ = false;\n    let chars: Vec<char> = word.chars().rev().collect();\n    for\
    \ c in chars {\n        if previous_consonant && VOWELS.contains(c) {\n      \
    \      return c.to_string();\n        }\n        previous_consonant = !VOWELS.contains(c);\n\
    \    }\n    String::new()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmphxw137ky.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"\
    ];\n    let mut closest = \"\";\n    let mut distance = word.len();\n    let mut\
    \ prev = ' ';\n    for c in word.chars().rev() {\n        if !vowels.contains(&c.to_string().as_str())\
    \ {\n            if prev != ' ' && vowels.contains(&prev.to_string().as_str())\
    \ {\n                let d = word.len() - distance;\n                if d < distance\
    \ {\n                    distance = d;\n                    closest = prev.to_string().as_str();\n\
    \                }\n            }\n        }\n        prev = c;\n        distance\
    \ -= 1;\n    }\n    closest.to_string()\n}\n\nfn main() {\n    let candidate =\
    \ get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmphaa958yw.rs:22:31\n\
    \   |\n22 |                     closest = prev.to_string().as_str();\n   |   \
    \                            ^^^^^^^^^^^^^^^^         - temporary value is freed\
    \ at the end of this statement\n   |                               |\n   |   \
    \                            creates a temporary which is freed while still in\
    \ use\n...\n29 |     closest.to_string()\n   |     ------------------- borrow\
    \ later used here\n   |\n   = note: consider using a `let` binding to create a\
    \ longer lived value\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0716`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp4ucylset.rs:12:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut first_idx = None;\n    let mut second_idx = None;\n    let mut first_vowel\
    \ = false;\n    let mut second_vowel = false;\n    let mut count = 0;\n    let\
    \ word_bytes = word.as_bytes();\n    for byte in word_bytes.iter().rev() {\n \
    \       count += 1;\n        if vowels.contains(&(byte.to_ascii_lowercase() as\
    \ char)) {\n            if first_vowel {\n                second_vowel = true;\n\
    \                second_idx = Some(count);\n                break;\n         \
    \   } else {\n                first_vowel = true;\n                first_idx =\
    \ Some(count);\n            }\n        }\n    }\n    if first_vowel && second_vowel\
    \ {\n        if first_idx < second_idx {\n            return word_bytes[word_bytes.len()\
    \ - first_idx.unwrap()].to_string();\n        } else {\n            return word_bytes[word_bytes.len()\
    \ - second_idx.unwrap()].to_string();\n        }\n    }\n    String::from(\"\"\
    )\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"117\"`,\n right: `\"u\"`', /tmp/tmpqv6syj3s.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    return word.chars().rev().filter(|&c| is_vowel(c)).nth(1).map(|c|\
    \ c.to_string()).unwrap_or(\"\".to_string());\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpka5_8ej7.rs:12:43\n\
    \   |\n12 |     return word.chars().rev().filter(|&c| is_vowel(c)).nth(1).map(|c|\
    \ c.to_string()).unwrap_or(\"\".to_string());\n   |                          \
    \                 ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest = String::new();\n    let vowels =\
    \ vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut start = false;\n    for\
    \ (index, letter) in word.chars().rev().enumerate() {\n        if vowels.contains(&letter.to_string().as_str())\
    \ {\n            if index > 0 && !vowels.contains(&word.chars().rev().nth(index\
    \ - 1).unwrap().to_string().as_str()) {\n                start = true;\n     \
    \       }\n            if start {\n                closest = letter.to_string();\n\
    \                break;\n            }\n        }\n    }\n    closest\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmptc49lpsv.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    if word.len() <= 1 {\n        return String::new();\n\
    \    }\n    let mut flag = true;\n    let mut res = String::new();\n    let mut\
    \ idx = 1;\n    while idx < word.len() {\n        if word.chars().nth(idx).unwrap().is_vowel()\
    \ {\n            if flag {\n                if word.chars().nth(idx - 1).unwrap().is_consonant()\
    \ {\n                    return word.chars().nth(idx).unwrap().to_string();\n\
    \                }\n            } else {\n                flag = true;\n     \
    \       }\n        } else {\n            flag = false;\n        }\n        idx\
    \ += 1;\n    }\n    return res;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp0f5x__jg.rs:19:43\n   |\n19 |         if word.chars().nth(idx).unwrap().is_vowel()\
    \ {\n   |                                           ^^^^^^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `is_consonant` found for type `char`\
    \ in the current scope\n  --> /tmp/tmp0f5x__jg.rs:21:55\n   |\n21 |          \
    \       if word.chars().nth(idx - 1).unwrap().is_consonant() {\n   |         \
    \                                              ^^^^^^^^^^^^ method not found in\
    \ `char`\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let word = word.into_bytes();\n    let mut i = word.len()\
    \ - 1;\n    let mut c = 0;\n    let mut d = 0;\n    loop {\n        if i == 0\
    \ {\n            break;\n        }\n        if word[i] == b'a' || word[i] == b'e'\
    \ || word[i] == b'i' || word[i] == b'o' || word[i] == b'u' {\n            d =\
    \ i;\n            break;\n        }\n        if word[i] != b'a' && word[i] !=\
    \ b'e' && word[i] != b'i' && word[i] != b'o' && word[i] != b'u' {\n          \
    \  c = i;\n        }\n        i -= 1;\n    }\n    if c == 0 {\n        return\
    \ String::from(\"\");\n    }\n    if d == 0 {\n        return String::from(\"\"\
    );\n    }\n    let mut j = d - 1;\n    while j != 0 {\n        if word[j] != b'a'\
    \ && word[j] != b'e' && word[j] != b'i' && word[j] != b'o' && word[j] != b'u'\
    \ {\n            c = j;\n            break;\n        }\n        j -= 1;\n    }\n\
    \    if c == 0 {\n        return String::from(\"\");\n    }\n    if d == 0 {\n\
    \        return String::from(\"\");\n    }\n    String::from_utf8(vec![word[d]]).unwrap()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpyj64vjwa.rs:56:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\n/// get_closest_vowel(\"\
    yogurt\") ==> \"u\"\n/// get_closest_vowel(\"FULL\") ==> \"U\"\n/// get_closest_vowel(\"\
    quick\") ==> \"\"\n/// get_closest_vowel(\"ab\") ==> \"\"\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut word_chars = word.chars().collect::<Vec<char>>();\n    word_chars.reverse();\n\
    \    for i in 0..word_chars.len() - 1 {\n        if vowels.contains(&word_chars[i])\
    \ && vowels.contains(&word_chars[i + 1]) {\n            continue;\n        }\n\
    \        if vowels.contains(&word_chars[i]) {\n            return word_chars[i].to_string();\n\
    \        }\n    }\n    \"\".to_string()\n}\n\nfn main() {\n    let candidate =\
    \ get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"i\"`,\n right: `\"\"`', /tmp/tmpdojg7udp.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
