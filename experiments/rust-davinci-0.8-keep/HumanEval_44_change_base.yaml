name: HumanEval_44_change_base
language: rust
prompt: "/// Change numerical base of input number x to base.\n/// return string representation\
  \ after the conversion.\n/// base numbers are less than 10.\n/// >>> change_base(8,\
  \ 3)\n/// '22'\n/// >>> change_base(8, 2)\n/// '1000'\n/// >>> change_base(7, 2)\n\
  /// '111'\nfn change_base(x: isize, base: isize) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
  \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
  ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
  \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
  1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
  \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
  ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
  \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
  ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
completions: ["    let mut m = x;\n    let mut result = String::new();\n    while\
    \ m > 0 {\n        let y = m % base;\n        result.push_str(&y.to_string());\n\
    \        m = m / base;\n    }\n    result.chars().rev().collect()", "  let mut\
    \ output = String::new();\n  let mut x = x;\n  while x > 0 {\n    output.push_str(&(x\
    \ % base).to_string());\n    x /= base;\n  }\n  output.chars().rev().collect()",
  "    let mut result = \"\".to_string();\n    let mut x = x;\n    let mut digit;\n\
    \    loop {\n        digit = x % base;\n        x = x / base;\n        result\
    \ = digit.to_string() + &result;\n        if x == 0 {\n            break;\n  \
    \      }\n    }\n    result", "    let mut results = vec![];\n    let mut n =\
    \ x;\n    while n > 0 {\n        results.push((n % base).to_string());\n     \
    \   n /= base;\n    }\n    results.reverse();\n    results.join(\"\")", "    let\
    \ mut result = String::new();\n    let mut num = x;\n    while num > 0 {\n   \
    \     result.push_str(&(num % base).to_string());\n        num /= base;\n    }\n\
    \    let mut result: String = result.chars().rev().collect();\n    if result.len()\
    \ == 0 {\n        result.push('0');\n    }\n    result", "    if x == 0 {\n  \
    \      return \"0\".to_string();\n    }\n    let mut x = x;\n    let mut re =\
    \ String::new();\n    while x > 0 {\n        re.push_str(&format!(\"{}\", x %\
    \ base));\n        x /= base;\n    }\n    re.chars().rev().collect()", "    let\
    \ mut result = Vec::new();\n    let mut x = x;\n    while x != 0 {\n        result.push((x\
    \ % base).to_string());\n        x /= base;\n    }\n    result.reverse();\n  \
    \  result.join(\"\")", "    if x == 0 {\n        return \"0\".to_string();\n \
    \   }\n    let mut ret = String::new();\n    let mut x = x;\n    while x > 0 {\n\
    \        ret.push_str(&((x % base).to_string()));\n        x /= base;\n    }\n\
    \    return ret.chars().rev().collect();", "    let mut new_string = String::new();\n\
    \    let mut value = x;\n    let mut res = 0;\n    while value != 0 {\n      \
    \  res = value % base;\n        new_string.push_str(&res.to_string());\n     \
    \   value = value / base;\n    }\n    let reversed: String = new_string.chars().rev().collect();\n\
    \    reversed", "    let mut res = String::new();\n    let mut x = x;\n    while\
    \ x != 0 {\n        res.push_str(&((x % base).to_string()));\n        x /= base;\n\
    \    }\n    res.chars().rev().collect()", "    let x = x as isize;\n    let base\
    \ = base as isize;\n    let mut result = \"\".to_string();\n    let mut n = x;\n\
    \    while n > 0 {\n        let (q, r) = n.div_rem(&base);\n        result = (r\
    \ as usize).to_string() + &result;\n        n = q;\n    }\n    result", "    assert!(base\
    \ < 10, \"base number is less than 10\");\n    let mut s = \"\".to_string();\n\
    \    let mut xx = x;\n    while xx > 0 {\n        s = format!(\"{}{}\", xx % base,\
    \ s);\n        xx /= base;\n    }\n    return s;", "  if x == 0 {\n    return\
    \ \"0\".to_string();\n  }\n  let mut res = String::new();\n  let mut x = x;\n\
    \  while x > 0 {\n    res.push_str(&((x % base).to_string()));\n    x /= base;\n\
    \  }\n  res", "    // To return the result as a String,\n    // this function\
    \ uses recursion.\n    if x >= base {\n        change_base(x / base, base) + (x\
    \ % base).to_string().as_str()\n    } else {\n        x.to_string()\n    }", " \
    \   let mut input = x;\n    let mut result = String::new();\n    while input >\
    \ 0 {\n        let tmp = input % base;\n        result.push_str(&format!(\"{}\"\
    , tmp));\n        input = input / base;\n    }\n    result.chars().rev().collect()",
  "    if x < base {\n        format!(\"{}\", x)\n    } else {\n        format!(\"\
    {}{}\", change_base(x / base, base), x % base)\n    }", '    format!("{:b}", x)',
  "    let mut result = String::new();\n    let mut x = x;\n    while x > 0 {\n  \
    \      result.push(((x % base) + '0' as isize) as u8 as char);\n        x /= base;\n\
    \    }\n    result.chars().rev().collect()", "    let mut string = String::new();\n\
    \    let mut result = x;\n    while result > 0 {\n        let rem = result % base;\n\
    \        result = result / base;\n        string.push(std::char::from_digit(rem\
    \ as u32, base as u32).unwrap());\n    }\n    string.chars().rev().collect()",
  "    if x < base {\n        return x.to_string();\n    }\n    let mut x = x;\n \
    \   let mut y = Vec::new();\n    let mut s = String::new();\n    while x >= base\
    \ {\n        y.push(x % base);\n        x = x / base;\n    }\n    y.push(x);\n\
    \    for x in y.iter().rev() {\n        s.push_str(&x.to_string());\n    }\n \
    \   s", "    if x < base {\n        return format!(\"{}\", x);\n    }\n    let\
    \ rest = x % base;\n    return format!(\"{}{}\", change_base(x / base, base),\
    \ rest);", "    let mut res = String::new();\n    let mut x = x;\n    while x\
    \ > 0 {\n        res = format!(\"{}{}\", x % base, res);\n        x /= base;\n\
    \    }\n    res", "    let mut str_rep = String::new();\n    let mut x = x;\n\
    \    let mut temp: isize;\n    let mut rem: isize;\n    let base = 10;\n    while\
    \ x > 0 {\n        temp = x / base;\n        rem = x % base;\n        x = temp;\n\
    \        str_rep.push(std::char::from_digit(rem as u32, base as u32).unwrap());\n\
    \    }\n    // let mut res = str_rep.chars().rev().collect::<String>();\n    //\
    \ res\n    str_rep", "    if x == 0 {\n        return String::from(\"0\");\n \
    \   }\n    let mut ans = String::new();\n    let mut x = x;\n    while x > 0 {\n\
    \        ans = (x % base).to_string() + &ans;\n        x /= base;\n    }\n   \
    \ ans", "    let mut res = String::new();\n    let mut cur = x;\n    while cur\
    \ > 0 {\n        res.push(((cur % base) + 48) as u8 as char);\n        cur /=\
    \ base;\n    }\n    res.chars().rev().collect()", "    let mut result = String::new();\n\
    \    let mut x = x;\n    let mut r = 0;\n    while x != 0 {\n        r = x % base;\n\
    \        x = x / base;\n        result.push_str(&r.to_string());\n    }\n    result.chars().rev().collect()",
  "    if x <= 0 {\n        return \"0\".to_string();\n    }\n    let mut s = String::new();\n\
    \    let mut y = x;\n    while y > 0 {\n        s.push((y % base + b'0') as char);\n\
    \        y /= base;\n    }\n    s.chars().rev().collect()", "    let mut x = x;\n\
    \    let mut result = String::new();\n    while x > 0 {\n        let rem = x %\
    \ base;\n        result.push(char::from_digit(rem as u32, base as u32).unwrap());\n\
    \        x /= base;\n    }\n    result.chars().rev().collect()", "    let mut\
    \ x = x;\n    let mut result = String::new();\n    while x > 0 {\n        let\
    \ digit = x % base;\n        result.push_str(&digit.to_string());\n        x /=\
    \ base;\n    }\n    result.chars().rev().collect()", "    let mut x = x;\n   \
    \ let mut result = String::new();\n    while x != 0 {\n        let remainder =\
    \ x % base;\n        x = x / base;\n        result.push(char::from_digit(remainder\
    \ as u32, base as u32).unwrap());\n    }\n    result.chars().rev().collect()",
  "    let mut result = String::new();\n    let mut x = x;\n    while x > 0 {\n  \
    \      result.push_str(&(x % base).to_string());\n        x /= base;\n    }\n\
    \    result.chars().rev().collect()", "    let mut result = String::new();\n \
    \   let mut x = x;\n    while x > 0 {\n        result.push_str(format!(\"{}\"\
    , x % base).as_str());\n        x /= base;\n    }\n    result.chars().rev().collect()",
  "    assert!(x >= 0);\n    assert!(base >= 2);\n    assert!(base <= 10);\n    let\
    \ mut x = x;\n    let mut s = String::new();\n    while x != 0 {\n        s.push(((x\
    \ % base) + b'0') as char);\n        x /= base;\n    }\n    s.chars().rev().collect()",
  "    let mut result = String::new();\n    let mut x = x;\n    while x != 0 {\n \
    \       let remainder = x % base;\n        x = x / base;\n        result.push(char::from_digit(remainder\
    \ as u32, base as u32).unwrap());\n    }\n    result.chars().rev().collect()",
  '  format!("{:b}", x)', "  let mut n = x;\n  let mut s = String::new();\n  while\
    \ n > 0 {\n    s.push_str(&format!(\"{}\", n % base));\n    n /= base;\n  }\n\
    \  s.chars().rev().collect()", "    let mut base_x = String::new();\n    let mut\
    \ x = x;\n    while x > 0 {\n        base_x = format!(\"{}{}\", x % base, base_x);\n\
    \        x /= base;\n    }\n    base_x", "    if x == 0 {\n        return \"0\"\
    .to_string();\n    }\n    let mut res = String::new();\n    let mut x = x;\n \
    \   while x > 0 {\n        res.push_str(&((x % base).to_string()));\n        x\
    \ /= base;\n    }\n    res.chars().rev().collect()", "    let mut x = x;\n   \
    \ let mut s = String::new();\n    while x > 0 {\n        s.push(((x % base) +\
    \ 48) as u8 as char);\n        x /= base;\n    }\n    s.chars().rev().collect()",
  "    // TODO: Your code here\n    let mut res = String::new();\n    let mut x =\
    \ x;\n    while x > 0 {\n        res.push_str(&((x % base).to_string()));\n  \
    \      x /= base;\n    }\n    res.chars().rev().collect()", "    let mut x = x;\n\
    \    let mut result = String::new();\n    while x > 0 {\n        let r = x % base;\n\
    \        result.push_str(&format!(\"{}\", r));\n        x /= base;\n    }\n  \
    \  result.chars().rev().collect()", "    let mut s = String::new();\n    let mut\
    \ x = x;\n    while x > 0 {\n        s.push_str(&(x % base).to_string());\n  \
    \      x /= base;\n    }\n    s.chars().rev().collect()", "    let mut ret: String\
    \ = String::new();\n    let mut r = x;\n    while r > 0 {\n        ret.push(((r\
    \ % base) + 48) as u8 as char);\n        r /= base;\n    }\n    ret.chars().rev().collect()",
  "    let mut result = String::new();\n    let mut n = x;\n    while n > 0 {\n  \
    \      result.push_str(&((n % base) as u8 + b'0' as u8) as &str);\n        n /=\
    \ base;\n    }\n    result.chars().rev().collect()", "    // TODO\n    let mut\
    \ x = x;\n    let mut result = String::new();\n    let mut digit;\n    while x\
    \ > 0 {\n        digit = x % base;\n        x = x / base;\n        result.push_str(&digit.to_string());\n\
    \    }\n    result", "    let mut out = String::new();\n    let mut current =\
    \ x;\n    while current != 0 {\n        let rem = current % base;\n        current\
    \ = current / base;\n        out.push_str(&rem.to_string());\n    }\n    out.chars().rev().collect()",
  "    let mut ans = String::new();\n    let mut x = x;\n    while x > 0 {\n     \
    \   ans.push_str(&((x % base) as u8 + 48) as &str);\n        x /= base;\n    }\n\
    \    ans.chars().rev().collect()", "    let mut k = x;\n    let mut num = String::new();\n\
    \    loop {\n        if k < base {\n            num.push_str(&k.to_string());\n\
    \            break;\n        } else {\n            num.push_str(&(k % base).to_string());\n\
    \            k /= base;\n        }\n    }\n    return num.chars().rev().collect::<String>();",
  "    if x == 0 {\n        return \"0\".to_string();\n    }\n    let mut num = x;\n\
    \    let mut result = String::new();\n    while num > 0 {\n        result.push_str(&((num\
    \ % base).to_string()));\n        num /= base;\n    }\n    result.chars().rev().collect()",
  "    let mut base_num = x;\n    let mut ret = String::new();\n    while base_num\
    \ > 0 {\n        let c = (base_num % base).to_string();\n        ret.push_str(&c);\n\
    \        base_num /= base;\n    }\n    ret.chars().rev().collect()", "    if x\
    \ == 0 {\n        return \"0\".to_string();\n    }\n    let is_neg = x < 0;\n\
    \    let mut x = x.abs();\n    let mut res = String::new();\n    while x > 0 {\n\
    \        res.push_str(&((x % base) as u8 + '0' as u8) as &str);\n        x /=\
    \ base;\n    }\n    if is_neg {\n        res.push_str(\"-\");\n    }\n    res.chars().rev().collect()",
  "    let mut n = x;\n    let mut r = Vec::new();\n    while n > 0 {\n        r.push((n\
    \ % base).to_string());\n        n /= base;\n    }\n    return r.join(\"\");",
  "    let mut x = x;\n    let mut res = vec![];\n    while x > 0 {\n        res.push((x\
    \ % base).to_string());\n        x /= base;\n    }\n    res.iter().rev().cloned().collect()",
  "    let mut rest = x;\n    let mut reversed_digits = Vec::new();\n    while rest\
    \ > 0 {\n        let digit = rest % base;\n        rest = rest / base;\n     \
    \   reversed_digits.push(digit);\n    }\n    let mut s = String::new();\n    for\
    \ i in reversed_digits.iter().rev() {\n        s.push_str(&format!(\"{}\", i));\n\
    \    }\n    s", "    let mut r = String::new();\n    let mut xx = x;\n    let\
    \ mut rr = 0;\n    let mut qq = 0;\n    loop {\n        rr = xx % base;\n    \
    \    qq = xx / base;\n        r.push_str(&rr.to_string());\n        if qq < base\
    \ {\n            r.push_str(&qq.to_string());\n            break;\n        }\n\
    \        xx = qq;\n    }\n    r.chars().rev().collect()", "    let mut result\
    \ = String::new();\n    let mut x = x;\n    while x > 0 {\n        result.push_str(format!(\"\
    {}\", x % base).as_str());\n        x /= base;\n    }\n    result.chars().rev().collect()",
  "    let mut ans = String::new();\n    let mut n = x;\n    while n > 0 {\n     \
    \   ans = format!(\"{}{}\", ans, n % base);\n        n /= base;\n    }\n    ans",
  "    let mut x = x;\n    let mut buf = String::new();\n    while x > 0 {\n     \
    \   buf.push_str(&format!(\"{}\", x % base));\n        x /= base;\n    }\n   \
    \ buf.chars().rev().collect()", "    if x == 0 {\n        return String::from(\"\
    0\");\n    }\n\n    let mut x = x;\n    let mut ans = String::new();\n    while\
    \ x > 0 {\n        ans.push(((x % base) + 48) as u8 as char);\n        x /= base;\n\
    \    }\n    ans.chars().rev().collect()", "    if x == 0 {\n        return \"\
    0\".to_string();\n    }\n    let mut res = String::new();\n    let mut n = x;\n\
    \    while n > 0 {\n        res.push(((n % base) + 48) as u8 as char);\n     \
    \   n /= base;\n    }\n    res.chars().rev().collect()", "    let mut result =\
    \ String::new();\n    let mut quotient = x;\n    let mut remainder = 0;\n    loop\
    \ {\n        remainder = quotient % base;\n        quotient = quotient / base;\n\
    \        result.push_str(&remainder.to_string());\n        if quotient == 0 {\n\
    \            break;\n        }\n    }\n    result.chars().rev().collect()", " \
    \   let mut ans = String::new();\n    let mut x = x;\n    while x > 0 {\n    \
    \    ans = format!(\"{}{}\", (x % base).to_string(), ans);\n        x /= base;\n\
    \    }\n    ans", "    let mut res = String::new();\n    let mut x = x;\n    while\
    \ x != 0 {\n        res = format!(\"{}{}\", x % base, res);\n        x /= base;\n\
    \    }\n    res", "    if x < base {\n        x.to_string()\n    } else {\n  \
    \      let mut output = String::new();\n        let mut temp = x;\n        while\
    \ temp > 0 {\n            let remainder = temp % base;\n            output.push_str(&remainder.to_string());\n\
    \            temp = temp / base;\n        }\n        output.chars().rev().collect()\n\
    \    }", "    let mut res = String::new();\n    let mut x = x;\n    let mut y\
    \ = base;\n    let mut y_cnt = 0;\n    while y <= x {\n        y *= base;\n  \
    \      y_cnt += 1;\n    }\n    for _ in 0..y_cnt {\n        y /= base;\n     \
    \   let digit = x / y;\n        res.push_str(&digit.to_string());\n        x -=\
    \ digit * y;\n    }\n    if x > 0 {\n        res.push_str(&x.to_string());\n \
    \   }\n    res", "    let mut x = x;\n    let mut result = String::new();\n  \
    \  while x > 0 {\n        let rem = x % base;\n        result.push_str(&rem.to_string());\n\
    \        x /= base;\n    }\n    result.chars().rev().collect()", "    let mut\
    \ r = String::new();\n    let mut num = x;\n    while num > 0 {\n        r.push(((num\
    \ % base) + ('0' as isize)) as u8 as char);\n        num /= base;\n    }\n   \
    \ r.chars().rev().collect()", "    let mut x = x;\n    let mut ret = String::new();\n\
    \    while x != 0 {\n        ret.push_str(&(x % base).to_string());\n        x\
    \ /= base;\n    }\n    ret.chars().rev().collect()", "    if x == 0 {\n      \
    \  return \"0\".to_string();\n    }\n    let mut x = x;\n    let mut ans = vec![];\n\
    \    while x > 0 {\n        ans.push((x % base) as u8);\n        x /= base;\n\
    \    }\n    ans.reverse();\n    String::from_utf8(ans).unwrap()", "    let mut\
    \ x = x;\n    let mut r = String::new();\n    loop {\n        let d = x % base;\n\
    \        x = x / base;\n        r.push_str(&d.to_string());\n        if x == 0\
    \ {\n            break;\n        }\n    }\n    r", "    let mut digits = Vec::new();\n\
    \    let mut x = x;\n    while x > 0 {\n        digits.push(x % base);\n     \
    \   x /= base;\n    }\n    digits.iter().rev().map(|x| x.to_string()).collect()",
  "    if x / base == 0 {\n        return format!(\"{}\", x % base);\n    }\n    return\
    \ format!(\"{}{}\", change_base(x / base, base), x % base);", "  let mut x = x;\n\
    \  let mut digits = Vec::new();\n  while x > 0 {\n    digits.push((x % base) as\
    \ u8);\n    x /= base;\n  }\n  digits.reverse();\n  String::from_utf8(digits).unwrap()",
  "    let mut q = x;\n    let mut s = String::new();\n    let mut r = 0;\n    while\
    \ q > 0 {\n        r = q % base;\n        q = q / base;\n        s.push_str(&r.to_string());\n\
    \    }\n    s.chars().rev().collect()", "    let mut x = x;\n    let mut res =\
    \ String::new();\n    while x > 0 {\n        res.push_str(format!(\"{}\", x %\
    \ base).as_str());\n        x /= base;\n    }\n    res.chars().rev().collect()",
  "    let mut q = x;\n    let mut r = 0;\n    let mut st = String::new();\n    while\
    \ q != 0 {\n        r = q % base;\n        q = q / base;\n        st = st + &r.to_string();\n\
    \    }\n    st.chars().rev().collect()", "    if x < base {\n        return x.to_string();\n\
    \    }\n    format!(\"{}{}\", change_base(x / base, base), x % base)", "    let\
    \ mut result = String::new();\n    let mut current = x;\n    while current > 0\
    \ {\n        let remainder = current % base;\n        result.push_str(&remainder.to_string());\n\
    \        current = current / base;\n    }\n    result.chars().rev().collect()",
  "    let mut n = x;\n    let mut s = String::new();\n    while n > 0 {\n       \
    \ s.push_str(&(n % base).to_string());\n        n /= base;\n    }\n    s.chars().rev().collect()",
  "    let mut res = String::new();\n    let mut x = x;\n    while x > 0 {\n     \
    \   res.push_str(&((x % base) as u8 + 48).to_string());\n        x /= base;\n\
    \    }\n    res.chars().rev().collect()", "    let mut rez = String::new();\n\
    \    let mut input = x;\n    while input != 0 {\n        rez.push_str(&(input\
    \ % base).to_string());\n        input /= base;\n    }\n    rez.chars().rev().collect()",
  "    if x == 0 {\n        return \"0\".to_string();\n    }\n    let mut result =\
    \ String::new();\n    let mut x = x;\n    while x > 0 {\n        result.push_str(format!(\"\
    {}\", x % base).as_str());\n        x /= base;\n    }\n    result.chars().rev().collect()",
  "    // Your code here!\n    unimplemented!();", "    let mut string = String::new();\n\
    \    let mut value = x;\n    while value > 0 {\n        let c = (value % base)\
    \ as u8 + '0' as u8;\n        string.push(c as char);\n        value /= base;\n\
    \    }\n    string.chars().rev().collect()", "    let mut s = String::new();\n\
    \    let mut n = x;\n    while n > 0 {\n        s.push_str(&(n % base).to_string());\n\
    \        n /= base;\n    }\n    s.chars().rev().collect()", "    let mut x = x;\n\
    \    let mut buf = String::new();\n    loop {\n        buf.push_str(&format!(\"\
    {}\", x % base));\n        x /= base;\n        if x == 0 {\n            break;\n\
    \        }\n    }\n    buf.chars().rev().collect()", "    // Complete this function\n\
    \    let mut result = String::new();\n    let mut temp = x;\n    while temp !=\
    \ 0 {\n        result.push_str(&(temp % base).to_string());\n        temp /= base;\n\
    \    }\n    result.chars().rev().collect()", "    let mut v = vec![];\n    let\
    \ mut x = x;\n    while x > 0 {\n        v.push((x % base).to_string());\n   \
    \     x /= base;\n    }\n    v.reverse();\n    v.join(\"\")", "    let mut ans\
    \ = String::new();\n    let mut x = x;\n    let mut base = base;\n    while x\
    \ != 0 {\n        ans.push_str(&format!(\"{}\", x % base));\n        x /= base;\n\
    \    }\n    ans.chars().rev().collect()", "    if x < base {\n        return x.to_string();\n\
    \    }\n\n    let x = x / base;\n    let r = x % base;\n    change_base(x, base)\
    \ + &r.to_string()", "    let res = if x == 0 {\n        return \"0\".to_string();\n\
    \    } else {\n        let mut x = x;\n        let mut res = String::new();\n\
    \        while x > 0 {\n            res.push_str(&((x % base).to_string()));\n\
    \            x /= base;\n        }\n        res\n    };\n    res.chars().rev().collect()",
  "  let mut s = String::new();\n  let mut x = x;\n  while x > 0 {\n    s.push(((x\
    \ % base) + 48) as u8 as char);\n    x /= base;\n  }\n  s.chars().rev().collect()",
  "  if x == 0 {\n    return \"0\".to_string();\n  }\n  let mut result = Vec::new();\n\
    \  let mut x = x;\n  while x > 0 {\n    result.push((x % base).to_string());\n\
    \    x /= base;\n  }\n  result.reverse();\n  result.join(\"\")", "    let mut\
    \ x = x;\n    let mut a = Vec::new();\n    while x > 0 {\n        a.push((x %\
    \ base).to_string());\n        x /= base;\n    }\n    a.reverse();\n    a.join(\"\
    \")", "    // if x == 0 {\n    //     return String::from(\"0\");\n    // }\n\
    \    let mut rem = x;\n    let mut result = String::new();\n    while rem > 0\
    \ {\n        let d = rem % base;\n        result.push_str(&d.to_string());\n \
    \       rem = rem / base;\n    }\n    result.chars().rev().collect()", "    let\
    \ mut res = String::new();\n    let mut x = x;\n    while x > 0 {\n        res.push_str(&format!(\"\
    {}\", x % base));\n        x /= base;\n    }\n    res.chars().rev().collect()",
  "    let mut num = x;\n    let mut result = String::new();\n    let mut r = num\
    \ % base;\n    num = num / base;\n    result = r.to_string() + &result;\n    while\
    \ num > 0 {\n        r = num % base;\n        num = num / base;\n        result\
    \ = r.to_string() + &result;\n    }\n    result", "    let mut result = String::new();\n\
    \    let mut x = x;\n    while x > 0 {\n        result.push_str(&(x % base).to_string());\n\
    \        x /= base;\n    }\n    result.chars().rev().collect()", "    let mut\
    \ x = x;\n    let mut r = String::new();\n    loop {\n        let y = x % base;\n\
    \        x = x / base;\n        r.push_str(&y.to_string());\n        if x == 0\
    \ {\n            break;\n        }\n    }\n    let mut r: String = r.chars().rev().collect();\n\
    \    r", "    let mut n = x;\n    let mut t = String::new();\n    loop {\n   \
    \     if n == 0 {\n            break;\n        }\n        let r = n % base;\n\
    \        n = n / base;\n        t.push_str(&r.to_string());\n    }\n    t.chars().rev().collect()",
  "    let mut result = String::new();\n    let mut x = x;\n    while x != 0 {\n \
    \       let remainder = x % base;\n        result.push(std::char::from_digit(remainder\
    \ as u32, base as u32).unwrap());\n        x /= base;\n    }\n    result.chars().rev().collect()",
  "    let mut x = x;\n    let mut result = String::new();\n    while x > 0 {\n  \
    \      let r = x % base;\n        result.push_str(&format!(\"{}\", r));\n    \
    \    x /= base;\n    }\n    result.chars().rev().collect()", "    if x < base\
    \ {\n        format!(\"{}\", x)\n    } else {\n        format!(\"{}{}\", change_base(x\
    \ / base, base), x % base)\n    }", "    let mut x = x;\n    let mut digits =\
    \ Vec::new();\n    while x > 0 {\n        digits.push((x % base) as char);\n \
    \       x /= base;\n    }\n    digits.iter().rev().collect()", "    if x == 0\
    \ {\n        \"0\".to_string()\n    } else {\n        let mut r = String::new();\n\
    \        let mut num = x;\n        while num > 0 {\n            r.push_str(&((num\
    \ % base) as u8 as char).to_string());\n            num /= base;\n        }\n\
    \        r.chars().rev().collect()\n    }", "    let quotient = x / base;\n  \
    \  let remainder = x % base;\n    let mut s = String::new();\n    if quotient\
    \ > 0 {\n        s = change_base(quotient, base);\n    }\n    s.push_str(&remainder.to_string());\n\
    \    s", "    let mut res = String::new();\n    let mut x = x;\n    while x !=\
    \ 0 {\n        res = format!(\"{}{}\", res, x % base);\n        x /= base;\n \
    \   }\n    res", "    if x < 0 {\n        panic!(\"x is not positive number\"\
    );\n    } else if x == 0 {\n        return \"0\".to_string();\n    }\n\n    let\
    \ s = \"\";\n    change_base_inner(x, base, s).to_string()", "    if x < base\
    \ {\n        return x.to_string();\n    }\n    let s = change_base(x / base, base);\n\
    \    return s + &(x % base).to_string();", "    let mut result = String::new();\n\
    \    let mut n = x;\n    while n > 0 {\n        result.push((n % base) as u8 as\
    \ char);\n        n /= base;\n    }\n    result.chars().rev().collect()", "  \
    \  let mut x = x;\n    let mut str = String::new();\n    while x > 0 {\n     \
    \   str.push_str(&((x % base).to_string()));\n        x /= base;\n    }\n    str.chars().rev().collect()",
  "  let mut x = x;\n  let mut s = String::new();\n  while x > 0 {\n    s.push(((x\
    \ % base) + b'0') as char);\n    x /= base;\n  }\n  s.chars().rev().collect()",
  "    let mut x = x;\n    let mut result = String::new();\n    loop {\n        let\
    \ d = x % base;\n        x = x / base;\n        result.push_str(&d.to_string());\n\
    \        if x == 0 {\n            break;\n        }\n    }\n    result", "   \
    \ let mut q = x;\n    let mut r = 0;\n    let mut result = String::new();\n  \
    \  while q > 0 {\n        r = q % base;\n        q = q / base;\n        result.push_str(&r.to_string());\n\
    \    }\n    result.chars().rev().collect()", "    let mut x = x;\n    let mut\
    \ result = \"\".to_string();\n    while x > 0 {\n        let rest = x % base;\n\
    \        x = x / base;\n        result = format!(\"{}{}\", rest, result);\n  \
    \  }\n    result", "    let mut x = x;\n    let mut ret = String::new();\n   \
    \ loop {\n        let modulo = x % base;\n        let x = x / base;\n        ret.push_str(&modulo.to_string());\n\
    \        if x == 0 {\n            break;\n        }\n    }\n    ret.chars().rev().collect()",
  "    if x < 0 {\n        // TODO: use to_string\n        let s: String = \"-\".to_string();\n\
    \        return s + &change_base(-x, base);\n    }\n    if x < base {\n      \
    \  // TODO: use to_string\n        let x: String = x.to_string();\n        return\
    \ x;\n    }\n    let q = x / base;\n    let r = x % base;\n    // TODO: use to_string\n\
    \    let r: String = r.to_string();\n    return change_base(q, base) + &r;", " \
    \   let mut x_copy = x;\n    let mut digits = Vec::new();\n    while x_copy >\
    \ 0 {\n        digits.push((x_copy % base) as usize);\n        x_copy /= base;\n\
    \    }\n    digits.iter().rev().map(|&x| x.to_string()).collect()", "    if x\
    \ == 0 {\n        return \"0\".to_string();\n    }\n    let mut x = x;\n    let\
    \ mut res = String::new();\n    while x > 0 {\n        res.push(((x % base) +\
    \ 48) as u8 as char);\n        x /= base;\n    }\n    res.chars().rev().collect()",
  "    let mut number = x;\n    let mut result = \"\".to_string();\n    while number\
    \ > 0 {\n        let modulo = number % base;\n        result = format!(\"{}{}\"\
    , result, modulo);\n        number = number / base;\n    }\n    let mut reversed_result\
    \ = result.chars().rev().collect::<String>();\n    reversed_result", "  if x <\
    \ base {\n    return format!(\"{}\", x);\n  }\n  let x_d = x / base;\n  let x_m\
    \ = x % base;\n  return format!(\"{}{}\", change_base(x_d, base), x_m);", "  \
    \  let mut remainder = x;\n    let mut i = 0;\n    let mut quotient = remainder\
    \ / base;\n    let mut output = String::new();\n    while quotient != 0 {\n  \
    \      remainder = quotient;\n        quotient = remainder / base;\n        output.push((remainder\
    \ % base + 48) as u8 as char);\n        i += 1;\n    }\n    output.push((remainder\
    \ % base + 48) as u8 as char);\n    output", "    let mut x = x;\n    let mut\
    \ base_val = base;\n    let mut base_number = String::new();\n    while x > 0\
    \ {\n        let base_division_res = x / base_val;\n        let base_remainder\
    \ = x % base_val;\n        base_number = format!(\"{}{}\", base_remainder, base_number);\n\
    \        x = base_division_res;\n    }\n    base_number", "    let mut x = x;\n\
    \    let mut t = Vec::new();\n    loop {\n        t.push((x % base).to_string());\n\
    \        x /= base;\n        if x <= 0 {\n            break;\n        }\n    }\n\
    \    t.reverse();\n    t.concat()", "    let mut x = x;\n    let mut ret = String::new();\n\
    \    while x != 0 {\n        ret.push((x % base + 48) as u8 as char);\n      \
    \  x /= base;\n    }\n    ret.chars().rev().collect()", "    let mut buf = String::new();\n\
    \    let mut val = x;\n    while val != 0 {\n        buf.push(((val % base) +\
    \ ('0' as isize)) as u8 as char);\n        val /= base;\n    }\n    buf.chars().rev().collect()",
  '    format!("{:b}", x)', "    let mut s = String::new();\n    let mut n = x;\n\
    \    while n != 0 {\n        s.push_str(&format!(\"{}\", n % base));\n       \
    \ n /= base;\n    }\n    s.chars().rev().collect()", "    let mut result = \"\"\
    .to_string();\n    let mut x = x;\n    while x > 0 {\n        result = format!(\"\
    {}{}\", (x % base).to_string(), result);\n        x /= base;\n    }\n    result",
  "    let mut x = x;\n    let mut r = String::new();\n    while x > 0 {\n       \
    \ r.push_str(&((x % base).to_string()));\n        x /= base;\n    }\n    r.chars().rev().collect()",
  "    let mut num = x;\n    let mut result = String::new();\n    loop {\n       \
    \ let m = num % base;\n        num = num / base;\n        result.push_str(&m.to_string());\n\
    \        if num == 0 {\n            break;\n        }\n    }\n    result.chars().rev().collect()",
  "    let mut s = String::new();\n    let mut x = x;\n    while x > 0 {\n       \
    \ s.push(((x % base) + b'0') as char);\n        x /= base;\n    }\n    s.chars().rev().collect()",
  '  return format!("{:b}", x).to_string();', "    let mut y = x;\n    let mut result\
    \ = String::new();\n    while y > 0 {\n        let div = y / base;\n        let\
    \ remainder = y % base;\n        let ch = ((remainder + 48) as u8) as char;\n\
    \        y = div;\n        result.push(ch);\n    }\n    result.chars().rev().collect()",
  "    if x < base {\n        return x.to_string();\n    }\n    return change_base(x\
    \ / base, base) + &(x % base).to_string();", "    let remainder = x % base;\n\
    \    let quotient = x / base;\n    if quotient == 0 {\n        return format!(\"\
    {}\", remainder);\n    } else {\n        return format!(\"{}{}\", change_base(quotient,\
    \ base), remainder);\n    }", "    let mut x = x;\n    let mut ret = String::new();\n\
    \    while x > 0 {\n        ret.push_str(&((x % base) as u8).to_string());\n \
    \       x /= base;\n    }\n    ret.chars().rev().collect()", "    if x < base\
    \ {\n        return x.to_string();\n    }\n    format!(\"{}{}\", change_base(x\
    \ / base, base), x % base)", "    let mut x = x;\n    let mut result = String::new();\n\
    \    while x != 0 {\n        let digit = x % base;\n        x = x / base;\n  \
    \      result.push_str(&digit.to_string());\n    }\n    result", "    let mut\
    \ x = x;\n    let mut s = String::new();\n    while x > 0 {\n        s.push_str(&(x\
    \ % base).to_string());\n        x /= base;\n    }\n    s.chars().rev().collect()",
  '    x.to_string()', "    // TODO\n    return String::new();", "    let mut ans\
    \ = String::new();\n    let mut base_x = x;\n    while base_x > 0 {\n        ans.push_str(&(base_x\
    \ % base).to_string());\n        base_x /= base;\n    }\n    ans.chars().rev().collect()",
  '    x.to_string()', "    let mut result = String::new();\n    let mut tmp = x;\n\
    \    while tmp > 0 {\n        result.push_str(&(tmp % base).to_string());\n  \
    \      tmp /= base;\n    }\n    result.chars().rev().collect()", "    // TODO\n\
    \    format!(\"{}\", x)", "    let mut quotient = x;\n    let mut ret = String::new();\n\
    \    while quotient > 0 {\n        ret.push_str(&format!(\"{}\", quotient % base));\n\
    \        quotient /= base;\n    }\n    ret.chars().rev().collect()", "    let\
    \ mut i = x;\n    let mut r = String::new();\n    while i > 0 {\n        r.push_str(&(i\
    \ % base).to_string());\n        i /= base;\n    }\n    r.chars().rev().collect()",
  "    let mut x = x;\n    let mut result = String::new();\n    while x > 0 {\n  \
    \      let current_digit = (x % base) as u8;\n        result.push(char::from(current_digit\
    \ + b'0'));\n        x /= base;\n    }\n    result.chars().rev().collect()", " \
    \   let mut result = String::new();\n    let mut n = x;\n    let mut divisor =\
    \ base;\n    while n >= divisor {\n        divisor *= base;\n    }\n    divisor\
    \ /= base;\n    while divisor >= 1 {\n        let d = n / divisor;\n        result.push(if\
    \ d < 10 {\n            (d as u8 + 48) as char\n        } else {\n           \
    \ (d as u8 + 87) as char\n        });\n        n -= d * divisor;\n        divisor\
    \ /= base;\n    }\n    result", "    let mut result = String::new();\n    let\
    \ mut x = x;\n    while x > 0 {\n        result.push(((x % base) + b'0') as char);\n\
    \        x /= base;\n    }\n    result.chars().rev().collect()", '    x.to_string()',
  "    let mut ret = String::new();\n    let mut x = x;\n    while x > 0 {\n     \
    \   ret.push(((x % base) + ('0' as isize)) as u8 as char);\n        x /= base;\n\
    \    }\n    ret.chars().rev().collect()", "    if x == 0 {\n        return \"\
    0\".to_string();\n    }\n    let mut x = x;\n    let mut s = String::new();\n\
    \    while x > 0 {\n        s.push(((x % base) + '0' as isize) as u8 as char);\n\
    \        x /= base;\n    }\n    s.chars().rev().collect()", "  let mut res = String::new();\n\
    \  let mut x = x;\n  while x > 0 {\n    res.push(((x % base) + b'0') as char);\n\
    \    x /= base;\n  }\n  res.chars().rev().collect()", "    assert!(base < 10,\
    \ \"base numbers must be less than 10\");\n    let mut remainder = x;\n    let\
    \ mut res = String::new();\n    while remainder > 0 {\n        res.push_str(&(remainder\
    \ % base).to_string());\n        remainder /= base;\n    }\n    res.chars().rev().collect()",
  "    let mut x = x;\n    let mut result = String::new();\n    let mut digit;\n \
    \   loop {\n        digit = x % base;\n        x = x / base;\n        result.push(digit.to_string().chars().next().unwrap());\n\
    \        if x == 0 {\n            break;\n        }\n    }\n    result.chars().rev().collect()",
  "    if x == 0 {\n        return \"0\".to_string();\n    }\n    let mut x = x;\n\
    \    let mut s = String::new();\n    while x > 0 {\n        s.push_str(&(x % base).to_string());\n\
    \        x /= base;\n    }\n    s.chars().rev().collect()", "    let mut res =\
    \ String::new();\n    let mut n = x;\n    while n != 0 {\n        res.push_str(&((n\
    \ % base).to_string()));\n        n /= base;\n    }\n    res.chars().rev().collect()",
  "    if x == 0 {\n        return \"0\".to_string();\n    }\n    let mut x = x;\n\
    \    let mut result = String::new();\n    while x > 0 {\n        result.push(((x\
    \ % base) + 48) as u8 as char);\n        x /= base;\n    }\n    result.chars().rev().collect()",
  "    let mut x = x;\n    let mut res = String::new();\n    while x > 0 {\n     \
    \   res = res + &((x % base).to_string());\n        x = x / base;\n    }\n   \
    \ res", "    let mut s = String::new();\n    if x < 0 {\n        s.push('-');\n\
    \    }\n    if x < 0 {\n        s.push_str(&change_base_pos(-x, base));\n    }\
    \ else {\n        s.push_str(&change_base_pos(x, base));\n    }\n    s", "   \
    \ if x == 0 {\n        \"0\".to_string()\n    } else {\n        let base_mul =\
    \ |x: isize| -> isize {\n            let mut t = 1;\n            for _ in 0..x\
    \ {\n                t *= base;\n            }\n            t\n        };\n  \
    \      let mut n = x;\n        let mut s = \"\".to_string();\n        for i in\
    \ (0..).take_while(|x| base_mul(*x) <= n) {\n            let base_n = base_mul(i);\n\
    \            let n_n = n / base_n;\n            s = format!(\"{}{}\", n_n, s);\n\
    \            n -= n_n * base_n;\n        }\n        s\n    }", "    // TODO: Implement.\n\
    \    return \"\".to_string();", "    let mut ret = String::new();\n    let mut\
    \ tmp = x;\n    let mut dummy = tmp;\n    let mut i = 0;\n    while dummy != 0\
    \ {\n        dummy /= base;\n        i += 1;\n    }\n    for _ in 0..i {\n   \
    \     ret.push_str(&((tmp % base).to_string()));\n        tmp /= base;\n    }\n\
    \    ret.chars().rev().collect()", "  // TODO\n  \"1\".to_string()", "  let mut\
    \ result = String::new();\n  let mut x = x;\n  loop {\n    result.push(((x % base)\
    \ + b'0') as char);\n    x /= base;\n    if x == 0 {\n      break;\n    }\n  }\n\
    \  result.chars().rev().collect()", "    let mut x = x;\n    let mut s = String::new();\n\
    \    while x > 0 {\n        s.push(((x % base) + 48) as u8 as char);\n       \
    \ x /= base;\n    }\n    s.chars().rev().collect()", "    assert!(base < 10);\n\
    \    let mut res = String::new();\n    let mut curr = x;\n    while curr > 0 {\n\
    \        res.push(((curr % base) + '0' as isize) as u8 as char);\n        curr\
    \ /= base;\n    }\n    res.chars().rev().collect()", "    let mut y = x;\n   \
    \ let mut result = String::new();\n    let mut modulo;\n    while y != 0 {\n \
    \       modulo = y % base;\n        y = y / base;\n        result.push_str(&modulo.to_string());\n\
    \    }\n    // let mut output = String::new();\n    // for c in result.chars().rev()\
    \ {\n    //     output.push(c);\n    // }\n    // output\n    result.chars().rev().collect()",
  "    assert!(base < 10);\n    let mut v = vec![];\n    let mut x = x;\n    while\
    \ x > 0 {\n        v.push((x % base).to_string());\n        x /= base;\n    }\n\
    \    v.reverse();\n    return v.join(\"\");", '    format!("{:b}", x)', "    //\
    \ FIXME: implement change_base\n    // you can change input number to another\
    \ base\n    // by calculating the remainder of division.\n    // e.g. 5 (decimal)\
    \ -> 101 (binary)\n    // 5%2=1, 5/2=2, 2%2=0, 2/2=1, 1%2=1, 1/2=0.\n    // then\
    \ the result is a binary number 101 from the bottom to the top.\n    // after\
    \ converting a number to another base,\n    // you can convert it to String using\
    \ the `format!` macro.\n    let mut x = x;\n    let mut result = \"\".to_string();\n\
    \    loop {\n        let remainder = x % base;\n        x = x / base;\n      \
    \  result = format!(\"{}{}\", remainder, result);\n        if x == 0 {\n     \
    \       break;\n        }\n    }\n    result", "    if x == 0 {\n        return\
    \ \"0\".to_string();\n    }\n    let mut result = String::new();\n    let mut\
    \ x = x;\n    while x > 0 {\n        result = ((x % base) as u8 + '0' as u8) as\
    \ char + &result;\n        x /= base;\n    }\n    result", "    let mut x = x;\n\
    \    let mut result = String::new();\n    while x > 0 {\n        let mod_result\
    \ = x % base;\n        result.push_str(&format!(\"{}\", mod_result));\n      \
    \  x = x / base;\n    }\n    result.chars().rev().collect()", "    let mut result\
    \ = String::new();\n    let mut num = x;\n    while num > 0 {\n        result.push_str(&format!(\"\
    {}\", num % base));\n        num /= base;\n    }\n    result.chars().rev().collect()",
  "    let mut output: String = String::new();\n    let mut num = x;\n    while num\
    \ > 0 {\n        let digit = num % base;\n        output.push_str(&digit.to_string());\n\
    \        num /= base;\n    }\n    output.chars().rev().collect()", "    let mut\
    \ base_number = x;\n    let mut representation = String::new();\n    while base_number\
    \ != 0 {\n        representation =\n            format!(\"{}{}\", base_number\
    \ % base, representation);\n        base_number /= base;\n    }\n    representation",
  "    // TODO: Change base of x from 10 to base.\n    // You need to return the representation\
    \ of x in base.\n    // Hint: use the function push of the VecDeque.\n    let\
    \ mut s = String::new();\n    let mut x = x;\n    let mut queue = VecDeque::new();\n\
    \    while x > 0 {\n        queue.push_front(x % base);\n        x /= base;\n\
    \    }\n    while !queue.is_empty() {\n        s.push_str(&queue.pop_front().unwrap().to_string());\n\
    \    }\n    s", "    assert!(base <= 10, \"Base numbers are less than 10\");\n\
    \    let mut n = x;\n    let mut result = String::new();\n    while n > 0 {\n\
    \        result.push_str(&format!(\"{}\", n % base));\n        n /= base;\n  \
    \  }\n    result.chars().rev().collect()", "    let mut x_copy = x;\n    let mut\
    \ s = String::new();\n    loop {\n        if x_copy == 0 {\n            break;\n\
    \        }\n        let remainder = x_copy % base;\n        x_copy = x_copy /\
    \ base;\n        s.push_str(&remainder.to_string());\n    }\n    s.chars().rev().collect()",
  '    return x.to_string();', "    let mut y = x;\n    let mut xs = Vec::new();\n\
    \    while y > 0 {\n        xs.push((y % base).to_string());\n        y /= base;\n\
    \    }\n    xs.reverse();\n    xs.join(\"\")", "    let mut num = x;\n    let\
    \ mut result = String::new();\n    while num > 0 {\n        let digit = num %\
    \ base;\n        result.push(digit.to_string().chars().next().unwrap());\n   \
    \     num /= base;\n    }\n    result.chars().rev().collect()", "    let mut d\
    \ = x;\n    let mut ret = String::new();\n    while d > 0 {\n        ret.push((d\
    \ % base + '0' as isize) as u8 as char);\n        d /= base;\n    }\n    ret.chars().rev().collect()",
  "    let mut x = x;\n    let mut ans = String::new();\n    while x > 0 {\n     \
    \   ans = format!(\"{}{}\", x % base, ans);\n        x /= base;\n    }\n    ans",
  "    let mut v = Vec::new();\n    let mut num = x;\n    loop {\n        v.push(num\
    \ % base);\n        num /= base;\n        if num == 0 {\n            break;\n\
    \        }\n    }\n    v.iter().rev().map(|d| d.to_string()).collect()", "   \
    \ let mut res = \"\".to_string();\n    let mut x = x;\n    while x > 0 {\n   \
    \     res = x % base.to_string() + &res;\n        x /= base;\n    }\n    res",
  "    let result: String = x.to_string().chars().map(|c| ((c as isize) - ('0' as\
    \ isize)).to_string()).collect();\n    let res = result.parse::<isize>().unwrap();\n\
    \    res.to_string()", "    // TODO\n    \"\".to_string()", "    let mut x = x;\n\
    \    let mut result = String::new();\n    while x > 0 {\n        let r = x % base;\n\
    \        x = x / base;\n        result.push(std::char::from_digit(r as u32, base\
    \ as u32).unwrap());\n    }\n    result.chars().rev().collect()", "    let mut\
    \ quotient = x;\n    let mut remainder = x;\n    let mut result = String::new();\n\
    \    while quotient != 0 {\n        remainder = quotient % base;\n        quotient\
    \ = quotient / base;\n        result.push_str(&remainder.to_string());\n    }\n\
    \    result.chars().rev().collect()", "    let mut x = x;\n    let mut result\
    \ = \"\".to_string();\n    let is_negative = x < 0;\n    x = if is_negative {\
    \ x * -1 } else { x };\n    while x > 0 {\n        let tmp = (x % base).to_string();\n\
    \        result = tmp + &result;\n        x = x / base;\n    }\n    if is_negative\
    \ {\n        result = \"-\" + &result;\n    }\n    result", "    let mut x = x;\n\
    \    let mut s = String::new();\n    while x > 0 {\n        s.push_str(&(x % base).to_string());\n\
    \        x /= base;\n    }\n    s.chars().rev().collect()", "    let mut x = x;\n\
    \    let mut ret = String::new();\n    while x > 0 {\n        ret.push_str(&(std::char::from_digit((x\
    \ % base) as u32, base as u32).unwrap()));\n        x /= base;\n    }\n    ret.chars().rev().collect()",
  "    let mut res = \"\".to_string();\n    let mut n = x;\n    while n > 0 {\n  \
    \      res = format!(\"{}{}\", n % base, res);\n        n /= base;\n    }\n  \
    \  res", "    if x == 0 {\n        return \"0\".to_string();\n    }\n    let mut\
    \ s = String::new();\n    let mut n = x;\n    while n > 0 {\n        s.push((n\
    \ % base + '0' as isize) as u8 as char);\n        n /= base;\n    }\n    s.chars().rev().collect()",
  "    let mut result = String::new();\n    let mut x = x;\n    while x > 0 {\n  \
    \      result.push(((x % base) + '0' as isize) as u8 as char);\n        x /= base;\n\
    \    }\n    result.chars().rev().collect()", "    if x / base == 0 {\n       \
    \ return format!(\"{}\", x % base);\n    } else {\n        return format!(\"{}{}\"\
    , change_base(x / base, base), x % base);\n    }", "    let mut num = x;\n   \
    \ let mut result = String::new();\n    while num > 0 {\n        let remainder\
    \ = num % base;\n        num = num / base;\n        result.push_str(&remainder.to_string());\n\
    \    }\n    result"]
stop_tokens:
- "\n}"
