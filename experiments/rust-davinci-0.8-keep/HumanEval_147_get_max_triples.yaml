name: HumanEval_147_get_max_triples
language: rust
prompt: "/// You are given a positive integer n. You have to create an integer array\
  \ a of length n.\n/// For each i (1 \u2264 i \u2264 n), the value of a[i] = i *\
  \ i - i + 1.\n/// Return the number of triples (a[i], a[j], a[k]) of a where i <\
  \ j < k, \n/// and a[i] + a[j] + a[k] is a multiple of 3.\n/// Example :\n/// Input:\
  \ n = 5\n/// Output: 1\n/// Explanation: \n/// a = [1, 3, 7, 13, 21]\n/// The only\
  \ valid triple is (1, 7, 13).\nfn get_max_triples(n: isize) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = get_max_triples;\n    assert_eq!(candidate(5),\
  \ 1);\n    assert_eq!(candidate(6), 4);\n    assert_eq!(candidate(10), 36);\n  \
  \  assert_eq!(candidate(100), 53361);\n}\n"
completions: ["    let mut counter = 0;\n    let mut a = vec![0; n as usize];\n  \
    \  for i in 0..n {\n        a[i as usize] = i * i - i + 1;\n    }\n    for i in\
    \ 0..n {\n        for j in i + 1..n {\n            for k in j + 1..n {\n     \
    \           if (a[i as usize] + a[j as usize] + a[k as usize]) % 3 == 0 {\n  \
    \                  counter += 1;\n                }\n            }\n        }\n\
    \    }\n    counter", "    let mut a = vec![0 as isize; n as usize];\n    for\
    \ i in 0..n {\n        a[i as usize] = i * i - i + 1;\n    }\n    let mut k =\
    \ 0;\n    for i in 0..n {\n        for j in i+1..n {\n            for t in j+1..n\
    \ {\n                if (a[i as usize] + a[j as usize] + a[t as usize]) % 3 ==\
    \ 0 {\n                    k += 1;\n                }\n            }\n       \
    \ }\n    }\n    k", "    let mut answer = 0;\n    for i in 0..n {\n        for\
    \ j in i+1..n {\n            for k in j+1..n {\n                if (i*i - i +\
    \ 1 + j*j - j + 1 + k*k - k + 1) % 3 == 0 {\n                    answer += 1;\n\
    \                }\n            }\n        }\n    }\n    answer", "    let mut\
    \ count = 0;\n    for i in 1..n-1 {\n        for j in i+1..n {\n            for\
    \ k in j+1..n+1 {\n                if ((i * i - i + 1) + (j * j - j + 1) + (k\
    \ * k - k + 1)) % 3 == 0 {\n                    count += 1;\n                }\n\
    \            }\n        }\n    }\n    count", "    let mut a = Vec::new();\n \
    \   for i in 1..=n {\n        a.push(i * i - i + 1);\n    }\n    let mut count\
    \ = 0;\n    for i in 0..n {\n        for j in i + 1..n {\n            for k in\
    \ j + 1..n {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n           \
    \         count += 1;\n                }\n            }\n        }\n    }\n  \
    \  count", "    let mut ret = 0;\n    for i in 1..n {\n        for j in i+1..n\
    \ {\n            for k in j+1..n {\n                let a = (i * i - i + 1) +\
    \ (j * j - j + 1) + (k * k - k + 1);\n                if a % 3 == 0 {\n      \
    \              ret += 1;\n                }\n            }\n        }\n    }\n\
    \    ret", "    if n < 3 {\n        return 0;\n    }\n    let mut count = 0;\n\
    \    let mut i = 2;\n    while i < n {\n        let mut j = i + 1;\n        while\
    \ j < n {\n            let mut k = j + 1;\n            while k < n {\n       \
    \         let a1 = i * i - i + 1;\n                let a2 = j * j - j + 1;\n \
    \               let a3 = k * k - k + 1;\n                if (a1 + a2 + a3) % 3\
    \ == 0 {\n                    count += 1;\n                }\n               \
    \ k += 1;\n            }\n            j += 1;\n        }\n        i += 1;\n  \
    \  }\n    count", "    // Return the number of triples (a[i], a[j], a[k]) of a\
    \ where i < j < k, \n    // and a[i] + a[j] + a[k] is a multiple of 3.\n    //\
    \ let n = 5;\n    // a = [1, 3, 7, 13, 21]\n    // The only valid triple is (1,\
    \ 7, 13).\n    let mut triples = 0;\n    for i in 1..n-1 {\n        for j in i+1..n\
    \ {\n            for k in j+1..n+1 {\n                let triple = (i*i-i+1) +\
    \ (j*j-j+1) + (k*k-k+1);\n                if triple % 3 == 0 {\n             \
    \       triples += 1;\n                }\n            }\n        }\n    }\n  \
    \  triples", "    let mut max_triples = 0;\n    let a = (1..=n).map(|x| x * x\
    \ - x + 1).collect::<Vec<isize>>();\n    for i in 0..(n - 2) {\n        for j\
    \ in (i + 1)..(n - 1) {\n            for k in (j + 1)..n {\n                if\
    \ (a[i as usize] + a[j as usize] + a[k as usize]) % 3 == 0 {\n               \
    \     max_triples += 1;\n                }\n            }\n        }\n    }\n\
    \    max_triples", "    let mut count = 0;\n    let mut f = 0;\n    let mut s\
    \ = 1;\n    let mut t = 2;\n    while (t < n) {\n        if f + s + t == n {\n\
    \            count += 1;\n            f += 1;\n            s += 1;\n         \
    \   t += 1;\n        } else if f + s + t < n {\n            t += 1;\n        }\
    \ else {\n            f += 1;\n            s += 1;\n            t += 1;\n    \
    \    }\n    }\n    count", "    let mut triples = 0;\n    for i in 1..n {\n  \
    \      for j in (i + 1)..n {\n            for k in (j + 1)..n {\n            \
    \    if (i * i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3 == 0 {\n         \
    \           triples += 1;\n                }\n            }\n        }\n    }\n\
    \    triples", "    let mut count = 0;\n    for i in 1..n {\n        for j in\
    \ (i + 1)..n {\n            for k in (j + 1)..n {\n                if (i * i -\
    \ i + 1 + j * j - j + 1 + k * k - k + 1) % 3 == 0 {\n                    count\
    \ += 1;\n                }\n            }\n        }\n    }\n    count", '    (1..n).map(|i|
    i * i - i + 1).collect::<Vec<isize>>().windows(3).filter(|x| (x[0] + x[1] + x[2])
    % 3 == 0).count() as isize', "    let mut count = 0;\n    let mut min = 0;\n \
    \   let mut max = 0;\n    let mut i = 1;\n    let mut j = 1;\n    let mut k =\
    \ 1;\n    while (i < n) {\n        while (j < n) {\n            while (k < n)\
    \ {\n                let ai = i * i - i + 1;\n                let aj = j * j -\
    \ j + 1;\n                let ak = k * k - k + 1;\n                if (ai + aj\
    \ + ak) % 3 == 0 {\n                    let min = min(ai, min(aj, ak));\n    \
    \                let max = max(ai, max(aj, ak));\n                    let sum\
    \ = ai + aj + ak;\n                    if (sum - min - max) > min {\n        \
    \                println!(\"Found ({}, {}, {})\", ai, aj, ak);\n             \
    \           count += 1;\n                    }\n                }\n          \
    \      k += 1;\n            }\n            j += 1;\n            k = j + 1;\n \
    \       }\n        i += 1;\n        j = i + 1;\n        k = j + 1;\n    }\n  \
    \  return count;", "    let mut a = Vec::with_capacity(n as usize);\n    let mut\
    \ pairs = Vec::with_capacity(n as usize);\n    let mut triples = 0;\n    let mut\
    \ a_sum = 0;\n    for i in 1..n+1 {\n        let a_i = i * i - i + 1;\n      \
    \  a.push(a_i);\n        for j in &a {\n            a_sum = j + a_i;\n       \
    \     if a_sum % 3 == 0 {\n                pairs.push(a_sum);\n            }\n\
    \        }\n    }\n    for i in &a {\n        for j in &pairs {\n            if\
    \ i + j % 3 == 0 {\n                triples += 1;\n            }\n        }\n\
    \    }\n    triples", "    let mut _max_triples = 0;\n    let mut _array: Vec<isize>\
    \ = Vec::new();\n    for i in 1..n + 1 {\n        _array.push(i * i - i + 1);\n\
    \    }\n    for i in 0.._array.len() {\n        for j in i + 1.._array.len() {\n\
    \            for k in j + 1.._array.len() {\n                if (_array[i] + _array[j]\
    \ + _array[k]) % 3 == 0 {\n                    _max_triples += 1;\n          \
    \      }\n            }\n        }\n    }\n    _max_triples", "    let mut count\
    \ = 0;\n    for i in 0..n - 2 {\n        for j in i + 1..n - 1 {\n           \
    \ for k in j + 1..n {\n                if (i + 1) * (i + 1) - (i + 1) + 1 + (j\
    \ + 1) * (j + 1) - (j + 1) + 1 + (k + 1) * (k + 1) - (k + 1) + 1 == 0 {\n    \
    \                count += 1;\n                }\n            }\n        }\n  \
    \  }\n    count", "    let mut triples = 0;\n    let mut a: Vec<isize> = vec![];\n\
    \    for i in 1..=n {\n        a.push(i * i - i + 1);\n    }\n    let a_len =\
    \ a.len();\n    for i in 0..a_len {\n        for j in (i + 1)..a_len {\n     \
    \       for k in (j + 1)..a_len {\n                if (a[i] + a[j] + a[k]) % 3\
    \ == 0 {\n                    triples += 1;\n                }\n            }\n\
    \        }\n    }\n    triples", '    unimplemented!();', '    0', "    if n <\
    \ 3 {\n        return 0;\n    }\n    let mut v = Vec::new();\n    for i in 1..=n\
    \ {\n        v.push(i * i - i + 1);\n    }\n    let mut i = 0;\n    let mut j\
    \ = 1;\n    let mut k = 2;\n    let mut count = 0;\n    while i < n - 2 {\n  \
    \      j = i + 1;\n        while j < n - 1 {\n            k = j + 1;\n       \
    \     while k < n {\n                if (v[i] + v[j] + v[k]) % 3 == 0 {\n    \
    \                count += 1;\n                }\n                k += 1;\n   \
    \         }\n            j += 1;\n        }\n        i += 1;\n    }\n    count",
  "    if n <= 1 {\n        return 0;\n    }\n    let mut sum = 0;\n    let mut result\
    \ = 0;\n    let mut counter = 1;\n    let mut prev = 1;\n    while counter < n\
    \ {\n        prev = prev + 2 * counter;\n        sum += prev;\n        if sum\
    \ % 3 == 0 {\n            result += counter - 1;\n        }\n        counter +=\
    \ 1;\n    }\n    result", "    let mut count = 0;\n    for i in 0..n {\n     \
    \   for j in i+1..n {\n            for k in j+1..n {\n                if (i *\
    \ i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3 == 0 {\n                    count\
    \ += 1;\n                }\n            }\n        }\n    }\n    count", "   \
    \ (1..n).map(|x| {\n        let mut x = x;\n        let mut sum = 0;\n       \
    \ while x < n {\n            sum += x;\n            x += 1;\n        }\n     \
    \   (sum % 3, 1)\n    }).fold((0, 0), |acc, x| {\n        (acc.0 + x.0, acc.1\
    \ + x.1)\n    }).1", "    let mut num_triples = 0;\n    let mut sum = 0;\n   \
    \ for i in 1..n - 1 {\n        sum += (i * i - i + 1);\n        for j in i + 1..n\
    \ {\n            sum += (j * j - j + 1);\n            for k in j + 1..n + 1 {\n\
    \                sum += (k * k - k + 1);\n                if sum % 3 == 0 {\n\
    \                    num_triples += 1;\n                }\n                sum\
    \ -= (k * k - k + 1);\n            }\n            sum -= (j * j - j + 1);\n  \
    \      }\n        sum = 0;\n    }\n    num_triples", "    let mut a = vec![0;\
    \ n as usize];\n    let mut count = 0;\n    for i in 1..n {\n        a[i as usize]\
    \ = i * i - i + 1;\n        for j in i + 1..n {\n            if (a[i as usize]\
    \ + a[j as usize]) % 3 == 0 {\n                for k in j + 1..n {\n         \
    \           if (a[j as usize] + a[k as usize]) % 3 == 0 {\n                  \
    \      count += 1;\n                    }\n                }\n            }\n\
    \        }\n    }\n    count", '    0', "    if n < 3 {\n        return 0;\n \
    \   }\n    let mut count = 0;\n    let mut sum = 0;\n    let mut mod_count = vec![0;\
    \ 3];\n    for i in 1..=n {\n        let val = i * i - i + 1;\n        sum +=\
    \ val;\n        mod_count[sum as usize % 3] += 1;\n    }\n    // each item with\
    \ index 0 is paired with all the items with index 2\n    count += mod_count[0]\
    \ * mod_count[2];\n    // each item with index 1 is paired with all the items\
    \ with index 1\n    count += mod_count[1] * (mod_count[1] - 1) / 2;\n    count",
  "    let mut triples = 0;\n    let mut values = vec![];\n    for i in 1..n+1 {\n\
    \        values.push(i*i - i + 1);\n    }\n    let mut i = 0;\n    while i < n\
    \ {\n        let mut j = i + 1;\n        while j < n {\n            let mut k\
    \ = j + 1;\n            while k < n {\n                if (values[i as usize]\
    \ + values[j as usize] + values[k as usize]) % 3 == 0 {\n                    triples\
    \ += 1;\n                }\n                k += 1;\n            }\n         \
    \   j += 1;\n        }\n        i += 1;\n    }\n    triples", "    (1..n).map(|i|\
    \ (i * i - i + 1) % 3)\n          .map(|i| i * (i + 1) / 2)\n          .sum()",
  "    let a = (1..=n).map(|i| i * i - i + 1).collect::<Vec<isize>>();\n    return\
    \ a.iter().enumerate().fold(0, |acc, (i, x)| {\n        let mut total = 0;\n \
    \       for j in i + 1..a.len() {\n            for k in j + 1..a.len() {\n   \
    \             if (x + a[j] + a[k]) % 3 == 0 {\n                    total += 1;\n\
    \                }\n            }\n        }\n        acc + total\n    });", " \
    \   let mut count = 0;\n    let len = ((n * n) as f64).sqrt() as isize;\n    let\
    \ mut a: Vec<isize> = Vec::new();\n    for i in 1..=len {\n        let x = i *\
    \ i - i + 1;\n        a.push(x);\n    }\n    for i in 0..len - 2 {\n        for\
    \ j in i + 1..len - 1 {\n            for k in j + 1..len {\n                if\
    \ (a[i] + a[j] + a[k]) % 3 == 0 {\n                    count += 1;\n         \
    \       }\n            }\n        }\n    }\n    count", "    if n < 3 {\n    \
    \    return 0;\n    }\n    let dp = vec![vec![0,0,0]; n as usize];\n    for i\
    \ in 2..n {\n        let val = (i * i - i + 1) % 3;\n        dp[i as usize][val\
    \ as usize] += 1;\n        for j in 0..3 {\n            dp[i as usize][j] += dp[(i\
    \ - 1) as usize][j];\n        }\n    }\n    let mut res = 0;\n    for i in 2..n\
    \ {\n        for j in 0..3 {\n            res += dp[(i - 1) as usize][j] * dp[n\
    \ as usize][(3 - j) % 3];\n        }\n    }\n    res as isize", "    let max_triples\
    \ = (1..n - 1).fold(0, |acc, i| {\n        let triples_count = (i + 1..n).fold(0,\
    \ |acc, j| {\n            (j + 1..n).fold(acc, |acc, k| {\n                if\
    \ (a(i) + a(j) + a(k)) % 3 == 0 {\n                    acc + 1\n             \
    \   } else {\n                    acc\n                }\n            })\n   \
    \     });\n        acc + triples_count\n    });\n    max_triples", '    0', " \
    \   let mut count = 0;\n    for i in 1..n-1 {\n        let mut n_i = i * i - i\
    \ + 1;\n        for j in i+1..n {\n            let mut n_j = j * j - j + 1;\n\
    \            if (n_i + n_j) % 3 == 0 {\n                count += n - j;\n    \
    \        }\n        }\n    }\n    count", "    if n < 3 {\n        return 0;\n\
    \    }\n    // Create a range of sequence numbers from 1 to n.\n    let range:\
    \ Vec<isize> = (1..n+1).collect();\n    // println!(\"range: {:?}\", range);\n\
    \    // Create a map of the sequence numbers as keys and the \n    // value as\
    \ the square of the number minus the number plus 1.\n    let mut map: HashMap<isize,\
    \ isize> = HashMap::new();\n    let mut count = 0;\n    for number in range {\n\
    \        let value = number * number - number + 1;\n        map.insert(number,\
    \ value);\n        // println!(\"value: {}\", value);\n        // Is the number\
    \ a multiple of 3?\n        if value % 3 == 0 {\n            count += 1;\n   \
    \     }\n    }\n    count", "    let mut sum: isize = 0;\n    for i in 1..(n -\
    \ 1) {\n        let mut k: isize = n - 1;\n        for j in (i + 1)..n {\n   \
    \         let num: isize = i * i - i + 1 + j * j - j + 1;\n            while k\
    \ > j && num + k * k - k + 1 > 3 * n {\n                k -= 1;\n            }\n\
    \            if num + k * k - k + 1 == 3 * n {\n                sum += 1;\n  \
    \          }\n        }\n    }\n    sum", "    let mut num_triples = 0;\n    for\
    \ i in 0..n {\n        for j in i+1..n {\n            for k in j+1..n {\n    \
    \            if (i*i - i + 1 + j*j - j + 1 + k*k - k + 1) % 3 == 0 {\n       \
    \             num_triples += 1;\n                }\n            }\n        }\n\
    \    }\n    num_triples", "    let mut max = isize::min_value();\n    let mut\
    \ arr = vec![0; n as usize];\n    for i in 0..n {\n        arr[i as usize] = i\
    \ * i - i + 1;\n        for j in 0..i {\n            for k in 0..j {\n       \
    \         if (arr[i as usize] + arr[j as usize] + arr[k as usize]) % 3 == 0 {\n\
    \                    if arr[i as usize] * arr[j as usize] * arr[k as usize] >\
    \ max {\n                        max = arr[i as usize] * arr[j as usize] * arr[k\
    \ as usize];\n                    }\n                }\n            }\n      \
    \  }\n    }\n    return max;", "    // 1 <= n <= 2000\n    if n < 1 || n > 2000\
    \ {\n        return 0;\n    }\n    let mut arr = vec![0; n as usize];\n    for\
    \ i in 0..n {\n        arr[i as usize] = i * i - i + 1;\n    }\n    let mut sum\
    \ = 0;\n    for i in 0..n {\n        for j in (i + 1)..n {\n            for k\
    \ in (j + 1)..n {\n                let tmp = arr[i as usize] + arr[j as usize]\
    \ + arr[k as usize];\n                if tmp % 3 == 0 {\n                    sum\
    \ += 1;\n                }\n            }\n        }\n    }\n    sum", "    let\
    \ mut c: isize = 0;\n    for i in 1..n {\n        for j in (i + 1)..n {\n    \
    \        for k in (j + 1)..n {\n                let i1 = (i * i) - i + 1;\n  \
    \              let j1 = (j * j) - j + 1;\n                let k1 = (k * k) - k\
    \ + 1;\n                if (i1 + j1 + k1) % 3 == 0 {\n                    c +=\
    \ 1;\n                }\n            }\n        }\n    }\n    c", "    let mut\
    \ tot = 0;\n    let a: Vec<_> = (1..n + 1).map(|x| x * x - x + 1).collect();\n\
    \    for i in 0..n - 2 {\n        for j in i + 1..n - 1 {\n            for k in\
    \ j + 1..n {\n                if (a[i as usize] + a[j as usize] + a[k as usize])\
    \ % 3 == 0 {\n                    tot += 1;\n                }\n            }\n\
    \        }\n    }\n    tot", "    let a = (1..n + 1).map(|i| i * i - i + 1).collect::<Vec<isize>>();\n\
    \    let mut count = 0;\n    for (i, ai) in a.iter().enumerate() {\n        for\
    \ (j, aj) in a.iter().enumerate() {\n            if i >= j {\n               \
    \ continue;\n            }\n            for (k, ak) in a.iter().enumerate() {\n\
    \                if i >= k || j >= k {\n                    continue;\n      \
    \          }\n                if (ai + aj + ak) % 3 == 0 {\n                 \
    \   count += 1;\n                }\n            }\n        }\n    }\n    count",
  "    let mut cnt = 0;\n    let mut sum = 0;\n    for i in 0..n {\n        sum +=\
    \ i * i - i + 1;\n        if sum % 3 == 0 {\n            cnt += 1;\n        }\n\
    \    }\n    cnt", "    let mut counter = 0;\n    let mut start = 1;\n    let mut\
    \ end = n - 1;\n    while start < end {\n        let s = get_square(start) + get_square(end);\n\
    \        if s % 3 == 0 {\n            if start == end - 1 {\n                counter\
    \ += 1;\n            } else {\n                counter += (end - start - 1) *\
    \ 2;\n            }\n            start += 1;\n        } else if s > end * end\
    \ {\n            end -= 1;\n        } else {\n            start += 1;\n      \
    \  }\n    }\n    counter", "    // if n < 3 { return 0; }\n    let mut a: Vec<isize>\
    \ = vec![];\n    for i in 1..=n {\n        a.push(i * i - i + 1);\n    }\n   \
    \ a.sort();\n    let mut max_count = 0;\n    for i in 0..(n - 2) {\n        for\
    \ j in (i + 1)..(n - 1) {\n            let elt = a[i] + a[j];\n            if\
    \ elt % 3 == 0 {\n                let max_k = n - 1;\n                let min_k\
    \ = j + 1;\n                let mut left = min_k;\n                let mut right\
    \ = max_k;\n                while left <= right {\n                    let mid\
    \ = (left + right) / 2;\n                    if a[mid] < elt {\n             \
    \           left = mid + 1;\n                    } else {\n                  \
    \      right = mid - 1;\n                    }\n                }\n          \
    \      max_count += right - j;\n            }\n        }\n    }\n    max_count",
  "    let mut triples = 0;\n    let mut index = 1;\n    let mut a = vec![];\n   \
    \ for _ in 0..n {\n        a.push(index * index - index + 1);\n        index +=\
    \ 1;\n    }\n    for i in 0..a.len() {\n        for j in i + 1..a.len() {\n  \
    \          for k in j + 1..a.len() {\n                if (a[i] + a[j] + a[k])\
    \ % 3 == 0 {\n                    triples += 1;\n                }\n         \
    \   }\n        }\n    }\n    triples", "    let mut result = 0;\n    for i in\
    \ 1..n - 1 {\n        for j in i + 1..n {\n            for k in j + 1..n + 1 {\n\
    \                if i * i - i + 1 + j * j - j + 1 + k * k - k + 1 % 3 == 0 {\n\
    \                    result += 1;\n                }\n            }\n        }\n\
    \    }\n    result", "    let mut total = 0;\n    for i in 0..n {\n        for\
    \ j in (i + 1)..n {\n            for k in (j + 1)..n {\n                if ((i\
    \ * i - i + 1) + (j * j - j + 1) + (k * k - k + 1)) % 3 == 0 {\n             \
    \       total += 1;\n                }\n            }\n        }\n    }\n    total",
  "    let mut triples = 0;\n    for i in 1..n {\n        for j in (i + 1)..n {\n\
    \            for k in (j + 1)..n {\n                if (i * i - i + 1 + j * j\
    \ - j + 1 + k * k - k + 1) % 3 == 0 {\n                    triples += 1;\n   \
    \             }\n            }\n        }\n    }\n    triples", "    let mut sum:\
    \ isize = 0;\n    let mut res: isize = 0;\n    let mut max_sum: isize = 0;\n \
    \   for i in 1..n {\n        sum = i * i - i + 1;\n        for j in i + 1..n {\n\
    \            sum += j * j - j + 1;\n            for k in j + 1..n {\n        \
    \        sum += k * k - k + 1;\n                if sum % 3 == 0 {\n          \
    \          res += 1;\n                }\n                sum -= k * k - k + 1;\n\
    \            }\n            sum -= j * j - j + 1;\n        }\n    }\n    res",
  "    let mut total: isize = 0;\n    let mut arr: Vec<isize> = vec![];\n    for i\
    \ in 1..=n {\n        arr.push(i * i - i + 1);\n    }\n    let n = arr.len();\n\
    \    for i in 0..n {\n        for j in i+1..n {\n            for k in j+1..n {\n\
    \                if (arr[i] + arr[j] + arr[k]) % 3 == 0 {\n                  \
    \  total += 1;\n                }\n            }\n        }\n    }\n    total",
  "    let mut triples: isize = 0;\n    for i in 0..n - 2 {\n        for j in i +\
    \ 1..n - 1 {\n            for k in j + 1..n {\n                let a = i * i -\
    \ i + 1;\n                let b = j * j - j + 1;\n                let c = k *\
    \ k - k + 1;\n                if a + b + c % 3 == 0 {\n                    triples\
    \ += 1;\n                }\n            }\n        }\n    }\n    triples", " \
    \   let mut a = vec![];\n    for i in 1..n+1 {\n        a.push(i*i - i + 1);\n\
    \    }\n    let mut count = 0;\n    for i in 0..a.len()-2 {\n        for j in\
    \ i+1..a.len()-1 {\n            for k in j+1..a.len() {\n                if (a[i]\
    \ + a[j] + a[k]) % 3 == 0 {\n                    count += 1;\n               \
    \ }\n            }\n        }\n    }\n    count", "    // TODO: Add your code\
    \ here\n    0", "    let mut result = 0;\n    let mut arr = vec![0; n as usize];\n\
    \    for i in 0..n {\n        arr[i as usize] = i * i - i + 1;\n    }\n    println!(\"\
    {:?}\", arr);\n    let mut i = 0;\n    while i < n - 2 {\n        let mut j =\
    \ i + 1;\n        while j < n - 1 {\n            let mut k = j + 1;\n        \
    \    while k < n {\n                if arr[i as usize] + arr[j as usize] + arr[k\
    \ as usize] % 3 == 0 {\n                    result += 1;\n                }\n\
    \                k += 1;\n            }\n            j += 1;\n        }\n    \
    \    i += 1;\n    }\n    result", "    let mut dp = vec![0; (n+1) as usize];\n\
    \    let mut sum = 0;\n    let mut res = 0;\n    for i in 1..n+1 {\n        let\
    \ a = i * i - i + 1;\n        sum += a;\n        sum %= 3;\n        res += dp[sum\
    \ as usize];\n        dp[sum as usize] += 1;\n    }\n    res", "    if n < 3 {\n\
    \        return 0;\n    }\n    let mut a = Vec::new();\n    for i in 1..n + 1\
    \ {\n        a.push(i * i - i + 1);\n    }\n    let mut result = 0;\n    for i\
    \ in 0..n - 2 {\n        for j in i + 1..n - 1 {\n            for k in j + 1..n\
    \ {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    result\
    \ += 1;\n                }\n            }\n        }\n    }\n    result", "  \
    \  let mut a = vec![0; n as usize];\n    for i in 0..n {\n        a[i as usize]\
    \ = i * i - i + 1;\n    }\n    let mut result = 0;\n    for i in 0..n - 2 {\n\
    \        for j in i + 1..n - 1 {\n            for k in j + 1..n {\n          \
    \      if (a[i as usize] + a[j as usize] + a[k as usize]) % 3 == 0 {\n       \
    \             result += 1;\n                }\n            }\n        }\n    }\n\
    \    result", "    let mut a = vec![0; n as usize];\n    for i in 0..n {\n   \
    \     a[i as usize] = i * i - i + 1;\n    }\n    let mut triples = 0;\n    for\
    \ i in 0..n - 2 {\n        for j in i + 1..n - 1 {\n            for k in j + 1..n\
    \ {\n                if (a[i as usize] + a[j as usize] + a[k as usize]) % 3 ==\
    \ 0 {\n                    triples += 1;\n                }\n            }\n \
    \       }\n    }\n    triples", "    let mut cnt = 0;\n    for i in 1..n-1 {\n\
    \        for j in i+1..n {\n            for k in j+1..n+1 {\n                if\
    \ (i*i-i+1+j*j-j+1+k*k-k+1) % 3 == 0 {\n                    cnt += 1;\n      \
    \          }\n            }\n        }\n    }\n    cnt", "    let mut triples\
    \ = vec![];\n    for i in 0..n {\n        let i_square = i * i;\n        let i_square_minus_i\
    \ = i_square - i;\n        for j in (i + 1)..n {\n            let j_square = j\
    \ * j;\n            let j_square_minus_j = j_square - j;\n            for k in\
    \ (j + 1)..n {\n                let k_square = k * k;\n                let k_square_minus_k\
    \ = k_square - k;\n                let triple = i_square_minus_i + j_square_minus_j\
    \ + k_square_minus_k;\n                if triple % 3 == 0 {\n                \
    \    triples.push((i, j, k));\n                }\n            }\n        }\n \
    \   }\n    triples.len() as isize", "    let mut sum = 0;\n    let mut a = vec![0;\
    \ n as usize];\n    for i in 0..n {\n        a[i as usize] = i * i - i + 1;\n\
    \    }\n    for i in 0..n {\n        for j in i + 1..n {\n            for k in\
    \ j + 1..n {\n                if (a[i as usize] + a[j as usize] + a[k as usize])\
    \ % 3 == 0 {\n                    sum += 1;\n                }\n            }\n\
    \        }\n    }\n    sum", "    let mut triples = 0;\n    for i in 1..n {\n\
    \        for j in i+1..n {\n            for k in j+1..n {\n                if\
    \ (j*j-j+1+i*i-i+1+k*k-k+1) % 3 == 0 {\n                    triples += 1;\n  \
    \              }\n            }\n        }\n    }\n    triples", "    let mut\
    \ count = 0;\n    let mut t = (1..n).collect::<Vec<isize>>();\n    for i in 0..n\
    \ {\n        for j in i+1..n {\n            for k in j+1..n {\n              \
    \  if (t[i] + t[j] + t[k]) % 3 == 0 {\n                    count += 1;\n     \
    \           }\n            }\n        }\n    }\n    count", "    if n <= 2 { return\
    \ 0; }\n    let mut triples = 0;\n    for i in 1..n {\n        for j in (i + 1)..n\
    \ {\n            for k in (j + 1)..n {\n                let tmp = i * i - i +\
    \ 1 + j * j - j + 1 + k * k - k + 1;\n                if tmp % 3 == 0 {\n    \
    \                triples += 1;\n                }\n            }\n        }\n\
    \    }\n    triples", "    if n < 3 {\n        return 0;\n    }\n    let mut a:\
    \ Vec<isize> = Vec::new();\n    for i in 1..n + 1 {\n        a.push(i * i - i\
    \ + 1);\n    }\n    let mut count = 0;\n    for i in 0..n - 2 {\n        for j\
    \ in i + 1..n - 1 {\n            for k in j + 1..n {\n                if (a[i]\
    \ + a[j] + a[k]) % 3 == 0 {\n                    count += 1;\n               \
    \ }\n            }\n        }\n    }\n    count", "    let mut result = 0;\n \
    \   for i in 1..n - 1 {\n        for j in i + 1..n {\n            let elem_i =\
    \ i * i - i + 1;\n            let elem_j = j * j - j + 1;\n            let remainder\
    \ = (elem_i + elem_j) % 3;\n            if remainder == 0 {\n                let\
    \ mut counter = 0;\n                for k in j + 1..n + 1 {\n                \
    \    let elem_k = k * k - k + 1;\n                    if (elem_i + elem_j + elem_k)\
    \ % 3 == 0 {\n                        counter += 1;\n                    }\n \
    \               }\n                result += counter;\n            }\n       \
    \ }\n    }\n    result", "    let mut triples = 0;\n    let mut a = vec![0; n\
    \ as usize];\n    let mut i = 1;\n    while i <= n {\n        a[(i - 1) as usize]\
    \ = i * i - i + 1;\n        let mut j = i + 1;\n        while j <= n {\n     \
    \       let mut k = j + 1;\n            while k <= n {\n                if (a[(i\
    \ - 1) as usize] + a[(j - 1) as usize] + a[(k - 1) as usize]) % 3 == 0 {\n   \
    \                 triples += 1;\n                }\n                k += 1;\n\
    \            }\n            j += 1;\n        }\n        i += 1;\n    }\n    triples",
  "    let mut result = 0;\n    for i in 1..n {\n        for j in i+1..n {\n     \
    \       for k in j+1..n {\n                if (i * i - i + 1 + j * j - j + 1 +\
    \ k * k - k + 1) % 3 == 0 {\n                    result += 1;\n              \
    \  }\n            }\n        }\n    }\n    result", "    let mut a = Vec::new();\n\
    \    for i in 1..=n {\n        a.push(i * i - i + 1);\n    }\n    let mut count\
    \ = 0;\n    for i in 0..n {\n        for j in i+1..n {\n            for k in j+1..n\
    \ {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    count\
    \ += 1;\n                }\n            }\n        }\n    }\n    count", "   \
    \ let mut total = 0;\n    let mut a = vec![0; n as usize];\n    for i in 0..n\
    \ {\n        a[i as usize] = i * i - i + 1;\n    }\n    for i in 0..n - 2 {\n\
    \        for j in i + 1..n - 1 {\n            for k in j + 1..n {\n          \
    \      if a[i as usize] + a[j as usize] + a[k as usize] % 3 == 0 {\n         \
    \           total += 1;\n                }\n            }\n        }\n    }\n\
    \    total", "    let mut a = vec![0isize; n as usize];\n    for i in 0..n {\n\
    \        a[i as usize] = i * i - i + 1;\n    }\n    let mut res = 0;\n    for\
    \ i in 0..n - 2 {\n        for j in i + 1..n - 1 {\n            for k in j + 1..n\
    \ {\n                if (a[i as usize] + a[j as usize] + a[k as usize]) % 3 ==\
    \ 0 {\n                    res += 1;\n                }\n            }\n     \
    \   }\n    }\n    res", '    unimplemented!()', "    let mut answer = 0;\n   \
    \ let mut i = 1;\n    let mut j = 2;\n    let mut k = 3;\n    while i < n - 2\
    \ {\n        while j < n - 1 {\n            while k < n {\n                if\
    \ ((i * i - i + 1) + (j * j - j + 1) + (k * k - k + 1)) % 3 == 0 {\n         \
    \           answer += 1;\n                }\n                k += 1;\n       \
    \     }\n            j += 1;\n            k = j + 1;\n        }\n        i +=\
    \ 1;\n        j = i + 1;\n        k = j + 1;\n    }\n    answer", "    let mut\
    \ a = vec![0; n as usize];\n    let mut last_index = n as usize - 1;\n    for\
    \ i in 0..n as usize {\n        a[i] = (i + 1) * (i + 1) - (i + 1) + 1;\n    }\n\
    \    let mut result = 0;\n    for i in 0..a.len() {\n        for j in (i + 1)..a.len()\
    \ {\n            for k in (j + 1)..a.len() {\n                if (a[i] + a[j]\
    \ + a[k]) % 3 == 0 {\n                    result += 1;\n                }\n  \
    \          }\n        }\n    }\n    result", "    // solve here\n    if n < 3\
    \ {\n        return 0;\n    }\n    let mut count = 0;\n    for i in 0..n {\n \
    \       for j in (i + 1)..n {\n            for k in (j + 1)..n {\n           \
    \     if (i * i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3 == 0 {\n        \
    \            count += 1;\n                }\n            }\n        }\n    }\n\
    \    count", "    let mut res = 0;\n    let mut rems = [0, 0, 0];\n\n    for i\
    \ in 1..=n {\n        rems[((i * i - i + 1) % 3) as usize] += 1;\n    }\n\n  \
    \  if rems[0] > 1 {\n        res += rems[0] * (rems[0] - 1) * (rems[0] - 2) /\
    \ 6;\n    }\n\n    if rems[1] > 1 {\n        res += rems[1] * (rems[1] - 1) *\
    \ (rems[2] - 2) / 6;\n    }\n\n    if rems[2] > 1 {\n        res += rems[2] *\
    \ (rems[2] - 1) * (rems[1] - 2) / 6;\n    }\n\n    res += rems[0] * rems[1] *\
    \ rems[2];\n\n    res", "    let mut max_triples = 0;\n    let mut max_sum_num\
    \ = 0;\n    for i in 1..n {\n        for j in (i + 1)..n {\n            for k\
    \ in (j + 1)..n {\n                let sum = i * i - i + 1 + j * j - j + 1 + k\
    \ * k - k + 1;\n                if sum % 3 == 0 {\n                    if sum\
    \ > max_sum_num {\n                        max_sum_num = sum;\n              \
    \          max_triples = 1;\n                    } else if sum == max_sum_num\
    \ {\n                        max_triples += 1;\n                    }\n      \
    \          }\n            }\n        }\n    }\n    max_triples", "    // a[i]\
    \ = i * i - i + 1, so if a[i] = b = 3 * m, where m is an integer,\n    // then\
    \ i = (sqrt(9m^2 + 4) + 1) / 2.\n    // If i is integer then 9m^2 + 4 is an integer\
    \ number and so its square root\n    // should be integer too. 9m^2 + 4 = (3m\
    \ + 2)(3m - 2). \n    // So, 9m^2 + 4 = k^2 -> 3m + 2 = k or 3m - 2 = k where\
    \ k is integer.\n    // So, m = (k^2 - 4) / 3 where k is integer.\n    // Thus,\
    \ we have that a[i] = b = 3 * m = 3 * (k^2 - 4) / 3 = k^2 - 4.\n    // Also, i\
    \ < j < k, so k = (k^2 - 4) / 3 + 1 = k^2 / 3 - 1 + 2 / 3 = \n    // (k^2 + 1)\
    \ / 3. So, if k^2 is integer then k^2 + 1 is divisible by 3.\n    // Thus, we\
    \ need to find all integer numbers k such that k^2 is integer and\n    // k^2\
    \ + 1 is divisible by 3.\n    // k^2 is integer, so k is integer.\n    // Thus,\
    \ we need to find all integer numbers k such that k^2 + 1 is divisible by 3.\n\
    \    // If k is odd then k^2 is odd, so k^2 + 1 is even and so not divisible by\
    \ 3.\n    // If k is even then k^2 is even, so k^2 + 1 is odd and so divisible\
    \ by 3 iff\n    // k^2 + 1 = 3m, where m is integer. Thus, we need to find all\
    \ even numbers k\n    // such that k^2 + 1 = 3m, where m is integer. So, m = (k^2\
    \ + 1) / 3 is integer.\n    // So, k^2 + 1 is divisible by 3. Let's find such\
    \ numbers k.\n    // k = 2m, where m is integer. So, k^2 + 1", "    if n < 3 {\
    \ return 0; }\n    let array = (1..n+1).map(|x| x*x - x + 1).collect::<Vec<isize>>();\n\
    \    let mut result = 0;\n    for i in 0..n-2 {\n        for j in i+1..n-1 {\n\
    \            for k in j+1..n {\n                if (array[i as usize] + array[j\
    \ as usize] + array[k as usize]) % 3 == 0 {\n                    result += 1;\n\
    \                }\n            }\n        }\n    }\n    result", "    let mut\
    \ count = 0;\n    let mut a = vec![0; n as usize];\n    for i in 0..n {\n    \
    \    a[i as usize] = i * i - i + 1;\n    }\n    for i in 0..n - 2 {\n        for\
    \ j in i + 1..n - 1 {\n            for k in j + 1..n {\n                if (a[i\
    \ as usize] + a[j as usize] + a[k as usize]) % 3 == 0 {\n                    count\
    \ += 1;\n                }\n            }\n        }\n    }\n    count", "   \
    \ let mut result = 0;\n    for i in 1..n {\n        let ai = i * i - i + 1;\n\
    \        for j in (i + 1)..n {\n            let aj = j * j - j + 1;\n        \
    \    for k in (j + 1)..n {\n                let ak = k * k - k + 1;\n        \
    \        if ai + aj + ak % 3 == 0 {\n                    result += 1;\n      \
    \          }\n            }\n        }\n    }\n    result", "    let mut total\
    \ = 0;\n    for i in 1..n {\n        for j in i + 1..n {\n            for k in\
    \ j + 1..n {\n                if (i * i - i + 1 + j * j - j + 1 + k * k - k +\
    \ 1) % 3 == 0 {\n                    total += 1;\n                }\n        \
    \    }\n        }\n    }\n    total", "    // TODO\n    unimplemented!();", " \
    \   let mut ans = 0;\n    let mut n = n - 2;\n    while n > 0 {\n        ans +=\
    \ n;\n        n -= 1;\n    }\n    ans", "    let mut count = 0;\n    for i in\
    \ 1..n {\n        for j in (i + 1)..n {\n            for k in (j + 1)..n {\n \
    \               if (i * i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3 == 0 {\n\
    \                    count += 1;\n                }\n            }\n        }\n\
    \    }\n    count", "    let mut res = 0;\n    let mut a = vec![0; n as usize];\n\
    \    for i in 0..n {\n        a[i as usize] = i * i - i + 1;\n    }\n    for i\
    \ in 0..n - 2 {\n        for j in i + 1..n - 1 {\n            for k in j + 1..n\
    \ {\n                if a[i as usize] + a[j as usize] + a[k as usize] % 3 == 0\
    \ {\n                    res += 1;\n                }\n            }\n       \
    \ }\n    }\n    res", "    let mut res = 0;\n    for a in 1..n {\n        for\
    \ b in (a + 1)..n {\n            for c in (b + 1)..n {\n                if (a\
    \ + b + c) % 3 == 0 {\n                    res += 1;\n                }\n    \
    \        }\n        }\n    }\n    res", "    let mut max_triples = 0;\n    let\
    \ mut a: Vec<isize> = Vec::new();\n    for i in 1..=n {\n        a.push(i * i\
    \ - i + 1);\n    }\n    let mut r: Vec<usize> = Vec::new();\n    let mut rs: Vec<isize>\
    \ = Vec::new();\n    let mut tmp_cnt = 0;\n    let mut cnt = 0;\n    for i in\
    \ 0..(n as usize) {\n        for j in i + 1..(n as usize) {\n            for k\
    \ in j + 1..(n as usize) {\n                r.push(i);\n                r.push(j);\n\
    \                r.push(k);\n                rs.push(a[i]);\n                rs.push(a[j]);\n\
    \                rs.push(a[k]);\n                tmp_cnt = rs.iter().sum();\n\
    \                if tmp_cnt % 3 == 0 {\n                    cnt += 1;\n      \
    \          }\n                r.clear();\n                rs.clear();\n      \
    \      }\n        }\n    }\n    max_triples = cnt;\n    max_triples", "    if\
    \ n < 3 {\n        return 0;\n    }\n    // a[i] = i * i - i + 1; a[i] = i * (i\
    \ - 1) + 1\n    // triplets: a[i] + a[j] + a[k] = i * (i - 1) + j * (j - 1) +\
    \ k * (k - 1) + 3\n    // where i < j < k;\n    // a[j] + a[k] = j * (j - 1) +\
    \ k * (k - 1) + 2;\n    // a[j] + a[k] is a multiple of 3 iff j + k is a multiple\
    \ of 3.\n    // a[i] is a multiple of 3 iff i - 1 is a multiple of 3.\n    //\
    \ a[i] + a[j] + a[k] is a multiple of 3 iff i + j + k is a multiple of 3.\n  \
    \  // i + j + k = n;\n    // (i + j + k) - (i + j) = k = n - i - j;\n    // i\
    \ + j = n - k;\n    // let k = n - i - j.\n    // a[i] + a[j] + a[k] = i * (i\
    \ - 1) + j * (j - 1) + (n - i - j) * (n - i - j - 1) + 3\n    //   = i * (i -\
    \ 1) + j * (j - 1) + n * (n - 1) - i * (n - 1) - i * j - j * (n - 1) + i + j\n\
    \    //   = n * (n - 1) - i * j + i + j;\n    // a[i] + a[j] + a[k] is a multiple\
    \ of 3 iff n - i - j is a multiple of 3.\n    // count[n - i - j] == the number\
    \ of times that n - i - j is a multiple of 3.\n    let mut count = vec![0; n as\
    \ usize + 1];\n    let mut num_triples = 0;\n    for i in 1..n {\n        for\
    \ j in i + 1", "    let mut count = 0;\n    for x in 1..n {\n        for y in\
    \ x + 1..n {\n            for z in y + 1..n {\n                if (x * x - x +\
    \ 1 + y * y - y + 1 + z * z - z + 1) % 3 == 0 {\n                    count +=\
    \ 1;\n                }\n            }\n        }\n    }\n    count", "    let\
    \ mut count = 0;\n    for i in 0..n {\n        for j in i+1..n {\n           \
    \ for k in j+1..n {\n                if (i * i - i + 1 + j * j - j + 1 + k * k\
    \ - k + 1) % 3 == 0 {\n                    count += 1;\n                }\n  \
    \          }\n        }\n    }\n    count", "    let mut sum = 0;\n    let mut\
    \ a = Vec::new();\n    for i in 1..n+1 {\n        a.push(i*i - i + 1);\n    }\n\
    \    for i in 0..n-2 {\n        for j in i+1..n-1 {\n            for k in j+1..n\
    \ {\n                if a[i as usize] + a[j as usize] + a[k as usize] % 3 == 0\
    \ {\n                    sum += 1;\n                }\n            }\n       \
    \ }\n    }\n    sum", "    let mut count = 0;\n    for i in 1..(n - 1) {\n   \
    \     let first = i * i - i + 1;\n        for j in (i + 1)..(n - 1) {\n      \
    \      let second = j * j - j + 1;\n            for k in (j + 1)..n {\n      \
    \          let third = k * k - k + 1;\n                if (first + second + third)\
    \ % 3 == 0 {\n                    count += 1;\n                }\n           \
    \ }\n        }\n    }\n    count", "    let modulo = MODULO_VALUE;\n    let mut\
    \ result = 0;\n    for i in 0..n {\n        for j in (i + 1)..n {\n          \
    \  for k in (j + 1)..n {\n                if (i * i - i + 1 + j * j - j + 1 +\
    \ k * k - k + 1) % modulo == 0 {\n                    result += 1;\n         \
    \       }\n            }\n        }\n    }\n    result", "    let mut max = 0;\n\
    \    let mut triples = 0;\n    let mut v = vec![];\n    for i in 1..n+1 {\n  \
    \      v.push(i*i-i+1);\n    }\n    for i in 0..v.len() {\n        for j in i+1..v.len()\
    \ {\n            if (v[i] + v[j]) % 3 == 0 {\n                max = j;\n     \
    \           break;\n            }\n        }\n        for k in max+1..v.len()\
    \ {\n            if (v[i] + v[j] + v[k]) % 3 == 0 {\n                triples +=\
    \ 1;\n            }\n        }\n    }\n    triples", '    return 0;', "    if\
    \ n < 3 {\n        return 0;\n    }\n    let mut a = vec![];\n    for i in 1..n\
    \ + 1 {\n        a.push(i * i - i + 1);\n    }\n    let mut total = 0;\n    for\
    \ i in 0..n {\n        for j in i + 1..n {\n            for k in j + 1..n {\n\
    \                if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    total\
    \ += 1;\n                }\n            }\n        }\n    }\n    total", "   \
    \ let mut a = vec![];\n    for i in 1..n + 1 {\n        a.push(i * i - i + 1);\n\
    \    }\n    let mut count = 0;\n    for i in 0..n - 2 {\n        for j in i +\
    \ 1..n - 1 {\n            for k in j + 1..n {\n                if (a[i] + a[j]\
    \ + a[k]) % 3 == 0 {\n                    count += 1;\n                }\n   \
    \         }\n        }\n    }\n    count", "    let mut triple = 0;\n    let mut\
    \ a = vec![];\n    for i in 1..n + 1 {\n        a.push(i * i - i + 1);\n    }\n\
    \    for i in 0..n - 2 {\n        for j in i + 1..n - 1 {\n            for k in\
    \ j + 1..n {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n           \
    \         triple += 1;\n                }\n            }\n        }\n    }\n \
    \   triple", "    let mut a = vec![0; n as usize];\n    for i in 0..n {\n    \
    \    a[i as usize] = i * i - i + 1;\n    }\n    let mut cnt = 0;\n    for i in\
    \ 0..n {\n        for j in i + 1..n {\n            for k in j + 1..n {\n     \
    \           if (a[i as usize] + a[j as usize] + a[k as usize]) % 3 == 0 {\n  \
    \                  cnt += 1;\n                }\n            }\n        }\n  \
    \  }\n    cnt", "    let mut max_triples = 0;\n    for i in 0..n {\n        for\
    \ j in i..n {\n            for k in j..n {\n                let ai = i * i - i\
    \ + 1;\n                let aj = j * j - j + 1;\n                let ak = k *\
    \ k - k + 1;\n                if (ai + aj + ak) % 3 == 0 {\n                 \
    \   max_triples += 1;\n                }\n            }\n        }\n    }\n  \
    \  max_triples", "    let mut count = 0;\n    let mut numbers = vec![];\n    let\
    \ mut k = 1;\n    while k <= n {\n        numbers.push(k * k - k + 1);\n     \
    \   k += 1;\n    }\n    for i in 0..numbers.len() {\n        for j in (i + 1)..numbers.len()\
    \ {\n            for k in (j + 1)..numbers.len() {\n                if (numbers[i]\
    \ + numbers[j] + numbers[k]) % 3 == 0 {\n                    count += 1;\n   \
    \             }\n            }\n        }\n    }\n    count", "    // num_valid_triples(i,\
    \ j, k) = 1 if valid, 0 if invalid\n    // num_valid_triples(n) = sum(num_valid_triples(i,\
    \ j, k))\n    // i = 0..n-2, j = i+1..n-1, k = j+1..n\n    //\n    // total valid\
    \ triplets = sum(num_valid_triples(i, j, k))\n    //                      = sum(a[i]\
    \ + a[j] + a[k] % 3 == 0)\n    //                      = sum(a[i] % 3 == 0)\n\
    \    //                      + sum(a[j] % 3 == 0)\n    //                    \
    \  + sum(a[k] % 3 == 0)\n    //                      - sum(a[i] % 3 == 0 and a[j]\
    \ % 3 == 0)\n    //                      - sum(a[j] % 3 == 0 and a[k] % 3 == 0)\n\
    \    //                      - sum(a[i] % 3 == 0 and a[k] % 3 == 0)\n    //  \
    \                    + sum(a[i] % 3 == 0 and a[j] % 3 == 0 and a[k] % 3 == 0)\n\
    \    //                      = 3 * count_mod_3(a, n, 0)\n    //              \
    \        + 3 * count_mod_3(a, n, 1)\n    //                      + 3 * count_mod_3(a,\
    \ n, 2)\n    //                      - 3 * count_mod_3(a, n, 0) * count_mod_3(a,\
    \ n, 0)\n    //                      - 3 * count_mod_3(a, n, 1) * count_mod_3(a,\
    \ n, 2)\n    //                      - 3 * count_mod_3(a, n, 0) * count_mod_3(a,\
    \ n, 2)\n    //                      + count_mod_3(a, n, 0) * count_mod_3(a, n,\
    \ 0) * count_mod_3(a, n, 0)\n    //                      + count_mod_3(a, n, 1)\
    \ * count_mod_3(a, n", "    let mut a = vec![0; n as usize];\n    for i in 0..n\
    \ {\n        a[i as usize] = i * i - i + 1;\n    }\n    let mut count = 0;\n \
    \   for i in 0..n {\n        for j in i+1..n {\n            for k in j+1..n {\n\
    \                if (a[i as usize] + a[j as usize] + a[k as usize]) % 3 == 0 {\n\
    \                    count += 1;\n                }\n            }\n        }\n\
    \    }\n    count", "    let mut count = 0;\n    for i in 1..n {\n        for\
    \ j in (i + 1)..n {\n            for k in (j + 1)..n {\n                if (i\
    \ * i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3 == 0 {\n                  \
    \  count += 1;\n                }\n            }\n        }\n    }\n    count",
  "    if n <= 2 {\n        return 0;\n    }\n    let mut counts = vec![0; 3];\n \
    \   let mut sum = 0;\n    let a = (1..n).map(|i| (i * i - i + 1) % 3).collect::<Vec<_>>();\n\
    \    for i in a {\n        sum += i;\n        counts[sum as usize] += 1;\n   \
    \ }\n    let mut count = 0;\n    for i in 0..=n - 3 {\n        let (idx1, idx2)\
    \ = (a[i as usize] % 3, (3 - a[i as usize]) % 3);\n        count += counts[idx1]\
    \ * counts[idx2];\n    }\n    count", "    let mut count = 0;\n    for a in 1..n\
    \ {\n        for b in (a + 1)..n {\n            for c in (b + 1)..n {\n      \
    \          if (a * a - a + 1 + b * b - b + 1 + c * c - c + 1) % 3 == 0 {\n   \
    \                 count += 1;\n                }\n            }\n        }\n \
    \   }\n    count", "    let mut count = 0;\n    for i in 1..n {\n        let ai\
    \ = (i * i) - i + 1;\n        for j in (i + 1)..n {\n            let aj = (j *\
    \ j) - j + 1;\n            for k in (j + 1)..n {\n                let ak = (k\
    \ * k) - k + 1;\n                if (ai + aj + ak) % 3 == 0 {\n              \
    \      count += 1;\n                }\n            }\n        }\n    }\n    count",
  "    let mut res = 0;\n    let mut a = Vec::new();\n    for i in 1..=n {\n     \
    \   a.push(i * i - i + 1);\n    }\n    for i in 0..(n - 2) {\n        for j in\
    \ (i + 1)..(n - 1) {\n            for k in (j + 1)..n {\n                if (a[i]\
    \ + a[j] + a[k]) % 3 == 0 {\n                    res += 1;\n                }\n\
    \            }\n        }\n    }\n    res", "    let mut count = 0;\n    for i\
    \ in 1..n {\n        for j in i + 1..n {\n            for k in j + 1..n {\n  \
    \              if ((i * i - i + 1) + (j * j - j + 1) + (k * k - k + 1)) % 3 ==\
    \ 0 {\n                    count += 1;\n                }\n            }\n   \
    \     }\n    }\n    count", "    let mut a = vec![];\n    for i in 1..n+1 {\n\
    \        a.push(i*i - i + 1);\n    }\n    let mut r = 0;\n    for i in 0..n-2\
    \ {\n        for j in i+1..n-1 {\n            for k in j+1..n {\n            \
    \    if a[i as usize] + a[j as usize] + a[k as usize] % 3 == 0 {\n           \
    \         r += 1;\n                }\n            }\n        }\n    }\n    r",
  "    let mut count = 0;\n    for i in 0..n {\n        for j in i + 1..n {\n    \
    \        let ij = i * i - i + 1 + j * j - j + 1;\n            for k in j + 1..n\
    \ {\n                let ijk = ij + k * k - k + 1;\n                if ijk % 3\
    \ == 0 {\n                    count += 1;\n                }\n            }\n\
    \        }\n    }\n    count", "    let mut count = 0;\n    for i in 1..(n - 1)\
    \ {\n        let ai = i * i - i + 1;\n        for j in (i + 1)..(n - 1) {\n  \
    \          let aj = j * j - j + 1;\n            for k in (j + 1)..n {\n      \
    \          let ak = k * k - k + 1;\n                if (ai + aj + ak) % 3 == 0\
    \ {\n                    count += 1;\n                }\n            }\n     \
    \   }\n    }\n    count", "    let a: Vec<isize> = (1..=n).map(|x| x * x - x +\
    \ 1).collect();\n    let mut total = 0;\n    for (i, x) in a.iter().enumerate()\
    \ {\n        for (j, y) in a.iter().enumerate() {\n            if j <= i {\n \
    \               continue;\n            }\n            for (k, z) in a.iter().enumerate()\
    \ {\n                if k <= j {\n                    continue;\n            \
    \    }\n                if (x + y + z) % 3 == 0 {\n                    total +=\
    \ 1;\n                }\n            }\n        }\n    }\n    total", "    let\
    \ mut sum = 0;\n    let mut sum2 = 0;\n    let mut triples = 0;\n    for i in\
    \ 1..n {\n        for j in (i + 1)..n {\n            for k in (j + 1)..n {\n \
    \               sum = (i*i - i + 1) + (j*j - j + 1) + (k*k - k + 1);\n       \
    \         if sum % 3 == 0 {\n                    triples += 1;\n             \
    \   }\n            }\n        }\n    }\n    triples", "    let mut ans = 0;\n\
    \    let mut pre_sum: isize = 0;\n    let mut pre_pre_sum: isize = 0;\n    for\
    \ i in 1..n {\n        let val = i * i - i + 1;\n        ans += pre_pre_sum *\
    \ (3 - val % 3) % 3;\n        pre_pre_sum = pre_sum;\n        pre_sum = (pre_sum\
    \ + val) % 3;\n    }\n    ans", "    let mut res = 0;\n    for i in 1..n {\n \
    \       for j in (i + 1)..n {\n            for k in (j + 1)..n {\n           \
    \     if (i * i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3 == 0 {\n        \
    \            res += 1;\n                }\n            }\n        }\n    }\n \
    \   res", '    return 0;', "    if n < 3 {\n        return 0;\n    }\n    let\
    \ mut triple = vec![];\n    let mut i = 1;\n    while i <= n {\n        triple.push(i\
    \ * i - i + 1);\n        i += 1;\n    }\n    let mut result = 0;\n    let size\
    \ = triple.len();\n    let mut i = 0;\n    while i < size - 2 {\n        let mut\
    \ j = i + 1;\n        while j < size - 1 {\n            let mut k = j + 1;\n \
    \           while k < size {\n                if triple[i] + triple[j] + triple[k]\
    \ % 3 == 0 {\n                    result += 1;\n                }\n          \
    \      k += 1;\n            }\n            j += 1;\n        }\n        i += 1;\n\
    \    }\n    result", "    let mut max = 0;\n    let mut t = 0;\n    let mut a\
    \ = 1;\n    for i in 1..=n {\n        if t == 0 {\n            t = a + a;\n  \
    \          a = a * a;\n            if a % 3 == 0 {\n                max += 1;\n\
    \            }\n        } else {\n            a += t;\n            t += 1;\n \
    \           if a % 3 == 0 {\n                max += 1;\n            }\n      \
    \  }\n    }\n    max", "    let mut sum = 0;\n    for i in 1..n {\n        for\
    \ j in (i + 1)..n {\n            for k in (j + 1)..n {\n                if (i\
    \ * i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3 == 0 {\n                  \
    \  sum += 1;\n                }\n            }\n        }\n    }\n    sum", " \
    \   let mut count = 0;\n    let mut a = Vec::with_capacity(n as usize);\n    for\
    \ i in 1..n + 1 {\n        a.push(i * i - i + 1);\n    }\n    let mut i = 0;\n\
    \    let mut j = 1;\n    let mut k = 2;\n    while i < n - 2 {\n        while\
    \ j < n - 1 {\n            while k < n {\n                if a[i as usize] + a[j\
    \ as usize] + a[k as usize] % 3 == 0 {\n                    count += 1;\n    \
    \            }\n                k += 1;\n            }\n            j += 1;\n\
    \            k = j + 1;\n        }\n        i += 1;\n        j = i + 1;\n    \
    \    k = j + 1;\n    }\n    count", "    let mut count = 0;\n    let mut arr =\
    \ Vec::with_capacity(n as usize);\n    for i in 1..=n {\n        arr.push(i *\
    \ i - i + 1);\n    }\n    for i in 0..n {\n        for j in i + 1..n {\n     \
    \       for k in j + 1..n {\n                if (arr[i as usize] + arr[j as usize]\
    \ + arr[k as usize]) % 3 == 0 {\n                    count += 1;\n           \
    \     }\n            }\n        }\n    }\n    count", "    let mut arr = vec![0;\
    \ n as usize];\n    let mut res = 0;\n    for i in 0..n {\n        arr[i as usize]\
    \ = i * i - i + 1;\n    }\n    for j in 0..n - 2 {\n        for k in j + 1..n\
    \ - 1 {\n            for l in k + 1..n {\n                if (arr[j as usize]\
    \ + arr[k as usize] + arr[l as usize]) % 3 == 0 {\n                    res +=\
    \ 1;\n                }\n            }\n        }\n    }\n    res", "    // trivial\
    \ case\n    if n < 3 {\n        return 0;\n    }\n\n    // number of triplets\n\
    \    let mut cnt = 0;\n\n    // sum of the previous two elements\n    let mut\
    \ sum: isize = 3;\n\n    // index of the previous two elements\n    let mut prev_i:\
    \ isize = 1;\n    let mut prev_j: isize = 2;\n\n    for i in 3..n {\n        //\
    \ update the sum\n        sum += i*i - i + 1;\n\n        // check for the condition\n\
    \        if sum % 3 == 0 {\n            cnt += (i - 1) - prev_j;\n           \
    \ prev_i = prev_j;\n            prev_j = i;\n        }\n    }\n\n    cnt", " \
    \   let mut counter = 0;\n    for i in 1..n {\n        for j in i + 1..n {\n \
    \           let s = (i * i - i + 1) + (j * j - j + 1);\n            for k in j\
    \ + 1..n {\n                if (k * k - k + 1) + s == 3 {\n                  \
    \  counter += 1;\n                }\n            }\n        }\n    }\n    counter",
  "    let numbers = (1..=n).map(|x| x * x - x + 1).collect::<Vec<isize>>();\n   \
    \ let mut triples = 0;\n    for i in 0..numbers.len() - 2 {\n        for j in\
    \ i + 1..numbers.len() - 1 {\n            for k in j + 1..numbers.len() {\n  \
    \              if numbers[i] + numbers[j] + numbers[k] % 3 == 0 {\n          \
    \          triples += 1;\n                }\n            }\n        }\n    }\n\
    \    triples", "    let mut triples = Vec::new();\n    for x in 1..n {\n     \
    \   for y in x+1..n {\n            for z in y+1..n {\n                let x_value\
    \ = (x*x) - x + 1;\n                let y_value = (y*y) - y + 1;\n           \
    \     let z_value = (z*z) - z + 1;\n                if (x_value + y_value + z_value)\
    \ % 3 == 0 {\n                    triples.push((x_value, y_value, z_value));\n\
    \                }\n            }\n        }\n    }\n    return triples.len()\
    \ as isize;", "    let mut total = 0;\n    for i in 1..n {\n        for j in i+1..n\
    \ {\n            for k in j+1..n {\n                if ((i*i - i + 1) + (j*j -\
    \ j + 1) + (k*k - k + 1)) % 3 == 0 {\n                    total += 1;\n      \
    \          }\n            }\n        }\n    }\n    total", "    let mut count\
    \ = 0;\n    for i in 1..n-1 {\n        let current = i * i - i + 1;\n        let\
    \ next = (i + 1) * (i + 1) - (i + 1) + 1;\n        if (current + next) % 3 ==\
    \ 0 {\n            count += 1;\n        }\n    }\n    count", '    (n + 1) / 3',
  "    let mut triples = 0;\n    for i in 1..(n - 1) {\n        let ai = i * i - i\
    \ + 1;\n        for j in (i + 1)..(n - 1) {\n            let aj = j * j - j +\
    \ 1;\n            for k in (j + 1)..n {\n                let ak = k * k - k +\
    \ 1;\n                if (ai + aj + ak) % 3 == 0 {\n                    triples\
    \ += 1;\n                }\n            }\n        }\n    }\n    triples", " \
    \   let mut result = 0;\n    for i in 1..n {\n        for j in (i + 1)..n {\n\
    \            let p = i * i - i + 1;\n            let q = j * j - j + 1;\n    \
    \        if (p + q) % 3 == 0 {\n                let r = ((p + q) / 3) - 1;\n \
    \               let r = (r as f64).sqrt().ceil() as isize;\n                if\
    \ r >= i && r >= j && r <= n && p + q + (r * r - r + 1) == 3 * (p + q) {\n   \
    \                 result += 1;\n                }\n            }\n        }\n\
    \    }\n    result", "    let mut a = vec![];\n    for i in 1..=n {\n        a.push(i\
    \ * i - i + 1);\n    }\n    println!(\"{:?}\", a);\n    let mut count = 0;\n \
    \   for i in 0..a.len() {\n        for j in i+1..a.len() {\n            for k\
    \ in j+1..a.len() {\n                if a[i] + a[j] + a[k] % 3 == 0 {\n      \
    \              count += 1;\n                }\n            }\n        }\n    }\n\
    \    count", "    let mut triples = Vec::with_capacity(n as usize);\n    let mut\
    \ count = 0;\n    for i in 1..n {\n        let a = i * i - i + 1;\n        triples.push(a);\n\
    \        for j in i + 1..n {\n            let b = j * j - j + 1;\n           \
    \ for k in j + 1..n {\n                let c = k * k - k + 1;\n              \
    \  if (a + b + c) % 3 == 0 {\n                    count += 1;\n              \
    \  }\n            }\n        }\n    }\n    count", "    let mut result = 0;\n\
    \    for i in 0..n {\n        for j in i + 1..n {\n            for k in j + 1..n\
    \ {\n                let sum = i * i - i + 1 + j * j - j + 1 + k * k - k + 1;\n\
    \                if sum % 3 == 0 {\n                    result += 1;\n       \
    \         }\n            }\n        }\n    }\n    result", "    let mut count\
    \ = 0;\n    for i in 1..n {\n        for j in (i + 1)..n {\n            for k\
    \ in (j + 1)..n {\n                if (i * i - i + 1 + j * j - j + 1 + k * k -\
    \ k + 1) % 3 == 0 {\n                    count += 1;\n                }\n    \
    \        }\n        }\n    }\n    count", "    let mut a = vec![];\n    for i\
    \ in 1..n + 1 {\n        a.push(i * i - i + 1);\n    }\n    let mut result = 0;\n\
    \    for i in 0..a.len() {\n        for j in i + 1..a.len() {\n            for\
    \ k in j + 1..a.len() {\n                if a[i] + a[j] + a[k] % 3 == 0 {\n  \
    \                  result += 1;\n                }\n            }\n        }\n\
    \    }\n    result", "    let mut m = 0;\n    for i in 1..n-1 {\n        for j\
    \ in i+1..n {\n            for k in j+1..n+1 {\n                if (i*i - i +\
    \ 1 + j*j - j + 1 + k*k - k + 1) % 3 == 0 {\n                    m += 1;\n   \
    \             }\n            }\n        }\n    }\n    m", "    let mut a = Vec::new();\n\
    \    for i in 1..n + 1 {\n        a.push(i * i - i + 1);\n    }\n    let mut count\
    \ = 0;\n    for i in 0..n {\n        for j in i + 1..n {\n            for k in\
    \ j + 1..n {\n                if a[i as usize] + a[j as usize] + a[k as usize]\
    \ % 3 == 0 {\n                    count += 1;\n                }\n           \
    \ }\n        }\n    }\n    count", "    if n < 3 {\n        return 0;\n    }\n\
    \    let mut max_value = n*n - n + 1;\n    let k = max_value % 3;\n    let mut\
    \ max_triples = 0;\n    if k == 0 {\n        max_triples = max_value / 3;\n  \
    \  } else if k == 1 {\n        max_triples = max_value / 3 - 1;\n    } else {\n\
    \        max_triples = max_value / 3 - 2;\n    }\n    max_triples", "    if n\
    \ < 3 {\n        return 0;\n    }\n    let mut i = 1;\n    let mut count = 0;\n\
    \    let mut a = vec![0; n as usize];\n    while i < n {\n        a[i as usize]\
    \ = i * i - i + 1;\n        if i > 2 {\n            let mut j = 1;\n         \
    \   while j < i - 1 {\n                let mut k = j + 1;\n                while\
    \ k < i {\n                    if a[j as usize] + a[k as usize] + a[i as usize]\
    \ % 3 == 0 {\n                        count += 1;\n                    }\n   \
    \                 k += 1;\n                }\n                j += 1;\n      \
    \      }\n        }\n        i += 1;\n    }\n    count", "    let mut a = Vec::new();\n\
    \    for i in 1..=n {\n        a.push(i * i - i + 1);\n    }\n    let mut count\
    \ = 0;\n    for i in 0..(n - 2) {\n        for j in (i + 1)..(n - 1) {\n     \
    \       for k in (j + 1)..n {\n                if (a[i as usize] + a[j as usize]\
    \ + a[k as usize]) % 3 == 0 {\n                    count += 1;\n             \
    \   }\n            }\n        }\n    }\n    count", "    let mut num_triples =\
    \ 0;\n    for i in 1..n {\n        for j in (i + 1)..n {\n            for k in\
    \ (j + 1)..n {\n                let a_i = i * i - i + 1;\n                let\
    \ a_j = j * j - j + 1;\n                let a_k = k * k - k + 1;\n           \
    \     if a_i + a_j + a_k % 3 == 0 {\n                    num_triples += 1;\n \
    \               }\n            }\n        }\n    }\n    num_triples", "    //\
    \ [1, 3, 7, 13, 21]\n    let mut triples = 0;\n    for i in 1..n {\n        let\
    \ a_i = i * i - i + 1;\n        let mut j = i + 1;\n        while a_i + (j * j\
    \ - j + 1) < n * n {\n            let a_j = j * j - j + 1;\n            let mut\
    \ k = j + 1;\n            while a_i + a_j + (k * k - k + 1) < n * n {\n      \
    \          let a_k = k * k - k + 1;\n                if (a_i + a_j + a_k) % 3\
    \ == 0 {\n                    triples += 1;\n                }\n             \
    \   k += 1;\n            }\n            j += 1;\n        }\n    }\n    triples",
  "    let mod_3 = n % 3;\n    let mut result = (n / 3) * (n - 1) * (n - 2) / 6;\n\
    \    if mod_3 == 1 {\n        result += (n - 1) * (n - 2) / 6;\n    } else if\
    \ mod_3 == 2 {\n        result += (n - 1) * (n - 2) / 3;\n    }\n    result",
  "    if n < 3 { return 0; }\n    let mut count = 0;\n    for i in 1..n {\n     \
    \   let ai = i * i - i + 1;\n        for j in (i + 1)..n {\n            let aj\
    \ = j * j - j + 1;\n            for k in (j + 1)..n {\n                let ak\
    \ = k * k - k + 1;\n                if (ai + aj + ak) % 3 == 0 {\n           \
    \         count += 1;\n                }\n            }\n        }\n    }\n  \
    \  count", "    let mut nums = vec![];\n    let mut cnt = 0;\n    let mut max_val\
    \ = 0;\n    for i in 1..n+1 {\n        nums.push(i*i-i+1);\n        if nums[nums.len()-1]\
    \ % 3 == 0 {\n            max_val = nums[nums.len()-1];\n            cnt += 1;\n\
    \        }\n    }\n    for i in 0..nums.len() {\n        for j in i+1..nums.len()\
    \ {\n            for k in j+1..nums.len() {\n                if nums[i] + nums[j]\
    \ + nums[k] % 3 == 0 {\n                    cnt += 1;\n                }\n   \
    \         }\n        }\n    }\n    cnt", "    // This is a good example to use\
    \ indexmap for this.\n    let mut map = std::collections::HashMap::new();\n  \
    \  let mut ret = 0;\n    for i in 1..=n {\n        let v = i * i - i + 1;\n  \
    \      if let Some(prev) = map.get(&v) {\n            ret += prev;\n        }\n\
    \        map.entry(v % 3).and_modify(|m| *m += 1).or_insert(1);\n    }\n    ret",
  '    (1..n-1).map(|i| i * i - i + 1).fold(0, |acc, x| acc + x)', "    let mut count\
    \ = 0;\n    for a in 1..n {\n        for b in (a + 1)..n {\n            for c\
    \ in (b + 1)..n {\n                if (a * a - a + 1 + b * b - b + 1 + c * c -\
    \ c + 1) % 3 == 0 {\n                    count += 1;\n                }\n    \
    \        }\n        }\n    }\n    count", "    let a = (1..n).map(|x| (x as isize).pow(2)\
    \ - x + 1).collect::<Vec<isize>>();\n    let mut count = 0;\n    for i in 0..n\
    \ {\n        for j in i + 1..n {\n            for k in j + 1..n {\n          \
    \      if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    count += 1;\n \
    \               }\n            }\n        }\n    }\n    count", "    let l: Vec<isize>\
    \ = (1..=n).map(|x| x * x - x + 1).collect();\n    let mut total: isize = 0;\n\
    \    for i in 0..n - 2 {\n        for j in i + 1..n - 1 {\n            for k in\
    \ j + 1..n {\n                if (l[i as usize] + l[j as usize] + l[k as usize])\
    \ % 3 == 0 {\n                    total += 1;\n                }\n           \
    \ }\n        }\n    }\n    total", "    let mut sum = 0;\n    let mut count =\
    \ 0;\n    let mut prev = 0;\n    let mut prev_prev = 0;\n    for i in 1..=n {\n\
    \        let value = i * i - i + 1;\n        sum += value;\n        if sum % 3\
    \ == 0 {\n            count += prev_prev;\n        }\n        prev_prev = prev;\n\
    \        prev = value;\n    }\n    count", "    let mut a = vec![];\n    for i\
    \ in 1..=n {\n        a.push(i * i - i + 1);\n    }\n    let mut sum = 0;\n  \
    \  for i in 0..a.len() {\n        for j in i+1..a.len() {\n            for k in\
    \ j+1..a.len() {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n       \
    \             sum += 1;\n                }\n            }\n        }\n    }\n\
    \    sum", '    0', "    let mut total = 0;\n    let mut index = 0;\n    let mut\
    \ pairs = Vec::new();\n    for i in 1..=n {\n        for j in i..=n {\n      \
    \      let val = i * i - i + 1 + j * j - j + 1;\n            if val % 3 == 0 {\n\
    \                index += 1;\n                pairs.push((i, j));\n          \
    \  }\n        }\n    }\n    for (i, j) in pairs {\n        for k in j..=n {\n\
    \            let val = i * i - i + 1 + j * j - j + 1 + k * k - k + 1;\n      \
    \      if val % 3 == 0 {\n                total += 1;\n            }\n       \
    \ }\n    }\n    println!(\"total = {}\", total);\n    total", '    0', "    let\
    \ mut a = Vec::new();\n    for i in 1..=n {\n        a.push(i * i - i + 1);\n\
    \    }\n    let mut cnt = 0;\n    for i in 0..n - 2 {\n        for j in i + 1..n\
    \ - 1 {\n            for k in j + 1..n {\n                if (a[i] + a[j] + a[k])\
    \ % 3 == 0 {\n                    cnt += 1;\n                }\n            }\n\
    \        }\n    }\n    cnt", "    let mut a = vec![];\n    let mut count = 0;\n\
    \    for i in 1..=n {\n        a.push(i * i - i + 1);\n    }\n    for i in 0..a.len()\
    \ - 2 {\n        for j in i + 1..a.len() - 1 {\n            for k in j + 1..a.len()\
    \ {\n                if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    count\
    \ += 1;\n                }\n            }\n        }\n    }\n    count", "   \
    \ let mut sum = 0;\n    for i in 1..n {\n        for j in (i + 1)..n {\n     \
    \       for k in (j + 1)..n {\n                let ai = i * i - i + 1;\n     \
    \           let aj = j * j - j + 1;\n                let ak = k * k - k + 1;\n\
    \                if (ai + aj + ak) % 3 == 0 {\n                    sum += 1;\n\
    \                }\n            }\n        }\n    }\n    sum", "    if n < 3 {\n\
    \        return 0;\n    }\n    let a: Vec<isize> = (1..=n).map(|a| a * a - a +\
    \ 1).collect();\n    let mut count = 0;\n    for i in 0..n-2 {\n        for j\
    \ in i+1..n-1 {\n            for k in j+1..n {\n                if (a[i] + a[j]\
    \ + a[k]) % 3 == 0 {\n                    count += 1;\n                }\n   \
    \         }\n        }\n    }\n    count", "    let mut res = 0;\n    for i in\
    \ 1..n {\n        for j in i+1..n {\n            for k in j+1..n {\n         \
    \       let i = i * i - i + 1;\n                let j = j * j - j + 1;\n     \
    \           let k = k * k - k + 1;\n                if (i + j + k) % 3 == 0 {\n\
    \                    res += 1;\n                }\n            }\n        }\n\
    \    }\n    res", "    let v: Vec<_> = (1..n + 1).map(|x| x * x - x + 1).collect();\n\
    \    let mut result = 0;\n    for i in 0..n - 2 {\n        for j in i + 1..n -\
    \ 1 {\n            if (v[i] + v[j]) % 3 == 0 {\n                for k in j + 1..n\
    \ {\n                    if (v[i] + v[j] + v[k]) % 3 == 0 {\n                \
    \        result += 1;\n                    }\n                }\n            }\n\
    \        }\n    }\n    result", "    let mut results = Vec::with_capacity(n as\
    \ usize);\n    for i in 1..=n {\n        results.push(i * i - i + 1);\n    }\n\
    \    let sum = results.iter().fold(0, |acc, x| acc + x);\n    if sum % 3 == 0\
    \ {\n        return results.len() as isize;\n    }\n    1", "    let mut result\
    \ = 0;\n    let mut a = vec![];\n    for i in 1..=n {\n        a.push(i * i -\
    \ i + 1);\n    }\n    for i in 0..(n - 2) {\n        for j in (i + 1)..(n - 1)\
    \ {\n            for k in (j + 1)..n {\n                if (a[i] + a[j] + a[k])\
    \ % 3 == 0 {\n                    result += 1;\n                }\n          \
    \  }\n        }\n    }\n    result", "    let mut a = Vec::new();\n    for i in\
    \ 1..n+1 {\n        a.push(i*i - i + 1);\n    }\n    let mut count = 0;\n    for\
    \ i in 0..n {\n        for j in (i+1)..n {\n            for k in (j+1)..n {\n\
    \                if (a[i] + a[j] + a[k]) % 3 == 0 {\n                    count\
    \ += 1;\n                }\n            }\n        }\n    }\n    count", "   \
    \ if n < 3 {\n        return 0;\n    }\n    let mut max_triples = 0;\n    let\
    \ mut max_value = 0;\n    let mut max_index = 0;\n    let mut a = vec![0; n as\
    \ usize];\n    for i in 0..n {\n        let mut value = i * i - i + 1;\n     \
    \   if value % 3 == 0 {\n            if value > max_value {\n                max_value\
    \ = value;\n                max_index = i;\n            }\n        }\n       \
    \ a[i as usize] = value;\n    }\n    if max_value == 0 {\n        return 0;\n\
    \    }\n    max_triples += 1;\n    for i in 0..n {\n        for j in i+1..n {\n\
    \            if a[i as usize] + a[j as usize] + max_value == 0 {\n           \
    \     max_triples += 1;\n            }\n        }\n    }\n    max_triples", " \
    \   let mut nums = vec![0; n as usize];\n    for i in 0..n {\n        nums[i as\
    \ usize] = (i + 1) * (i + 1) - (i + 1) + 1;\n    }\n    let mut result = 0;\n\
    \    for i in 0..nums.len() {\n        for j in i + 1..nums.len() {\n        \
    \    for k in j + 1..nums.len() {\n                if (nums[i] + nums[j] + nums[k])\
    \ % 3 == 0 {\n                    result += 1;\n                }\n          \
    \  }\n        }\n    }\n    result", '    return 0;', "    let mut count = 0;\n\
    \    let mut value = 1;\n    let mut a: Vec<isize> = Vec::new();\n    for i in\
    \ 1..=n {\n        a.push(value);\n        value += 2 * i;\n    }\n    let mut\
    \ i = 0;\n    let mut j = i + 1;\n    let mut k = j + 1;\n    loop {\n       \
    \ if i >= a.len() - 2 {\n            break;\n        }\n        if j >= a.len()\
    \ - 1 {\n            i += 1;\n            j = i + 1;\n            k = j + 1;\n\
    \            continue;\n        }\n        if k >= a.len() {\n            j +=\
    \ 1;\n            k = j + 1;\n            continue;\n        }\n        if a[i]\
    \ + a[j] + a[k] % 3 == 0 {\n            count += 1;\n        }\n        k += 1;\n\
    \    }\n    count", "    let mut count = 0;\n    let mut sum = 0;\n    let mut\
    \ i = 0;\n    while i < n - 2 {\n        sum = i * i - i + 1;\n        let mut\
    \ j = i + 1;\n        while j < n - 1 {\n            sum += j * j - j + 1;\n \
    \           let mut k = j + 1;\n            while k < n {\n                sum\
    \ += k * k - k + 1;\n                if sum % 3 == 0 {\n                    count\
    \ += 1;\n                }\n                sum -= k * k - k + 1;\n          \
    \      k += 1;\n            }\n            sum -= j * j - j + 1;\n           \
    \ j += 1;\n        }\n        i += 1;\n    }\n    count", "    let mut triples\
    \ = 0;\n    for i in 1..n {\n        for j in (i + 1)..n {\n            for k\
    \ in (j + 1)..n {\n                let sum = i*i - i + 1 + j*j - j + 1 + k*k -\
    \ k + 1;\n                if sum % 3 == 0 {\n                    triples += 1;\n\
    \                }\n            }\n        }\n    }\n    triples", "    let mut\
    \ count = 0;\n    let mut numbers = Vec::with_capacity(n as usize);\n    for i\
    \ in 1..=n {\n        numbers.push(i * i - i + 1);\n    }\n    for i in 0..numbers.len()\
    \ {\n        for j in i+1..numbers.len() {\n            for k in j+1..numbers.len()\
    \ {\n                if numbers[i] + numbers[j] + numbers[k] % 3 == 0 {\n    \
    \                count += 1;\n                }\n            }\n        }\n  \
    \  }\n    count", "    let sum_cache = vec![0; n as usize];\n    for i in 0..n\
    \ {\n        for j in i+1..n {\n            for k in j+1..n {\n              \
    \  let ai = i * i - i + 1;\n                let aj = j * j - j + 1;\n        \
    \        let ak = k * k - k + 1;\n                if (ai + aj + ak) % 3 == 0 {\n\
    \                    if i > 0 {\n                        sum_cache[i as usize]\
    \ += 1;\n                    }\n                    if j > 0 {\n             \
    \           sum_cache[j as usize] += 1;\n                    }\n             \
    \       if k > 0 {\n                        sum_cache[k as usize] += 1;\n    \
    \                }\n                }\n            }\n        }\n    }\n    sum_cache.iter().fold(0,\
    \ |acc, x| if acc < *x { *x } else { acc })", "    let mut count = 0;\n    let\
    \ mut a = Vec::new();\n    for i in 1..=n {\n        a.push(i * i - i + 1);\n\
    \    }\n    for i in 0..(n - 2) {\n        for j in (i + 1)..(n - 1) {\n     \
    \       for k in (j + 1)..n {\n                if (a[i as usize] + a[j as usize]\
    \ + a[k as usize]) % 3 == 0 {\n                    count += 1;\n             \
    \   }\n            }\n        }\n    }\n    count", "    let mut max_triples =\
    \ 0;\n    let mut i = 1;\n    let mut last_i = 0;\n    let mut j = 2;\n    let\
    \ mut last_j = 0;\n    let mut k = 3;\n    let mut last_k = 0;\n    loop {\n \
    \       if i == last_i {\n            last_i = i;\n            i += 1;\n     \
    \   }\n        if j == last_j {\n            last_j = j;\n            j += 1;\n\
    \        }\n        if k == last_k {\n            last_k = k;\n            k +=\
    \ 1;\n        }\n        let sum = i * i - i + 1 + j * j - j + 1 + k * k - k +\
    \ 1;\n        if sum % 3 == 0 {\n            max_triples += 1;\n            last_i\
    \ = i;\n            last_j = j;\n            last_k = k;\n        }\n        if\
    \ k > n {\n            break;\n        }\n    }\n    max_triples", "    if n <\
    \ 3 { return 0; }\n    let mut count = 0;\n    for i in 1..(n-1) {\n        for\
    \ j in (i+1)..(n) {\n            if (i*i-i+1+j*j-j+1) % 3 == 0 {\n           \
    \     count += 1;\n            }\n        }\n    }\n    count", "    let mut triples\
    \ = 0;\n    let mut a = Vec::new();\n    for i in 1..n+1 {\n        a.push(i*i\
    \ - i + 1);\n    }\n    for i in 0..a.len()-2 {\n        for j in i+1..a.len()-1\
    \ {\n            for k in j+1..a.len() {\n                if (a[i] + a[j] + a[k])\
    \ % 3 == 0 {\n                    triples += 1;\n                }\n         \
    \   }\n        }\n    }\n    triples", "    let mut cnt = 0;\n    for i in 1..n\
    \ {\n        for j in (i + 1)..n {\n            for k in (j + 1)..n {\n      \
    \          if i * i - i + 1 + j * j - j + 1 + k * k - k + 1 % 3 == 0 {\n     \
    \               cnt += 1;\n                }\n            }\n        }\n    }\n\
    \    cnt", "    // The sum of numbers 1 to n can be computed as n * (n + 1) /\
    \ 2\n    // The sum of squares of numbers 1 to n can be computed as n * (n + 1)\
    \ * (2 * n + 1) / 6\n    // We can use this and the fact that we can turn any\
    \ sum into a sum of three numbers\n    // with the following identity:\n    //\
    \   a + b + c = 3n\n    //   a^2 + b^2 + c^2 = 3(n^2 - n) + 3\n    // (a + b +\
    \ c)^2 = a^2 + b^2 + c^2 + 2(ab + bc + ca)\n    //   => 3n^2 = 3(n^2 - n) + 3\
    \ + 2(ab + bc + ca)\n    //   => ab + bc + ca = n^2 - n\n    //     => ab = n^2\
    \ - n - bc - ca\n    //     => b * c = n^2 - n - a * (b + c)\n    //     => b\
    \ * c = n^2 - n - a * 3n\n    //     => b * c = n^2 - 4n^2 + n\n    //     =>\
    \ b * c = n - n^2\n    // The equation cannot be solved if there is a common factor\
    \ of n\n    // because it means b * c < n - n^2 if n > 1\n    // Thus we can only\
    \ add numbers where gcd(a, n) = 1\n    // We can use the fact that a^2 - a + 1\
    \ is divisible by 3 for all non-negative a\n    // a^2 - a + 1 = 3x + y\n    //\
    \ a^2 - a = 3x + y - 1\n    // a * (a - 1) = 3x + y - 1\n    //\n    // We can\
    \ use the fact that a * (a - 1) can be converted to a sum of three numbers\n \
    \   // x + y + z = a * (a - 1)\n    // xyz = a * (a - 1)\n    // x = a - y - z\n\
    \    // x = a - a = 0\n    // Thus we only need to check for numbers where a is\
    \ div", "    let mut cnt = 0;\n    for i in 0..n {\n        for j in (i + 1)..n\
    \ {\n            for k in (j + 1)..n {\n                if (i * i - i + 1 + j\
    \ * j - j + 1 + k * k - k + 1) % 3 == 0 {\n                    cnt += 1;\n   \
    \             }\n            }\n        }\n    }\n    cnt", '    0', "    (1..=n).map(|i|\
    \ i*i - i + 1).fold(\n        (0, 0, 0),\n        |(c0, c1, c2), val| match val\
    \ % 3 {\n            0 => (c0 + 1, c1, c2),\n            1 => (c0, c1 + 1, c2),\n\
    \            2 => (c0, c1, c2 + 1),\n            _ => unreachable!()\n       \
    \ }\n    )", '    let a = vec![0, 1, 3, 7, 13, 21, 31, 43, 57, 73, 91, 111, 133,
    157, 183, 211, 241, 273, 307, 343, 381, 421, 463, 507, 553, 601, 651, 703, 757,
    813, 871, 931, 993, 1057, 1123, 1191, 1261, 1333, 1407, 1483, 1561, 1641, 1723,
    1807, 1883, 1961, 2041, 2123, 2207, 2283, 2361, 2441, 2523, 2607, 2683, 2761,
    2841, 2923, 3007, 3083, 3161, 3241, 3323, 3407, 3483, 3561, 3641, 3723, 3807,
    3883, 3961, 4041, 4123, 4207, 4283, 4361, 4441, 4523, 4607, 4683, 4761, 4841,
    4923, 5007, 5083, 5161, 5241, 5323, 5407, 5483, 5561, 5641, 5723, 5807, 5883,
    5961, 6041, 6123, 6207, 6283, 6361, 6441, 6523, 6607, 6683, 6761, 6841, 6923,
    7007, 7083, 7161, 7241, 7323, 7407, 7483, 7561, 7641, 7723, 7807, 7883, 7961,
    8041, 8123, 8207, 8283, 8361, 8441, 8523, 8607, 8683, 8761, 8841, 8923, 9007,
    9083, 9161, 9241, 9323, 9407, 9483, 9561, 9641, 9723, 9807, 9883, 9961, 10041,
    10123, 10207, 10283, 10361, 10441, 10523, 10607, 10683, 10761, 10841, 10923, 11007,
    11083, 11161, 11241, 11323, 11407, 11483, 11561, 11641, 11723, 11807, 11883, 11961,
    12041, 12123, 12', "    let mut triples = 0;\n    let mut a = Vec::new();\n  \
    \  for i in 1..=n {\n        a.push(i * i - i + 1);\n    }\n    for (i, _) in\
    \ a.iter().enumerate() {\n        for (j, _) in a.iter().enumerate() {\n     \
    \       if i < j {\n                for (k, _) in a.iter().enumerate() {\n   \
    \                 if j < k {\n                        if a[i] + a[j] + a[k] %\
    \ 3 == 0 {\n                            triples += 1;\n                      \
    \  }\n                    }\n                }\n            }\n        }\n   \
    \ }\n    triples", "    let mut count = 0;\n    for i in 0..n {\n        for j\
    \ in i+1..n {\n            for k in j+1..n {\n                let val = i*i -\
    \ i + 1 + j*j - j + 1 + k*k - k + 1;\n                if val % 3 == 0 {\n    \
    \                count += 1;\n                }\n            }\n        }\n  \
    \  }\n    count", "    let mut count = 0;\n    for i in 1..n {\n        for j\
    \ in i+1..n {\n            for k in j+1..n {\n                if (i*i-i+1 + j*j-j+1\
    \ + k*k-k+1) % 3 == 0 {\n                    count += 1;\n                }\n\
    \            }\n        }\n    }\n    count", "    let mut r = 0;\n    for i in\
    \ 1..n {\n        for j in (i + 1)..n {\n            for k in (j + 1)..n {\n \
    \               if (i * i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3 == 0 {\n\
    \                    r += 1;\n                }\n            }\n        }\n  \
    \  }\n    r", "    let mut count = 0;\n    let seq = (1..=n).map(|i| i * i - i\
    \ + 1).collect::<Vec<isize>>();\n    for i in 0..n - 2 {\n        for j in i +\
    \ 1..n - 1 {\n            for k in j + 1..n {\n                if (seq[i] + seq[j]\
    \ + seq[k]) % 3 == 0 {\n                    count += 1;\n                }\n \
    \           }\n        }\n    }\n    count", "    let mut a = Vec::new();\n  \
    \  for i in 1..=n {\n        a.push(i * i - i + 1);\n    }\n    let mut count\
    \ = 0;\n    for i in 0..n - 2 {\n        for j in i + 1..n - 1 {\n           \
    \ for k in j + 1..n {\n                if a[i as usize] + a[j as usize] + a[k\
    \ as usize] % 3 == 0 {\n                    count += 1;\n                }\n \
    \           }\n        }\n    }\n    count", "    if n < 3 { return 0; }\n   \
    \ let mut arr = Vec::with_capacity(n as usize);\n    for i in 1..n+1 {\n     \
    \   arr.push(i*i - i + 1);\n    }\n    let mut count = 0;\n    for i in 0..n-2\
    \ {\n        for j in i+1..n-1 {\n            if (arr[i as usize] + arr[j as usize])\
    \ % 3 != 0 { continue; }\n            for k in j+1..n {\n                if (arr[i\
    \ as usize] + arr[j as usize] + arr[k as usize]) % 3 == 0 { count += 1; }\n  \
    \          }\n        }\n    }\n    count", "    let mut total = 0;\n    for i\
    \ in 1..n {\n        for j in i+1..n {\n            let mut a = i * i - i + 1;\n\
    \            let mut b = j * j - j + 1;\n            let mut rem = (a + b) % 3;\n\
    \            if rem == 0 {\n                total += n - j;\n            } else\
    \ {\n                for k in j+1..n {\n                    let c = k * k - k\
    \ + 1;\n                    let rem = (rem + c) % 3;\n                    if rem\
    \ == 0 {\n                        total += 1;\n                    }\n       \
    \         }\n            }\n        }\n    }\n    total", "    let mut total =\
    \ 0;\n    let mut sum = 0;\n    let mut current = 0;\n    let mut left = 0;\n\
    \    let mut right = 0;\n    for i in 0..n {\n        current = i * i - i + 1;\n\
    \        right = current;\n        while left < right {\n            sum = left\
    \ + right + current;\n            if sum % 3 == 0 {\n                total +=\
    \ 1;\n            }\n            right -= 1;\n        }\n        left = current;\n\
    \    }\n    total", "    let mut count = 0;\n    for i in 1..n {\n        for\
    \ j in (i + 1)..n {\n            for k in (j + 1)..n {\n                if (i\
    \ * i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3 == 0 {\n                  \
    \  count += 1;\n                }\n            }\n        }\n    }\n    count",
  "    let mut a = vec![];\n    for i in 1..=n {\n        a.push(i * i - i + 1);\n\
    \    }\n    let mut counter = 0;\n    for i in 0..n - 2 {\n        for j in i\
    \ + 1..n - 1 {\n            for k in j + 1..n {\n                if (a[i] + a[j]\
    \ + a[k]) % 3 == 0 {\n                    counter += 1;\n                }\n \
    \           }\n        }\n    }\n    counter", "    let mut count = 0;\n    for\
    \ i in 1..n {\n        for j in (i + 1)..n {\n            for k in (j + 1)..n\
    \ {\n                if (i * i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3 ==\
    \ 0 {\n                    count += 1;\n                }\n            }\n   \
    \     }\n    }\n    count"]
stop_tokens:
- "\n}"
